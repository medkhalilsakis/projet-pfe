import {
  DefaultValueAccessor,
  FormsModule,
  MaxLengthValidator,
  MinLengthValidator,
  NgControl,
  NgControlStatus,
  NgModel,
  PatternValidator,
  RequiredValidator
} from "./chunk-TV5E5VMI.js";
import {
  DomSanitizer
} from "./chunk-HQ2V76IY.js";
import "./chunk-MDS4VJZ4.js";
import "./chunk-PAD7XWD6.js";
import {
  CommonModule,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgTemplateOutlet
} from "./chunk-WONRTEEZ.js";
import "./chunk-E3DWXUPZ.js";
import {
  ApplicationRef,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  NgModule,
  NgZone,
  Optional,
  Output,
  Self,
  SkipSelf,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation,
  forwardRef,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵpureFunction5,
  ɵɵpureFunction6,
  ɵɵpureFunction8,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-BQ5UH2I7.js";
import "./chunk-IC62NIWK.js";
import "./chunk-ISM5WLAM.js";
import "./chunk-ZZ67MR3E.js";
import "./chunk-KBUIKKCC.js";

// node_modules/@mobiscroll/angular/dist/esm5/mobiscroll.angular.min.js
var _c0 = ["*"];
var _c1 = ["*", [["", "mbsc-icon", ""]], [["", "mbsc-start-icon", ""]], [["", "mbsc-end-icon", ""]]];
var _c2 = ["*", "[mbsc-icon]", "[mbsc-start-icon]", "[mbsc-end-icon]"];
function MbscButton_mbsc_icon_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-icon", 1);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0._iconClass);
    ɵɵproperty("name", ctx_r0.s.icon)("svg", ctx_r0.s.iconSvg)("theme", ctx_r0.s.theme);
  }
}
function MbscButton_mbsc_icon_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-icon", 1);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0._startIconClass);
    ɵɵproperty("name", ctx_r0.s.startIcon)("svg", ctx_r0.s.startIconSvg)("theme", ctx_r0.s.theme);
  }
}
function MbscButton_mbsc_icon_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-icon", 1);
    ɵɵprojection(1, 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0._endIconClass);
    ɵɵproperty("name", ctx_r0.s.endIcon)("svg", ctx_r0.s.endIconSvg)("theme", ctx_r0.s.theme);
  }
}
function MbscCalendarPrev_mbsc_button_0_Template(rf, ctx2) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-button", 1);
    ɵɵlistener("click", function MbscCalendarPrev_mbsc_button_0_Template_mbsc_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.inst.prevPage());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ariaLabel", ctx_r1.inst.s.prevPageText)("disabled", ctx_r1.inst._isPrevDisabled())("iconSvg", ctx_r1.inst._prevIcon)("theme", ctx_r1.inst.s.theme)("themeVariant", ctx_r1.inst.s.themeVariant);
  }
}
function MbscCalendarNext_mbsc_button_0_Template(rf, ctx2) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-button", 1);
    ɵɵlistener("click", function MbscCalendarNext_mbsc_button_0_Template_mbsc_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.inst.nextPage());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ariaLabel", ctx_r1.inst.s.nextPageText)("disabled", ctx_r1.inst._isNextDisabled())("iconSvg", ctx_r1.inst._nextIcon)("theme", ctx_r1.inst.s.theme)("themeVariant", ctx_r1.inst.s.themeVariant);
  }
}
function MbscCalendarToday_mbsc_button_0_Template(rf, ctx2) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-button", 1);
    ɵɵlistener("click", function MbscCalendarToday_mbsc_button_0_Template_mbsc_button_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.inst._onTodayClick($event));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("theme", ctx_r1.inst.s.theme)("themeVariant", ctx_r1.inst.s.themeVariant);
    ɵɵattribute("aria-label", ctx_r1.inst.s.todayText);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.inst.s.todayText, " ");
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_ng_container_1_span_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-title mbsc-calendar-year" + ctx_r1.inst._theme);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r3.yearTitle, " ");
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_ng_container_1_span_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext(3).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-title mbsc-calendar-year" + ctx_r1.inst._theme);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r3.yearTitle, " ");
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_ng_container_1_span_1_Template, 2, 3, "span", 4);
    ɵɵelementStart(2, "span");
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_ng_container_1_span_4_Template, 2, 3, "span", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.inst._yearFirst);
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-title mbsc-calendar-month" + ctx_r1.inst._theme);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r3.monthTitle, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.inst._yearFirst);
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_span_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-title" + ctx_r1.inst._theme);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r3.title, " ");
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_ng_container_1_Template, 5, 5, "ng-container", 1)(2, MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_span_2_Template, 2, 3, "span", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const item_r3 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !item_r3.title);
    ɵɵadvance();
    ɵɵproperty("ngIf", item_r3.title);
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_span_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-calendar-title" + ctx_r1.inst._theme);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.inst._viewTitle, " ");
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_mbsc_icon_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-icon", 6);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("svg", ctx_r1.inst._view === ctx_r1.inst.PAGE_VIEW ? ctx_r1.inst.s.downIcon : ctx_r1.inst.s.upIcon)("theme", ctx_r1.inst.s.theme)("themeVariant", ctx_r1.inst.s.themeVariant);
  }
}
function MbscCalendarNav_ng_container_0_mbsc_button_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-button", 3, 0);
    ɵɵlistener("click", function MbscCalendarNav_ng_container_0_mbsc_button_1_Template_mbsc_button_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.inst._onPickerBtnClick($event));
    });
    ɵɵtemplate(2, MbscCalendarNav_ng_container_0_mbsc_button_1_ng_container_2_Template, 3, 2, "ng-container", 1)(3, MbscCalendarNav_ng_container_0_mbsc_button_1_span_3_Template, 2, 3, "span", 4)(4, MbscCalendarNav_ng_container_0_mbsc_button_1_mbsc_icon_4_Template, 1, 3, "mbsc-icon", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-button" + (ctx_r1.inst._pageNr > 1 ? " mbsc-flex-1-1" : ""));
    ɵɵproperty("theme", ctx_r1.inst.s.theme)("themeVariant", ctx_r1.inst.s.themeVariant);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.inst._hasPicker || ctx_r1.inst._view === ctx_r1.inst.PAGE_VIEW);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.inst._hasPicker && ctx_r1.inst._view !== ctx_r1.inst.PAGE_VIEW);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.inst.s.downIcon && ctx_r1.inst._pageNr === 1);
  }
}
function MbscCalendarNav_ng_container_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscCalendarNav_ng_container_0_mbsc_button_1_Template, 5, 7, "mbsc-button", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.inst._title)("ngForTrackBy", ctx_r1.inst._getKey);
  }
}
var _c3 = ["input"];
var _c4 = ["lbl"];
var _c5 = [[["", "mbsc-label", ""]]];
var _c6 = ["[mbsc-label]"];
function MbscInput_input_7_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "input", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._dummyElmClass);
    ɵɵproperty("disabled", ctx_r1._disabled)("placeholder", ctx_r1.s.placeholder)("readonly", true)("value", ctx_r1.state.files || "");
  }
}
function MbscInput_span_8_ng_container_1_span_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span")(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "mbsc-icon", 12);
    ɵɵlistener("click", function MbscInput_span_8_ng_container_1_span_1_Template_mbsc_icon_click_3_listener($event) {
      ɵɵrestoreView(_r3);
      const i_r4 = ɵɵnextContext().index;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._onTagClear($event, i_r4));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const v_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-textfield-tag" + ctx_r1._theme + ctx_r1._rtl);
    ɵɵadvance();
    ɵɵclassMap("mbsc-textfield-tag-text" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(v_r5);
    ɵɵadvance();
    ɵɵproperty("svg", ctx_r1.s.clearIcon)("theme", ctx_r1.s.theme);
  }
}
function MbscInput_span_8_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscInput_span_8_ng_container_1_span_1_Template, 4, 7, "span", 6);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const v_r5 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", v_r5);
  }
}
function MbscInput_span_8_span_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-textfield-tags-placeholder" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.placeholder);
  }
}
function MbscInput_span_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, MbscInput_span_8_ng_container_1_Template, 2, 1, "ng-container", 11)(2, MbscInput_span_8_span_2_Template, 2, 3, "span", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-textfield-tags" + ctx_r1._nativeElmClass);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1._tagsArray);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1._tagsArray.length);
  }
}
function MbscInput_mbsc_icon_9_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-icon", 13);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._selectIconClass);
    ɵɵproperty("svg", ctx_r1.s.dropdownIcon)("theme", ctx_r1.s.theme);
  }
}
function MbscInput_mbsc_icon_10_Template(rf, ctx2) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 14);
    ɵɵlistener("click", function MbscInput_mbsc_icon_10_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onIconClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._startIconClass);
    ɵɵproperty("name", ctx_r1.s.startIcon)("svg", ctx_r1.s.startIconSvg)("theme", ctx_r1.s.theme);
  }
}
function MbscInput_mbsc_icon_11_Template(rf, ctx2) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 14);
    ɵɵlistener("click", function MbscInput_mbsc_icon_11_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onIconClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._endIconClass);
    ɵɵproperty("name", ctx_r1.s.endIcon)("svg", ctx_r1.s.endIconSvg)("theme", ctx_r1.s.theme);
  }
}
function MbscInput_mbsc_icon_12_Template(rf, ctx2) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 14);
    ɵɵlistener("click", function MbscInput_mbsc_icon_12_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r8);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._passIconClass);
    ɵɵproperty("name", ctx_r1._hidePass ? ctx_r1.s.showIcon : ctx_r1.s.hideIcon)("svg", ctx_r1._hidePass ? ctx_r1.s.showIconSvg : ctx_r1.s.hideIconSvg)("theme", ctx_r1.s.theme);
  }
}
function MbscInput_span_13_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._errorClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.errorMessage);
  }
}
function MbscInput_fieldset_14_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "fieldset", 15)(1, "legend");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._fieldSetClass);
    ɵɵadvance();
    ɵɵclassMap(ctx_r1._legendClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.label && ctx_r1.s.labelStyle !== "inline" ? ctx_r1.s.label : "&nbsp;");
  }
}
function MbscInput_span_15_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "span");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1._rippleClass);
  }
}
var _c7 = [[["", "mbsc-label", ""]], "*"];
var _c8 = ["[mbsc-label]", "*"];
function MbscDropdown_mbsc_icon_8_Template(rf, ctx2) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 7);
    ɵɵlistener("click", function MbscDropdown_mbsc_icon_8_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3._onIconClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap(ctx_r3._startIconClass);
    ɵɵproperty("name", ctx_r3.s.startIcon)("svg", ctx_r3.s.startIconSvg)("theme", ctx_r3.s.theme);
  }
}
function MbscDropdown_mbsc_icon_9_Template(rf, ctx2) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 7);
    ɵɵlistener("click", function MbscDropdown_mbsc_icon_9_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3._onIconClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap(ctx_r3._endIconClass);
    ɵɵproperty("name", ctx_r3.s.endIcon)("svg", ctx_r3.s.endIconSvg)("theme", ctx_r3.s.theme);
  }
}
function MbscDropdown_span_10_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap(ctx_r3._errorClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.s.errorMessage);
  }
}
function MbscDropdown_fieldset_11_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "fieldset", 8)(1, "legend");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap(ctx_r3._fieldSetClass);
    ɵɵadvance();
    ɵɵclassMap(ctx_r3._legendClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r3.s.label && ctx_r3.s.labelStyle !== "inline" ? ctx_r3.s.label : "&nbsp;");
  }
}
function MbscDropdown_span_12_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "span");
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap(ctx_r3._rippleClass);
  }
}
function MbscTextarea_mbsc_icon_6_Template(rf, ctx2) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 6);
    ɵɵlistener("click", function MbscTextarea_mbsc_icon_6_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._onIconClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2._startIconClass);
    ɵɵproperty("name", ctx_r2.s.startIcon)("svg", ctx_r2.s.startIconSvg)("theme", ctx_r2.s.theme);
  }
}
function MbscTextarea_mbsc_icon_7_Template(rf, ctx2) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 6);
    ɵɵlistener("click", function MbscTextarea_mbsc_icon_7_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._onIconClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2._endIconClass);
    ɵɵproperty("name", ctx_r2.s.endIcon)("svg", ctx_r2.s.endIconSvg)("theme", ctx_r2.s.theme);
  }
}
function MbscTextarea_span_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2._errorClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.s.errorMessage);
  }
}
function MbscTextarea_fieldset_9_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "fieldset", 7)(1, "legend");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2._fieldSetClass);
    ɵɵadvance();
    ɵɵclassMap(ctx_r2._legendClass);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.s.label && ctx_r2.s.labelStyle !== "inline" ? ctx_r2.s.label : "&nbsp;");
  }
}
function MbscTextarea_span_10_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "span");
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap(ctx_r2._rippleClass);
  }
}
var _c9 = ["active"];
var _c10 = ["content"];
var _c11 = ["limit"];
var _c12 = ["wrapper"];
var _c13 = ["popup"];
function MbscPopup_ng_template_0_ng_container_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵprojection(1);
    ɵɵelementContainerEnd();
  }
}
function MbscPopup_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscPopup_ng_template_0_ng_container_0_Template, 2, 0, "ng-container", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r0._isVisible || !ctx_r0._isModal);
  }
}
function MbscPopup_ng_container_2_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 16);
    ɵɵlistener("click", function MbscPopup_ng_container_2_div_3_Template_div_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r0 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r0._onOverlayClick());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-popup-overlay mbsc-popup-overlay-" + ctx_r0.s.display + ctx_r0._theme + (ctx_r0._isClosing ? " mbsc-popup-overlay-out" : "") + (ctx_r0._isOpening && ctx_r0.state.isReady ? " mbsc-popup-overlay-in" : ""));
  }
}
function MbscPopup_ng_container_2_div_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "div", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-popup-arrow-wrapper mbsc-popup-arrow-wrapper-" + ctx_r0.state.bubblePos + ctx_r0._theme);
    ɵɵadvance();
    ɵɵclassMap("mbsc-popup-arrow mbsc-popup-arrow-" + ctx_r0.state.bubblePos + ctx_r0._theme);
    ɵɵproperty("ngStyle", ctx_r0.state.arrowPos);
  }
}
function MbscPopup_ng_container_2_div_12_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 17);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-flex-none mbsc-popup-header mbsc-popup-header-" + ctx_r0.s.display + ctx_r0._theme + ctx_r0._hb + (ctx_r0._buttons ? "" : " mbsc-popup-header-no-buttons"));
    ɵɵproperty("innerHTML", ctx_r0._headerText, ɵɵsanitizeHtml);
  }
}
function MbscPopup_ng_container_2_div_16_mbsc_button_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-button", 19);
    ɵɵlistener("click", function MbscPopup_ng_container_2_div_16_mbsc_button_1_Template_mbsc_button_click_0_listener($event) {
      const btn_r5 = ɵɵrestoreView(_r4).$implicit;
      return ɵɵresetView(!btn_r5.disabled && btn_r5.handler($event));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r5 = ctx2.$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-popup-button mbsc-popup-button-" + ctx_r0.s.display + ctx_r0._rtl + ctx_r0._hb + (ctx_r0._flexButtons ? " mbsc-popup-button-flex" : "") + " " + (btn_r5.cssClass || ""));
    ɵɵproperty("color", btn_r5.color)("disabled", btn_r5.disabled)("icon", btn_r5.icon)("theme", ctx_r0.s.theme)("themeVariant", ctx_r0.s.themeVariant)("variant", btn_r5.variant || ctx_r0.s.buttonVariant);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", btn_r5.text, " ");
  }
}
function MbscPopup_ng_container_2_div_16_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscPopup_ng_container_2_div_16_mbsc_button_1_Template, 2, 9, "mbsc-button", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-flex-none mbsc-popup-buttons mbsc-popup-buttons-" + ctx_r0.s.display + ctx_r0._theme + ctx_r0._rtl + ctx_r0._hb + (ctx_r0._flexButtons ? " mbsc-flex" : "") + (ctx_r0.s.fullScreen ? " mbsc-popup-buttons-" + ctx_r0.s.display + "-full" : ""));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0._buttons);
  }
}
function MbscPopup_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 8, 1);
    ɵɵlistener("keydown", function MbscPopup_ng_container_2_Template_div_keydown_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onKeyDown($event));
    });
    ɵɵtemplate(3, MbscPopup_ng_container_2_div_3_Template, 1, 2, "div", 9);
    ɵɵelement(4, "div", 10, 2);
    ɵɵelementStart(6, "div", 11, 3);
    ɵɵlistener("animationend", function MbscPopup_ng_container_2_Template_div_animationend_6_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onAnimationEnd($event));
    })("click", function MbscPopup_ng_container_2_Template_div_click_6_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r0 = ɵɵnextContext();
      return ɵɵresetView(ctx_r0._onPopupClick());
    });
    ɵɵtemplate(8, MbscPopup_ng_container_2_div_8_Template, 2, 5, "div", 12);
    ɵɵelement(9, "div", 13, 4);
    ɵɵelementStart(11, "div");
    ɵɵtemplate(12, MbscPopup_ng_container_2_div_12_Template, 1, 3, "div", 14);
    ɵɵelementStart(13, "div", null, 5);
    ɵɵelementContainer(15, 15);
    ɵɵelementEnd();
    ɵɵtemplate(16, MbscPopup_ng_container_2_div_16_Template, 2, 3, "div", 12);
    ɵɵelementEnd()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const ngcontent_r6 = ɵɵreference(1);
    ɵɵadvance();
    ɵɵclassMap("mbsc-font mbsc-flex mbsc-popup-wrapper mbsc-popup-wrapper-" + ctx_r0.s.display + ctx_r0._theme + ctx_r0._rtl + " " + ctx_r0._className + (ctx_r0.s.fullScreen ? " mbsc-popup-wrapper-" + ctx_r0.s.display + "-full" : "") + (ctx_r0._touchUi ? "" : " mbsc-popup-pointer") + (ctx_r0._round ? " mbsc-popup-round" : "") + (ctx_r0._hasContext ? " mbsc-popup-wrapper-ctx" : "") + (ctx_r0.state.isReady ? "" : " mbsc-popup-hidden"));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.s.showOverlay);
    ɵɵadvance();
    ɵɵclassMap("mbsc-popup-limits mbsc-popup-limits-" + ctx_r0.s.display);
    ɵɵproperty("ngStyle", ctx_r0._limits);
    ɵɵadvance(2);
    ɵɵclassMap("mbsc-flex-col mbsc-popup mbsc-popup-" + ctx_r0.s.display + (ctx_r0.s.fullScreen ? "-full" : "") + ctx_r0._theme + ctx_r0._hb + (ctx_r0.state.bubblePos && ctx_r0.state.showArrow && ctx_r0.s.display === "anchored" ? " mbsc-popup-anchored-" + ctx_r0.state.bubblePos : "") + (ctx_r0._isClosing ? " mbsc-popup-" + ctx_r0._animation + "-out" : "") + (ctx_r0._isOpening && ctx_r0.state.isReady ? " mbsc-popup-" + ctx_r0._animation + "-in" : ""));
    ɵɵproperty("ngStyle", ctx_r0._style);
    ɵɵattribute("aria-label", ctx_r0.ariaLabel);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r0.s.display === "anchored" && ctx_r0.state.showArrow);
    ɵɵadvance(3);
    ɵɵclassMap("mbsc-flex-col mbsc-flex-1-1 mbsc-popup-body mbsc-popup-body-" + ctx_r0.s.display + ctx_r0._theme + ctx_r0._hb + (ctx_r0.s.fullScreen ? " mbsc-popup-body-" + ctx_r0.s.display + "-full" : "") + (ctx_r0._round ? " mbsc-popup-body-round" : ""));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0._headerText);
    ɵɵadvance();
    ɵɵclassMap("mbsc-flex-1-1 mbsc-popup-content" + (ctx_r0.s.contentPadding ? " mbsc-popup-padding" : ""));
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ngcontent_r6);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0._buttons);
  }
}
function MbscPopup_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0, 15);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const ngcontent_r6 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", ngcontent_r6);
  }
}
function MbscPrompt_h2_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "h2", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.title);
  }
}
function MbscSnackbar_mbsc_button_5_Template(rf, ctx2) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-button", 5);
    ɵɵlistener("click", function MbscSnackbar_mbsc_button_5_Template_mbsc_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onButtonClick());
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("icon", ctx_r1.button.icon)("theme", ctx_r1.props.theme)("themeVariant", ctx_r1.props.themeVariant);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.button.text, " ");
  }
}
var _c14 = (a0) => ({
  $implicit: a0
});
function MbscCalendarLabel_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-label-resize mbsc-calendar-label-resize-start" + ctx_r0._rtl + (ctx_r0.isUpdate ? " mbsc-calendar-label-resize-start-touch" : ""));
  }
}
function MbscCalendarLabel_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-label-resize mbsc-calendar-label-resize-end" + ctx_r0._rtl + (ctx_r0.isUpdate ? " mbsc-calendar-label-resize-start-touch" : ""));
  }
}
function MbscCalendarLabel_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-label-background" + ctx_r0._theme);
  }
}
function MbscCalendarLabel_div_4_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-label-text" + ctx_r0._theme);
    ɵɵstyleProp("color", ctx_r0.event && ctx_r0.event.textColor);
    ɵɵproperty("innerHTML", ctx_r0._html, ɵɵsanitizeHtml);
  }
}
function MbscCalendarLabel_div_4_div_2_ng_template_1_Template(rf, ctx2) {
}
function MbscCalendarLabel_div_4_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscCalendarLabel_div_4_div_2_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-label-text" + ctx_r0._theme);
    ɵɵstyleProp("color", ctx_r0.event && ctx_r0.event.textColor);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.contentTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c14, ctx_r0._data));
  }
}
function MbscCalendarLabel_div_4_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.s.label);
  }
}
function MbscCalendarLabel_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscCalendarLabel_div_4_div_1_Template, 1, 5, "div", 3)(2, MbscCalendarLabel_div_4_div_2_Template, 2, 8, "div", 1)(3, MbscCalendarLabel_div_4_div_3_Template, 2, 1, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-label-inner" + ctx_r0._theme);
    ɵɵstyleProp("color", ctx_r0._textColor);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0._html);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0._html);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.s.label);
  }
}
function MbscCalendarLabel_5_ng_template_0_Template(rf, ctx2) {
}
function MbscCalendarLabel_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscCalendarLabel_5_ng_template_0_Template, 0, 0, "ng-template", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0._data));
  }
}
var _c15 = ["btn"];
function MbscCalendarDay_2_ng_template_0_Template(rf, ctx2) {
}
function MbscCalendarDay_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscCalendarDay_2_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.dayTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0._data));
  }
}
function MbscCalendarDay_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-month-name" + ctx_r0._theme + ctx_r0._rtl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.s.monthShort, " ");
  }
}
function MbscCalendarDay_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7, 0);
    ɵɵtext(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-cell-text mbsc-calendar-" + ctx_r0.s.type + "-text" + ctx_r0._theme + ctx_r0._todayClass);
    ɵɵproperty("ngStyle", ctx_r0._circleStyles);
    ɵɵattribute("aria-describedby", ctx_r0.s.isActiveMonth ? "mbsc-calendar-day-desc-" + ctx_r0.s.date : null)("aria-disabled", ctx_r0.s.disabled ? "true" : null)("aria-label", ctx_r0._ariaLabel)("aria-pressed", ctx_r0.s.selected)("tabindex", ctx_r0.s.disabled ? null : ctx_r0.s.active ? 0 : -1);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.s.text, " ");
  }
}
function MbscCalendarDay_div_5_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const mark_r2 = ctx2.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-mark " + (mark_r2.markCssClass || "") + ctx_r0._theme);
    ɵɵstyleProp("background", mark_r2.color);
  }
}
function MbscCalendarDay_div_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div");
    ɵɵtemplate(2, MbscCalendarDay_div_5_div_2_Template, 1, 4, "div", 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-marks" + ctx_r0._theme + ctx_r0._rtl);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.s.marks)("ngForTrackBy", ctx_r0._getKey);
  }
}
function MbscCalendarDay_6_ng_template_0_Template(rf, ctx2) {
}
function MbscCalendarDay_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscCalendarDay_6_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.dayContentTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0._data));
  }
}
function MbscCalendarDay_div_7_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "mbsc-calendar-label", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-labels mbsc-calendar-labels-dragging");
    ɵɵadvance();
    ɵɵproperty("amText", ctx_r0.s.amText)("date", ctx_r0.s.date)("dataTimezone", ctx_r0.dataTimezone)("displayTimezone", ctx_r0.displayTimezone)("drag", ctx_r0.s.dragToMove)("resize", ctx_r0._computeEventResize(ctx_r0._draggedLabelOrig.event.resize, ctx_r0.s.dragToResize))("event", ctx_r0._draggedLabelOrig.event)("exclusiveEndDates", ctx_r0.exclusiveEndDates)("firstDay", ctx_r0.s.firstDay)("hidden", !!ctx_r0.s.dragData.draggedDates)("isExact", ctx_r0._draggedLabelOrig.isExact)("isUpdate", true)("position", ctx_r0._draggedLabelOrig.position)("pmText", ctx_r0.s.pmText)("resourcesMap", ctx_r0.s.resourcesMap)("rtl", ctx_r0.s.rtl)("showEventTooltip", ctx_r0.s.showEventTooltip)("showText", true)("theme", ctx_r0.s.theme)("timeFormat", ctx_r0.s.timeFormat)("timezonePlugin", ctx_r0.timezonePlugin)("template", ctx_r0.labelTemplate)("contentTemplate", ctx_r0.labelContentTemplate)("onClick", ctx_r0._onLabelClick)("onDoubleClick", ctx_r0._onLabelDoubleClick)("onRightClick", ctx_r0._onLabelRightClick)("onHoverIn", ctx_r0._onLabelHoverIn)("onHoverOut", ctx_r0._onLabelHoverOut)("onDelete", ctx_r0.s.onLabelDelete)("onDragStart", ctx_r0.s.onLabelUpdateStart)("onDragMove", ctx_r0.s.onLabelUpdateMove)("onDragEnd", ctx_r0.s.onLabelUpdateEnd)("onDragModeOn", ctx_r0.s.onLabelUpdateModeOn)("onDragModeOff", ctx_r0.s.onLabelUpdateModeOff);
  }
}
function MbscCalendarDay_div_7_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "mbsc-calendar-label", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-labels mbsc-calendar-labels-dragging");
    ɵɵadvance();
    ɵɵproperty("amText", ctx_r0.s.amText)("date", ctx_r0.s.date)("dataTimezone", ctx_r0.dataTimezone)("displayTimezone", ctx_r0.displayTimezone)("drag", ctx_r0.s.dragToMove)("resize", ctx_r0._computeEventResize(ctx_r0._draggedLabel.event.resize, ctx_r0.s.dragToResize))("event", ctx_r0._draggedLabel.event)("exclusiveEndDates", ctx_r0.exclusiveEndDates)("firstDay", ctx_r0.s.firstDay)("isExact", ctx_r0._draggedLabel.isExact)("isUpdate", true)("pmText", ctx_r0.s.pmText)("position", ctx_r0._draggedLabel.position)("resourcesMap", ctx_r0.s.resourcesMap)("rtl", ctx_r0.s.rtl)("showEventTooltip", ctx_r0.s.showEventTooltip)("showText", true)("theme", ctx_r0.s.theme)("timeFormat", ctx_r0.s.timeFormat)("timezonePlugin", ctx_r0.timezonePlugin)("template", ctx_r0.labelTemplate)("contentTemplate", ctx_r0.labelContentTemplate)("onClick", ctx_r0._onLabelClick)("onDoubleClick", ctx_r0._onLabelDoubleClick)("onRightClick", ctx_r0._onLabelRightClick)("onHoverIn", ctx_r0._onLabelHoverIn)("onHoverOut", ctx_r0._onLabelHoverOut)("onDelete", ctx_r0.s.onLabelDelete)("onDragStart", ctx_r0.s.onLabelUpdateStart)("onDragMove", ctx_r0.s.onLabelUpdateMove)("onDragEnd", ctx_r0.s.onLabelUpdateEnd)("onDragModeOn", ctx_r0.s.onLabelUpdateModeOn)("onDragModeOff", ctx_r0.s.onLabelUpdateModeOff);
  }
}
function MbscCalendarDay_div_7_ng_container_4_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 12);
  }
}
function MbscCalendarDay_div_7_ng_container_4_ng_container_3_mbsc_calendar_label_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-label", 19);
  }
  if (rf & 2) {
    const label_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("count", label_r3.count ? label_r3.count + " " + (label_r3.count > 1 ? ctx_r0.s.eventsText : ctx_r0.s.eventText) : void 0)("id", label_r3.id)("isActiveMonth", ctx_r0.isActiveMonth)("label", label_r3.label)("more", label_r3.more)("position", label_r3.position)("rtl", ctx_r0.s.rtl)("theme", ctx_r0.s.theme)("onClick", ctx_r0._onLabelClick)("onDoubleClick", ctx_r0._onLabelDoubleClick)("onRightClick", ctx_r0._onLabelRightClick)("onHoverIn", ctx_r0._onLabelHoverIn)("onHoverOut", ctx_r0._onLabelHoverOut)("showText", true);
  }
}
function MbscCalendarDay_div_7_ng_container_4_ng_container_3_mbsc_calendar_label_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-label", 20);
  }
  if (rf & 2) {
    const label_r3 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext(3);
    ɵɵproperty("amText", ctx_r0.s.amText)("date", ctx_r0.s.date)("dataTimezone", ctx_r0.dataTimezone)("displayTimezone", ctx_r0.displayTimezone)("drag", ctx_r0.s.dragToMove)("resize", ctx_r0._computeEventResize(label_r3.event.resize, ctx_r0.s.dragToResize))("event", label_r3.event)("exclusiveEndDates", ctx_r0.exclusiveEndDates)("firstDay", ctx_r0.s.firstDay)("id", label_r3.id)("inactive", label_r3.event && ctx_r0.s.dragData && ctx_r0.s.dragData.draggedEvent && label_r3.event.id === ctx_r0.s.dragData.draggedEvent.id)("isActiveMonth", ctx_r0.isActiveMonth)("isExact", label_r3.isExact)("isPicker", ctx_r0.s.isPicker)("label", label_r3.label)("position", label_r3.position)("pmText", ctx_r0.s.pmText)("resourcesMap", ctx_r0.s.resourcesMap)("rtl", ctx_r0.s.rtl)("selected", label_r3.event && ctx_r0.selectedEventsMap && !!(ctx_r0.selectedEventsMap[label_r3.id] || ctx_r0.selectedEventsMap[label_r3.event.id]))("showText", label_r3.showText)("showEventTooltip", ctx_r0.s.showEventTooltip)("theme", ctx_r0.s.theme)("timeFormat", ctx_r0.s.timeFormat)("timezonePlugin", ctx_r0.timezonePlugin)("template", ctx_r0.labelTemplate)("contentTemplate", ctx_r0.labelContentTemplate)("onClick", ctx_r0._onLabelClick)("onDoubleClick", ctx_r0._onLabelDoubleClick)("onRightClick", ctx_r0._onLabelRightClick)("onHoverIn", ctx_r0._onLabelHoverIn)("onHoverOut", ctx_r0._onLabelHoverOut)("onDelete", ctx_r0.s.onLabelDelete)("onDragStart", ctx_r0.s.onLabelUpdateStart)("onDragMove", ctx_r0.s.onLabelUpdateMove)("onDragEnd", ctx_r0.s.onLabelUpdateEnd)("onDragModeOn", ctx_r0.s.onLabelUpdateModeOn)("onDragModeOff", ctx_r0.s.onLabelUpdateModeOff);
  }
}
function MbscCalendarDay_div_7_ng_container_4_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscCalendarDay_div_7_ng_container_4_ng_container_3_mbsc_calendar_label_1_Template, 1, 14, "mbsc-calendar-label", 17)(2, MbscCalendarDay_div_7_ng_container_4_ng_container_3_mbsc_calendar_label_2_Template, 1, 38, "mbsc-calendar-label", 18);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const label_r3 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", label_r3.more || label_r3.count);
    ɵɵadvance();
    ɵɵproperty("ngIf", label_r3.event);
  }
}
function MbscCalendarDay_div_7_ng_container_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 15);
    ɵɵtemplate(2, MbscCalendarDay_div_7_ng_container_4_div_2_Template, 1, 0, "div", 16)(3, MbscCalendarDay_div_7_ng_container_4_ng_container_3_Template, 3, 2, "ng-container", 11);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const labels_r4 = ctx2.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !labels_r4.length);
    ɵɵadvance();
    ɵɵproperty("ngForOf", labels_r4)("ngForTrackBy", ctx_r0._getLabelKey);
  }
}
function MbscCalendarDay_div_7_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscCalendarDay_div_7_div_1_Template, 2, 36, "div", 9)(2, MbscCalendarDay_div_7_div_2_Template, 2, 35, "div", 9);
    ɵɵelementStart(3, "div", 10);
    ɵɵtemplate(4, MbscCalendarDay_div_7_ng_container_4_Template, 4, 3, "ng-container", 11);
    ɵɵelementEnd();
    ɵɵelement(5, "div", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0._draggedLabelOrig && ctx_r0._draggedLabelOrig.event);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0._draggedLabel && ctx_r0._draggedLabel.event);
    ɵɵadvance();
    ɵɵattribute("id", ctx_r0.s.isActiveMonth ? "mbsc-calendar-day-desc-" + ctx_r0.s.date : null);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r0.s.labels.data)("ngForTrackBy", ctx_r0._getKey);
  }
}
function MbscCalendarWeekDays_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", "mbsc-calendar-week-day mbsc-calendar-week-nr mbsc-flex-none" + ctx_r0.theme + ctx_r0.rtl);
  }
}
function MbscCalendarWeekDays_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r2 = ctx2.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", "mbsc-calendar-week-day mbsc-flex-1-0-0" + ctx_r0.theme + ctx_r0.rtl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.dayNamesShort[(i_r2 + ctx_r0.firstDay) % 7], " ");
  }
}
function MbscCalendarWeekDays_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4);
  }
}
function MbscMonthView_mbsc_calendar_weekdays_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-weekdays", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("rtl", ctx_r0._rtl)("theme", ctx_r0._theme)("firstDay", ctx_r0.s.firstDay)("dayNamesShort", ctx_r0.s.dayNamesShort)("showWeekNumbers", ctx_r0.s.showWeekNumbers);
  }
}
function MbscMonthView_div_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6)(1, "div", 7);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 8);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r2 = ɵɵnextContext().$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngClass", "mbsc-calendar-cell mbsc-flex-none mbsc-calendar-day mbsc-calendar-week-nr" + ctx_r0._theme);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0._getWeekNr(ctx_r0.s, row_r2[0].date));
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.s.weekText.replace("{count}", ctx_r0._getWeekNr(ctx_r0.s, row_r2[0].date)));
  }
}
function MbscMonthView_div_2_mbsc_calendar_day_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-day", 9);
  }
  if (rf & 2) {
    const cell_r3 = ctx2.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("active", cell_r3.display && ctx_r0._isActive(cell_r3.date))("amText", ctx_r0.s.amText)("colors", cell_r3.colors)("clickToCreate", ctx_r0.s.clickToCreate)("date", cell_r3.date)("day", cell_r3.day)("dayTemplate", ctx_r0.dayTemplate)("dayContentTemplate", ctx_r0.dayContentTemplate)("disabled", ctx_r0._isInvalid(cell_r3.date))("display", cell_r3.display)("dataTimezone", ctx_r0.dataTimezone)("displayTimezone", ctx_r0.displayTimezone)("dragToCreate", ctx_r0.s.dragToCreate)("dragToResize", ctx_r0.s.dragToResize)("dragToMove", ctx_r0.s.dragToMove)("eventText", ctx_r0.s.eventText)("events", cell_r3.events)("eventsText", ctx_r0.s.eventsText)("exclusiveEndDates", ctx_r0.exclusiveEndDates)("firstDay", ctx_r0.s.firstDay)("hasMarks", ctx_r0.s.hasMarks)("hoverEnd", ctx_r0.s.hoverEnd)("hoverStart", ctx_r0.s.hoverStart)("isActiveMonth", ctx_r0.s.isActive)("isPicker", ctx_r0.s.isPicker)("labels", cell_r3.labels)("labelTemplate", ctx_r0.labelTemplate)("labelContentTemplate", ctx_r0.labelContentTemplate)("dragData", ctx_r0.s.dragData)("marks", cell_r3.marks)("month", cell_r3.month)("monthShort", cell_r3.monthShort)("outer", cell_r3.outer)("pmText", ctx_r0.s.pmText)("rangeEnd", ctx_r0.s.rangeEnd)("rangeStart", ctx_r0.s.rangeStart)("resourcesMap", ctx_r0.s.resourcesMap)("rtl", ctx_r0.s.rtl)("selected", ctx_r0._isSelected(cell_r3.date))("selectedEventsMap", ctx_r0.s.selectedEventsMap)("showEventTooltip", ctx_r0.s.showEventTooltip)("text", cell_r3.text)("timeFormat", ctx_r0.s.timeFormat)("timezonePlugin", ctx_r0.timezonePlugin)("todayText", ctx_r0.s.todayText)("theme", ctx_r0.s.theme)("year", cell_r3.year)("onDayClick", ctx_r0.s.onDayClick)("onDayDoubleClick", ctx_r0.s.onDayDoubleClick)("onDayRightClick", ctx_r0.s.onDayRightClick)("onHoverIn", ctx_r0.s.onDayHoverIn)("onHoverOut", ctx_r0.s.onDayHoverOut)("onLabelClick", ctx_r0.s.onLabelClick)("onLabelDoubleClick", ctx_r0.s.onLabelDoubleClick)("onLabelRightClick", ctx_r0.s.onLabelRightClick)("onLabelHoverIn", ctx_r0.s.onLabelHoverIn)("onLabelHoverOut", ctx_r0.s.onLabelHoverOut)("onLabelDelete", ctx_r0.s.onLabelDelete)("onLabelUpdateStart", ctx_r0.s.onLabelUpdateStart)("onLabelUpdateMove", ctx_r0.s.onLabelUpdateMove)("onLabelUpdateEnd", ctx_r0.s.onLabelUpdateEnd)("onLabelUpdateModeOn", ctx_r0.s.onLabelUpdateModeOn)("onLabelUpdateModeOff", ctx_r0.s.onLabelUpdateModeOff);
  }
}
function MbscMonthView_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 3);
    ɵɵtemplate(1, MbscMonthView_div_2_div_1_Template, 5, 3, "div", 4)(2, MbscMonthView_div_2_mbsc_calendar_day_2_Template, 1, 63, "mbsc-calendar-day", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r2 = ctx2.$implicit;
    const i_r4 = ctx2.index;
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("min-height", ctx_r0._rowHeights[i_r4] || 0, "px");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.s.showWeekNumbers);
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r2)("ngForTrackBy", ctx_r0._getKey);
  }
}
var _c16 = ["el"];
var _c17 = ["innerEl"];
var _c18 = ["barCont"];
var _c19 = ["bar"];
var _c20 = ["el3d"];
var _c21 = ["*", [["", "content-3d", ""]]];
var _c22 = ["*", "[content-3d]"];
function MbscScrollviewBase_div_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 7, 4);
    ɵɵprojection(2, 1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.s.itemSize, "px");
  }
}
function MbscMultiYearView_div_0_mbsc_calendar_day_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-day", 3);
  }
  if (rf & 2) {
    const cell_r1 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("active", cell_r1.year === ctx_r1._activeYear)("date", cell_r1.d)("display", true)("selected", cell_r1.year === ctx_r1._selectedYear)("disabled", cell_r1.year < ctx_r1.min || cell_r1.year > ctx_r1.max)("rtl", ctx_r1.rtl)("text", cell_r1.year + ctx_r1.yearSuffix)("theme", ctx_r1.theme)("onDayClick", ctx_r1.onYearClick);
  }
}
function MbscMultiYearView_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtemplate(1, MbscMultiYearView_div_0_mbsc_calendar_day_1_Template, 1, 9, "mbsc-calendar-day", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r3)("ngForTrackBy", ctx_r1.getKey);
  }
}
function MbscYearView_div_0_mbsc_calendar_day_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-day", 3);
  }
  if (rf & 2) {
    const cell_r1 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("active", cell_r1.y === ctx_r1._activeYear && cell_r1.m === ctx_r1._activeMonth)("date", cell_r1.d)("display", true)("selected", cell_r1.y === ctx_r1._selectedYear && cell_r1.m === ctx_r1._selectedMonth)("disabled", cell_r1.d < ctx_r1.min || cell_r1.d >= ctx_r1.max)("month", ctx_r1.monthNames[cell_r1.m])("rtl", ctx_r1.rtl)("text", ctx_r1.monthNamesShort[cell_r1.m])("theme", ctx_r1.theme)("onDayClick", ctx_r1.onMonthClick);
  }
}
function MbscYearView_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtemplate(1, MbscYearView_div_0_mbsc_calendar_day_1_Template, 1, 10, "mbsc-calendar-day", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r3)("ngForTrackBy", ctx_r1.getKey);
  }
}
var _c23 = ["body"];
var _c24 = ["pickerCont"];
var _c25 = (a0) => ({
  timestamp: a0,
  drag: false,
  isActive: true
});
var _c26 = (a0) => ({
  timestamp: a0,
  isActive: true,
  drag: true
});
var _c27 = (a0, a1) => ({
  timestamp: a0,
  drag: true,
  isActive: a1
});
function MbscCalendarView_div_2_ng_template_1_Template(rf, ctx2) {
}
function MbscCalendarView_div_2_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-nav", 14)(1, "mbsc-calendar-prev")(2, "mbsc-calendar-today", 15)(3, "mbsc-calendar-next");
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-button-prev" + (ctx_r1._pageNr > 1 ? " mbsc-calendar-button-prev-multi" : ""));
    ɵɵadvance(2);
    ɵɵclassMap("mbsc-calendar-button-next" + (ctx_r1._pageNr > 1 ? " mbsc-calendar-button-next-multi" : ""));
  }
}
function MbscCalendarView_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscCalendarView_div_2_ng_template_1_Template, 0, 0, "ng-template", 13)(2, MbscCalendarView_div_2_ng_template_2_Template, 4, 4, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const defaultHeader_r3 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-controls mbsc-flex" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.headerTemplate || defaultHeader_r3);
  }
}
function MbscCalendarView_mbsc_calendar_weekdays_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar-weekdays", 16);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("dayNamesShort", ctx_r1._dayNames)("firstDay", ctx_r1.s.firstDay)("hasScroll", ctx_r1.state.hasScrollY)("hidden", ctx_r1._view !== ctx_r1.PAGE_VIEW && !ctx_r1._hasPicker)("showWeekNumbers", ctx_r1.s.showWeekNumbers)("rtl", ctx_r1._rtl)("theme", ctx_r1._theme);
  }
}
function MbscCalendarView_ng_template_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-month-view", 17);
  }
  if (rf & 2) {
    const timestamp_r4 = ctx2.timestamp;
    const drag_r5 = ctx2.drag;
    const isActive_r6 = ctx2.isActive;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("activeDate", ctx_r1._active)("amText", ctx_r1.s.amText)("calendarType", ctx_r1.s.calendarType)("cellTextHeight", ctx_r1.state.cellTextHeight)("clickToCreate", ctx_r1.s.clickToCreate)("colors", ctx_r1._colors)("dayNames", ctx_r1.s.dayNames)("dayNamesShort", ctx_r1._dayNames)("dayTemplate", ctx_r1.dayTemplate)("dayContentTemplate", ctx_r1.dayContentTemplate)("dataTimezone", ctx_r1.dataTimezone)("displayTimezone", ctx_r1.displayTimezone)("dragData", drag_r5 && ctx_r1.s.dragData)("dragToCreate", drag_r5 && ctx_r1.s.dragToCreate)("dragToResize", drag_r5 && ctx_r1.s.dragToResize)("dragToMove", drag_r5 && ctx_r1.s.dragToMove)("eventText", ctx_r1.s.eventText)("events", ctx_r1.s.eventMap)("eventsText", ctx_r1.s.eventsText)("exclusiveEndDates", ctx_r1.exclusiveEndDates)("firstDay", ctx_r1.s.firstDay)("firstPageDay", timestamp_r4)("getDate", ctx_r1.s.getDate)("getDay", ctx_r1.s.getDay)("getMonth", ctx_r1.s.getMonth)("getYear", ctx_r1.s.getYear)("getWeekNumber", ctx_r1.s.getWeekNumber)("hasMarks", !!ctx_r1._marked)("hoverEnd", ctx_r1.s.hoverEnd)("hoverStart", ctx_r1.s.hoverStart)("invalid", ctx_r1._invalid)("isActive", isActive_r6)("isPicker", ctx_r1.s.isPicker)("labels", ctx_r1._labelsLayout)("labelHeight", ctx_r1.state.labelHeight)("labelTemplate", ctx_r1.labelTemplate)("labelContentTemplate", ctx_r1.labelContentTemplate)("marked", ctx_r1._marked)("max", ctx_r1._maxDate)("min", ctx_r1._minDate)("monthNames", ctx_r1.s.monthNames)("monthNamesShort", ctx_r1.s.monthNamesShort)("onDayClick", ctx_r1._onDayClick)("onDayDoubleClick", ctx_r1.s.onDayDoubleClick)("onDayRightClick", ctx_r1.s.onDayRightClick)("onDayHoverIn", ctx_r1._onDayHoverIn)("onDayHoverOut", ctx_r1._onDayHoverOut)("onLabelClick", ctx_r1._onLabelClick)("onLabelDoubleClick", ctx_r1.s.onLabelDoubleClick)("onLabelRightClick", ctx_r1.s.onLabelRightClick)("onLabelHoverIn", ctx_r1.s.onLabelHoverIn)("onLabelHoverOut", ctx_r1.s.onLabelHoverOut)("onLabelDelete", ctx_r1.s.onLabelDelete)("onLabelUpdateStart", drag_r5 && ctx_r1.s.onLabelUpdateStart)("onLabelUpdateMove", drag_r5 && ctx_r1.s.onLabelUpdateMove)("onLabelUpdateEnd", drag_r5 && ctx_r1.s.onLabelUpdateEnd)("onLabelUpdateModeOn", drag_r5 && ctx_r1.s.onLabelUpdateModeOn)("onLabelUpdateModeOff", drag_r5 && ctx_r1.s.onLabelUpdateModeOff)("pmText", ctx_r1.s.pmText)("rangeEnd", ctx_r1.s.rangeEnd)("rangeStart", ctx_r1.s.rangeStart)("resourcesMap", ctx_r1.s.resourcesMap)("rtl", ctx_r1.s.rtl)("selectedDates", ctx_r1.s.selectedDates)("selectedEventsMap", ctx_r1.s.selectedEventsMap)("showEventTooltip", ctx_r1.s.showEventTooltip)("showOuter", ctx_r1._showOuter)("showSingleMark", !!ctx_r1.s.marksMap)("showWeekDays", !ctx_r1._showDaysTop)("showWeekNumbers", ctx_r1.s.showWeekNumbers)("theme", ctx_r1.s.theme)("timeFormat", ctx_r1.s.timeFormat)("timezonePlugin", ctx_r1.timezonePlugin)("todayText", ctx_r1.s.todayText)("valid", ctx_r1._valid)("variableRow", !!ctx_r1._variableRow)("weeks", ctx_r1._weeks)("weekText", ctx_r1.s.weekText);
  }
}
function MbscCalendarView_div_8_div_1_div_1_div_1_ng_template_3_Template(rf, ctx2) {
}
function MbscCalendarView_div_8_div_1_div_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, MbscCalendarView_div_8_div_1_div_1_div_1_ng_template_3_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r7 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    const monthView_r8 = ɵɵreference(5);
    ɵɵclassMap("mbsc-calendar-grid-item mbsc-flex-col mbsc-flex-1-1" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-month-title" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1._getMonthName(item_r7));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", monthView_r8)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c25, item_r7));
  }
}
function MbscCalendarView_div_8_div_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 21);
    ɵɵtemplate(1, MbscCalendarView_div_8_div_1_div_1_div_1_Template, 4, 9, "div", 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r9 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r9)("ngForTrackBy", ctx_r1._getKey);
  }
}
function MbscCalendarView_div_8_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscCalendarView_div_8_div_1_div_1_Template, 2, 2, "div", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-grid mbsc-flex-1-1 mbsc-flex-col" + ctx_r1._theme + ctx_r1._hb);
    ɵɵattribute("aria-hidden", ctx_r1._view !== ctx_r1.PAGE_VIEW);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1._monthsMulti)("ngForTrackBy", ctx_r1._getKey);
  }
}
function MbscCalendarView_div_8_div_2_ng_template_1_Template(rf, ctx2) {
}
function MbscCalendarView_div_8_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscCalendarView_div_8_div_2_ng_template_1_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    const monthView_r8 = ɵɵreference(5);
    ɵɵclassMap("mbsc-calendar-slide mbsc-calendar-slide-active " + ctx_r1._getPickerClass(ctx_r1.PAGE_VIEW));
    ɵɵattribute("aria-hidden", ctx_r1._view !== ctx_r1.PAGE_VIEW);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", monthView_r8)("ngTemplateOutletContext", ɵɵpureFunction1(5, _c26, ctx_r1._getFirstDay()));
  }
}
function MbscCalendarView_div_8_div_3_div_3_ng_template_1_Template(rf, ctx2) {
}
function MbscCalendarView_div_8_div_3_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵtemplate(1, MbscCalendarView_div_8_div_3_div_3_ng_template_1_Template, 0, 0, "ng-template", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r11 = ctx2.$implicit;
    ɵɵnextContext();
    const scrollview_r12 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    const monthView_r8 = ɵɵreference(5);
    ɵɵclassMap("mbsc-calendar-slide" + (item_r11.key >= ctx_r1._pageIndex && item_r11.key < ctx_r1._pageIndex + ctx_r1._pageNr && ctx_r1._view === ctx_r1.PAGE_VIEW ? " mbsc-calendar-slide-active" : "") + ctx_r1._theme + ctx_r1._rtl);
    ɵɵproperty("ngStyle", ctx_r1._getPageStyle(item_r11.key, scrollview_r12._offset, ctx_r1._pageIndex, ctx_r1._pageNr));
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", monthView_r8)("ngTemplateOutletContext", ɵɵpureFunction2(5, _c27, ctx_r1._getPageDay(item_r11.key), item_r11.key >= ctx_r1._pageIndex && item_r11.key < ctx_r1._pageIndex + ctx_r1._pageNr && ctx_r1._view === ctx_r1.PAGE_VIEW));
  }
}
function MbscCalendarView_div_8_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24);
    ɵɵlistener("animationend", function MbscCalendarView_div_8_div_3_Template_div_animationend_0_listener() {
      ɵɵrestoreView(_r10);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._onViewAnimationEnd());
    });
    ɵɵelementStart(1, "mbsc-scrollview-base", 25, 4);
    ɵɵtemplate(3, MbscCalendarView_div_8_div_3_div_3_Template, 2, 8, "div", 26);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const scrollview_r12 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1._getPickerClass(ctx_r1.PAGE_VIEW));
    ɵɵattribute("aria-hidden", ctx_r1._view !== ctx_r1.PAGE_VIEW);
    ɵɵadvance();
    ɵɵproperty("axis", ctx_r1._axis)("batchSize", 1)("changeOnEnd", true)("items", ctx_r1._months)("itemNr", ctx_r1._pageNr)("itemSize", ctx_r1.state.pageSize / ctx_r1._pageNr)("maxIndex", ctx_r1._maxIndex)("minIndex", ctx_r1._minIndex)("mouseSwipe", ctx_r1.s.mouseSwipe)("mousewheel", ctx_r1._mousewheel)("onAnimationEnd", ctx_r1._onAnimationEnd)("onGestureStart", ctx_r1._onGestureStart)("onIndexChange", ctx_r1._onPageChange)("onStart", ctx_r1._onStart)("prevAnim", ctx_r1._prevAnim)("rtl", ctx_r1.s.rtl)("selectedIndex", ctx_r1._pageIndex)("snap", true)("swipe", ctx_r1.s.swipe)("time", 200);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", scrollview_r12.visibleItems)("ngForTrackBy", ctx_r1._getKey);
  }
}
function MbscCalendarView_div_8_div_4_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MbscCalendarView_div_8_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", null, 5);
    ɵɵtemplate(2, MbscCalendarView_div_8_div_4_ng_container_2_Template, 1, 0, "ng-container", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const picker_r13 = ɵɵreference(12);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", picker_r13);
  }
}
function MbscCalendarView_div_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscCalendarView_div_8_div_1_Template, 2, 5, "div", 9)(2, MbscCalendarView_div_8_div_2_Template, 2, 7, "div", 9)(3, MbscCalendarView_div_8_div_3_Template, 4, 25, "div", 18)(4, MbscCalendarView_div_8_div_4_Template, 3, 1, "div", 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-calendar-body-inner mbsc-flex-col mbsc-flex-1-1" + (ctx_r1._variableRow ? " mbsc-calendar-body-inner-variable" : ""));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._isGrid);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1._isGrid && ctx_r1._variableRow);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.s.selectView === ctx_r1.PAGE_VIEW && !ctx_r1._isGrid && !ctx_r1._variableRow);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1._hasPicker);
  }
}
function MbscCalendarView_mbsc_popup_10_ng_container_10_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function MbscCalendarView_mbsc_popup_10_Template(rf, ctx2) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-popup", 29);
    ɵɵlistener("onClose", function MbscCalendarView_mbsc_popup_10_Template_mbsc_popup_onClose_0_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onPickerClose());
    })("onOpen", function MbscCalendarView_mbsc_popup_10_Template_mbsc_popup_onOpen_0_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onPickerOpen());
    });
    ɵɵelementStart(1, "div", 11);
    ɵɵlistener("keydown", function MbscCalendarView_mbsc_popup_10_Template_div_keydown_1_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onKeyDown($event));
    });
    ɵɵelementStart(2, "div")(3, "div", 30)(4, "mbsc-button", 31);
    ɵɵlistener("click", function MbscCalendarView_mbsc_popup_10_Template_mbsc_button_click_4_listener($event) {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onPickerBtnClick($event));
    });
    ɵɵtext(5);
    ɵɵelementEnd()();
    ɵɵelementStart(6, "mbsc-button", 32);
    ɵɵlistener("click", function MbscCalendarView_mbsc_popup_10_Template_mbsc_button_click_6_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.prevPage());
    });
    ɵɵelementEnd();
    ɵɵelementStart(7, "mbsc-button", 32);
    ɵɵlistener("click", function MbscCalendarView_mbsc_popup_10_Template_mbsc_button_click_7_listener() {
      ɵɵrestoreView(_r14);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.nextPage());
    });
    ɵɵelementEnd()();
    ɵɵelementStart(8, "div", 33, 5);
    ɵɵtemplate(10, MbscCalendarView_mbsc_popup_10_ng_container_10_Template, 1, 0, "ng-container", 28);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const picker_r13 = ɵɵreference(12);
    ɵɵproperty("anchor", ctx_r1._pickerBtn)("closeOnScroll", true)("contentPadding", false)("context", ctx_r1.s.context)("isOpen", ctx_r1._view !== ctx_r1.PAGE_VIEW)("locale", ctx_r1.s.locale)("rtl", ctx_r1.s.rtl)("scrollLock", false)("showOverlay", false)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵadvance(2);
    ɵɵclassMap("mbsc-calendar-controls mbsc-flex" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-picker-button-wrapper mbsc-calendar-title-wrapper mbsc-flex mbsc-flex-1-1" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵproperty("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1._viewTitle, " ");
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1._isPrevDisabled(true))("iconSvg", ctx_r1._prevIcon)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵattribute("aria-label", ctx_r1.s.prevPageText);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1._isNextDisabled(true))("iconSvg", ctx_r1._nextIcon)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵattribute("aria-label", ctx_r1.s.nextPageText);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", picker_r13);
  }
}
function MbscCalendarView_ng_template_11_div_0_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵelement(1, "mbsc-multi-year-view", 35);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r16 = ctx2.$implicit;
    ɵɵnextContext();
    const multiYearView_r17 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-picker-slide mbsc-calendar-slide" + ctx_r1._theme + ctx_r1._rtl);
    ɵɵproperty("ngStyle", ctx_r1._getPageStyle(item_r16.key, multiYearView_r17._offset, ctx_r1._yearsIndex));
    ɵɵattribute("aria-hidden", item_r16.key === ctx_r1._yearsIndex ? void 0 : "true");
    ɵɵadvance();
    ɵɵproperty("active", ctx_r1._active)("activeMonth", ctx_r1._activeMonth)("firstYear", ctx_r1._getPageYears(item_r16.key))("getDate", ctx_r1.s.getDate)("getYear", ctx_r1.s.getYear)("max", ctx_r1._maxYears)("min", ctx_r1._minYears)("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("yearSuffix", ctx_r1.s.yearSuffix)("onYearClick", ctx_r1._onYearClick);
  }
}
function MbscCalendarView_ng_template_11_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24);
    ɵɵlistener("animationend", function MbscCalendarView_ng_template_11_div_0_Template_div_animationend_0_listener() {
      ɵɵrestoreView(_r15);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._onViewAnimationEnd());
    });
    ɵɵelementStart(1, "mbsc-scrollview-base", 34, 6);
    ɵɵtemplate(3, MbscCalendarView_ng_template_11_div_0_div_3_Template, 2, 15, "div", 26);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const multiYearView_r17 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1._getPickerClass(ctx_r1.MULTI_YEAR_VIEW));
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-scroll-wrapper" + ctx_r1._theme);
    ɵɵproperty("axis", ctx_r1._axis)("batchSize", 1)("changeOnEnd", true)("items", ctx_r1._months)("itemSize", ctx_r1.state.pickerSize)("maxIndex", ctx_r1._maxYearsIndex)("minIndex", ctx_r1._minYearsIndex)("mousewheel", ctx_r1._mousewheel)("onGestureEnd", ctx_r1._onGestureEnd)("onIndexChange", ctx_r1._onYearsPageChange)("prevAnim", ctx_r1._prevAnim)("rtl", ctx_r1.s.rtl)("selectedIndex", ctx_r1._yearsIndex)("snap", true)("time", 200);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", multiYearView_r17.visibleItems)("ngForTrackBy", ctx_r1._getKey);
  }
}
function MbscCalendarView_ng_template_11_div_1_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵelement(1, "mbsc-year-view", 36);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r19 = ctx2.$implicit;
    ɵɵnextContext();
    const yearView_r20 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-picker-slide mbsc-calendar-slide" + ctx_r1._theme + ctx_r1._rtl);
    ɵɵproperty("ngStyle", ctx_r1._getPageStyle(item_r19.key, yearView_r20._offset, ctx_r1._yearIndex));
    ɵɵattribute("aria-hidden", item_r19.key === ctx_r1._yearIndex ? void 0 : "true");
    ɵɵadvance();
    ɵɵproperty("active", ctx_r1._active)("activeMonth", ctx_r1._activeMonth)("getDate", ctx_r1.s.getDate)("getMonth", ctx_r1.s.getMonth)("getYear", ctx_r1.s.getYear)("max", ctx_r1._maxYear)("min", ctx_r1._minYear)("monthNames", ctx_r1.s.monthNames)("monthNamesShort", ctx_r1.s.monthNamesShort)("onMonthClick", ctx_r1._onMonthClick)("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("year", ctx_r1._getPageYear(item_r19.key));
  }
}
function MbscCalendarView_ng_template_11_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r18 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24);
    ɵɵlistener("animationend", function MbscCalendarView_ng_template_11_div_1_Template_div_animationend_0_listener() {
      ɵɵrestoreView(_r18);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._onViewAnimationEnd());
    });
    ɵɵelementStart(1, "mbsc-scrollview-base", 34, 7);
    ɵɵtemplate(3, MbscCalendarView_ng_template_11_div_1_div_3_Template, 2, 17, "div", 26);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const yearView_r20 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1._getPickerClass(ctx_r1.YEAR_VIEW));
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-scroll-wrapper" + ctx_r1._theme);
    ɵɵproperty("axis", ctx_r1._axis)("batchSize", 1)("changeOnEnd", true)("items", ctx_r1._months)("itemSize", ctx_r1.state.pickerSize)("maxIndex", ctx_r1._maxYearIndex)("minIndex", ctx_r1._minYearIndex)("mousewheel", ctx_r1._mousewheel)("onGestureEnd", ctx_r1._onGestureEnd)("onIndexChange", ctx_r1._onYearPageChange)("prevAnim", ctx_r1._prevAnim)("rtl", ctx_r1.s.rtl)("selectedIndex", ctx_r1._yearIndex)("snap", true)("time", 200);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", yearView_r20.visibleItems)("ngForTrackBy", ctx_r1._getKey);
  }
}
function MbscCalendarView_ng_template_11_div_2_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵelement(1, "mbsc-month-view", 37);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r22 = ctx2.$implicit;
    ɵɵnextContext();
    const montView_r23 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-calendar-picker-slide mbsc-calendar-slide" + ctx_r1._theme + ctx_r1._rtl);
    ɵɵproperty("ngStyle", ctx_r1._getPageStyle(item_r22.key, montView_r23._offset, 1));
    ɵɵadvance();
    ɵɵproperty("activeDate", ctx_r1._activeMonth)("dataTimezone", ctx_r1.dataTimezone)("dayNames", ctx_r1.s.dayNames)("dayNamesShort", ctx_r1.s.dayNamesMin)("displayTimezone", ctx_r1.displayTimezone)("firstDay", ctx_r1.s.firstDay)("firstPageDay", ctx_r1._getPageMonth(item_r22.key))("getDate", ctx_r1.s.getDate)("getDay", ctx_r1.s.getDay)("getMonth", ctx_r1.s.getMonth)("getYear", ctx_r1.s.getYear)("isActive", item_r22.key >= ctx_r1._monthIndex && item_r22.key < ctx_r1._monthIndex + 1)("max", ctx_r1._maxDate)("min", ctx_r1._minDate)("monthNames", ctx_r1.s.monthNames)("monthNamesShort", ctx_r1.s.monthNamesShort)("onDayClick", ctx_r1._onNavDayClick)("rtl", ctx_r1.s.rtl)("selectedDates", ctx_r1.s.selectedDates)("showOuter", true)("showWeekDays", !ctx_r1._showDaysTop)("theme", ctx_r1.s.theme)("timezonePlugin", ctx_r1.timezonePlugin)("todayText", ctx_r1.s.todayText);
  }
}
function MbscCalendarView_ng_template_11_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    const _r21 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 24);
    ɵɵlistener("animationend", function MbscCalendarView_ng_template_11_div_2_Template_div_animationend_0_listener() {
      ɵɵrestoreView(_r21);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._onViewAnimationEnd());
    });
    ɵɵelementStart(1, "mbsc-scrollview-base", 34, 8);
    ɵɵtemplate(3, MbscCalendarView_ng_template_11_div_2_div_3_Template, 2, 27, "div", 26);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const montView_r23 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap(ctx_r1._getPickerClass(ctx_r1.MONTH_VIEW));
    ɵɵadvance();
    ɵɵclassMap("mbsc-calendar-scroll-wrapper" + ctx_r1._theme);
    ɵɵproperty("axis", ctx_r1._axis)("batchSize", 1)("changeOnEnd", true)("items", ctx_r1._months)("itemSize", ctx_r1.state.pickerSize)("maxIndex", ctx_r1._maxMonthIndex)("minIndex", ctx_r1._minMonthIndex)("mousewheel", ctx_r1._mousewheel)("onGestureEnd", ctx_r1._onGestureEnd)("onIndexChange", ctx_r1._onMonthPageChange)("prevAnim", ctx_r1._prevAnim)("rtl", ctx_r1.s.rtl)("selectedIndex", ctx_r1._monthIndex)("snap", true)("time", 200);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", montView_r23.visibleItems)("ngForTrackBy", ctx_r1._getKey);
  }
}
function MbscCalendarView_ng_template_11_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscCalendarView_ng_template_11_div_0_Template, 4, 21, "div", 18)(1, MbscCalendarView_ng_template_11_div_1_Template, 4, 21, "div", 18)(2, MbscCalendarView_ng_template_11_div_2_Template, 4, 21, "div", 18);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngIf", ctx_r1.state.view === ctx_r1.MULTI_YEAR_VIEW || ctx_r1.state.viewClosing === ctx_r1.MULTI_YEAR_VIEW || ctx_r1.selectView === ctx_r1.MULTI_YEAR_VIEW);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.state.view === ctx_r1.YEAR_VIEW || ctx_r1.state.viewClosing === ctx_r1.YEAR_VIEW || ctx_r1.selectView === ctx_r1.YEAR_VIEW);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._hasPicker && (ctx_r1.state.view === ctx_r1.MONTH_VIEW || ctx_r1.state.viewClosing === ctx_r1.MONTH_VIEW));
  }
}
var _c28 = ["cal"];
function MbscWheelItem_span_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "span");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap(ctx_r0._checkmarkClass);
  }
}
function MbscWheelItem_div_2_ng_template_1_Template(rf, ctx2) {
}
function MbscWheelItem_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscWheelItem_div_2_ng_template_1_Template, 0, 0, "ng-template", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.itemTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0.data));
  }
}
function MbscWheelItem_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.text);
  }
}
function MbscWheel_mbsc_wheel_item_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-wheel-item", 4);
  }
  if (rf & 2) {
    const item_r1 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext();
    const scrollview_r3 = ɵɵreference(1);
    ɵɵproperty("active", ctx_r1._isActive(item_r1, ctx_r1._getText(item_r1.data), false))("angle3d", ctx_r1._angle3d)("data", item_r1.data)("disabled", ctx_r1._isDisabled(item_r1.data))("height", ctx_r1.itemHeight)("is3d", false)("isGroup", item_r1.data && item_r1.data.isGroup)("index", item_r1.key)("itemTemplate", ctx_r1.itemTemplate)("multiple", ctx_r1.multiple)("offset", scrollview_r3._offset)("checkmark", ctx_r1.wheel.checkmark)("rows", ctx_r1.rows)("rtl", ctx_r1.rtl)("scroll3d", ctx_r1.scroll3d)("selected", ctx_r1._isSelected(item_r1))("text", ctx_r1._getText(item_r1.data))("theme", ctx_r1.theme)("onClick", ctx_r1._onItemClick);
  }
}
function MbscWheel_mbsc_wheel_item_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-wheel-item", 4);
  }
  if (rf & 2) {
    const item_r4 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext();
    const scrollview_r3 = ɵɵreference(1);
    ɵɵproperty("active", ctx_r1._isActive(item_r4, ctx_r1._getText(item_r4.data), true))("angle3d", ctx_r1._angle3d)("data", item_r4.data)("disabled", ctx_r1._isDisabled(item_r4.data))("height", ctx_r1.itemHeight)("is3d", true)("isGroup", item_r4.data && item_r4.data.isGroup)("index", item_r4.key)("itemTemplate", ctx_r1.itemTemplate)("multiple", ctx_r1.multiple)("offset", scrollview_r3._offset)("checkmark", ctx_r1.wheel.checkmark)("rows", ctx_r1.rows)("rtl", ctx_r1.rtl)("scroll3d", ctx_r1.scroll3d)("selected", ctx_r1._isSelected(item_r4))("text", ctx_r1._getText(item_r4.data))("theme", ctx_r1.theme)("onClick", ctx_r1._onItemClick);
  }
}
var _c29 = (a0) => ({
  data: a0
});
function MbscScroller_ng_template_0_Template(rf, ctx2) {
}
function MbscScroller_ng_template_2_Template(rf, ctx2) {
}
function MbscScroller_div_3_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-scroller-wheel-line" + ctx_r0._theme);
    ɵɵproperty("ngStyle", ctx_r0._lineStyle);
  }
}
function MbscScroller_div_3_mbsc_wheel_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-wheel", 5);
  }
  if (rf & 2) {
    const wheel_r2 = ctx2.$implicit;
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("activeIndex", ctx_r0._activeIndexes[wheel_r2._key])("disabled", ctx_r0._disabled && ctx_r0._disabled[wheel_r2._key])("display", ctx_r0._displayStyle)("itemHeight", ctx_r0.s.itemHeight)("onActiveChange", ctx_r0._onActiveChange)("onIndexChange", ctx_r0._onWheelIndexChange)("onSet", ctx_r0._onSet)("maxIndex", wheel_r2.max)("maxWheelWidth", ctx_r0.s.maxWheelWidth)("minIndex", wheel_r2.min)("minWheelWidth", ctx_r0.s.minWheelWidth)("multiple", wheel_r2.multiple)("rows", ctx_r0._rows)("scroll3d", ctx_r0._scroll3d)("selectedIndex", ctx_r0._indexes[wheel_r2._key])("selectedValues", ctx_r0._tempValueRep[wheel_r2._key])("selectOnScroll", ctx_r0.s.selectOnScroll)("itemTemplate", ctx_r0.s.itemTemplate)("theme", ctx_r0.s.theme)("rtl", ctx_r0.s.rtl)("wheel", wheel_r2)("wheelWidth", ctx_r0.s.wheelWidth)("touchUi", ctx_r0.s.touchUi);
  }
}
function MbscScroller_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScroller_div_3_div_1_Template, 1, 3, "div", 2);
    ɵɵelementStart(2, "div");
    ɵɵelement(3, "div", 3);
    ɵɵtemplate(4, MbscScroller_div_3_mbsc_wheel_4_Template, 1, 23, "mbsc-wheel", 4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const wheelGroup_r3 = ctx2.$implicit;
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-scroller-wheel-group-cont" + (ctx_r0.s.scroll3d ? " mbsc-scroller-wheel-group-cont-3d" : "") + ctx_r0._theme);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.s.selectOnScroll);
    ɵɵadvance();
    ɵɵclassMap("mbsc-flex mbsc-scroller-wheel-group" + (ctx_r0.s.scroll3d ? " mbsc-scroller-wheel-group-3d" : "") + ctx_r0._theme);
    ɵɵadvance();
    ɵɵclassMap("mbsc-scroller-wheel-overlay mbsc-scroller-wheel-overlay-" + ctx_r0._displayStyle + ctx_r0._theme);
    ɵɵproperty("ngStyle", ctx_r0._overlayStyle);
    ɵɵadvance();
    ɵɵproperty("ngForOf", wheelGroup_r3);
  }
}
function MbscTimegrid_div_0_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵelement(1, "div", 3)(2, "mbsc-timebox", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const v_r1 = ctx2.$implicit;
    const cellIndex_r2 = ctx2.index;
    const rowIndex_r3 = ɵɵnextContext().index;
    const ctx_r3 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timegrid-cell" + (ctx_r3._isDisabled(v_r1.value) ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵproperty("innerHTML", ctx_r3.textParamMulti(rowIndex_r3 * 3 + cellIndex_r2), ɵɵsanitizeHtml);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r3._isDisabled(v_r1.value))("selected", ctx_r3._value === v_r1.value)("timeSlot", v_r1)("theme", ctx_r3._theme)("onClick", ctx_r3._setTime)("onKeyDown", ctx_r3._onKeyDown);
  }
}
function MbscTimegrid_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1);
    ɵɵtemplate(1, MbscTimegrid_div_0_div_1_Template, 3, 9, "div", 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const arr_r5 = ctx2.$implicit;
    const ctx_r3 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", arr_r5)("ngForTrackBy", ctx_r3._getKey);
  }
}
var _c30 = ["box"];
var _c31 = ["ctrlVar"];
function MbscDatepicker_mbsc_input_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-input", 7, 1);
    ɵɵprojection(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ariaExpanded", !!ctx_r1._isOpen)("ariaHaspopup", "dialog")("ariaLabel", ctx_r1.ariaLabel)("dropdown", ctx_r1.s.dropdown)("disabled", ctx_r1.disabled)("endIcon", ctx_r1.endIcon)("endIconSrc", ctx_r1.endIconSrc)("endIconSvg", ctx_r1.endIconSvg)("error", ctx_r1.error)("errorMessage", ctx_r1.errorMessage)("inputStyle", ctx_r1.s.inputStyle)("label", ctx_r1.label)("labelStyle", ctx_r1.s.labelStyle)("name", ctx_r1.name)("placeholder", ctx_r1.placeholder)("pickerMap", ctx_r1._valueMap)("pickerValue", ctx_r1._value)("role", "combobox")("rtl", ctx_r1.s.rtl)("startIcon", ctx_r1.startIcon)("startIconSrc", ctx_r1.startIconSrc)("startIconSvg", ctx_r1.startIconSvg)("tags", ctx_r1.s.tagInput === void 0 ? ctx_r1.s.selectMultiple : ctx_r1.s.tagInput)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant)("value", ctx_r1._value != null && ctx_r1._valueText || "");
  }
}
function MbscDatepicker_ng_container_3_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-picker-header" + ctx_r1._theme + ctx_r1._hb);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1._headerText, " ");
  }
}
function MbscDatepicker_ng_container_3_mbsc_segmented_group_3_mbsc_segmented_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-segmented", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const control_r4 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant)("value", control_r4.name);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", control_r4.title, " ");
  }
}
function MbscDatepicker_ng_container_3_mbsc_segmented_group_3_Template(rf, ctx2) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-segmented-group", 11);
    ɵɵtwoWayListener("ngModelChange", function MbscDatepicker_ng_container_3_mbsc_segmented_group_3_Template_mbsc_segmented_group_ngModelChange_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1._activeTab, $event) || (ctx_r1._activeTab = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("change", function MbscDatepicker_ng_container_3_mbsc_segmented_group_3_Template_mbsc_segmented_group_change_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._changeActiveTab($event));
    });
    ɵɵtemplate(1, MbscDatepicker_ng_container_3_mbsc_segmented_group_3_mbsc_segmented_1_Template, 2, 5, "mbsc-segmented", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵtwoWayProperty("ngModel", ctx_r1._activeTab);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1._controls);
  }
}
function MbscDatepicker_ng_container_3_div_4_mbsc_icon_7_Template(rf, ctx2) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 17);
    ɵɵlistener("click", function MbscDatepicker_ng_container_3_div_4_mbsc_icon_7_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1._clearStart());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-range-label-clear" + ctx_r1._rtl);
    ɵɵproperty("svg", ctx_r1.s.clearIcon)("theme", ctx_r1.s.theme);
  }
}
function MbscDatepicker_ng_container_3_div_4_mbsc_icon_13_Template(rf, ctx2) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 17);
    ɵɵlistener("click", function MbscDatepicker_ng_container_3_div_4_mbsc_icon_13_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1._clearEnd());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-range-label-clear" + ctx_r1._rtl);
    ɵɵproperty("svg", ctx_r1.s.clearIcon)("theme", ctx_r1.s.theme);
  }
}
function MbscDatepicker_ng_container_3_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "mbsc-segmented-group", 11);
    ɵɵtwoWayListener("ngModelChange", function MbscDatepicker_ng_container_3_div_4_Template_mbsc_segmented_group_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1._activeSelect, $event) || (ctx_r1._activeSelect = $event);
      return ɵɵresetView($event);
    });
    ɵɵlistener("change", function MbscDatepicker_ng_container_3_div_4_Template_mbsc_segmented_group_change_1_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._changeActiveSelect($event));
    });
    ɵɵelementStart(2, "mbsc-segmented", 14)(3, "div");
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div");
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵtemplate(7, MbscDatepicker_ng_container_3_div_4_mbsc_icon_7_Template, 1, 4, "mbsc-icon", 15);
    ɵɵelementEnd();
    ɵɵelementStart(8, "mbsc-segmented", 16)(9, "div");
    ɵɵtext(10);
    ɵɵelementEnd();
    ɵɵelementStart(11, "div");
    ɵɵtext(12);
    ɵɵelementEnd();
    ɵɵtemplate(13, MbscDatepicker_ng_container_3_div_4_mbsc_icon_13_Template, 1, 4, "mbsc-icon", 15);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-range-control-wrapper" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵproperty("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵtwoWayProperty("ngModel", ctx_r1._activeSelect);
    ɵɵadvance();
    ɵɵclassMap("mbsc-range-start" + (ctx_r1._tempStartText ? " mbsc-range-value-nonempty" : ""));
    ɵɵproperty("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵadvance();
    ɵɵclassMap("mbsc-range-control-label" + ctx_r1._theme + ctx_r1._rtl + (ctx_r1._activeSelect === "start" ? " active" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.rangeStartLabel);
    ɵɵadvance();
    ɵɵclassMap("mbsc-range-control-value" + ctx_r1._theme + ctx_r1._rtl + (ctx_r1._activeSelect === "start" ? " active" : "") + (!ctx_r1._tempStartText ? " mbsc-range-control-text-empty" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1._tempStartText || ctx_r1.s.rangeStartHelp);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._activeSelect === "start" && ctx_r1._tempStartText);
    ɵɵadvance();
    ɵɵclassMap("mbsc-range-end" + (ctx_r1._tempEndText ? " mbsc-range-value-nonempty" : ""));
    ɵɵproperty("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵadvance();
    ɵɵclassMap("mbsc-range-control-label" + ctx_r1._theme + ctx_r1._rtl + (ctx_r1._activeSelect === "end" ? " active" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.rangeEndLabel);
    ɵɵadvance();
    ɵɵclassMap("mbsc-range-control-value" + ctx_r1._theme + ctx_r1._rtl + (ctx_r1._activeSelect === "end" ? " active" : "") + (!ctx_r1._tempEndText ? " mbsc-range-control-text-empty" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1._tempEndText || ctx_r1.s.rangeEndHelp);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._activeSelect === "end" && ctx_r1._tempEndText);
  }
}
function MbscDatepicker_ng_container_3_div_7_mbsc_calendar_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-calendar", 19, 3);
  }
  if (rf & 2) {
    const control_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("options", control_r8.options);
  }
}
function MbscDatepicker_ng_container_3_div_7_mbsc_datetime_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-datetime", 19, 3);
  }
  if (rf & 2) {
    const control_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("options", control_r8.options);
  }
}
function MbscDatepicker_ng_container_3_div_7_mbsc_date_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-date", 19, 3);
  }
  if (rf & 2) {
    const control_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("options", control_r8.options);
  }
}
function MbscDatepicker_ng_container_3_div_7_mbsc_time_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-time", 19, 3);
  }
  if (rf & 2) {
    const control_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("options", control_r8.options);
  }
}
function MbscDatepicker_ng_container_3_div_7_mbsc_timegrid_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-timegrid", 19, 3);
  }
  if (rf & 2) {
    const control_r8 = ɵɵnextContext().$implicit;
    ɵɵproperty("options", control_r8.options);
  }
}
function MbscDatepicker_ng_container_3_div_7_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscDatepicker_ng_container_3_div_7_mbsc_calendar_1_Template, 2, 1, "mbsc-calendar", 18)(2, MbscDatepicker_ng_container_3_div_7_mbsc_datetime_2_Template, 2, 1, "mbsc-datetime", 18)(3, MbscDatepicker_ng_container_3_div_7_mbsc_date_3_Template, 2, 1, "mbsc-date", 18)(4, MbscDatepicker_ng_container_3_div_7_mbsc_time_4_Template, 2, 1, "mbsc-time", 18)(5, MbscDatepicker_ng_container_3_div_7_mbsc_timegrid_5_Template, 2, 1, "mbsc-timegrid", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const control_r8 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-flex mbsc-datepicker-tab mbsc-datepicker-tab-" + control_r8.name + ctx_r1._theme + (ctx_r1._renderTabs && control_r8.name === ctx_r1._activeTab || !ctx_r1._renderTabs ? " mbsc-datepicker-tab-active" : "") + (ctx_r1._renderTabs && control_r8.name === "time" ? " mbsc-datepicker-time-modal" : "") + (ctx_r1._renderTabs || ctx_r1._controls.length === 1 ? " mbsc-datepicker-tab-expand mbsc-flex-1-1" : ""));
    ɵɵadvance();
    ɵɵproperty("ngIf", control_r8.name === "calendar");
    ɵɵadvance();
    ɵɵproperty("ngIf", control_r8.name === "datetime");
    ɵɵadvance();
    ɵɵproperty("ngIf", control_r8.name === "date");
    ɵɵadvance();
    ɵɵproperty("ngIf", control_r8.name === "time");
    ɵɵadvance();
    ɵɵproperty("ngIf", control_r8.name === "timegrid");
  }
}
function MbscDatepicker_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div");
    ɵɵtemplate(2, MbscDatepicker_ng_container_3_div_2_Template, 2, 3, "div", 8)(3, MbscDatepicker_ng_container_3_mbsc_segmented_group_3_Template, 2, 5, "mbsc-segmented-group", 9)(4, MbscDatepicker_ng_container_3_div_4_Template, 14, 30, "div", 8);
    ɵɵelementStart(5, "div", null, 2);
    ɵɵtemplate(7, MbscDatepicker_ng_container_3_div_7_Template, 6, 7, "div", 10);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMap("mbsc-datepicker mbsc-flex-col mbsc-datepicker-" + ctx_r1.s.display + ctx_r1._theme + (ctx_r1.s.display === "inline" ? " " + ctx_r1._className + ctx_r1._hb : "") + ctx_r1._controlsClass);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._headerText && ctx_r1.s.display === "inline");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._renderTabs);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._renderControls);
    ɵɵadvance();
    ɵɵclassMap("mbsc-datepicker-tab-wrapper mbsc-flex mbsc-flex-1-1 " + ctx_r1._theme);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r1._controls);
  }
}
var _c32 = ["defaultInput"];
var _c33 = ["filterInput"];
function MbscSelect_mbsc_input_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-input", 10, 2);
    ɵɵprojection(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ariaExpanded", !!ctx_r1._isOpen)("ariaHaspopup", "dialog")("ariaLabel", ctx_r1.ariaLabel)("dropdown", ctx_r1.s.dropdown)("disabled", ctx_r1.disabled)("endIcon", ctx_r1.endIcon)("endIconSrc", ctx_r1.endIconSrc)("endIconSvg", ctx_r1.endIconSvg)("error", ctx_r1.error)("errorMessage", ctx_r1.errorMessage)("inputStyle", ctx_r1.s.inputStyle)("label", ctx_r1.label)("labelStyle", ctx_r1.s.labelStyle)("name", ctx_r1.name)("placeholder", ctx_r1.placeholder)("pickerMap", ctx_r1._valueMap)("pickerValue", ctx_r1._value)("role", "combobox")("rtl", ctx_r1.s.rtl)("startIcon", ctx_r1.startIcon)("startIconSrc", ctx_r1.startIconSrc)("startIconSvg", ctx_r1.startIconSvg)("tags", ctx_r1.s.tagInput === void 0 ? ctx_r1.s.selectMultiple : ctx_r1.s.tagInput)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant)("value", ctx_r1._value != null && ctx_r1._valueText || "");
  }
}
function MbscSelect_ng_container_5_ng_template_1_mbsc_icon_3_Template(rf, ctx2) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 14);
    ɵɵlistener("click", function MbscSelect_ng_container_5_ng_template_1_mbsc_icon_3_Template_mbsc_icon_click_0_listener() {
      ɵɵrestoreView(_r6);
      const inst_r5 = ɵɵnextContext().data;
      return ɵɵresetView(inst_r5._onFilterClear());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const inst_r5 = ɵɵnextContext().data;
    ɵɵclassMap("mbsc-select-filter-clear" + inst_r5._rtl);
    ɵɵproperty("svg", inst_r5.s.clearIcon)("theme", inst_r5.s.theme);
  }
}
function MbscSelect_ng_container_5_ng_template_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div")(1, "mbsc-input", 12, 5);
    ɵɵlistener("input", function MbscSelect_ng_container_5_ng_template_1_Template_mbsc_input_input_1_listener($event) {
      const inst_r5 = ɵɵrestoreView(_r4).data;
      return ɵɵresetView(inst_r5._onFilterChange($event));
    });
    ɵɵelementEnd();
    ɵɵtemplate(3, MbscSelect_ng_container_5_ng_template_1_mbsc_icon_3_Template, 1, 4, "mbsc-icon", 13);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const inst_r5 = ctx2.data;
    ɵɵclassMap("mbsc-select-filter-cont" + inst_r5._theme + inst_r5._rtl);
    ɵɵadvance();
    ɵɵproperty("placeholder", inst_r5.s.filterPlaceholderText)("rtl", inst_r5.s.rtl)("theme", inst_r5.s.theme)("themeVariant", inst_r5.s.themeVariant);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", inst_r5._filterText);
  }
}
function MbscSelect_ng_container_5_ng_template_3_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const inst_r7 = ɵɵnextContext().data;
    ɵɵclassMap("mbsc-select-empty-text mbsc-flex" + inst_r7._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(inst_r7.s.filterEmptyText);
  }
}
function MbscSelect_ng_container_5_ng_template_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscSelect_ng_container_5_ng_template_3_div_0_Template, 2, 3, "div", 15);
  }
  if (rf & 2) {
    const inst_r7 = ctx2.data;
    ɵɵproperty("ngIf", inst_r7._noResults);
  }
}
function MbscSelect_ng_container_5_Template(rf, ctx2) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscSelect_ng_container_5_ng_template_1_Template, 4, 7, "ng-template", null, 3, ɵɵtemplateRefExtractor)(3, MbscSelect_ng_container_5_ng_template_3_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    ɵɵelementStart(5, "mbsc-scroller", 11);
    ɵɵlistener("onChange", function MbscSelect_ng_container_5_Template_mbsc_scroller_onChange_5_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onChange($event));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const filterInputTemplate_r8 = ɵɵreference(2);
    const filterEmptyTemplate_r9 = ɵɵreference(4);
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(5);
    ɵɵclassMap((ctx_r1.s.cssClass || ctx_r1.s.class || "") + (ctx_r1._noResults ? " mbsc-select-empty" : "") + " mbsc-select-scroller mbsc-select-scroller-" + ctx_r1.s.display);
    ɵɵproperty("circular", ctx_r1.s.circular)("display", ctx_r1.s.display)("getValue", ctx_r1._get)("inContentTemplate", filterEmptyTemplate_r9)("invalid", ctx_r1.s.invalid)("itemHeight", ctx_r1.s.itemHeight)("itemTemplate", ctx_r1.itemTemplate)("maxWheelWidth", ctx_r1.s.maxWheelWidth)("minWheelWidth", ctx_r1.s.minWheelWidth)("onWheelMove", ctx_r1._onWheelMove)("parseValue", ctx_r1._parse)("preContentData", ctx_r1)("preContentTemplate", ctx_r1.s.filter && filterInputTemplate_r8)("rows", ctx_r1._rows)("rtl", ctx_r1.s.rtl)("selectOnScroll", ctx_r1._selectOnScroll)("shouldValidate", ctx_r1._shouldValidate)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant)("touchUi", ctx_r1._touchUi)("validate", ctx_r1._validateScroller)("valueEquality", ctx_r1._valueEquals)("value", ctx_r1._tempVal)("wheelWidth", ctx_r1._wheelWidth)("wheels", ctx_r1._wheels);
  }
}
function MbscScheduleEvent_div_0_1_ng_template_0_Template(rf, ctx2) {
}
function MbscScheduleEvent_div_0_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscScheduleEvent_div_0_1_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.bufferBeforeTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0.event));
  }
}
function MbscScheduleEvent_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtemplate(1, MbscScheduleEvent_div_0_1_Template, 1, 4, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-" + ctx_r0._host + "-event-buffer mbsc-" + ctx_r0._host + "-event-buffer-before" + (ctx_r0.bufferBeforeTemplate ? "" : " mbsc-schedule-event-buffer-background") + ctx_r0._theme + ctx_r0._rtl);
    ɵɵproperty("ngStyle", ctx_r0._bufferStyleStart);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.bufferBeforeTemplate);
  }
}
function MbscScheduleEvent_div_1_1_ng_template_0_Template(rf, ctx2) {
}
function MbscScheduleEvent_div_1_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscScheduleEvent_div_1_1_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.bufferAfterTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0.event));
  }
}
function MbscScheduleEvent_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtemplate(1, MbscScheduleEvent_div_1_1_Template, 1, 4, null, 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-" + ctx_r0._host + "-event-buffer mbsc-" + ctx_r0._host + "-event-buffer-after" + (ctx_r0.isTimeline ? " mbsc-timeline-event-buffer" : "") + (ctx_r0.bufferAfterTemplate ? "" : " mbsc-schedule-event-buffer-background") + ctx_r0._theme + ctx_r0._rtl);
    ɵɵproperty("ngStyle", ctx_r0._bufferStyleEnd);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.bufferAfterTemplate);
  }
}
function MbscScheduleEvent_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-event-resize mbsc-schedule-event-resize-start" + (ctx_r0.isDrag ? " mbsc-schedule-event-resize-start-touch" : "") + (ctx_r0.isTimeline ? " mbsc-timeline-event-resize" : "") + ctx_r0._rtl);
  }
}
function MbscScheduleEvent_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-event-resize mbsc-schedule-event-resize-end" + (ctx_r0.isDrag ? " mbsc-schedule-event-resize-start-touch" : "") + (ctx_r0.isTimeline ? " mbsc-timeline-event-resize" : "") + ctx_r0._rtl);
  }
}
function MbscScheduleEvent_ng_template_4_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-schedule-event-bar" + ctx_r0._theme + ctx_r0._rtl);
  }
}
function MbscScheduleEvent_ng_template_4_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("innerHTML", ctx_r0._html, ɵɵsanitizeHtml);
  }
}
function MbscScheduleEvent_ng_template_4_5_ng_template_0_Template(rf, ctx2) {
}
function MbscScheduleEvent_ng_template_4_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscScheduleEvent_ng_template_4_5_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r0.contentTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0.event));
  }
}
function MbscScheduleEvent_ng_template_4_div_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-schedule-event-range" + ctx_r0._theme);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0._rangeText, " ");
  }
}
function MbscScheduleEvent_ng_template_4_div_7_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 10);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.event.ariaLabel);
  }
}
function MbscScheduleEvent_ng_template_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscScheduleEvent_ng_template_4_div_0_Template, 1, 2, "div", 2);
    ɵɵelement(1, "div");
    ɵɵelementStart(2, "div", 7)(3, "div");
    ɵɵtemplate(4, MbscScheduleEvent_ng_template_4_div_4_Template, 1, 1, "div", 8)(5, MbscScheduleEvent_ng_template_4_5_Template, 1, 4, null, 6);
    ɵɵelementEnd();
    ɵɵtemplate(6, MbscScheduleEvent_ng_template_4_div_6_Template, 2, 3, "div", 2);
    ɵɵelementEnd();
    ɵɵtemplate(7, MbscScheduleEvent_ng_template_4_div_7_Template, 2, 1, "div", 9);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngIf", !ctx_r0._isAllDay && !ctx_r0._isMore && !ctx_r0.isTimeline);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-event-background" + (ctx_r0.isTimeline ? " mbsc-timeline-event-background" : "") + (ctx_r0._isAllDay ? " mbsc-schedule-event-all-day-background" : "") + ctx_r0._theme);
    ɵɵstyleProp("background", ctx_r0.event.style.background);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-event-inner" + ctx_r0._theme + (ctx_r0._isAllDay ? " mbsc-schedule-event-all-day-inner" : "") + (ctx_r0.event.cssClass || ""));
    ɵɵstyleProp("color", ctx_r0.event.style.color)("left", !ctx_r0.s.rtl ? ctx_r0.s.stickyPos : void 0)("right", ctx_r0.s.rtl ? ctx_r0.s.stickyPos : void 0);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-event-title" + (ctx_r0._isAllDay ? " mbsc-schedule-event-all-day-title" : "") + ctx_r0._theme);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0.contentTemplate || ctx_r0._isMore);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.contentTemplate && !ctx_r0._isMore);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r0._isAllDay && !ctx_r0._isMore);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.event.ariaLabel);
  }
}
function MbscScheduleEvent_ng_template_6_Template(rf, ctx2) {
}
function MbscWeekDay_0_ng_template_0_Template(rf, ctx2) {
}
function MbscWeekDay_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscWeekDay_0_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.dayTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0._data));
  }
}
function MbscWeekDay_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-header-dayname" + ctx_r0._theme + (ctx_r0.s.selected ? " mbsc-selected" : "") + (ctx_r0.s.isToday ? " mbsc-schedule-header-dayname-curr" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.dayNames[ctx_r0._day], " ");
  }
}
function MbscWeekDay_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-header-day" + ctx_r0._theme + ctx_r0._rtl + (ctx_r0.s.selected ? " mbsc-selected" : "") + (ctx_r0.s.isToday ? " mbsc-schedule-header-day-today" : "") + (ctx_r0.state.hasHover ? " mbsc-hover" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.day, " ");
  }
}
function MbscWeekDay_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("role", ctx_r0.s.selectable ? "button" : null)("aria-pressed", ctx_r0.s.selectable ? ctx_r0.s.selected ? "true" : "false" : null);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r0.label, " ");
  }
}
function MbscWeekDay_4_ng_template_0_Template(rf, ctx2) {
}
function MbscWeekDay_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscWeekDay_4_ng_template_0_Template, 0, 0, "ng-template", 3);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.dayContentTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, ctx_r0._data));
  }
}
function MbscTimeIndicator_ng_container_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const i_r1 = ctx2.index;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-schedule-time-indicator-tz" + ctx_r1._theme + ctx_r1._rtl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1._times[i_r1], " ");
  }
}
function MbscTimeIndicator_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeIndicator_ng_container_2_div_1_Template, 2, 3, "div", 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.timezones)("ngForTrackBy", ctx_r1._getKey);
  }
}
function MbscTimeIndicator_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1._time, " ");
  }
}
function MbscTimeIndicator_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-time-indicator-day" + ctx_r1._theme + ctx_r1._rtl);
    ɵɵproperty("ngStyle", ctx_r1._dayPos);
  }
}
var _c34 = ["scrollCont"];
var _c35 = ["gridCont"];
var _c36 = ["headerCont"];
var _c37 = ["allDayCont"];
var _c38 = ["timeCont"];
var _c39 = ["cursorTimeCont"];
var _c40 = (a0, a1, a2, a3, a4) => ({
  allDay: true,
  dateKey: a0,
  dragData: a1,
  dragKey: a2,
  events: a3,
  resource: a4
});
var _c41 = (a0, a1, a2, a3, a4) => ({
  allDay: false,
  dateKey: a0,
  dragData: a1,
  dragKey: a2,
  events: a3,
  resource: a4
});
var _c42 = () => ({});
var _c43 = (a0, a1) => ({
  $implicit: a0,
  day: a1
});
var _c44 = (a0, a1, a2, a3) => ({
  dateKey: a0,
  dayName: a1,
  resource: a2,
  timestamp: a3
});
var _c45 = (a0) => ({
  index: a0
});
var _c46 = () => ({
  index: 0
});
function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-schedule-event", 36);
    ɵɵlistener("onClick", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onClick_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2._onEventClick($event));
    })("onDoubleClick", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDoubleClick_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2.onEventDoubleClick($event));
    })("onRightClick", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onRightClick_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2.onEventRightClick($event));
    })("onHoverIn", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onHoverIn_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2.onEventHoverIn($event));
    })("onHoverOut", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onHoverOut_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2.onEventHoverOut($event));
    })("onDelete", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDelete_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2.onEventDelete($event));
    })("onDragStart", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragStart_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2._onEventDragStart($event));
    })("onDragMove", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragMove_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2._onEventDragMove($event));
    })("onDragEnd", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragEnd_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2._onEventDragEnd($event));
    })("onDragModeOn", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragModeOn_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2._onEventDragModeOn($event));
    })("onDragModeOff", function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragModeOff_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r2._onEventDragModeOff($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r4 = ɵɵnextContext().$implicit;
    const ctx_r4 = ɵɵnextContext(2);
    const dragData_r6 = ctx_r4.dragData;
    const resource_r7 = ctx_r4.resource;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("bufferAfterTemplate", ctx_r2.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r2.bufferBeforeTemplate)("contentTemplate", ctx_r2.eventContentTemplate)("displayTimezone", ctx_r2.displayTimezone)("drag", ctx_r2.dragToMove || ctx_r2.externalDrag)("event", event_r4)("endDay", ctx_r2.endDay)("exclusiveEndDates", ctx_r2.exclusiveEndDates)("gridEndTime", ctx_r2._endTime)("gridStartTime", ctx_r2._startTime)("inactive", dragData_r6 && dragData_r6.draggedEvent && dragData_r6.draggedEvent.id === event_r4.id)("lastDay", ctx_r2._lastDay)("resize", ctx_r2._computeEventResize(event_r4.original.resize, ctx_r2.dragToResize, resource_r7.eventResize))("resource", resource_r7.id)("resourceObj", resource_r7)("rtl", ctx_r2.rtl)("singleDay", !ctx_r2._groupByResource)("selected", !!(ctx_r2.selectedEventsMap[event_r4.uid] || ctx_r2.selectedEventsMap[event_r4.id]))("slot", ctx_r2._defId)("startDay", ctx_r2.startDay)("theme", ctx_r2.theme)("template", ctx_r2.eventTemplate)("timezonePlugin", ctx_r2.timezonePlugin);
  }
}
function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 37);
    ɵɵelement(1, "div");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-event-all-day-inner" + ctx_r2._theme);
  }
}
function MbscScheduler_ng_template_0_ng_container_0_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_template_0_ng_container_0_ng_container_1_mbsc_schedule_event_1_Template, 1, 23, "mbsc-schedule-event", 34)(2, MbscScheduler_ng_template_0_ng_container_0_ng_container_1_div_2_Template, 2, 2, "div", 35);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const event_r4 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", event_r4.showText && event_r4.position);
    ɵɵadvance();
    ɵɵproperty("ngIf", !event_r4.showText);
  }
}
function MbscScheduler_ng_template_0_ng_container_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_template_0_ng_container_0_ng_container_1_Template, 3, 2, "ng-container", 33);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const events_r8 = ɵɵnextContext().events;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", events_r8)("ngForTrackBy", ctx_r2._getEventKey);
  }
}
function MbscScheduler_ng_template_0_mbsc_schedule_event_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-schedule-event", 38);
    ɵɵlistener("onDragStart", function MbscScheduler_ng_template_0_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragStart_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2._onEventDragStart($event));
    })("onDragMove", function MbscScheduler_ng_template_0_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragMove_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2._onEventDragMove($event));
    })("onDragEnd", function MbscScheduler_ng_template_0_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragEnd_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2._onEventDragEnd($event));
    })("onDragModeOff", function MbscScheduler_ng_template_0_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragModeOff_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2._onEventDragModeOff($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const dragData_r6 = ctx_r4.dragData;
    const dragKey_r10 = ctx_r4.dragKey;
    const resource_r7 = ctx_r4.resource;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("bufferAfterTemplate", ctx_r2.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r2.bufferBeforeTemplate)("contentTemplate", ctx_r2.eventContentTemplate)("displayTimezone", ctx_r2.displayTimezone)("drag", ctx_r2.dragToMove || ctx_r2.externalDrag)("event", dragData_r6.originDates[dragKey_r10])("endDay", ctx_r2.endDay)("exclusiveEndDates", ctx_r2.exclusiveEndDates)("gridEndTime", ctx_r2._endTime)("gridStartTime", ctx_r2._startTime)("hidden", !!dragData_r6.draggedDates)("isDrag", true)("lastDay", ctx_r2._lastDay)("resize", ctx_r2._computeEventResize(dragData_r6.originDates[dragKey_r10].original.resize, ctx_r2.dragToResize, resource_r7.eventResize))("resource", resource_r7.id)("resourceObj", resource_r7)("rtl", ctx_r2.rtl)("singleDay", !ctx_r2._groupByResource)("slot", ctx_r2._defId)("startDay", ctx_r2.startDay)("theme", ctx_r2.theme)("template", ctx_r2.eventTemplate)("timezonePlugin", ctx_r2.timezonePlugin);
  }
}
function MbscScheduler_ng_template_0_mbsc_schedule_event_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-schedule-event", 39);
  }
  if (rf & 2) {
    const ctx_r4 = ɵɵnextContext();
    const dragData_r6 = ctx_r4.dragData;
    const dragKey_r10 = ctx_r4.dragKey;
    const resource_r7 = ctx_r4.resource;
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("bufferAfterTemplate", ctx_r2.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r2.bufferBeforeTemplate)("contentTemplate", ctx_r2.eventContentTemplate)("displayTimezone", ctx_r2.displayTimezone)("drag", ctx_r2.dragToMove || ctx_r2.externalDrag)("event", dragData_r6.draggedDates[dragKey_r10])("endDay", ctx_r2.endDay)("exclusiveEndDates", ctx_r2.exclusiveEndDates)("gridEndTime", ctx_r2._endTime)("gridStartTime", ctx_r2._startTime)("isDrag", true)("lastDay", ctx_r2._lastDay)("resize", ctx_r2._computeEventResize(dragData_r6.draggedDates[dragKey_r10].original.resize, ctx_r2.dragToResize, resource_r7.eventResize))("resource", resource_r7.id)("resourceObj", resource_r7)("rtl", ctx_r2.rtl)("singleDay", !ctx_r2._groupByResource)("slot", ctx_r2._defId)("startDay", ctx_r2.startDay)("theme", ctx_r2.theme)("template", ctx_r2.eventTemplate)("timezonePlugin", ctx_r2.timezonePlugin);
  }
}
function MbscScheduler_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscScheduler_ng_template_0_ng_container_0_Template, 2, 2, "ng-container", 15)(1, MbscScheduler_ng_template_0_mbsc_schedule_event_1_Template, 1, 23, "mbsc-schedule-event", 31)(2, MbscScheduler_ng_template_0_mbsc_schedule_event_2_Template, 1, 22, "mbsc-schedule-event", 32);
  }
  if (rf & 2) {
    const allDay_r11 = ctx2.allDay;
    const events_r8 = ctx2.events;
    const dragData_r6 = ctx2.dragData;
    const dragKey_r10 = ctx2.dragKey;
    ɵɵproperty("ngIf", events_r8);
    ɵɵadvance();
    ɵɵproperty("ngIf", dragData_r6 && dragData_r6.originDates && dragData_r6.originDates[dragKey_r10] && !!dragData_r6.originDates[dragKey_r10].allDay === allDay_r11);
    ɵɵadvance();
    ɵɵproperty("ngIf", dragData_r6 && dragData_r6.draggedDates && dragData_r6.draggedDates[dragKey_r10] && !!dragData_r6.draggedDates[dragKey_r10].allDay === allDay_r11);
  }
}
function MbscScheduler_ng_template_2_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 42);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r11 = ɵɵnextContext();
    const dateKey_r13 = ctx_r11.dateKey;
    const resId_r14 = ctx_r11.resource.id;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-invalid mbsc-schedule-invalid-all-day" + ctx_r2._invalids[resId_r14][ctx_r2._defId][dateKey_r13].allDay[0].cssClass + ctx_r2._theme);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2._invalids[resId_r14][ctx_r2._defId][dateKey_r13].allDay[0].title, " ");
  }
}
function MbscScheduler_ng_template_2_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "div", 43);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r11 = ɵɵnextContext();
    const dateKey_r13 = ctx_r11.dateKey;
    const resId_r14 = ctx_r11.resource.id;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-color mbsc-schedule-color-all-day" + ctx_r2._colors[resId_r14][ctx_r2._defId][dateKey_r13].allDay[0].cssClass + ctx_r2._theme);
    ɵɵproperty("ngStyle", ctx_r2._colors[resId_r14][ctx_r2._defId][dateKey_r13].allDay[0].position);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r2._colors[resId_r14][ctx_r2._defId][dateKey_r13].allDay[0].title, " ");
  }
}
function MbscScheduler_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵelementContainer(1, 40);
    ɵɵtemplate(2, MbscScheduler_ng_template_2_div_2_Template, 3, 3, "div", 18)(3, MbscScheduler_ng_template_2_div_3_Template, 3, 4, "div", 41);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dateKey_r13 = ctx2.dateKey;
    const dayName_r15 = ctx2.dayName;
    const r_r16 = ctx2.resource;
    const resId_r14 = ctx2.resource.id;
    const ctx_r2 = ɵɵnextContext();
    const tplEvents_r17 = ɵɵreference(1);
    ɵɵclassMap("mbsc-schedule-all-day-item mbsc-flex-1-0 " + (ctx_r2._groupByResource ? "mbsc-schedule-column-" + dayName_r15 : r_r16.cssClass || "") + ctx_r2._colClass + ctx_r2._theme + ctx_r2._rtl + ctx_r2._hb);
    ɵɵstyleProp("background", r_r16.background);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplEvents_r17)("ngTemplateOutletContext", ɵɵpureFunction5(8, _c40, dateKey_r13, ctx_r2.state.dragData, ctx_r2._getDragKey(resId_r14, dateKey_r13), ctx_r2._events[resId_r14][ctx_r2._defId][dateKey_r13] && ctx_r2._events[resId_r14][ctx_r2._defId][dateKey_r13].allDay, r_r16));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2._invalids[resId_r14][ctx_r2._defId][dateKey_r13] && ctx_r2._invalids[resId_r14][ctx_r2._defId][dateKey_r13].allDay[0]);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2._colors[resId_r14][ctx_r2._defId][dateKey_r13] && ctx_r2._colors[resId_r14][ctx_r2._defId][dateKey_r13].allDay[0]);
  }
}
function MbscScheduler_ng_template_4_ng_container_4_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "div", 42);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const invalid_r18 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-schedule-invalid" + invalid_r18.cssClass + ctx_r2._theme);
    ɵɵproperty("ngStyle", invalid_r18.position);
    ɵɵadvance(2);
    ɵɵtextInterpolate(invalid_r18.allDay ? "" : invalid_r18.title);
  }
}
function MbscScheduler_ng_template_4_ng_container_4_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_template_4_ng_container_4_ng_container_1_div_1_Template, 3, 4, "div", 41);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const invalid_r18 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", invalid_r18.position);
  }
}
function MbscScheduler_ng_template_4_ng_container_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_template_4_ng_container_4_ng_container_1_Template, 2, 1, "ng-container", 33);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r18 = ɵɵnextContext();
    const dateKey_r20 = ctx_r18.dateKey;
    const resId_r21 = ctx_r18.resource.id;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._invalids[resId_r21][ctx_r2._defId][dateKey_r20].data)("ngForTrackBy", ctx_r2._getKey);
  }
}
function MbscScheduler_ng_template_4_ng_container_5_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "div", 43);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const color_r22 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-schedule-color" + color_r22.cssClass + ctx_r2._theme);
    ɵɵproperty("ngStyle", color_r22.position);
    ɵɵadvance(2);
    ɵɵtextInterpolate(color_r22.title);
  }
}
function MbscScheduler_ng_template_4_ng_container_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_template_4_ng_container_5_div_1_Template, 3, 4, "div", 45);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r18 = ɵɵnextContext();
    const dateKey_r20 = ctx_r18.dateKey;
    const resId_r21 = ctx_r18.resource.id;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._colors[resId_r21][ctx_r2._defId][dateKey_r20].data)("ngForTrackBy", ctx_r2._getKey);
  }
}
function MbscScheduler_ng_template_4_div_6_Template(rf, ctx2) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 46);
    ɵɵlistener("click", function MbscScheduler_ng_template_4_div_6_Template_div_click_0_listener($event) {
      const v_r24 = ɵɵrestoreView(_r23).$implicit;
      const ctx_r18 = ɵɵnextContext();
      const resId_r21 = ctx_r18.resource.id;
      const timestamp_r25 = ctx_r18.timestamp;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._onCellClick("onCellClick", timestamp_r25, v_r24, $event, resId_r21));
    })("dblclick", function MbscScheduler_ng_template_4_div_6_Template_div_dblclick_0_listener($event) {
      const v_r24 = ɵɵrestoreView(_r23).$implicit;
      const ctx_r18 = ɵɵnextContext();
      const resId_r21 = ctx_r18.resource.id;
      const timestamp_r25 = ctx_r18.timestamp;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._onCellClick("onCellDoubleClick", timestamp_r25, v_r24, $event, resId_r21));
    })("contextmenu", function MbscScheduler_ng_template_4_div_6_Template_div_contextmenu_0_listener($event) {
      const v_r24 = ɵɵrestoreView(_r23).$implicit;
      const ctx_r18 = ɵɵnextContext();
      const resId_r21 = ctx_r18.resource.id;
      const timestamp_r25 = ctx_r18.timestamp;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._onCellClick("onCellRightClick", timestamp_r25, v_r24, $event, resId_r21));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const first_r26 = ctx2.first;
    const last_r27 = ctx2.last;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-schedule-item mbsc-flex-1-0" + ctx_r2._theme + ctx_r2._hb + (last_r27 ? " mbsc-schedule-item-last" : "") + (first_r26 && !last_r27 && ctx_r2._startCellStyle || last_r27 && !first_r26 && ctx_r2._endCellStyle ? " mbsc-flex-none" : ""));
    ɵɵproperty("ngStyle", first_r26 && !last_r27 ? ctx_r2._startCellStyle : last_r27 && !first_r26 ? ctx_r2._endCellStyle : ɵɵpureFunction0(3, _c42));
  }
}
function MbscScheduler_ng_template_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div")(2, "div");
    ɵɵelementContainer(3, 40);
    ɵɵelementEnd();
    ɵɵtemplate(4, MbscScheduler_ng_template_4_ng_container_4_Template, 2, 2, "ng-container", 15)(5, MbscScheduler_ng_template_4_ng_container_5_Template, 2, 2, "ng-container", 15)(6, MbscScheduler_ng_template_4_div_6_Template, 1, 4, "div", 44);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const dateKey_r20 = ctx2.dateKey;
    const dayName_r28 = ctx2.dayName;
    const r_r29 = ctx2.resource;
    const resId_r21 = ctx2.resource.id;
    const ctx_r2 = ɵɵnextContext();
    const tplEvents_r17 = ɵɵreference(1);
    ɵɵclassMap("mbsc-flex-col mbsc-flex-1-0 mbsc-schedule-column " + (ctx_r2._groupByResource ? "mbsc-schedule-column-" + dayName_r28 : r_r29.cssClass || "") + ctx_r2._colClass + ctx_r2._theme + ctx_r2._rtl + ctx_r2._hb);
    ɵɵstyleProp("background", r_r29.background);
    ɵɵadvance();
    ɵɵclassMap("mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-column-inner" + ctx_r2._theme + ctx_r2._rtl + ctx_r2._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-events" + (ctx_r2._events[resId_r21][ctx_r2._defId][dateKey_r20] && ctx_r2._events[resId_r21][ctx_r2._defId][dateKey_r20].hasMore ? " mbsc-schedule-events-more" : "") + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplEvents_r17)("ngTemplateOutletContext", ɵɵpureFunction5(14, _c41, dateKey_r20, ctx_r2.state.dragData, ctx_r2._getDragKey(resId_r21, dateKey_r20), ctx_r2._events[resId_r21][ctx_r2._defId][dateKey_r20] && ctx_r2._events[resId_r21][ctx_r2._defId][dateKey_r20].data, r_r29));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2._invalids[resId_r21][ctx_r2._defId][dateKey_r20]);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2._colors[resId_r21][ctx_r2._defId][dateKey_r20]);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._times)("ngForTrackBy", ctx_r2._getKey);
  }
}
function MbscScheduler_ng_template_6_div_0_ng_container_3_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const j_r30 = ɵɵnextContext().index;
    const v_r31 = ɵɵnextContext().$implicit;
    const index_r32 = ɵɵnextContext().index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-flex-1-1 mbsc-schedule-time" + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2._timeLabels[index_r32][v_r31 + (j_r30 + 1) * ctx_r2._stepLabel], " ");
  }
}
function MbscScheduler_ng_template_6_div_0_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_template_6_div_0_ng_container_3_div_1_Template, 2, 3, "div", 18);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const j_r30 = ctx2.index;
    const v_r31 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", v_r31 + (j_r30 + 1) * ctx_r2._stepLabel > ctx_r2._startTime && v_r31 + (j_r30 + 1) * ctx_r2._stepLabel < ctx_r2._endTime);
  }
}
function MbscScheduler_ng_template_6_div_0_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const index_r32 = ɵɵnextContext(2).index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-time mbsc-schedule-time-end" + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2._timeLabels[index_r32][ctx_r2._endTime + 1], " ");
  }
}
function MbscScheduler_ng_template_6_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11)(1, "div");
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, MbscScheduler_ng_template_6_div_0_ng_container_3_Template, 2, 1, "ng-container", 33)(4, MbscScheduler_ng_template_6_div_0_div_4_Template, 2, 3, "div", 18);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const v_r31 = ctx2.$implicit;
    const first_r33 = ctx2.first;
    const last_r34 = ctx2.last;
    const index_r32 = ɵɵnextContext().index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-flex-col mbsc-flex-1-0 mbsc-schedule-time-wrapper" + ctx_r2._theme + ctx_r2._rtl + (last_r34 ? " mbsc-schedule-time-wrapper-end" : "") + (first_r33 && !last_r34 && ctx_r2._startCellStyle || last_r34 && !first_r33 && ctx_r2._endCellStyle ? " mbsc-flex-none" : ""));
    ɵɵproperty("ngStyle", first_r33 && !last_r34 ? ctx_r2._startCellStyle : last_r34 && !first_r33 ? ctx_r2._endCellStyle : ɵɵpureFunction0(9, _c42));
    ɵɵadvance();
    ɵɵclassMap("mbsc-flex-1-1 mbsc-schedule-time" + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r2._timeLabels[index_r32][v_r31], " ");
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._timesBetween)("ngForTrackBy", ctx_r2._getKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", last_r34);
  }
}
function MbscScheduler_ng_template_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscScheduler_ng_template_6_div_0_Template, 5, 10, "div", 45);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngForOf", ctx_r2._times)("ngForTrackBy", ctx_r2._getKey);
  }
}
function MbscScheduler_div_13_div_1_mbsc_week_day_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-week-day", 50);
  }
  if (rf & 2) {
    const dayData_r35 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵproperty("day", dayData_r35.day)("dayNames", ctx_r2._dayNames)("dayTemplate", ctx_r2.dayTemplate)("dayContentTemplate", ctx_r2.dayContentTemplate)("events", ctx_r2.eventMap[dayData_r35.dateKey])("isToday", ctx_r2._isToday(dayData_r35.timestamp))("label", dayData_r35.label)("largeNames", ctx_r2._largeDayNames)("onClick", ctx_r2.onWeekDayClick)("rtl", ctx_r2.rtl)("selectable", true)("selected", ctx_r2._selectedDay === dayData_r35.timestamp)("theme", ctx_r2.theme)("timestamp", dayData_r35.timestamp);
  }
}
function MbscScheduler_div_13_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, MbscScheduler_div_13_div_1_mbsc_week_day_1_Template, 1, 14, "mbsc-week-day", 49);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._headerDays)("ngForTrackBy", ctx_r2._getDayKey);
  }
}
function MbscScheduler_div_13_div_2_ng_container_1_div_1_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const r_r37 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate1(" ", r_r37.name, " ");
  }
}
function MbscScheduler_div_13_div_2_ng_container_1_div_1_ng_template_4_Template(rf, ctx2) {
}
function MbscScheduler_div_13_div_2_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r36 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 52);
    ɵɵlistener("click", function MbscScheduler_div_13_div_2_ng_container_1_div_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r36);
      const r_r37 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceClick", $event, r_r37));
    })("dblclick", function MbscScheduler_div_13_div_2_ng_container_1_div_1_Template_div_dblclick_0_listener($event) {
      ɵɵrestoreView(_r36);
      const r_r37 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceDoubleClick", $event, r_r37));
    })("contextmenu", function MbscScheduler_div_13_div_2_ng_container_1_div_1_Template_div_contextmenu_0_listener($event) {
      ɵɵrestoreView(_r36);
      const r_r37 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceRightClick", $event, r_r37));
    });
    ɵɵelementStart(1, "div", 53);
    ɵɵtemplate(2, MbscScheduler_div_13_div_2_ng_container_1_div_1_ng_template_2_Template, 1, 1, "ng-template", null, 8, ɵɵtemplateRefExtractor)(4, MbscScheduler_div_13_div_2_ng_container_1_div_1_ng_template_4_Template, 0, 0, "ng-template", 40);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const default_r38 = ɵɵreference(3);
    const r_r37 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-schedule-resource mbsc-flex-1-0 mbsc-schedule-col-width " + (r_r37.cssClass || "") + ctx_r2._theme + ctx_r2._rtl + ctx_r2._hb);
    ɵɵstyleProp("background", r_r37.background);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.resourceTemplate || default_r38)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c14, r_r37));
  }
}
function MbscScheduler_div_13_div_2_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_div_13_div_2_ng_container_1_div_1_Template, 5, 8, "div", 51);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const r_r37 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", r_r37.name || ctx_r2.resourceTemplate && r_r37.id !== ctx_r2._defId);
  }
}
function MbscScheduler_div_13_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, MbscScheduler_div_13_div_2_ng_container_1_Template, 2, 1, "ng-container", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._resources)("ngForTrackBy", ctx_r2._getId);
  }
}
function MbscScheduler_div_13_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 47);
    ɵɵtemplate(1, MbscScheduler_div_13_div_1_Template, 2, 2, "div", 48)(2, MbscScheduler_div_13_div_2_Template, 2, 2, "div", 48);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showDays);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.resources);
  }
}
function MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const r_r40 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate1(" ", r_r40.name, " ");
  }
}
function MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_ng_template_4_Template(rf, ctx2) {
}
function MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r39 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 52);
    ɵɵlistener("click", function MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r39);
      const r_r40 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceClick", $event, r_r40));
    })("dblclick", function MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_Template_div_dblclick_0_listener($event) {
      ɵɵrestoreView(_r39);
      const r_r40 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceDoubleClick", $event, r_r40));
    })("contextmenu", function MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_Template_div_contextmenu_0_listener($event) {
      ɵɵrestoreView(_r39);
      const r_r40 = ɵɵnextContext().$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceRightClick", $event, r_r40));
    });
    ɵɵelementStart(1, "div", 53);
    ɵɵtemplate(2, MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_ng_template_2_Template, 1, 1, "ng-template", null, 8, ɵɵtemplateRefExtractor)(4, MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_ng_template_4_Template, 0, 0, "ng-template", 40);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const default_r41 = ɵɵreference(3);
    const r_r40 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-schedule-resource " + ctx_r2._theme + ctx_r2._rtl + ctx_r2._hb);
    ɵɵstyleProp("background", r_r40.background);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.resourceTemplate || default_r41)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c14, r_r40));
  }
}
function MbscScheduler_ng_container_14_ng_container_1_div_1_div_2_mbsc_week_day_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-week-day", 56);
  }
  if (rf & 2) {
    const dayData_r42 = ctx2.$implicit;
    const r_r40 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-flex-1-0" + ctx_r2._colClass + " mbsc-schedule-column-" + dayData_r42.dayName);
    ɵɵproperty("background", r_r40.background)("day", dayData_r42.day)("dayNames", ctx_r2._dayNames)("dayTemplate", ctx_r2.dayTemplate)("dayContentTemplate", ctx_r2.dayContentTemplate)("events", ctx_r2.eventMap[dayData_r42.dateKey])("isToday", ctx_r2._isSingleResource && ctx_r2._isToday(dayData_r42.timestamp))("label", dayData_r42.label)("largeNames", ctx_r2._largeDayNames)("onClick", ctx_r2.onWeekDayClick)("resource", r_r40.id)("rtl", ctx_r2.rtl)("selectable", false)("selected", ctx_r2._isSingleResource && ctx_r2._isToday(dayData_r42.timestamp))("theme", ctx_r2.theme)("timestamp", dayData_r42.timestamp);
  }
}
function MbscScheduler_ng_container_14_ng_container_1_div_1_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_1_div_1_div_2_mbsc_week_day_1_Template, 1, 18, "mbsc-week-day", 55);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._days)("ngForTrackBy", ctx_r2._getDayKey);
  }
}
function MbscScheduler_ng_container_14_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_1_div_1_div_1_Template, 5, 8, "div", 54)(2, MbscScheduler_ng_container_14_ng_container_1_div_1_div_2_Template, 2, 2, "div", 48);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const r_r40 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-flex-1-0-0 mbsc-schedule-resource-group " + (r_r40.cssClass || "") + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵproperty("ngIf", r_r40.name || ctx_r2.resourceTemplate && r_r40.id !== ctx_r2._defId);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showDays);
  }
}
function MbscScheduler_ng_container_14_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_1_div_1_Template, 3, 4, "div", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._resources)("ngForTrackBy", ctx_r2._getId);
  }
}
function MbscScheduler_ng_container_14_ng_container_2_div_1_mbsc_week_day_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-week-day", 58);
  }
  if (rf & 2) {
    const dayData_r43 = ɵɵnextContext().$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵproperty("day", dayData_r43.day)("dayNames", ctx_r2._dayNames)("dayTemplate", ctx_r2.dayTemplate)("dayContentTemplate", ctx_r2.dayContentTemplate)("events", ctx_r2.eventMap[dayData_r43.dateKey])("isToday", ctx_r2._isSingleResource && ctx_r2._isToday(dayData_r43.timestamp))("label", dayData_r43.label)("largeNames", ctx_r2._largeDayNames)("onClick", ctx_r2.onWeekDayClick)("rtl", ctx_r2.rtl)("selectable", false)("selected", ctx_r2._isToday(dayData_r43.timestamp))("theme", ctx_r2.theme)("timestamp", dayData_r43.timestamp);
  }
}
function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const r_r45 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate1(" ", r_r45.name, " ");
  }
}
function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_ng_template_4_Template(rf, ctx2) {
}
function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r44 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 52);
    ɵɵlistener("click", function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r44);
      const r_r45 = ɵɵnextContext().$implicit;
      const dayData_r43 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceClick", $event, r_r45, dayData_r43.date));
    })("dblclick", function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_Template_div_dblclick_0_listener($event) {
      ɵɵrestoreView(_r44);
      const r_r45 = ɵɵnextContext().$implicit;
      const dayData_r43 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceDoubleClick", $event, r_r45, dayData_r43.date));
    })("contextmenu", function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_Template_div_contextmenu_0_listener($event) {
      ɵɵrestoreView(_r44);
      const r_r45 = ɵɵnextContext().$implicit;
      const dayData_r43 = ɵɵnextContext(2).$implicit;
      const ctx_r2 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r2._onResourceClick("onResourceRightClick", $event, r_r45, dayData_r43.date));
    });
    ɵɵelementStart(1, "div", 53);
    ɵɵtemplate(2, MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_ng_template_2_Template, 1, 1, "ng-template", null, 8, ɵɵtemplateRefExtractor)(4, MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_ng_template_4_Template, 0, 0, "ng-template", 40);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const default_r46 = ɵɵreference(3);
    const r_r45 = ɵɵnextContext().$implicit;
    const dayData_r43 = ɵɵnextContext(2).$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-schedule-resource mbsc-flex-1-0 " + (r_r45.cssClass || "") + ctx_r2._colClass + ctx_r2._theme + ctx_r2._rtl + ctx_r2._hb);
    ɵɵstyleProp("background", r_r45.background);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r2.resourceTemplate || default_r46)("ngTemplateOutletContext", ɵɵpureFunction2(6, _c43, r_r45, dayData_r43.date));
  }
}
function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_div_1_Template, 5, 9, "div", 51);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const r_r45 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵproperty("ngIf", r_r45.name || ctx_r2.resourceTemplate && r_r45.id !== ctx_r2._defId);
  }
}
function MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_ng_container_1_Template, 2, 1, "ng-container", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._resources)("ngForTrackBy", ctx_r2._getId);
  }
}
function MbscScheduler_ng_container_14_ng_container_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_2_div_1_mbsc_week_day_1_Template, 1, 14, "mbsc-week-day", 57)(2, MbscScheduler_ng_container_14_ng_container_2_div_1_div_2_Template, 2, 2, "div", 48);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dayData_r43 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-flex-1-0-0 mbsc-schedule-resource-group mbsc-schedule-column-" + dayData_r43.dayName + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.showDays);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.resources);
  }
}
function MbscScheduler_ng_container_14_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_2_div_1_Template, 3, 4, "div", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._days)("ngForTrackBy", ctx_r2._getDayKey);
  }
}
function MbscScheduler_ng_container_14_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_container_14_ng_container_1_Template, 2, 2, "ng-container", 15)(2, MbscScheduler_ng_container_14_ng_container_2_Template, 2, 2, "ng-container", 15);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2._groupByResource);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2._groupByResource);
  }
}
function MbscScheduler_div_17_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tz_r47 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-flex-1-0-0 mbsc-schedule-timezone-label" + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", tz_r47.label, " ");
  }
}
function MbscScheduler_div_17_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 59);
    ɵɵtemplate(1, MbscScheduler_div_17_div_1_Template, 2, 3, "div", 23);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngStyle", ctx_r2._timeWidth);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._timezones)("ngForTrackBy", ctx_r2._getKey);
  }
}
function MbscScheduler_div_18_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-schedule-all-day-text" + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r2.allDayText);
  }
}
function MbscScheduler_div_18_ng_container_7_div_1_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0, 40);
  }
  if (rf & 2) {
    const dayData_r48 = ctx2.$implicit;
    const r_r49 = ɵɵnextContext().$implicit;
    ɵɵnextContext(3);
    const tplAllDay_r50 = ɵɵreference(3);
    ɵɵproperty("ngTemplateOutlet", tplAllDay_r50)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c44, dayData_r48.dateKey, dayData_r48.dayName, r_r49, dayData_r48.timestamp));
  }
}
function MbscScheduler_div_18_ng_container_7_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScheduler_div_18_ng_container_7_div_1_ng_container_1_Template, 1, 7, "ng-container", 61);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const r_r49 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group " + (r_r49.cssClass || "") + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._days)("ngForTrackBy", ctx_r2._getDayKey);
  }
}
function MbscScheduler_div_18_ng_container_7_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_div_18_ng_container_7_div_1_Template, 2, 4, "div", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._resources)("ngForTrackBy", ctx_r2._getId);
  }
}
function MbscScheduler_div_18_ng_container_8_div_1_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0, 40);
  }
  if (rf & 2) {
    const r_r51 = ctx2.$implicit;
    const dayData_r52 = ɵɵnextContext().$implicit;
    ɵɵnextContext(3);
    const tplAllDay_r50 = ɵɵreference(3);
    ɵɵproperty("ngTemplateOutlet", tplAllDay_r50)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c44, dayData_r52.dateKey, dayData_r52.dayName, r_r51, dayData_r52.timestamp));
  }
}
function MbscScheduler_div_18_ng_container_8_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScheduler_div_18_ng_container_8_div_1_ng_container_1_Template, 1, 7, "ng-container", 61);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dayData_r52 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group mbsc-schedule-column-" + dayData_r52.dayName + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._resources)("ngForTrackBy", ctx_r2._getId);
  }
}
function MbscScheduler_div_18_ng_container_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_div_18_ng_container_8_div_1_Template, 2, 4, "div", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._days)("ngForTrackBy", ctx_r2._getDayKey);
  }
}
function MbscScheduler_div_18_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div")(2, "div", 11);
    ɵɵtemplate(3, MbscScheduler_div_18_div_3_Template, 2, 3, "div", 18);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 60)(5, "div", 28, 9);
    ɵɵtemplate(7, MbscScheduler_div_18_ng_container_7_Template, 2, 2, "ng-container", 15)(8, MbscScheduler_div_18_ng_container_8_Template, 2, 2, "ng-container", 15);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-all-day-wrapper mbsc-flex-none" + ctx_r2._theme + ctx_r2._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-flex mbsc-schedule-all-day" + ctx_r2._theme);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-time-col" + ctx_r2._theme + ctx_r2._rtl);
    ɵɵproperty("ngStyle", ctx_r2._timeWidth);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.timezones);
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r2._groupByResource);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2._groupByResource);
  }
}
function MbscScheduler_div_26_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0, 40);
  }
  if (rf & 2) {
    const i_r53 = ɵɵnextContext().index;
    ɵɵnextContext();
    const tplTimes_r54 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", tplTimes_r54)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c45, i_r53));
  }
}
function MbscScheduler_div_26_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScheduler_div_26_ng_container_1_Template, 1, 4, "ng-container", 24);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const last_r55 = ctx2.last;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-flex-col" + ctx_r2._theme + (last_r55 ? " mbsc-schedule-time-col-last" : ""));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.timezones);
  }
}
function MbscScheduler_ng_container_27_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0, 40);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const tplTimes_r54 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", tplTimes_r54)("ngTemplateOutletContext", ɵɵpureFunction0(2, _c46));
  }
}
function MbscScheduler_mbsc_time_indicator_28_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-time-indicator", 62);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("amText", ctx_r2.s.amText)("displayedTime", ctx_r2._time)("displayedDays", ctx_r2._daysNr)("displayTimezone", ctx_r2.displayTimezone)("endDay", ctx_r2.endDay)("firstDay", ctx_r2._firstDayTz)("pmText", ctx_r2.s.pmText)("rtl", ctx_r2.rtl)("showDayIndicator", ctx_r2._isSingleResource && !ctx_r2._isMulti && ctx_r2.type === "week")("startDay", ctx_r2.startDay)("startTime", ctx_r2._startTime)("theme", ctx_r2.theme)("timeFormat", ctx_r2.timeFormat)("timezones", ctx_r2._timezones)("timezonePlugin", ctx_r2.timezonePlugin);
  }
}
function MbscScheduler_div_29_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", null, 10);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-cursor-time mbsc-schedule-cursor-time-x" + ctx_r2._theme + ctx_r2._rtl);
  }
}
function MbscScheduler_div_30_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 63);
  }
}
function MbscScheduler_ng_container_37_div_1_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementContainer(1, 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const dayData_r56 = ctx2.$implicit;
    const r_r57 = ɵɵnextContext().$implicit;
    ɵɵnextContext(2);
    const tplDay_r58 = ɵɵreference(5);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplDay_r58)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c44, dayData_r56.dateKey, dayData_r56.dayName, r_r57, dayData_r56.timestamp));
  }
}
function MbscScheduler_ng_container_37_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScheduler_ng_container_37_div_1_ng_container_1_Template, 2, 7, "ng-container", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const r_r57 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group " + (r_r57.cssClass || "") + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._days)("ngForTrackBy", ctx_r2._getDayKey);
  }
}
function MbscScheduler_ng_container_37_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_container_37_div_1_Template, 2, 4, "div", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._resources)("ngForTrackBy", ctx_r2._getId);
  }
}
function MbscScheduler_ng_container_38_div_1_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementContainer(1, 40);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const r_r59 = ctx2.$implicit;
    const dayData_r60 = ɵɵnextContext().$implicit;
    ɵɵnextContext(2);
    const tplDay_r58 = ɵɵreference(5);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplDay_r58)("ngTemplateOutletContext", ɵɵpureFunction4(2, _c44, dayData_r60.dateKey, dayData_r60.dayName, r_r59, dayData_r60.timestamp));
  }
}
function MbscScheduler_ng_container_38_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscScheduler_ng_container_38_div_1_ng_container_1_Template, 2, 7, "ng-container", 33);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dayData_r60 = ctx2.$implicit;
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group mbsc-schedule-column-" + dayData_r60.dayName + ctx_r2._theme + ctx_r2._rtl);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._resources)("ngForTrackBy", ctx_r2._getId);
  }
}
function MbscScheduler_ng_container_38_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscScheduler_ng_container_38_div_1_Template, 2, 4, "div", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2._days)("ngForTrackBy", ctx_r2._getDayKey);
  }
}
function MbscScheduler_div_39_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 64);
  }
}
var _c47 = ["footerCont"];
var _c48 = ["resCont"];
var _c49 = ["sidebarCont"];
var _c50 = ["stickyFooter"];
var _c51 = ["stickyHeader"];
var _c52 = ["stickyDate"];
var _c53 = ["stickyMonth"];
var _c54 = ["stickyWeek"];
var _c55 = ["draggedResourceEl"];
var _c56 = ["draggedResourceLineEl"];
var _c57 = () => [];
var _c58 = (a0, a1, a2, a3, a4, a5, a6, a7) => ({
  colors: a0,
  events: a1,
  invalids: a2,
  dragData: a3,
  dragKey: a4,
  resource: a5,
  slot: a6,
  tracks: a7
});
var _c59 = (a0) => [a0];
var _c60 = (a0, a1, a2) => ({
  date: a0,
  events: a1,
  isActive: a2
});
var _c61 = (a0, a1) => ({
  date: a0,
  events: a1
});
var _c62 = (a0, a1, a2, a3, a4, a5) => ({
  date: a0,
  events: a1,
  isActive: a2,
  startDate: a3,
  endDate: a4,
  weekNr: a5
});
var _c63 = (a0) => ({
  month: a0
});
var _c64 = (a0) => ({
  week: a0
});
var _c65 = (a0) => ({
  day: a0
});
var _c66 = (a0, a1) => ({
  slot: a0,
  date: a1
});
var _c67 = (a0, a1) => ({
  hour: a0,
  timestamp: a1
});
var _c68 = (a0) => ({
  quarter: a0
});
var _c69 = (a0) => ({
  year: a0
});
var _c70 = (a0, a1) => ({
  res: a0,
  key: a1
});
var _c71 = (a0, a1, a2) => ({
  res: a0,
  key: a1,
  day: a2
});
var _c72 = (a0, a1, a2) => ({
  res: a0,
  dateKey: a1,
  day: a2
});
var _c73 = (a0, a1, a2) => ({
  res: a0,
  key: a1,
  day: a2,
  isDrag: true
});
function MbscTimeline_ng_template_0_div_0_mbsc_icon_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-icon", 64);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-timeline-resource-icon mbsc-timeline-resource-sort " + ctx_r5._rtl + ctx_r5._hb);
    ɵɵproperty("svg", ctx_r5.s.dragIcon)("theme", ctx_r5.theme);
  }
}
function MbscTimeline_ng_template_0_div_0_mbsc_icon_2_Template(rf, ctx2) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-icon", 65);
    ɵɵlistener("click", function MbscTimeline_ng_template_0_div_0_mbsc_icon_2_Template_mbsc_icon_click_0_listener($event) {
      ɵɵrestoreView(_r7);
      const res_r4 = ɵɵnextContext(2).res;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._toggleResource(res_r4, $event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const res_r4 = ɵɵnextContext(2).res;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-resource-icon" + ctx_r5._rtl + ctx_r5._hb);
    ɵɵproperty("svg", res_r4.collapsed ? ctx_r5.rtl ? ctx_r5.nextIconRtl : ctx_r5.nextIcon : ctx_r5.downIcon)("theme", ctx_r5.theme);
  }
}
function MbscTimeline_ng_template_0_div_0_ng_template_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const res_r4 = ɵɵnextContext(2).res;
    ɵɵtextInterpolate(res_r4.name);
  }
}
function MbscTimeline_ng_template_0_div_0_6_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_0_div_0_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_0_div_0_6_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const default_r8 = ɵɵreference(5);
    const ctx_r2 = ɵɵnextContext();
    const res_r4 = ctx_r2.res;
    const day_r5 = ctx_r2.day;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.resourceTemplate || default_r8)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c43, res_r4, day_r5));
  }
}
function MbscTimeline_ng_template_0_div_0_7_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_0_div_0_7_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_0_div_0_7_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const default_r8 = ɵɵreference(5);
    const res_r4 = ɵɵnextContext().res;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.resourceEmptyTemplate || default_r8)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, res_r4));
  }
}
function MbscTimeline_ng_template_0_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 61);
    ɵɵlistener("click", function MbscTimeline_ng_template_0_div_0_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      const res_r4 = ctx_r2.res;
      const day_r5 = ctx_r2.day;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._onResourceClick("onResourceClick", $event, res_r4, day_r5));
    })("dblclick", function MbscTimeline_ng_template_0_div_0_Template_div_dblclick_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      const res_r4 = ctx_r2.res;
      const day_r5 = ctx_r2.day;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._onResourceClick("onResourceDoubleClick", $event, res_r4, day_r5));
    })("contextmenu", function MbscTimeline_ng_template_0_div_0_Template_div_contextmenu_0_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      const res_r4 = ctx_r2.res;
      const day_r5 = ctx_r2.day;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._onResourceClick("onResourceRightClick", $event, res_r4, day_r5));
    });
    ɵɵtemplate(1, MbscTimeline_ng_template_0_div_0_mbsc_icon_1_Template, 1, 4, "mbsc-icon", 62)(2, MbscTimeline_ng_template_0_div_0_mbsc_icon_2_Template, 1, 4, "mbsc-icon", 63);
    ɵɵelementStart(3, "div");
    ɵɵtemplate(4, MbscTimeline_ng_template_0_div_0_ng_template_4_Template, 1, 1, "ng-template", null, 20, ɵɵtemplateRefExtractor)(6, MbscTimeline_ng_template_0_div_0_6_Template, 1, 5, null, 43)(7, MbscTimeline_ng_template_0_div_0_7_Template, 1, 4, null, 43);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const res_r4 = ctx_r2.res;
    const key_r9 = ctx_r2.key;
    const isDrag_r10 = ctx_r2.isDrag;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-resource mbsc-timeline-row mbsc-flex-1-0" + (res_r4.isParent ? " mbsc-timeline-parent" : "") + (res_r4.isParent || ctx_r5.resourceReorder && res_r4.reorder !== false && res_r4.id !== ctx_r5._defId ? " mbsc-flex" : "") + (ctx_r5.state.dragData && res_r4.id === ctx_r5.state.dragData.hoverResource ? " mbsc-timeline-parent-hover" : "") + (res_r4.fixed && !ctx_r5._hasResY ? " mbsc-timeline-row-fixed" : "") + (key_r9 === ctx_r5._dragRow && !isDrag_r10 ? " mbsc-timeline-hidden" : "") + (res_r4.cssClass ? " " + res_r4.cssClass : "") + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("background", res_r4.background)("min-height", ctx_r5._rowHeights[key_r9])("padding-left", ctx_r5.rtl ? void 0 : ctx_r5._hasHierarchy ? res_r4.depth * 1.75 : void 0, "em")("padding-right", ctx_r5.rtl ? ctx_r5._hasHierarchy ? res_r4.depth * 1.75 : void 0 : void 0, "em")("top", res_r4.fixed && !ctx_r5._hasResY ? ctx_r5._fixedResourceTops[key_r9] + "px" : void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.resourceReorder && res_r4.reorder !== false && res_r4.id !== ctx_r5._defId);
    ɵɵadvance();
    ɵɵproperty("ngIf", res_r4.isParent);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-resource-title" + (res_r4.isParent || ctx_r5.resourceReorder && res_r4.reorder !== false && res_r4.id !== ctx_r5._defId ? " mbsc-flex-1-1" : ""));
    ɵɵadvance(3);
    ɵɵproperty("ngIf", res_r4.id !== ctx_r5._defId);
    ɵɵadvance();
    ɵɵproperty("ngIf", res_r4.id === ctx_r5._defId);
  }
}
function MbscTimeline_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_0_div_0_Template, 8, 18, "div", 60);
  }
  if (rf & 2) {
    const key_r9 = ctx2.key;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("ngIf", key_r9 !== ctx_r5._dragRow);
  }
}
function MbscTimeline_ng_template_2_div_0_2_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_2_div_0_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_2_div_0_2_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const res_r11 = ɵɵnextContext(2).res;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.sidebarTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c14, res_r11));
  }
}
function MbscTimeline_ng_template_2_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 68);
    ɵɵtemplate(2, MbscTimeline_ng_template_2_div_0_2_Template, 1, 4, null, 43);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r11 = ɵɵnextContext();
    const res_r11 = ctx_r11.res;
    const key_r13 = ctx_r11.key;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-sidebar-resource mbsc-timeline-row mbsc-flex-1-0" + (res_r11.isParent ? " mbsc-timeline-parent mbsc-flex" : "") + (ctx_r5.state.dragData && res_r11.id === ctx_r5.state.dragData.hoverResource ? " mbsc-timeline-parent-hover" : "") + (res_r11.fixed && !ctx_r5._hasResY ? " mbsc-timeline-row-fixed" : "") + (res_r11.cssClass ? " " + res_r11.cssClass : "") + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("background", res_r11.background)("min-height", ctx_r5._rowHeights[key_r13])("top", res_r11.fixed && !ctx_r5._hasResY ? ctx_r5._fixedResourceTops[key_r13] + "px" : void 0);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", res_r11.id !== ctx_r5._defId);
  }
}
function MbscTimeline_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_2_div_0_Template, 3, 9, "div", 67);
  }
  if (rf & 2) {
    const key_r13 = ctx2.key;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("ngIf", key_r13 !== ctx_r5._dragRow);
  }
}
function MbscTimeline_ng_template_4_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0, 66);
  }
  if (rf & 2) {
    const ctx_r13 = ɵɵnextContext();
    const res_r15 = ctx_r13.res;
    const dateKey_r16 = ctx_r13.dateKey;
    const ctx_r5 = ɵɵnextContext();
    const tplDayData_r17 = ɵɵreference(31);
    ɵɵproperty("ngTemplateOutlet", tplDayData_r17)("ngTemplateOutletContext", ɵɵpureFunction8(3, _c58, ctx_r5._viewColors[(dateKey_r16 ? dateKey_r16 + "-" : "") + res_r15.id], ctx_r5._viewEvents[(dateKey_r16 ? dateKey_r16 + "-" : "") + res_r15.id], ctx_r5._viewInvalids[(dateKey_r16 ? dateKey_r16 + "-" : "") + res_r15.id], ctx_r5.state.dragData, ctx_r5._getDragKey(res_r15.id, ctx_r5._defId, dateKey_r16 || "all"), res_r15, ctx_r5._slots[0], ctx_r5._events[res_r15.id][ctx_r5._defId][dateKey_r16 || "all"] ? ctx_r5._events[res_r15.id][ctx_r5._defId][dateKey_r16 || "all"].tracks : ɵɵpureFunction0(2, _c57)));
  }
}
function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainer(0, 66);
  }
  if (rf & 2) {
    const slot_r18 = ɵɵnextContext().$implicit;
    const dayData_r19 = ɵɵnextContext(2).$implicit;
    const ctx_r13 = ɵɵnextContext();
    const res_r15 = ctx_r13.res;
    const dateKey_r16 = ctx_r13.dateKey;
    const ctx_r5 = ɵɵnextContext();
    const tplDayData_r17 = ɵɵreference(31);
    ɵɵproperty("ngTemplateOutlet", tplDayData_r17)("ngTemplateOutletContext", ɵɵpureFunction8(18, _c58, ctx_r5._colors[res_r15.id][slot_r18.id][dateKey_r16 || dayData_r19.dateKey] && ɵɵpureFunction1(2, _c59, ctx_r5._colors[res_r15.id][slot_r18.id][dateKey_r16 || dayData_r19.dateKey].data) || ɵɵpureFunction1(5, _c59, ɵɵpureFunction0(4, _c57)), ctx_r5._events[res_r15.id][slot_r18.id][dateKey_r16 || dayData_r19.dateKey] && ɵɵpureFunction1(7, _c59, ctx_r5._events[res_r15.id][slot_r18.id][dateKey_r16 || dayData_r19.dateKey].data) || ɵɵpureFunction1(10, _c59, ɵɵpureFunction0(9, _c57)), ctx_r5._invalids[res_r15.id][slot_r18.id][dateKey_r16 || dayData_r19.dateKey] && ɵɵpureFunction1(12, _c59, ctx_r5._invalids[res_r15.id][slot_r18.id][dateKey_r16 || dayData_r19.dateKey].data) || ɵɵpureFunction1(15, _c59, ɵɵpureFunction0(14, _c57)), ctx_r5.state.dragData, ctx_r5._getDragKey(res_r15.id, slot_r18.id, dayData_r19.dateKey), res_r15, slot_r18, ɵɵpureFunction0(17, _c57)));
  }
}
function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 51);
  }
  if (rf & 2) {
    const dayData_r19 = ɵɵnextContext(3).$implicit;
    ɵɵstyleProp("width", dayData_r19.phStart, "px");
  }
}
function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 75);
    ɵɵlistener("click", function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_3_Template_div_click_0_listener($event) {
      const v_r21 = ɵɵrestoreView(_r20).$implicit;
      const slot_r18 = ɵɵnextContext().$implicit;
      const dayData_r19 = ɵɵnextContext(2).$implicit;
      const ctx_r13 = ɵɵnextContext();
      const res_r15 = ctx_r13.res;
      const day_r22 = ctx_r13.day;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._onCellClick("onCellClick", (day_r22 || dayData_r19).timestamp, v_r21.t, $event, res_r15.id, slot_r18.id));
    })("dblclick", function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_3_Template_div_dblclick_0_listener($event) {
      const v_r21 = ɵɵrestoreView(_r20).$implicit;
      const slot_r18 = ɵɵnextContext().$implicit;
      const dayData_r19 = ɵɵnextContext(2).$implicit;
      const ctx_r13 = ɵɵnextContext();
      const res_r15 = ctx_r13.res;
      const day_r22 = ctx_r13.day;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._onCellClick("onCellDoubleClick", (day_r22 || dayData_r19).timestamp, v_r21.t, $event, res_r15.id, slot_r18.id));
    })("contextmenu", function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_3_Template_div_contextmenu_0_listener($event) {
      const v_r21 = ɵɵrestoreView(_r20).$implicit;
      const slot_r18 = ɵɵnextContext().$implicit;
      const dayData_r19 = ɵɵnextContext(2).$implicit;
      const ctx_r13 = ɵɵnextContext();
      const res_r15 = ctx_r13.res;
      const day_r22 = ctx_r13.day;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._onCellClick("onCellRightClick", (day_r22 || dayData_r19).timestamp, v_r21.t, $event, res_r15.id, slot_r18.id));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const v_r21 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(5);
    ɵɵclassMap("mbsc-timeline-column mbsc-flex-1-1" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (v_r21.hidden ? " mbsc-timeline-hidden" : "") + (v_r21.first && !v_r21.last && ctx_r5._startCellStyle || v_r21.last && !v_r21.first && ctx_r5._endCellStyle ? " mbsc-flex-none" : ""));
    ɵɵproperty("ngStyle", v_r21.first && !v_r21.last ? ctx_r5._startCellStyle : v_r21.last && !v_r21.first ? ctx_r5._endCellStyle : ɵɵpureFunction0(3, _c42));
  }
}
function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 51);
  }
  if (rf & 2) {
    const dayData_r19 = ɵɵnextContext(3).$implicit;
    ɵɵstyleProp("width", dayData_r19.phEnd, "px");
  }
}
function MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_ng_container_1_Template, 1, 27, "ng-container", 69)(2, MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_2_Template, 1, 2, "div", 73)(3, MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_3_Template, 1, 4, "div", 74)(4, MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_div_4_Template, 1, 2, "div", 73);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dayData_r19 = ɵɵnextContext(2).$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-flex mbsc-flex-1-1" + (ctx_r5._hasSlots ? " mbsc-timeline-slot" : ""));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasSlots);
    ɵɵadvance();
    ɵɵproperty("ngIf", dayData_r19.phStart !== 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", dayData_r19.times)("ngForTrackBy", ctx_r5._getTimeKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", dayData_r19.phEnd !== 0);
  }
}
function MbscTimeline_ng_template_4_ng_container_5_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_template_4_ng_container_5_div_1_div_1_Template, 5, 7, "div", 72);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dayData_r19 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-day mbsc-flex mbsc-flex-1-0-0" + ctx_r5._dayClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (dayData_r19.dateKey === ctx_r5._dragCol ? " mbsc-timeline-hidden" : "") + (dayData_r19.dateIndex < ctx_r5._daysNr - 1 && (ctx_r5._stepCell < ctx_r5._oneDay || dayData_r19.lastOfMonth) ? " mbsc-timeline-day-border" : ""));
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._slots)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_ng_template_4_ng_container_5_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 61);
    ɵɵlistener("click", function MbscTimeline_ng_template_4_ng_container_5_div_2_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r23);
      const dayData_r19 = ɵɵnextContext().$implicit;
      const res_r15 = ɵɵnextContext().res;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onCellClick({
        date: dayData_r19.date,
        domEvent: $event,
        resource: res_r15.id,
        source: "timeline"
      }));
    })("dblclick", function MbscTimeline_ng_template_4_ng_container_5_div_2_Template_div_dblclick_0_listener($event) {
      ɵɵrestoreView(_r23);
      const dayData_r19 = ɵɵnextContext().$implicit;
      const res_r15 = ɵɵnextContext().res;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onCellDoubleClick({
        date: dayData_r19.date,
        domEvent: $event,
        resource: res_r15.id,
        source: "timeline"
      }));
    })("contextmenu", function MbscTimeline_ng_template_4_ng_container_5_div_2_Template_div_contextmenu_0_listener($event) {
      ɵɵrestoreView(_r23);
      const dayData_r19 = ɵɵnextContext().$implicit;
      const res_r15 = ɵɵnextContext().res;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5.onCellRightClick({
        date: dayData_r19.date,
        domEvent: $event,
        resource: res_r15.id,
        source: "timeline"
      }));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dayData_r19 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-day mbsc-timeline-column mbsc-flex-1-0-0" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (dayData_r19.dateKey === ctx_r5._dragCol ? " mbsc-timeline-hidden" : ""));
  }
}
function MbscTimeline_ng_template_4_ng_container_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_template_4_ng_container_5_div_1_Template, 2, 4, "div", 46)(2, MbscTimeline_ng_template_4_ng_container_5_div_2_Template, 1, 2, "div", 71);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._isDailyResolution);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r5._isDailyResolution);
  }
}
function MbscTimeline_ng_template_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_template_4_ng_container_1_Template, 1, 12, "ng-container", 69);
    ɵɵelement(2, "div")(3, "div", 51);
    ɵɵelementStart(4, "div", 70);
    ɵɵtemplate(5, MbscTimeline_ng_template_4_ng_container_5_Template, 3, 2, "ng-container", 57);
    ɵɵelementEnd();
    ɵɵelement(6, "div", 51);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const res_r15 = ctx2.res;
    const dateKey_r16 = ctx2.dateKey;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-row mbsc-timeline-row-outer mbsc-flex mbsc-flex-1-0" + (res_r15.isParent ? " mbsc-timeline-parent" : "") + (ctx_r5.state.dragData && res_r15.id === ctx_r5.state.dragData.hoverResource ? " mbsc-timeline-parent-hover" : "") + (res_r15.fixed && !ctx_r5._hasResY ? " mbsc-timeline-row-fixed" : "") + (res_r15.cssClass ? " " + res_r15.cssClass : "") + ((dateKey_r16 ? dateKey_r16 + "-" : "") + res_r15.id === ctx_r5._dragRow ? " mbsc-timeline-hidden" : "") + ctx_r5._theme + ctx_r5._hb);
    ɵɵstyleProp("background", res_r15.background)("min-height", ctx_r5._rowHeights[(dateKey_r16 ? dateKey_r16 + "-" : "") + res_r15.id])("top", res_r15.fixed && !ctx_r5._hasResY ? ctx_r5._fixedResourceTops[(dateKey_r16 ? dateKey_r16 + "-" : "") + res_r15.id] + "px" : void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r5._hasSlots);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-row mbsc-timeline-row-size" + (res_r15.cssClass ? " " + res_r15.cssClass : ""));
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r5._phXStart, "px");
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r5._virtualDays)("ngForTrackBy", ctx_r5._getDayKey);
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r5._phXEnd, "px");
  }
}
function MbscTimeline_ng_template_6_ng_template_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const timestamp_r24 = ɵɵnextContext().timestamp;
    const ctx_r5 = ɵɵnextContext();
    ɵɵtextInterpolate(ctx_r5._timeLabels[0][timestamp_r24]);
  }
}
function MbscTimeline_ng_template_6_3_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_6_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_6_3_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const ctx_r24 = ɵɵnextContext();
    const hour_r26 = ctx_r24.hour;
    const timestamp_r24 = ctx_r24.timestamp;
    const defaultHour_r27 = ɵɵreference(2);
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.hourTemplate || defaultHour_r27)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction3(3, _c60, ctx_r5._getDate(+hour_r26.date + timestamp_r24), hour_r26.eventMap[+hour_r26.date + timestamp_r24] || ɵɵpureFunction0(2, _c57), hour_r26.isActive)));
  }
}
function MbscTimeline_ng_template_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 76);
    ɵɵtemplate(1, MbscTimeline_ng_template_6_ng_template_1_Template, 1, 1, "ng-template", null, 21, ɵɵtemplateRefExtractor)(3, MbscTimeline_ng_template_6_3_Template, 1, 9, null, 43);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const timestamp_r24 = ctx2.timestamp;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-header-time mbsc-flex-1-1" + ctx_r5._theme);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r5._timeLabels[0][timestamp_r24]);
  }
}
function MbscTimeline_ng_template_8_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_8_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_8_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const ctx_r27 = ɵɵnextContext();
    const hour_r29 = ctx_r27.hour;
    const timestamp_r30 = ctx_r27.timestamp;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.hourFooterTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction3(3, _c60, ctx_r5._getDate(+hour_r29.date + timestamp_r30), hour_r29.eventMap[+hour_r29.date + timestamp_r30] || ɵɵpureFunction0(2, _c57), hour_r29.isActive)));
  }
}
function MbscTimeline_ng_template_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 76);
    ɵɵtemplate(1, MbscTimeline_ng_template_8_1_Template, 1, 9, null, 43);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const timestamp_r30 = ctx2.timestamp;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-footer-time mbsc-flex-1-1 " + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._timeLabels[0][timestamp_r30]);
  }
}
function MbscTimeline_ng_template_10_ng_template_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const day_r31 = ɵɵnextContext().day;
    ɵɵtextInterpolate(day_r31.dateText);
  }
}
function MbscTimeline_ng_template_10_ng_template_3_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_10_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 76);
    ɵɵtemplate(1, MbscTimeline_ng_template_10_ng_template_1_Template, 1, 1, "ng-template", null, 22, ɵɵtemplateRefExtractor)(3, MbscTimeline_ng_template_10_ng_template_3_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r31 = ctx2.day;
    const defaultDay_r32 = ɵɵreference(2);
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap((ctx_r5.dayTemplate ? "" : "mbsc-timeline-header-date-text") + (day_r31.isActive && !ctx_r5.dayTemplate ? " mbsc-timeline-header-active" : "") + ctx_r5._theme);
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.dayTemplate || defaultDay_r32)("ngTemplateOutletContext", ɵɵpureFunction1(8, _c14, ɵɵpureFunction3(4, _c60, day_r31.date, day_r31.eventMap.all, day_r31.isActive)));
  }
}
function MbscTimeline_ng_template_12_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_12_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_template_12_ng_template_1_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r33 = ctx2.day;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-footer-date-cont" + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.dayFooterTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction2(4, _c61, day_r33.date, day_r33.eventMap.all)));
  }
}
function MbscTimeline_ng_template_14_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const week_r34 = ɵɵnextContext().week;
    ɵɵtextInterpolate(week_r34.weekText);
  }
}
function MbscTimeline_ng_template_14_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_14_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_14_ng_template_0_Template, 1, 1, "ng-template", null, 23, ɵɵtemplateRefExtractor)(2, MbscTimeline_ng_template_14_ng_template_2_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const week_r34 = ctx2.week;
    const defaultWeek_r35 = ɵɵreference(1);
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.weekTemplate || defaultWeek_r35)("ngTemplateOutletContext", ɵɵpureFunction1(10, _c14, ɵɵpureFunction6(3, _c62, week_r34.date, week_r34.eventMap[week_r34.timestamp] || ɵɵpureFunction0(2, _c57), week_r34.isActive, week_r34.date, week_r34.endDate, week_r34.weekNr)));
  }
}
function MbscTimeline_ng_template_16_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_16_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 77);
    ɵɵtemplate(1, MbscTimeline_ng_template_16_ng_template_1_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const week_r36 = ctx2.week;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.weekFooterTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(10, _c14, ɵɵpureFunction6(3, _c62, week_r36.date, week_r36.eventMap[week_r36.timestamp] || ɵɵpureFunction0(2, _c57), week_r36.isActive, week_r36.date, week_r36.endDate, week_r36.weekNr)));
  }
}
function MbscTimeline_ng_template_18_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const month_r37 = ɵɵnextContext().month;
    ɵɵtextInterpolate(month_r37.monthText);
  }
}
function MbscTimeline_ng_template_18_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_18_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_18_ng_template_0_Template, 1, 1, "ng-template", null, 24, ɵɵtemplateRefExtractor)(2, MbscTimeline_ng_template_18_ng_template_2_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const month_r37 = ctx2.month;
    const defaultMonth_r38 = ɵɵreference(1);
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.monthTemplate || defaultMonth_r38)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction3(3, _c60, month_r37.date, month_r37.eventMap[month_r37.timestamp] || ɵɵpureFunction0(2, _c57), month_r37.isActive)));
  }
}
function MbscTimeline_ng_template_20_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_20_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 78);
    ɵɵtemplate(1, MbscTimeline_ng_template_20_ng_template_1_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const month_r39 = ctx2.month;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.monthFooterTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c14, ɵɵpureFunction2(3, _c61, month_r39.date, month_r39.eventMap[month_r39.timestamp] || ɵɵpureFunction0(2, _c57))));
  }
}
function MbscTimeline_ng_template_22_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const quarter_r40 = ɵɵnextContext().quarter;
    ɵɵtextInterpolate(quarter_r40.quarterText);
  }
}
function MbscTimeline_ng_template_22_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_22_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_22_ng_template_0_Template, 1, 1, "ng-template", null, 25, ɵɵtemplateRefExtractor)(2, MbscTimeline_ng_template_22_ng_template_2_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const quarter_r40 = ctx2.quarter;
    const defaultQuarter_r41 = ɵɵreference(1);
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.quarterTemplate || defaultQuarter_r41)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction3(3, _c60, quarter_r40.date, quarter_r40.eventMap[quarter_r40.timestamp] || ɵɵpureFunction0(2, _c57), quarter_r40.isActive)));
  }
}
function MbscTimeline_ng_template_24_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_24_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 79);
    ɵɵtemplate(1, MbscTimeline_ng_template_24_ng_template_1_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const quarter_r42 = ctx2.quarter;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.quarterFooterTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction3(3, _c60, quarter_r42.date, quarter_r42.eventMap[quarter_r42.timestamp] || ɵɵpureFunction0(2, _c57), quarter_r42.isActive)));
  }
}
function MbscTimeline_ng_template_26_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const year_r43 = ɵɵnextContext().year;
    ɵɵtextInterpolate(year_r43.columnTitle);
  }
}
function MbscTimeline_ng_template_26_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_26_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_template_26_ng_template_0_Template, 1, 1, "ng-template", null, 26, ɵɵtemplateRefExtractor)(2, MbscTimeline_ng_template_26_ng_template_2_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const year_r43 = ctx2.year;
    const defaultYear_r44 = ɵɵreference(1);
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.yearTemplate || defaultYear_r44)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction3(3, _c60, year_r43.date, year_r43.eventMap[year_r43.timestamp] || ɵɵpureFunction0(2, _c57), year_r43.isActive)));
  }
}
function MbscTimeline_ng_template_28_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_ng_template_28_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 80);
    ɵɵtemplate(1, MbscTimeline_ng_template_28_ng_template_1_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const year_r45 = ctx2.year;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r5.yearFooterTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction3(3, _c60, year_r45.date, year_r45.eventMap[year_r45.timestamp] || ɵɵpureFunction0(2, _c57), year_r45.isActive)));
  }
}
function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template(rf, ctx2) {
  if (rf & 1) {
    const _r46 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-schedule-event", 87);
    ɵɵlistener("onClick", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onClick_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5._onEventClick($event));
    })("onDoubleClick", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDoubleClick_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5.onEventDoubleClick($event));
    })("onRightClick", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onRightClick_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5.onEventRightClick($event));
    })("onHoverIn", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onHoverIn_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5.onEventHoverIn($event));
    })("onHoverOut", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onHoverOut_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5.onEventHoverOut($event));
    })("onDelete", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDelete_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5.onEventDelete($event));
    })("onDragStart", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragStart_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5._onEventDragStart($event));
    })("onDragMove", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragMove_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5._onEventDragMove($event));
    })("onDragEnd", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragEnd_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5._onEventDragEnd($event));
    })("onDragModeOn", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragModeOn_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5._onEventDragModeOn($event));
    })("onDragModeOff", function MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template_mbsc_schedule_event_onDragModeOff_0_listener($event) {
      ɵɵrestoreView(_r46);
      const ctx_r5 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r5._onEventDragModeOff($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r47 = ɵɵnextContext().$implicit;
    const ctx_r47 = ɵɵnextContext(2);
    const dragData_r49 = ctx_r47.dragData;
    const resource_r50 = ctx_r47.resource;
    const slot_r51 = ctx_r47.slot;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("bufferAfterTemplate", ctx_r5.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r5.bufferBeforeTemplate)("contentTemplate", ctx_r5.eventContentTemplate)("displayTimezone", ctx_r5.displayTimezone)("drag", ctx_r5.dragToMove || ctx_r5.externalDrag)("endDay", ctx_r5.endDay)("event", event_r47)("eventHeight", ctx_r5._setRowHeight && !ctx_r5._variableEventHeight ? ctx_r5._eventHeight : void 0)("exclusiveEndDates", ctx_r5.exclusiveEndDates)("gridEndTime", ctx_r5._endTime)("gridStartTime", ctx_r5._startTime)("hasResY", ctx_r5._hasResY)("inactive", dragData_r49 && dragData_r49.draggedEvent && dragData_r49.draggedEvent.id === event_r47.id)("isTimeline", true)("isListing", ctx_r5.eventList)("lastDay", ctx_r5._lastDay)("resize", ctx_r5._computeResize(event_r47.original.resize, ctx_r5.dragToResize, resource_r50.eventResize))("resource", resource_r50.id)("resourceObj", resource_r50)("rtl", ctx_r5.rtl)("selected", !!(ctx_r5.selectedEventsMap[event_r47.uid] || ctx_r5.selectedEventsMap[event_r47.id]))("slot", slot_r51.id)("slotObj", slot_r51)("startDay", ctx_r5.startDay)("stickyPos", ctx_r5._hasSticky && !ctx_r5._hasSlots ? (ctx_r5._hasResources ? ctx_r5._resourceWidth : 0) + "px" : void 0)("theme", ctx_r5.theme)("template", ctx_r5.eventTemplate)("timezonePlugin", ctx_r5.timezonePlugin);
  }
}
function MbscTimeline_ng_template_30_div_1_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_template_30_div_1_ng_container_1_mbsc_schedule_event_1_Template, 1, 28, "mbsc-schedule-event", 86);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const event_r47 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", event_r47.position);
  }
}
function MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_2_Template(rf, ctx2) {
  if (rf & 1) {
    const _r52 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-schedule-event", 88);
    ɵɵlistener("onDragStart", function MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_2_Template_mbsc_schedule_event_onDragStart_0_listener($event) {
      ɵɵrestoreView(_r52);
      const ctx_r5 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r5._onEventDragStart($event));
    })("onDragMove", function MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_2_Template_mbsc_schedule_event_onDragMove_0_listener($event) {
      ɵɵrestoreView(_r52);
      const ctx_r5 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r5._onEventDragMove($event));
    })("onDragEnd", function MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_2_Template_mbsc_schedule_event_onDragEnd_0_listener($event) {
      ɵɵrestoreView(_r52);
      const ctx_r5 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r5._onEventDragEnd($event));
    })("onDragModeOff", function MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_2_Template_mbsc_schedule_event_onDragModeOff_0_listener($event) {
      ɵɵrestoreView(_r52);
      const ctx_r5 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r5._onEventDragModeOff($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r47 = ɵɵnextContext(2);
    const dragData_r49 = ctx_r47.dragData;
    const dragKey_r53 = ctx_r47.dragKey;
    const resource_r50 = ctx_r47.resource;
    const slot_r51 = ctx_r47.slot;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("bufferAfterTemplate", ctx_r5.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r5.bufferBeforeTemplate)("contentTemplate", ctx_r5.eventContentTemplate)("displayTimezone", ctx_r5.displayTimezone)("drag", ctx_r5.dragToMove || ctx_r5.externalDrag)("endDay", ctx_r5.endDay)("event", dragData_r49.originDates[dragKey_r53])("eventHeight", ctx_r5._setRowHeight && !ctx_r5._variableEventHeight ? ctx_r5._eventHeight : void 0)("exclusiveEndDates", ctx_r5.exclusiveEndDates)("gridEndTime", ctx_r5._endTime)("gridStartTime", ctx_r5._startTime)("hasResY", ctx_r5._hasResY)("hidden", !!dragData_r49.draggedDates)("isDrag", true)("isTimeline", true)("isListing", ctx_r5.eventList)("lastDay", ctx_r5._lastDay)("resize", ctx_r5._computeResize(dragData_r49.originDates[dragKey_r53].original.resize, ctx_r5.dragToResize, resource_r50.eventResize))("resource", resource_r50.id)("resourceObj", resource_r50)("rtl", ctx_r5.rtl)("slot", slot_r51.id)("slotObj", slot_r51)("startDay", ctx_r5.startDay)("theme", ctx_r5.theme)("template", ctx_r5.eventTemplate)("timezonePlugin", ctx_r5.timezonePlugin);
  }
}
function MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-schedule-event", 89);
  }
  if (rf & 2) {
    const ctx_r47 = ɵɵnextContext(2);
    const dragData_r49 = ctx_r47.dragData;
    const dragKey_r53 = ctx_r47.dragKey;
    const resource_r50 = ctx_r47.resource;
    const slot_r51 = ctx_r47.slot;
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("bufferAfterTemplate", ctx_r5.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r5.bufferBeforeTemplate)("contentTemplate", ctx_r5.eventContentTemplate)("displayTimezone", ctx_r5.displayTimezone)("drag", ctx_r5.dragToMove || ctx_r5.externalDrag)("endDay", ctx_r5.endDay)("event", dragData_r49.draggedDates[dragKey_r53])("eventHeight", ctx_r5._setRowHeight && !ctx_r5._variableEventHeight ? ctx_r5._eventHeight : void 0)("exclusiveEndDates", ctx_r5.exclusiveEndDates)("gridEndTime", ctx_r5._endTime)("gridStartTime", ctx_r5._startTime)("hasResY", ctx_r5._hasResY)("isDrag", true)("isTimeline", true)("isListing", ctx_r5.eventList)("lastDay", ctx_r5._lastDay)("resize", ctx_r5._computeResize(dragData_r49.draggedDates[dragKey_r53].original.resize, ctx_r5.dragToResize, resource_r50.eventResize))("resource", resource_r50.id)("resourceObj", resource_r50)("rtl", ctx_r5.rtl)("slot", slot_r51.id)("slotObj", slot_r51)("startDay", ctx_r5.startDay)("theme", ctx_r5.theme)("template", ctx_r5.eventTemplate)("timezonePlugin", ctx_r5.timezonePlugin);
  }
}
function MbscTimeline_ng_template_30_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 83);
    ɵɵtemplate(1, MbscTimeline_ng_template_30_div_1_ng_container_1_Template, 2, 1, "ng-container", 57)(2, MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_2_Template, 1, 27, "mbsc-schedule-event", 84)(3, MbscTimeline_ng_template_30_div_1_mbsc_schedule_event_3_Template, 1, 26, "mbsc-schedule-event", 85);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const track_r54 = ctx2.$implicit;
    const i_r55 = ctx2.index;
    const ctx_r47 = ɵɵnextContext();
    const dragData_r49 = ctx_r47.dragData;
    const dragKey_r53 = ctx_r47.dragKey;
    const tracks_r56 = ctx_r47.tracks;
    const ctx_r5 = ɵɵnextContext();
    ɵɵstyleProp("min-height", ctx_r5._variableEventHeight ? (tracks_r56[i_r55] || 0) + "px" : void 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", track_r54)("ngForTrackBy", ctx_r5._getEventKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", dragData_r49 && dragData_r49.originDates && dragData_r49.originDates[dragKey_r53] && dragData_r49.originDates[dragKey_r53].track === i_r55);
    ɵɵadvance();
    ɵɵproperty("ngIf", dragData_r49 && dragData_r49.draggedDates && dragData_r49.draggedDates[dragKey_r53] && dragData_r49.draggedDates[dragKey_r53].track === i_r55);
  }
}
function MbscTimeline_ng_template_30_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-row-gutter" + ctx_r5._theme);
  }
}
function MbscTimeline_ng_template_30_ng_container_3_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 91)(1, "div", 92);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const invalid_r57 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-schedule-invalid mbsc-timeline-invalid" + invalid_r57.cssClass + ctx_r5._theme);
    ɵɵproperty("ngStyle", invalid_r57.position);
    ɵɵadvance(2);
    ɵɵtextInterpolate(invalid_r57.title);
  }
}
function MbscTimeline_ng_template_30_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_template_30_ng_container_3_div_1_Template, 3, 4, "div", 90);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const invalid_r57 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", invalid_r57.position);
  }
}
function MbscTimeline_ng_template_30_ng_container_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 91)(2, "div", 93);
    ɵɵtext(3);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const color_r58 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-color mbsc-timeline-color" + color_r58.cssClass + ctx_r5._theme);
    ɵɵproperty("ngStyle", color_r58.position);
    ɵɵadvance(2);
    ɵɵtextInterpolate(color_r58.title);
  }
}
function MbscTimeline_ng_template_30_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 81);
    ɵɵtemplate(1, MbscTimeline_ng_template_30_div_1_Template, 4, 6, "div", 82)(2, MbscTimeline_ng_template_30_div_2_Template, 1, 2, "div", 46);
    ɵɵelementEnd();
    ɵɵtemplate(3, MbscTimeline_ng_template_30_ng_container_3_Template, 2, 1, "ng-container", 57)(4, MbscTimeline_ng_template_30_ng_container_4_Template, 4, 4, "ng-container", 57);
  }
  if (rf & 2) {
    const colors_r59 = ctx2.colors;
    const events_r60 = ctx2.events;
    const invalids_r61 = ctx2.invalids;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", events_r60)("ngForTrackBy", ctx_r5._getKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._setRowHeight && ctx_r5._variableEventHeight);
    ɵɵadvance();
    ɵɵproperty("ngForOf", invalids_r61[0])("ngForTrackBy", ctx_r5._getKey);
    ɵɵadvance();
    ɵɵproperty("ngForOf", colors_r59[0])("ngForTrackBy", ctx_r5._getKey);
  }
}
function MbscTimeline_div_35_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_div_35_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 94);
    ɵɵtemplate(2, MbscTimeline_div_35_ng_template_2_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-resource-header-cont " + ctx_r5._colClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("height", ctx_r5.state.headerHeight, "px")("width", ctx_r5._hasResources ? ctx_r5._resourceWidth : void 0, "px");
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.resourceHeaderTemplate);
  }
}
function MbscTimeline_ng_container_37_div_1_ng_template_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵtextInterpolate(ctx_r5._stickyDay.monthText);
  }
}
function MbscTimeline_ng_container_37_div_1_ng_template_5_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_37_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", null, 27);
    ɵɵtemplate(3, MbscTimeline_ng_container_37_div_1_ng_template_3_Template, 1, 1, "ng-template", null, 28, ɵɵtemplateRefExtractor)(5, MbscTimeline_ng_container_37_div_1_ng_template_5_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const defaultTmpl_r62 = ɵɵreference(4);
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-header-month mbsc-flex" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-text " + (ctx_r5.monthTemplate ? "mbsc-timeline-header-month-cont" : "mbsc-timeline-header-month-text") + ctx_r5._theme);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.monthTemplate || defaultTmpl_r62)("ngTemplateOutletContext", ɵɵpureFunction1(11, _c14, ɵɵpureFunction3(7, _c60, ctx_r5._stickyDay.date, ctx_r5._stickyDay.eventMap[ctx_r5._stickyDay.timestamp] || ɵɵpureFunction0(6, _c57), ctx_r5._stickyDay.isActive)));
  }
}
function MbscTimeline_ng_container_37_div_2_ng_template_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵtextInterpolate(ctx_r5._stickyDay.weekText);
  }
}
function MbscTimeline_ng_container_37_div_2_ng_template_5_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_37_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", null, 29);
    ɵɵtemplate(3, MbscTimeline_ng_container_37_div_2_ng_template_3_Template, 1, 1, "ng-template", null, 28, ɵɵtemplateRefExtractor)(5, MbscTimeline_ng_container_37_div_2_ng_template_5_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const defaultTmpl_r63 = ɵɵreference(4);
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-header-week mbsc-flex" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-text " + (ctx_r5.weekTemplate ? "mbsc-timeline-header-week-cont" : "mbsc-timeline-header-week-text") + ctx_r5._theme);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.weekTemplate || defaultTmpl_r63)("ngTemplateOutletContext", ɵɵpureFunction1(14, _c14, ɵɵpureFunction6(7, _c62, ctx_r5._stickyDay.date, ctx_r5._stickyDay.eventMap[ctx_r5._stickyDay.timestamp] || ɵɵpureFunction0(6, _c57), ctx_r5._stickyDay.isActive, ctx_r5._stickyDay.date, ctx_r5._stickyDay.endDate, ctx_r5._stickyDay.weekNr)));
  }
}
function MbscTimeline_ng_container_37_div_3_ng_template_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵtextInterpolate(ctx_r5._stickyDay.dateText);
  }
}
function MbscTimeline_ng_container_37_div_3_ng_template_5_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_37_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", null, 30);
    ɵɵtemplate(3, MbscTimeline_ng_container_37_div_3_ng_template_3_Template, 1, 1, "ng-template", null, 22, ɵɵtemplateRefExtractor)(5, MbscTimeline_ng_container_37_div_3_ng_template_5_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const defaultDay_r64 = ɵɵreference(4);
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-header-date mbsc-flex" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-text " + (ctx_r5._stickyDay.isActive && !ctx_r5.dayTemplate ? "mbsc-timeline-header-active " : "") + (ctx_r5.dayTemplate ? "mbsc-timeline-header-date-cont" : "mbsc-timeline-header-date-text") + ctx_r5._theme);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.dayTemplate || defaultDay_r64)("ngTemplateOutletContext", ɵɵpureFunction1(10, _c14, ɵɵpureFunction3(6, _c60, ctx_r5._stickyDay.date, ctx_r5._stickyDay.eventMap.all, ctx_r5._stickyDay.isActive)));
  }
}
function MbscTimeline_ng_container_37_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_37_div_1_Template, 6, 13, "div", 46)(2, MbscTimeline_ng_container_37_div_2_Template, 6, 16, "div", 46)(3, MbscTimeline_ng_container_37_div_3_Template, 6, 12, "div", 46);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._isMulti);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.weekNumbers);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasSlots || ctx_r5._stepCell < ctx_r5._oneDay);
  }
}
function MbscTimeline_div_38_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_div_38_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 96);
    ɵɵtemplate(2, MbscTimeline_div_38_ng_template_2_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-sidebar-header-cont mbsc-timeline-sidebar-col" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("height", ctx_r5.state.headerHeight, "px");
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.sidebarHeaderTemplate);
  }
}
function MbscTimeline_div_39_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 97);
  }
}
function MbscTimeline_div_40_div_2_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_div_40_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 99);
    ɵɵtemplate(2, MbscTimeline_div_40_div_2_ng_template_2_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-resource-footer-cont " + ctx_r5._colClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("height", ctx_r5.state.footerHeight, "px")("width", ctx_r5._hasResources ? ctx_r5._resourceWidth : void 0, "px");
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.resourceFooterTemplate);
  }
}
function MbscTimeline_div_40_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 42);
  }
}
function MbscTimeline_div_40_div_4_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_div_40_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 100);
    ɵɵtemplate(2, MbscTimeline_div_40_div_4_ng_template_2_Template, 0, 0, "ng-template", 95);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-sidebar-footer-cont mbsc-timeline-sidebar-col" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("height", ctx_r5.state.footerHeight, "px");
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.sidebarFooterTemplate);
  }
}
function MbscTimeline_div_40_div_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 97);
  }
}
function MbscTimeline_div_40_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", null, 31);
    ɵɵtemplate(2, MbscTimeline_div_40_div_2_Template, 3, 7, "div", 41)(3, MbscTimeline_div_40_div_3_Template, 1, 0, "div", 98)(4, MbscTimeline_div_40_div_4_Template, 3, 5, "div", 44)(5, MbscTimeline_div_40_div_5_Template, 1, 0, "div", 45);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-footer-sticky mbsc-flex" + ctx_r5._theme);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r5._hasRows);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._isDailyResolution);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasRows && !!ctx_r5.sidebarTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.state.hasScrollY);
  }
}
function MbscTimeline_div_46_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-resource-header-cont " + ctx_r5._colClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("width", ctx_r5._hasResources ? ctx_r5._resourceWidth : void 0, "px");
  }
}
function MbscTimeline_mbsc_time_indicator_49_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-time-indicator", 101);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵproperty("amText", ctx_r5.s.amText)("displayedTime", ctx_r5._time)("displayedDays", ctx_r5._daysNr)("displayTimezone", ctx_r5.displayTimezone)("endDay", ctx_r5.endDay)("firstDay", ctx_r5._firstDayTz)("hasResY", ctx_r5._hasResY)("pmText", ctx_r5.s.pmText)("rtl", ctx_r5.rtl)("startDay", ctx_r5.startDay)("startTime", ctx_r5._startTime)("theme", ctx_r5.theme)("timeFormat", ctx_r5.timeFormat)("timezonePlugin", ctx_r5.timezonePlugin);
  }
}
function MbscTimeline_div_50_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", null, 32);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-cursor-time mbsc-schedule-cursor-time-y" + ctx_r5._theme);
  }
}
function MbscTimeline_ng_container_53_div_1_ng_container_1_div_1_3_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_53_div_1_ng_container_1_div_1_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_53_div_1_ng_container_1_div_1_3_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r65 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext(3);
    const tplMonth_r66 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", tplMonth_r66)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c63, d_r65));
  }
}
function MbscTimeline_ng_container_53_div_1_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div")(2, "div");
    ɵɵtemplate(3, MbscTimeline_ng_container_53_div_1_ng_container_1_div_1_3_Template, 1, 4, null, 43);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const d_r65 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-timeline-month mbsc-flex-1-0-0" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (d_r65.dateIndex < ctx_r5._daysNr - 1 && d_r65.lastOfMonth ? " mbsc-timeline-day mbsc-timeline-day-border" : ""));
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-month" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (d_r65.dateIndex < ctx_r5._daysNr - 1 && d_r65.lastOfMonth ? " mbsc-timeline-header-month-last" : ""));
    ɵɵadvance();
    ɵɵclassMap((ctx_r5.monthTemplate ? "mbsc-timeline-header-month-cont" : "mbsc-timeline-header-month-text") + (d_r65.lastOfMonth ? " mbsc-timeline-header-month-text-last" : "") + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r65.monthTitle);
  }
}
function MbscTimeline_ng_container_53_div_1_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_div_1_ng_container_1_div_1_Template, 4, 7, "div", 46);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const d_r65 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r65.dateKey !== ctx_r5._dragCol);
  }
}
function MbscTimeline_ng_container_53_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 102);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_div_1_ng_container_1_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._virtualDays)("ngForTrackBy", ctx_r5._getDayKey);
  }
}
function MbscTimeline_ng_container_53_div_2_ng_container_1_div_1_3_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_53_div_2_ng_container_1_div_1_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_53_div_2_ng_container_1_div_1_3_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r67 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext(3);
    const tplWeek_r68 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", tplWeek_r68)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c64, d_r67));
  }
}
function MbscTimeline_ng_container_53_div_2_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div")(2, "div");
    ɵɵtemplate(3, MbscTimeline_ng_container_53_div_2_ng_container_1_div_1_3_Template, 1, 4, null, 43);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const d_r67 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-timeline-month mbsc-flex-1-0-0" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (d_r67.dateIndex < ctx_r5._daysNr - 1 && d_r67.lastOfWeek && (ctx_r5._stepCell < ctx_r5._oneDay || d_r67.lastOfMonth) ? " mbsc-timeline-day mbsc-timeline-day-border" : ""));
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-week" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (d_r67.lastOfWeek ? " mbsc-timeline-header-week-last" : ""));
    ɵɵadvance();
    ɵɵclassMap((ctx_r5.weekTemplate ? "mbsc-timeline-header-week-cont" : "mbsc-timeline-header-week-text") + (d_r67.lastOfWeek ? " mbsc-timeline-header-week-text-last" : "") + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r67.weekTitle);
  }
}
function MbscTimeline_ng_container_53_div_2_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_div_2_ng_container_1_div_1_Template, 4, 7, "div", 46);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const d_r67 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r67.dateKey !== ctx_r5._dragCol);
  }
}
function MbscTimeline_ng_container_53_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 102);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_div_2_ng_container_1_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._virtualDays)("ngForTrackBy", ctx_r5._getDayKey);
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_1_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_1_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 106);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const d_r69 = ɵɵnextContext(3).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate(d_r69.label);
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_container_53_ng_container_4_div_1_div_1_ng_template_1_Template, 0, 0, "ng-template", 66)(2, MbscTimeline_ng_container_53_ng_container_4_div_1_div_1_div_2_Template, 2, 1, "div", 105);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const d_r69 = ɵɵnextContext(2).$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    const tplDay_r70 = ɵɵreference(11);
    ɵɵclassMap("mbsc-timeline-header-date" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplDay_r70)("ngTemplateOutletContext", ɵɵpureFunction1(5, _c65, d_r69));
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r69.label);
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_div_1_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const slot_r71 = ɵɵnextContext().$implicit;
    ɵɵtextInterpolate1(" ", slot_r71.name, " ");
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_div_1_ng_template_4_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 107);
    ɵɵtemplate(2, MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_div_1_ng_template_2_Template, 1, 1, "ng-template", null, 33, ɵɵtemplateRefExtractor)(4, MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_div_1_ng_template_4_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const slot_r71 = ctx2.$implicit;
    const defaultSlot_r72 = ɵɵreference(3);
    const d_r69 = ɵɵnextContext(3).$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-slot mbsc-timeline-slot-header mbsc-flex-1-1" + ctx_r5._colWidthClass + ctx_r5._rtl + ctx_r5._theme);
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r5.slotTemplate || defaultSlot_r72)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction2(4, _c66, slot_r71, d_r69.date)));
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_div_1_Template, 5, 9, "div", 72);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(4);
    ɵɵclassMap("mbsc-flex mbsc-timeline-slots" + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._slots)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 51);
  }
  if (rf & 2) {
    const d_r69 = ɵɵnextContext(2).$implicit;
    ɵɵstyleProp("width", d_r69.phStart, "px");
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const v_r73 = ɵɵnextContext().$implicit;
    const d_r69 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext(2);
    const tplHour_r74 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", tplHour_r74)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c67, d_r69, v_r73.t));
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_ng_container_2_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_ng_container_2_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const j_r75 = ɵɵnextContext().index;
    const v_r73 = ɵɵnextContext().$implicit;
    const d_r69 = ɵɵnextContext(2).$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    const tplHour_r74 = ɵɵreference(7);
    ɵɵproperty("ngTemplateOutlet", tplHour_r74)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c67, d_r69, v_r73.t + (j_r75 + 1) * ctx_r5._stepLabel));
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_ng_container_2_1_Template, 1, 5, null, 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const j_r75 = ctx2.index;
    const v_r73 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵproperty("ngIf", v_r73.t + (j_r75 + 1) * ctx_r5._stepLabel > ctx_r5._startTime && v_r73.t + (j_r75 + 1) * ctx_r5._stepLabel < ctx_r5._endTime);
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 91);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_1_Template, 1, 5, null, 43)(2, MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_ng_container_2_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const v_r73 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(4);
    ɵɵclassMap("mbsc-flex mbsc-flex-1-1 mbsc-timeline-header-column" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (v_r73.hidden ? " mbsc-timeline-hidden" : "") + (!ctx_r5._displayTime || ctx_r5._hasSlots ? " mbsc-timeline-no-height" : "") + (ctx_r5._stepLabel > ctx_r5._stepCell && ctx_r5._times[v_r73.i + 1] % ctx_r5._stepLabel ? " mbsc-timeline-no-border" : "") + (v_r73.first && !v_r73.last && ctx_r5._startCellStyle || v_r73.last && !v_r73.first && ctx_r5._endCellStyle ? " mbsc-flex-none" : ""));
    ɵɵproperty("ngStyle", v_r73.first && !v_r73.last ? ctx_r5._startCellStyle : v_r73.last && !v_r73.first ? ctx_r5._endCellStyle : ɵɵpureFunction0(6, _c42));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._displayTime);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._timesBetween)("ngForTrackBy", ctx_r5._getKey);
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_div_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 51);
  }
  if (rf & 2) {
    const d_r69 = ɵɵnextContext(2).$implicit;
    ɵɵstyleProp("width", d_r69.phEnd, "px");
  }
}
function MbscTimeline_ng_container_53_ng_container_4_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_container_53_ng_container_4_div_1_div_1_Template, 3, 7, "div", 46)(2, MbscTimeline_ng_container_53_ng_container_4_div_1_div_2_Template, 2, 4, "div", 46);
    ɵɵelementStart(3, "div", 103);
    ɵɵtemplate(4, MbscTimeline_ng_container_53_ng_container_4_div_1_div_4_Template, 1, 2, "div", 73)(5, MbscTimeline_ng_container_53_ng_container_4_div_1_div_5_Template, 3, 7, "div", 104)(6, MbscTimeline_ng_container_53_ng_container_4_div_1_div_6_Template, 1, 2, "div", 73);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const d_r69 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-day mbsc-flex-1-0-0" + ctx_r5._dayClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (d_r69.dateIndex < ctx_r5._daysNr - 1 && (ctx_r5._stepCell < ctx_r5._oneDay || d_r69.lastOfMonth) ? " mbsc-timeline-day-border" : ""));
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r5._hasResY);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasSlots);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", d_r69.phStart !== 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", d_r69.times)("ngForTrackBy", ctx_r5._getTimeKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r69.phEnd !== 0);
  }
}
function MbscTimeline_ng_container_53_ng_container_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_ng_container_4_div_1_Template, 7, 8, "div", 46);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const d_r69 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r69.dateKey !== ctx_r5._dragCol);
  }
}
function MbscTimeline_ng_container_53_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_53_div_1_Template, 2, 2, "div", 53)(2, MbscTimeline_ng_container_53_div_2_Template, 2, 2, "div", 53);
    ɵɵelementStart(3, "div", 102);
    ɵɵtemplate(4, MbscTimeline_ng_container_53_ng_container_4_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._isMulti && !ctx_r5._hasResY);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.s.weekNumbers);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r5._virtualDays)("ngForTrackBy", ctx_r5._getDayKey);
  }
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_2_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_2_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r76 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(2);
    const tplWeek_r68 = ɵɵreference(15);
    ɵɵproperty("ngTemplateOutlet", tplWeek_r68)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c64, d_r76));
  }
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_3_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_3_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r76 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(2);
    const tplMonth_r66 = ɵɵreference(19);
    ɵɵproperty("ngTemplateOutlet", tplMonth_r66)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c63, d_r76));
  }
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_4_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_4_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r76 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(2);
    const tplQuarter_r77 = ɵɵreference(23);
    ɵɵproperty("ngTemplateOutlet", tplQuarter_r77)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c68, d_r76));
  }
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_5_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_5_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r76 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(2);
    const tplYear_r78 = ɵɵreference(27);
    ɵɵproperty("ngTemplateOutlet", tplYear_r78)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c69, d_r76));
  }
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 109);
    ɵɵelementStart(1, "div");
    ɵɵtemplate(2, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_2_Template, 1, 4, null, 110)(3, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_3_Template, 1, 4, null, 110)(4, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_4_Template, 1, 4, null, 110)(5, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_5_Template, 1, 4, null, 110);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(4);
    ɵɵproperty("ngSwitch", ctx_r5.resolution);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-" + ctx_r5.resolution + "-cont");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "week");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "month");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "quarter");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "year");
  }
}
function MbscTimeline_div_54_ng_container_1_div_1_ng_template_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const d_r76 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate(d_r76.columnTitle);
  }
}
function MbscTimeline_div_54_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div")(2, "div");
    ɵɵtemplate(3, MbscTimeline_div_54_ng_container_1_div_1_ng_container_3_Template, 6, 7, "ng-container", 108)(4, MbscTimeline_div_54_ng_container_1_div_1_ng_template_4_Template, 1, 1, "ng-template", null, 34, ɵɵtemplateRefExtractor);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const defaultTitle_r79 = ɵɵreference(5);
    const d_r76 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-day mbsc-flex-1-0-0" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-week mbsc-timeline-header-week-last" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-header-week-text mbsc-timeline-header-week-text-last" + (d_r76.isActive && !(ctx_r5.weekTemplate || ctx_r5.dayTemplate || ctx_r5.monthTemplate || ctx_r5.quarterTemplate || ctx_r5.yearTemplate) ? " mbsc-timeline-header-active" : "") + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.weekTemplate || ctx_r5.monthTemplate || ctx_r5.quarterTemplate || ctx_r5.yearTemplate)("ngIfElse", defaultTitle_r79);
  }
}
function MbscTimeline_div_54_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_div_54_ng_container_1_div_1_Template, 6, 8, "div", 46);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const d_r76 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r76.dateKey !== ctx_r5._dragCol);
  }
}
function MbscTimeline_div_54_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 102);
    ɵɵtemplate(1, MbscTimeline_div_54_ng_container_1_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._virtualDays)("ngForTrackBy", ctx_r5._getDayKey);
  }
}
function MbscTimeline_div_56_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-sidebar-header-cont mbsc-timeline-sidebar-col" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
  }
}
function MbscTimeline_div_59_ng_container_5_ng_container_1_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_59_ng_container_5_ng_container_1_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_59_ng_container_5_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const r_r80 = ctx2.$implicit;
    ɵɵnextContext(4);
    const tplResource_r81 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tplResource_r81)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c70, r_r80, r_r80.id));
  }
}
function MbscTimeline_div_59_ng_container_5_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_div_59_ng_container_5_ng_container_1_1_Template, 1, 5, null, 57);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r82 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", rowGroup_r82.rows)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_4_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_4_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const r_r83 = ctx2.$implicit;
    const rowGroup_r82 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(2);
    const tplResource_r81 = ɵɵreference(1);
    ɵɵproperty("ngTemplateOutlet", tplResource_r81)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c71, r_r83, rowGroup_r82.day.dateKey + "-" + r_r83.id, rowGroup_r82.day.date));
  }
}
function MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div");
    ɵɵtemplate(2, MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_ng_template_2_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 113);
    ɵɵtemplate(4, MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_4_Template, 1, 6, null, 57);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const rowGroup_r82 = ɵɵnextContext(2).$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    const tplDay_r70 = ɵɵreference(11);
    ɵɵclassMap("mbsc-timeline-row-group mbsc-flex mbsc-flex-1-0" + ctx_r5._theme + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-row-date mbsc-timeline-row-date-col mbsc-flex-none" + ctx_r5._rtl + ctx_r5._theme + ctx_r5._hb);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplDay_r70)("ngTemplateOutletContext", ɵɵpureFunction1(8, _c65, rowGroup_r82.day));
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", rowGroup_r82.rows)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_div_59_ng_container_5_ng_container_2_div_2_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_div_59_ng_container_5_ng_container_2_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_div_59_ng_container_5_ng_container_2_div_2_ng_template_1_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const rowGroup_r82 = ɵɵnextContext(2).$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    const tplDay_r70 = ɵɵreference(11);
    ɵɵclassMap("mbsc-timeline-row-date mbsc-flex-1-0" + ctx_r5._rtl + ctx_r5._theme + ctx_r5._hb);
    ɵɵstyleProp("min-height", ctx_r5._rowHeights[rowGroup_r82.day.dateKey + "-" + ctx_r5._defId]);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplDay_r70)("ngTemplateOutletContext", ɵɵpureFunction1(6, _c65, rowGroup_r82.day));
  }
}
function MbscTimeline_div_59_ng_container_5_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_div_59_ng_container_5_ng_container_2_div_1_Template, 5, 10, "div", 46)(2, MbscTimeline_div_59_ng_container_5_ng_container_2_div_2_Template, 2, 8, "div", 112);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasResources);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r5._hasResources);
  }
}
function MbscTimeline_div_59_ng_container_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_div_59_ng_container_5_ng_container_1_Template, 2, 2, "ng-container", 43)(2, MbscTimeline_div_59_ng_container_5_ng_container_2_Template, 3, 2, "ng-container", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r82 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !rowGroup_r82.day && !rowGroup_r82.hidden);
    ɵɵadvance();
    ɵɵproperty("ngIf", rowGroup_r82.day && !rowGroup_r82.hidden);
  }
}
function MbscTimeline_div_59_div_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 114);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵstyleProp("height", ctx_r5._hasSideSticky ? void 0 : ctx_r5.state.footerHeight, "px");
  }
}
function MbscTimeline_div_59_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", null, 35);
    ɵɵelement(2, "div");
    ɵɵelementStart(3, "div");
    ɵɵelement(4, "div", 51);
    ɵɵtemplate(5, MbscTimeline_div_59_ng_container_5_Template, 3, 2, "ng-container", 57);
    ɵɵelementEnd();
    ɵɵtemplate(6, MbscTimeline_div_59_div_6_Template, 1, 2, "div", 111);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-resources mbsc-flex-col " + ctx_r5._colClass + ctx_r5._theme + ctx_r5._rtl);
    ɵɵstyleProp("width", ctx_r5._hasResources ? ctx_r5._resourceWidth : void 0, "px");
    ɵɵadvance(2);
    ɵɵclassMap("mbsc-flex-none");
    ɵɵstyleProp("height", ctx_r5._hasSideSticky ? void 0 : ctx_r5.state.headerHeight, "px");
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-resource-bg mbsc-flex-1-1" + (ctx_r5._hasHierarchy || ctx_r5.state.hasScrollY ? "" : " mbsc-flex-col") + ctx_r5._theme);
    ɵɵadvance();
    ɵɵstyleProp("height", ctx_r5._phY, "px");
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._virtualRows)("ngForTrackBy", ctx_r5._getRowKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasFooter);
  }
}
function MbscTimeline_div_60_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap(ctx_r5._hasSideSticky ? "" : ctx_r5._colClass);
    ɵɵstyleProp("width", ctx_r5._hasSideSticky || !ctx_r5._hasResources ? void 0 : ctx_r5._resourceWidth, "px");
  }
}
function MbscTimeline_ng_container_71_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "div", null, 36);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-resource-drop" + (ctx_r5.state.dragData && ctx_r5.state.dragData.draggedResourceInvalid ? " mbsc-timeline-resource-drop-invalid " : " ") + ctx_r5._theme);
  }
}
function MbscTimeline_ng_container_73_ng_container_1_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_73_ng_container_1_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_73_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const r_r84 = ctx2.$implicit;
    const rowGroup_r85 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext();
    const tplRow_r86 = ɵɵreference(5);
    ɵɵproperty("ngTemplateOutlet", tplRow_r86)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c72, r_r84, rowGroup_r85.day ? rowGroup_r85.day.dateKey : "", rowGroup_r85.day));
  }
}
function MbscTimeline_ng_container_73_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_73_ng_container_1_1_Template, 1, 6, null, 57);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r85 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", rowGroup_r85.rows)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_ng_container_73_ng_container_2_2_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_73_ng_container_2_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_73_ng_container_2_2_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const r_r87 = ctx2.$implicit;
    const rowGroup_r85 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext();
    const tplRow_r86 = ɵɵreference(5);
    ɵɵproperty("ngTemplateOutlet", tplRow_r86)("ngTemplateOutletContext", ɵɵpureFunction3(2, _c72, r_r87, rowGroup_r85.day.dateKey, rowGroup_r85.day));
  }
}
function MbscTimeline_ng_container_73_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div");
    ɵɵtemplate(2, MbscTimeline_ng_container_73_ng_container_2_2_Template, 1, 6, null, 57);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r85 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-row-group mbsc-flex-col mbsc-flex-1-0" + ctx_r5._theme + ctx_r5._hb);
    ɵɵadvance();
    ɵɵproperty("ngForOf", rowGroup_r85.rows)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_ng_container_73_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_73_ng_container_1_Template, 2, 2, "ng-container", 43)(2, MbscTimeline_ng_container_73_ng_container_2_Template, 3, 4, "ng-container", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r85 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !rowGroup_r85.day || !ctx_r5._hasResources);
    ɵɵadvance();
    ɵɵproperty("ngIf", rowGroup_r85.day && ctx_r5._hasResources);
  }
}
function MbscTimeline__svg_svg_74__svg_ng_container_1__svg_path_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelement(0, "path", 117);
  }
  if (rf & 2) {
    const c_r88 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵstyleProp("stroke", c_r88.color)("fill", c_r88.fill);
    ɵɵattribute("d", c_r88.pathD)("class", "mbsc-connection " + c_r88.cssClass + ctx_r5._theme);
  }
}
function MbscTimeline__svg_svg_74__svg_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline__svg_svg_74__svg_ng_container_1__svg_path_1_Template, 1, 6, "path", 116);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const c_r88 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._virtualStart <= c_r88.endDate && ctx_r5._virtualEnd > c_r88.startDate);
  }
}
function MbscTimeline__svg_svg_74_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵnamespaceSVG();
    ɵɵelementStart(0, "svg", 115);
    ɵɵtemplate(1, MbscTimeline__svg_svg_74__svg_ng_container_1_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵattribute("class", "mbsc-connections" + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._connections)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_div_75_ng_container_5_ng_container_1_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_75_ng_container_5_ng_container_1_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_75_ng_container_5_ng_container_1_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const r_r89 = ctx2.$implicit;
    ɵɵnextContext(4);
    const tplSidebar_r90 = ɵɵreference(3);
    ɵɵproperty("ngTemplateOutlet", tplSidebar_r90)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c70, r_r89, r_r89.id));
  }
}
function MbscTimeline_div_75_ng_container_5_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_div_75_ng_container_5_ng_container_1_1_Template, 1, 5, null, 57);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r91 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", rowGroup_r91.rows)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_div_75_ng_container_5_ng_container_2_2_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_div_75_ng_container_5_ng_container_2_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_div_75_ng_container_5_ng_container_2_2_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const r_r92 = ctx2.$implicit;
    const rowGroup_r91 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext(2);
    const tplSidebar_r90 = ɵɵreference(3);
    ɵɵproperty("ngTemplateOutlet", tplSidebar_r90)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c70, r_r92, rowGroup_r91.day.dateKey + "-" + r_r92.id));
  }
}
function MbscTimeline_div_75_ng_container_5_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div");
    ɵɵtemplate(2, MbscTimeline_div_75_ng_container_5_ng_container_2_2_Template, 1, 5, null, 57);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r91 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-row-group mbsc-flex-col mbsc-flex-1-0" + ctx_r5._theme + ctx_r5._hb);
    ɵɵadvance();
    ɵɵproperty("ngForOf", rowGroup_r91.rows)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_div_75_ng_container_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_div_75_ng_container_5_ng_container_1_Template, 2, 2, "ng-container", 43)(2, MbscTimeline_div_75_ng_container_5_ng_container_2_Template, 3, 4, "ng-container", 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const rowGroup_r91 = ctx2.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !rowGroup_r91.day && !rowGroup_r91.hidden);
    ɵɵadvance();
    ɵɵproperty("ngIf", rowGroup_r91.day && !rowGroup_r91.hidden);
  }
}
function MbscTimeline_div_75_div_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 114);
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵstyleProp("height", ctx_r5._hasSideSticky ? void 0 : ctx_r5.state.footerHeight, "px");
  }
}
function MbscTimeline_div_75_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", null, 37);
    ɵɵelement(2, "div");
    ɵɵelementStart(3, "div");
    ɵɵelement(4, "div", 51);
    ɵɵtemplate(5, MbscTimeline_div_75_ng_container_5_Template, 3, 2, "ng-container", 57);
    ɵɵelementEnd();
    ɵɵtemplate(6, MbscTimeline_div_75_div_6_Template, 1, 2, "div", 111);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap("mbsc-timeline-sidebar mbsc-timeline-sidebar-col mbsc-flex-col" + ctx_r5._theme + ctx_r5._rtl);
    ɵɵadvance(2);
    ɵɵclassMap("mbsc-flex-none");
    ɵɵstyleProp("height", ctx_r5._hasSideSticky ? void 0 : ctx_r5.state.headerHeight, "px");
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-resource-bg mbsc-flex-1-1" + (ctx_r5._hasHierarchy || ctx_r5.state.hasScrollY ? "" : " mbsc-flex-col") + ctx_r5._theme);
    ɵɵadvance();
    ɵɵstyleProp("height", ctx_r5._phY, "px");
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._virtualRows)("ngForTrackBy", ctx_r5._getRowKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasFooter);
  }
}
function MbscTimeline_div_76_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassMap(ctx_r5._hasSideSticky ? "" : "mbsc-timeline-sidebar-col");
  }
}
function MbscTimeline_ng_container_77_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-resource-footer-cont " + ctx_r5._colClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵstyleProp("width", ctx_r5._hasResources ? ctx_r5._resourceWidth : void 0, "px");
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 51);
  }
  if (rf & 2) {
    const d_r93 = ɵɵnextContext(2).$implicit;
    ɵɵstyleProp("width", d_r93.phStart, "px");
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const v_r94 = ɵɵnextContext().$implicit;
    const d_r93 = ɵɵnextContext(2).$implicit;
    ɵɵnextContext(3);
    const tplHourFooter_r95 = ɵɵreference(9);
    ɵɵproperty("ngTemplateOutlet", tplHourFooter_r95)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c67, d_r93, v_r94.t));
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_ng_container_2_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_ng_container_2_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_ng_container_2_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const j_r96 = ɵɵnextContext().index;
    const v_r94 = ɵɵnextContext().$implicit;
    const d_r93 = ɵɵnextContext(2).$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    const tplHourFooter_r95 = ɵɵreference(9);
    ɵɵproperty("ngTemplateOutlet", tplHourFooter_r95)("ngTemplateOutletContext", ɵɵpureFunction2(2, _c67, d_r93, v_r94.t + (j_r96 + 1) * ctx_r5._stepLabel));
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_ng_container_2_1_Template, 1, 5, null, 43);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const j_r96 = ctx2.index;
    const v_r94 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵproperty("ngIf", v_r94.t + (j_r96 + 1) * ctx_r5._stepLabel > ctx_r5._startTime && v_r94.t + (j_r96 + 1) * ctx_r5._stepLabel < ctx_r5._endTime);
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 91);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_1_Template, 1, 5, null, 43)(2, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_ng_container_2_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const v_r94 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(5);
    ɵɵclassMap("mbsc-flex mbsc-flex-1-1 mbsc-timeline-column mbsc-timeline-footer-column" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (v_r94.hidden ? " mbsc-timeline-hidden" : "") + (!ctx_r5._displayTime || ctx_r5._hasSlots ? " mbsc-timeline-no-height" : "") + (ctx_r5._stepLabel > ctx_r5._stepCell && ctx_r5._times[v_r94.i + 1] % ctx_r5._stepLabel ? " mbsc-timeline-no-border" : "") + (v_r94.first && !v_r94.last && ctx_r5._startCellStyle || v_r94.last && !v_r94.first && ctx_r5._endCellStyle ? " mbsc-flex-none" : ""));
    ɵɵproperty("ngStyle", v_r94.first && !v_r94.last ? ctx_r5._startCellStyle : v_r94.last && !v_r94.first ? ctx_r5._endCellStyle : ɵɵpureFunction0(6, _c42));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._displayTime);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._timesBetween)("ngForTrackBy", ctx_r5._getKey);
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 51);
  }
  if (rf & 2) {
    const d_r93 = ɵɵnextContext(2).$implicit;
    ɵɵstyleProp("width", d_r93.phEnd, "px");
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_5_ng_template_1_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_5_ng_template_1_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const d_r93 = ɵɵnextContext(2).$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    const tplDayFooter_r97 = ɵɵreference(13);
    ɵɵclassMap("mbsc-timeline-footer-date" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", tplDayFooter_r97)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c65, d_r93));
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_6_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(6);
    ɵɵclassMap("mbsc-timeline-slot mbsc-flex-1-1" + ctx_r5._rtl + ctx_r5._theme);
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 102);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_6_div_1_Template, 1, 2, "div", 72);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(5);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._slots)("ngForTrackBy", ctx_r5._getId);
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div", 102);
    ɵɵtemplate(2, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_2_Template, 1, 2, "div", 73)(3, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_3_Template, 3, 7, "div", 104)(4, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_4_Template, 1, 2, "div", 73);
    ɵɵelementEnd();
    ɵɵtemplate(5, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_5_Template, 2, 6, "div", 46)(6, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_div_6_Template, 2, 2, "div", 53);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const d_r93 = ɵɵnextContext().$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵclassMap("mbsc-timeline-day mbsc-flex-1-0-0" + ctx_r5._dayClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb + (d_r93.dateIndex < ctx_r5._daysNr - 1 && (ctx_r5._stepCell < ctx_r5._oneDay || d_r93.lastOfMonth) ? " mbsc-timeline-day-border" : ""));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", d_r93.phStart !== 0);
    ɵɵadvance();
    ɵɵproperty("ngForOf", d_r93.times)("ngForTrackBy", ctx_r5._getTimeKey);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r93.phEnd !== 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.dayFooterTemplate);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasSlots);
  }
}
function MbscTimeline_ng_container_77_div_8_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_8_ng_container_1_div_1_Template, 7, 8, "div", 46);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const d_r93 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r93.dateKey !== ctx_r5._dragCol);
  }
}
function MbscTimeline_ng_container_77_div_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 102);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_8_ng_container_1_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._virtualDays)("ngForTrackBy", ctx_r5._getDayKey);
  }
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_1_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_1_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r98 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(3);
    const tplWeekFooter_r99 = ɵɵreference(17);
    ɵɵproperty("ngTemplateOutlet", tplWeekFooter_r99)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c64, d_r98));
  }
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_2_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_2_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r98 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(3);
    const tplMonthFooter_r100 = ɵɵreference(21);
    ɵɵproperty("ngTemplateOutlet", tplMonthFooter_r100)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c63, d_r98));
  }
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_3_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_3_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r98 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(3);
    const tplQuarterFooter_r101 = ɵɵreference(25);
    ɵɵproperty("ngTemplateOutlet", tplQuarterFooter_r101)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c68, d_r98));
  }
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_4_ng_template_0_Template(rf, ctx2) {
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_4_ng_template_0_Template, 0, 0, "ng-template", 66);
  }
  if (rf & 2) {
    const d_r98 = ɵɵnextContext(3).$implicit;
    ɵɵnextContext(3);
    const tplYearFooter_r102 = ɵɵreference(29);
    ɵɵproperty("ngTemplateOutlet", tplYearFooter_r102)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c69, d_r98));
  }
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 109);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_1_Template, 1, 4, null, 110)(2, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_2_Template, 1, 4, null, 110)(3, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_3_Template, 1, 4, null, 110)(4, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_4_Template, 1, 4, null, 110);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(5);
    ɵɵproperty("ngSwitch", ctx_r5.s.resolution);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "week");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "month");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "quarter");
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "year");
  }
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div")(1, "div")(2, "div");
    ɵɵtemplate(3, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_ng_container_3_Template, 5, 5, "ng-container", 118);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(4);
    ɵɵclassMap("mbsc-timeline-day mbsc-flex-1-0-0" + ctx_r5._colWidthClass + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-footer-week mbsc-timeline-footer-week-last" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-footer-week-text" + ctx_r5._theme);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5.weekFooterTemplate || ctx_r5.monthFooterTemplate || ctx_r5.quarterFooterTemplate || ctx_r5.yearFooterTemplate);
  }
}
function MbscTimeline_ng_container_77_div_9_ng_container_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_9_ng_container_1_div_1_Template, 4, 7, "div", 46);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const d_r98 = ctx2.$implicit;
    const ctx_r5 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", d_r98.dateKey !== ctx_r5._dragCol);
  }
}
function MbscTimeline_ng_container_77_div_9_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 102);
    ɵɵtemplate(1, MbscTimeline_ng_container_77_div_9_ng_container_1_Template, 2, 1, "ng-container", 57);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5._virtualDays)("ngForTrackBy", ctx_r5._getDayKey);
  }
}
function MbscTimeline_ng_container_77_div_11_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div");
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-timeline-sidebar-footer-cont mbsc-timeline-sidebar-col" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
  }
}
function MbscTimeline_ng_container_77_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "div");
    ɵɵelementStart(2, "div", null, 38);
    ɵɵtemplate(4, MbscTimeline_ng_container_77_div_4_Template, 1, 4, "div", 48);
    ɵɵelementStart(5, "div");
    ɵɵelement(6, "div", 51);
    ɵɵelementStart(7, "div", 52);
    ɵɵtemplate(8, MbscTimeline_ng_container_77_div_8_Template, 2, 2, "div", 53)(9, MbscTimeline_ng_container_77_div_9_Template, 2, 2, "div", 53);
    ɵɵelementEnd();
    ɵɵelement(10, "div", 51);
    ɵɵelementEnd();
    ɵɵtemplate(11, MbscTimeline_ng_container_77_div_11_Template, 1, 2, "div", 46);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassMap("mbsc-flex-none");
    ɵɵstyleProp("height", ctx_r5._hasSticky ? void 0 : ctx_r5.state.footerHeight, "px");
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-footer mbsc-flex" + ctx_r5._theme + ctx_r5._rtl + ctx_r5._hb);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r5._hasRows);
    ɵɵadvance();
    ɵɵclassMap("mbsc-timeline-footer-bg mbsc-flex-1-0 mbsc-flex" + ctx_r5._theme);
    ɵɵstyleProp("width", ctx_r5.state.hasScrollX ? ctx_r5._gridWidth : void 0, "px");
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r5._phXStart, "px");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r5._isDailyResolution);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r5._isDailyResolution);
    ɵɵadvance();
    ɵɵstyleProp("width", ctx_r5._phXEnd, "px");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r5._hasRows && !!ctx_r5.sidebarTemplate);
  }
}
function MbscTimeline_div_78_ng_template_2_Template(rf, ctx2) {
}
function MbscTimeline_div_78_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", null, 39);
    ɵɵtemplate(2, MbscTimeline_div_78_ng_template_2_Template, 0, 0, "ng-template", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    const tplResource_r81 = ɵɵreference(1);
    ɵɵclassMap("mbsc-timeline-resource-dragged mbsc-flex mbsc-flex-1-1" + ctx_r5._theme);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", tplResource_r81)("ngTemplateOutletContext", ɵɵpureFunction3(4, _c73, ctx_r5.state.dragData.draggedResource, ctx_r5.state.dragData.draggedResource.id, ctx_r5._getOriginDate(ctx_r5.state.dragData)));
  }
}
function MbscTimeline_div_79_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 119);
  }
}
function MbscEventListItem_ng_template_0_div_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-event-color" + ctx_r0._theme + ctx_r0._rtl);
    ɵɵproperty("ngStyle", ctx_r0.eventData.style);
  }
}
function MbscEventListItem_ng_template_0_ng_template_2_Template(rf, ctx2) {
}
function MbscEventListItem_ng_template_0_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-event-all-day" + ctx_r0._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.eventData.allDayText);
  }
}
function MbscEventListItem_ng_template_0_div_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-event-until" + ctx_r0._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.eventData.lastDay);
  }
}
function MbscEventListItem_ng_template_0_div_6_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-event-start" + ctx_r0._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.eventData.start);
  }
}
function MbscEventListItem_ng_template_0_div_7_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1, "-");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-event-sep" + ctx_r0._theme);
  }
}
function MbscEventListItem_ng_template_0_div_8_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-event-end" + ctx_r0._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.eventData.end);
  }
}
function MbscEventListItem_ng_template_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtemplate(0, MbscEventListItem_ng_template_0_div_0_Template, 1, 3, "div", 3);
    ɵɵelementStart(1, "div");
    ɵɵtemplate(2, MbscEventListItem_ng_template_0_ng_template_2_Template, 0, 0, "ng-template", 2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div");
    ɵɵtemplate(4, MbscEventListItem_ng_template_0_div_4_Template, 2, 3, "div", 4)(5, MbscEventListItem_ng_template_0_div_5_Template, 2, 3, "div", 4)(6, MbscEventListItem_ng_template_0_div_6_Template, 2, 3, "div", 4)(7, MbscEventListItem_ng_template_0_div_7_Template, 2, 2, "div", 4)(8, MbscEventListItem_ng_template_0_div_8_Template, 2, 3, "div", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    const defaultEventContent_r2 = ɵɵreference(3);
    ɵɵproperty("ngIf", ctx_r0.showColor);
    ɵɵadvance();
    ɵɵclassMap("mbsc-event-content mbsc-flex-1-1 " + ctx_r0._theme);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.eventContentTemplate || defaultEventContent_r2)("ngTemplateOutletContext", ɵɵpureFunction1(12, _c14, ctx_r0.eventData));
    ɵɵadvance();
    ɵɵclassMap("mbsc-event-time" + (ctx_r0.hasDate ? " mbsc-event-date" : "") + ctx_r0._theme + ctx_r0._rtl);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.eventData.allDayText);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.eventData.lastDay);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.eventData.start);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.eventData.start && ctx_r0.eventData.end);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.eventData.end);
  }
}
function MbscEventListItem_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-event-text" + ctx_r0._theme);
    ɵɵproperty("innerHTML", ctx_r0.eventData.html, ɵɵsanitizeHtml);
    ɵɵattribute("title", ctx_r0.eventData.tooltip);
  }
}
function MbscEventListItem_ng_template_4_Template(rf, ctx2) {
}
var _c74 = ["list"];
var _c75 = ["calendar"];
function MbscEventcalendar_div_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 16);
  }
}
function MbscEventcalendar_div_2_div_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 17);
  }
}
function MbscEventcalendar_div_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscEventcalendar_div_2_div_1_Template, 1, 0, "div", 14);
    ɵɵelementStart(2, "div");
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, MbscEventcalendar_div_2_div_4_Template, 1, 0, "div", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-schedule-date-header mbsc-flex" + ctx_r1._theme + ctx_r1._hb);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._showSchedule && !ctx_r1._showCalendar && ctx_r1.s.resources);
    ɵɵadvance();
    ɵɵclassMap("mbsc-schedule-date-header-text mbsc-flex-1-1" + ctx_r1._theme);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1._selectedDateHeader);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._showSchedule && !ctx_r1._showCalendar && ctx_r1.s.resources);
  }
}
function MbscEventcalendar_div_3_ng_template_2_div_1_ng_template_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵtextInterpolate1(" ", ctx_r1.s.noEventsText, " ");
  }
}
function MbscEventcalendar_div_3_ng_template_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, MbscEventcalendar_div_3_ng_template_2_div_1_ng_template_1_Template, 1, 1, "ng-template", null, 3, ɵɵtemplateRefExtractor);
    ɵɵelementContainer(3, 22);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const noEventsText_r4 = ɵɵreference(2);
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵclassMap(!ctx_r1.agendaEmptyTemplate ? "mbsc-event-list-empty" + ctx_r1._theme : "");
    ɵɵadvance(3);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.agendaEmptyTemplate || noEventsText_r4);
  }
}
function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_list_header_1_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const day_r5 = ɵɵnextContext(2).$implicit;
    ɵɵtextInterpolate(day_r5.date);
  }
}
function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_list_header_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-list-header", 27);
    ɵɵelementContainer(1, 19);
    ɵɵtemplate(2, MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_list_header_1_ng_template_2_Template, 1, 1, "ng-template", null, 4, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const default_r6 = ɵɵreference(3);
    const day_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.dayTemplate || default_r6)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ɵɵpureFunction2(4, _c61, day_r5.dateObj, day_r5.events)));
  }
}
function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_event_list_item_2_Template(rf, ctx2) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-event-list-item", 28);
    ɵɵlistener("onHoverIn", function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_event_list_item_2_Template_mbsc_event_list_item_onHoverIn_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1._onEventHoverIn($event));
    })("onHoverOut", function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_event_list_item_2_Template_mbsc_event_list_item_onHoverOut_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1._onEventHoverOut($event));
    })("onClick", function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_event_list_item_2_Template_mbsc_event_list_item_onClick_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1._onEventClick($event));
    })("onDoubleClick", function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_event_list_item_2_Template_mbsc_event_list_item_onDoubleClick_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1._onEventDoubleClick($event));
    })("onRightClick", function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_event_list_item_2_Template_mbsc_event_list_item_onRightClick_0_listener($event) {
      ɵɵrestoreView(_r7);
      const ctx_r1 = ɵɵnextContext(5);
      return ɵɵresetView(ctx_r1._onEventRightClick($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r8 = ctx2.$implicit;
    const day_r5 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵproperty("actionable", ctx_r1.s.actionableEvents)("cssClass", event_r8.original.cssClass)("date", day_r5.timestamp)("event", event_r8.original)("eventContentTemplate", ctx_r1.eventContentTemplate)("eventData", event_r8)("rtl", ctx_r1.s.rtl)("selected", !!(ctx_r1._selectedEventsMap[event_r8.uid] || ctx_r1._selectedEventsMap[event_r8.id]))("showColor", !ctx_r1._colorEventList)("template", ctx_r1.eventTemplate)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
  }
}
function MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 24);
    ɵɵtemplate(1, MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_list_header_1_Template, 4, 9, "mbsc-list-header", 25)(2, MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_mbsc_event_list_item_2_Template, 1, 12, "mbsc-event-list-item", 26);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const day_r5 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵclassMap("mbsc-event-group" + (day_r5.events.length || ctx_r1._showEmptyDays ? "" : " mbsc-event-group-empty") + ctx_r1._theme);
    ɵɵproperty("timestamp", day_r5.timestamp);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._showEmptyDays || day_r5.events.length);
    ɵɵadvance();
    ɵɵproperty("ngForOf", day_r5.events)("ngForTrackBy", ctx_r1._getEventKey);
  }
}
function MbscEventcalendar_div_3_ng_template_2_ng_container_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MbscEventcalendar_div_3_ng_template_2_ng_container_2_div_1_Template, 3, 6, "div", 23);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const data_r9 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", data_r9)("ngForTrackBy", ctx_r1._getDayKey);
  }
}
function MbscEventcalendar_div_3_ng_template_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "mbsc-list", 20);
    ɵɵtemplate(1, MbscEventcalendar_div_3_ng_template_2_div_1_Template, 4, 3, "div", 6)(2, MbscEventcalendar_div_3_ng_template_2_ng_container_2_Template, 2, 2, "ng-container", 21);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("rtl", ctx_r1.s.rtl)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1._eventListNr && !ctx_r1._showEmptyDays);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._eventListNr || ctx_r1._showEmptyDays);
  }
}
function MbscEventcalendar_div_3_Template(rf, ctx2) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 18, 1);
    ɵɵlistener("scroll", function MbscEventcalendar_div_3_Template_div_scroll_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onScroll());
    });
    ɵɵtemplate(2, MbscEventcalendar_div_3_ng_template_2_Template, 3, 5, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementContainer(4, 19);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const def_r10 = ɵɵreference(3);
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-flex-1-1 mbsc-event-list" + (ctx_r1.state.isListScrollable ? " mbsc-event-list-scroll" : ""));
    ɵɵadvance(4);
    ɵɵproperty("ngTemplateOutlet", ctx_r1.agendaTemplate || def_r10)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx_r1.state.eventList));
  }
}
function MbscEventcalendar_mbsc_scheduler_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-scheduler", 29);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("allDayText", ctx_r1.s.allDayText)("amText", ctx_r1.s.amText)("bufferAfterTemplate", ctx_r1.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r1.bufferBeforeTemplate)("checkSize", ctx_r1._checkSize)("clickToCreate", ctx_r1.s.clickToCreate)("colorsMap", ctx_r1._colorsMap)("context", ctx_r1.s.context)("currentTimeIndicator", ctx_r1._currentTimeIndicator)("dataTimezone", ctx_r1.s.dataTimezone)("dateFormat", ctx_r1.s.dateFormat)("dateFormatFull", ctx_r1.s.dateFormatFull)("dateFormatLong", ctx_r1.s.dateFormatLong)("dayNames", ctx_r1.s.dayNames)("dayNamesMin", ctx_r1.s.dayNamesMin)("dayNamesShort", ctx_r1.s.dayNamesShort)("dayTemplate", ctx_r1.dayTemplate)("dayContentTemplate", ctx_r1.dayContentTemplate)("displayTimezone", ctx_r1.s.displayTimezone)("dragBetweenResources", ctx_r1.s.dragBetweenResources)("dragInTime", ctx_r1.s.dragInTime)("dragTimeStep", ctx_r1._dragTimeStep)("dragToCreate", ctx_r1.s.dragToCreate)("dragToMove", ctx_r1.s.dragToMove)("dragToResize", ctx_r1.s.dragToResize)("endDay", ctx_r1._scheduleEndDay)("endTime", ctx_r1._scheduleEndTime)("eventContentTemplate", ctx_r1.scheduleEventContentTemplate)("eventDragEnd", ctx_r1._onEventDragStop)("eventMap", ctx_r1._eventMap)("eventOrder", ctx_r1.s.eventOrder)("eventOverlap", ctx_r1.s.eventOverlap)("eventTemplate", ctx_r1.scheduleEventTemplate)("exclusiveEndDates", ctx_r1.s.exclusiveEndDates)("extendDefaultEvent", ctx_r1.s.extendDefaultEvent)("externalDrag", ctx_r1.s.externalDrag)("externalDrop", ctx_r1.s.externalDrop)("firstDay", ctx_r1.s.firstDay)("fromText", ctx_r1.s.fromText)("getDay", ctx_r1.s.getDay)("getDate", ctx_r1.s.getDate)("getMaxDayOfMonth", ctx_r1.s.getMaxDayOfMonth)("getMonth", ctx_r1.s.getMonth)("getYear", ctx_r1.s.getYear)("getWeekNumber", ctx_r1.s.getWeekNumber)("groupBy", ctx_r1.s.groupBy)("height", ctx_r1.state.height)("immutableData", ctx_r1.s.immutableData)("invalidateEvent", ctx_r1.s.invalidateEvent)("invalidsMap", ctx_r1._invalidsMap)("maxDate", ctx_r1.s.max)("maxEventStack", ctx_r1._scheduleMaxEventStack)("minEventWidth", ctx_r1._scheduleMinEventWidth)("moreEventsPluralText", ctx_r1.s.moreEventsPluralText)("moreEventsText", ctx_r1.s.moreEventsText)("navigateToEvent", ctx_r1._navigateToEvent)("minDate", ctx_r1.s.min)("monthNames", ctx_r1.s.monthNames)("monthNamesShort", ctx_r1.s.monthNamesShort)("navService", ctx_r1._navService)("newEventText", ctx_r1.s.newEventText)("pmText", ctx_r1.s.pmText)("refDate", ctx_r1._refDate)("resources", ctx_r1.s.resources)("resourceTemplate", ctx_r1.resourceTemplate)("rtl", ctx_r1.s.rtl)("scroll", ctx_r1._shouldScrollSchedule)("selected", ctx_r1._selectedDateTime)("selectedEventsMap", ctx_r1._selectedEventsMap)("showAllDay", ctx_r1._showScheduleAllDay)("showDays", ctx_r1._showScheduleDays)("showEventBuffer", ctx_r1.s.showEventBuffer)("showEventTooltip", ctx_r1.s.showEventTooltip)("size", ctx_r1._scheduleSize)("startDay", ctx_r1._scheduleStartDay)("startTime", ctx_r1._scheduleStartTime)("timeCellStep", ctx_r1._scheduleTimeCellStep)("timeFormat", ctx_r1.s.timeFormat)("timeLabelStep", ctx_r1._scheduleTimeLabelStep)("timezonePlugin", ctx_r1.s.timezonePlugin)("timezones", ctx_r1._scheduleTimezones)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant)("toText", ctx_r1.s.toText)("type", ctx_r1._scheduleType)("width", ctx_r1.state.width)("onCellClick", ctx_r1._onCellClick)("onCellDoubleClick", ctx_r1._onCellDoubleClick)("onCellRightClick", ctx_r1._onCellRightClick)("onEventClick", ctx_r1._onEventClick)("onEventDoubleClick", ctx_r1._onEventDoubleClick)("onEventRightClick", ctx_r1._onEventRightClick)("onEventHoverIn", ctx_r1._onEventHoverIn)("onEventHoverOut", ctx_r1._onEventHoverOut)("onEventDelete", ctx_r1._onEventDelete)("onEventDragEnd", ctx_r1._onEventDragEnd)("onEventDragStart", ctx_r1._onEventDragStart)("onEventDragEnter", ctx_r1._onEventDragEnter)("onEventDragLeave", ctx_r1._onEventDragLeave)("onMoreClick", ctx_r1._onMoreClick)("onPopoverClose", ctx_r1._onPopoverClose)("onResourceClick", ctx_r1._proxy)("onResourceDoubleClick", ctx_r1._proxy)("onResourceRightClick", ctx_r1._proxy)("onWeekDayClick", ctx_r1._onWeekDayClick);
  }
}
function MbscEventcalendar_mbsc_timeline_5_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "mbsc-timeline", 30);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("allDayText", ctx_r1.s.allDayText)("amText", ctx_r1.s.amText)("bufferAfterTemplate", ctx_r1.bufferAfterTemplate)("bufferBeforeTemplate", ctx_r1.bufferBeforeTemplate)("checkSize", ctx_r1._checkSize)("clickToCreate", ctx_r1.s.clickToCreate)("colorsMap", ctx_r1._colorsMap)("connections", ctx_r1.s.connections)("context", ctx_r1.s.context)("currentTimeIndicator", ctx_r1._currentTimeIndicator)("columnWidth", ctx_r1._timelineColWidth)("dataTimezone", ctx_r1.s.dataTimezone)("dateFormat", ctx_r1.s.dateFormat)("dateFormatFull", ctx_r1.s.dateFormatFull)("dateFormatLong", ctx_r1.s.dateFormatLong)("dayNames", ctx_r1.s.dayNames)("dayNamesMin", ctx_r1.s.dayNamesMin)("dayNamesShort", ctx_r1.s.dayNamesShort)("dayFooterTemplate", ctx_r1.dayFooterTemplate)("dayTemplate", ctx_r1.dayTemplate)("weekTemplate", ctx_r1.weekTemplate)("weekFooterTemplate", ctx_r1.weekFooterTemplate)("yearTemplate", ctx_r1.yearTemplate)("yearFooterTemplate", ctx_r1.yearFooterTemplate)("hourTemplate", ctx_r1.hourTemplate)("hourFooterTemplate", ctx_r1.hourFooterTemplate)("monthTemplate", ctx_r1.monthTemplate)("monthFooterTemplate", ctx_r1.monthFooterTemplate)("displayTimezone", ctx_r1.s.displayTimezone)("dragBetweenResources", ctx_r1.s.dragBetweenResources)("dragBetweenSlots", ctx_r1.s.dragBetweenSlots)("dragIcon", ctx_r1.s.dragIcon)("dragInTime", ctx_r1.s.dragInTime)("dragTimeStep", ctx_r1._dragTimeStep)("dragToCreate", ctx_r1.slots ? false : ctx_r1.s.dragToCreate)("dragToMove", ctx_r1.s.dragToMove)("dragToResize", ctx_r1.slots ? false : ctx_r1.s.dragToResize)("downIcon", ctx_r1.s.chevronIconDown)("endDay", ctx_r1._timelineEndDay)("endTime", ctx_r1._timelineEndTime)("eventHeight", ctx_r1._timelineEventHeight)("eventList", ctx_r1._timelineListing)("eventDragEnd", ctx_r1._onEventDragStop)("eventContentTemplate", ctx_r1.scheduleEventContentTemplate)("eventMap", ctx_r1._eventMap)("eventOrder", ctx_r1.s.eventOrder)("eventOverlap", ctx_r1.s.eventOverlap)("eventTemplate", ctx_r1.scheduleEventTemplate)("exclusiveEndDates", ctx_r1.s.exclusiveEndDates)("extendDefaultEvent", ctx_r1.s.extendDefaultEvent)("externalDrag", ctx_r1.s.externalDrag)("externalDrop", ctx_r1.s.externalDrop)("externalResourceDrag", ctx_r1.s.externalResourceDrag)("externalResourceDrop", ctx_r1.s.externalResourceDrop)("firstDay", ctx_r1.s.firstDay)("fromText", ctx_r1.s.fromText)("getDay", ctx_r1.s.getDay)("getDate", ctx_r1.s.getDate)("getMaxDayOfMonth", ctx_r1.s.getMaxDayOfMonth)("getMonth", ctx_r1.s.getMonth)("getWeekNumber", ctx_r1.s.getWeekNumber)("getYear", ctx_r1.s.getYear)("groupBy", ctx_r1.s.groupBy)("height", ctx_r1.state.height)("immutableData", ctx_r1.s.immutableData)("invalidateEvent", ctx_r1.s.invalidateEvent)("invalidsMap", ctx_r1._invalidsMap)("maxDate", ctx_r1.s.max)("maxEventStack", ctx_r1._timelineMaxEventStack)("minDate", ctx_r1.s.min)("moreEventsPluralText", ctx_r1.s.moreEventsPluralText)("moreEventsText", ctx_r1.s.moreEventsText)("navigateToEvent", ctx_r1._navigateToEvent)("monthNames", ctx_r1.s.monthNames)("monthNamesShort", ctx_r1.s.monthNamesShort)("navService", ctx_r1._navService)("newEventText", ctx_r1.s.newEventText)("nextIcon", ctx_r1.s.nextIconH)("nextIconRtl", ctx_r1.s.prevIconH)("pmText", ctx_r1.s.pmText)("refDate", ctx_r1._refDate)("resolution", ctx_r1._timelineResolution)("resolutionVertical", ctx_r1._timelineResolutionVertical)("resources", ctx_r1.s.resources)("resourceFooterTemplate", ctx_r1.resourceFooterTemplate)("resourceHeaderTemplate", ctx_r1.resourceHeaderTemplate)("resourceReorder", ctx_r1._timelineResourceOrder)("resourceTemplate", ctx_r1.resourceTemplate)("resourceEmptyTemplate", ctx_r1.resourceEmptyTemplate)("rtl", ctx_r1.s.rtl)("rowHeight", ctx_r1._timelineRowHeight)("scroll", ctx_r1._shouldScrollSchedule)("showEventBuffer", ctx_r1.s.showEventBuffer)("showEventTooltip", ctx_r1.s.showEventTooltip)("slots", ctx_r1.s.slots)("slotTemplate", ctx_r1.slotTemplate)("selected", ctx_r1._selectedDateTime)("selectedEventsMap", ctx_r1._selectedEventsMap)("sidebarFooterTemplate", ctx_r1.sidebarFooterTemplate)("sidebarHeaderTemplate", ctx_r1.sidebarHeaderTemplate)("sidebarTemplate", ctx_r1.sidebarTemplate)("size", ctx_r1._timelineSize)("startDay", ctx_r1._timelineStartDay)("startTime", ctx_r1._timelineStartTime)("quarterFooterTemplate", ctx_r1.quarterFooterTemplate)("quarterTemplate", ctx_r1.quarterTemplate)("quarterText", ctx_r1.s.quarterText)("timeCellStep", ctx_r1._timelineTimeCellStep)("timeFormat", ctx_r1.s.timeFormat)("timeLabelStep", ctx_r1._timelineTimeLabelStep)("timezonePlugin", ctx_r1.s.timezonePlugin)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant)("toText", ctx_r1.s.toText)("type", ctx_r1._timelineType)("virtualScroll", !ctx_r1._print && ctx_r1._timelineVirtualScroll)("weekNumbers", ctx_r1._showTimelineWeekNumbers)("weekText", ctx_r1.s.weekText)("width", ctx_r1.state.width)("onActiveChange", ctx_r1._onActiveChange)("onCellClick", ctx_r1._onCellClick)("onCellDoubleClick", ctx_r1._onCellDoubleClick)("onCellRightClick", ctx_r1._onCellRightClick)("onEventClick", ctx_r1._onEventClick)("onEventDoubleClick", ctx_r1._onEventDoubleClick)("onEventRightClick", ctx_r1._onEventRightClick)("onEventHoverIn", ctx_r1._onEventHoverIn)("onEventHoverOut", ctx_r1._onEventHoverOut)("onEventDelete", ctx_r1._onEventDelete)("onEventDragEnd", ctx_r1._onEventDragEnd)("onEventDragStart", ctx_r1._onEventDragStart)("onEventDragEnter", ctx_r1._onEventDragEnter)("onEventDragLeave", ctx_r1._onEventDragLeave)("onMoreClick", ctx_r1._onMoreClick)("onPopoverClose", ctx_r1._onPopoverClose)("onResourceClick", ctx_r1._proxy)("onResourceCollapse", ctx_r1._proxy)("onResourceCreate", ctx_r1._proxy)("onResourceCreated", ctx_r1._proxy)("onResourceDelete", ctx_r1._proxy)("onResourceDeleted", ctx_r1._proxy)("onResourceDoubleClick", ctx_r1._proxy)("onResourceExpand", ctx_r1._proxy)("onResourceDragEnd", ctx_r1._proxy)("onResourceDragEnter", ctx_r1._proxy)("onResourceDragLeave", ctx_r1._proxy)("onResourceDragStart", ctx_r1._proxy)("onResourceOrderUpdate", ctx_r1._proxy)("onResourceRightClick", ctx_r1._proxy)("onVirtualLoading", ctx_r1._proxy)("zoomLevel", ctx_r1.s.zoomLevel);
  }
}
function MbscEventcalendar_mbsc_event_list_item_8_Template(rf, ctx2) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mbsc-event-list-item", 31);
    ɵɵlistener("onHoverIn", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onHoverIn_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onEventHoverIn($event));
    })("onHoverOut", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onHoverOut_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onEventHoverOut($event));
    })("onClick", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onClick_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onEventClick($event));
    })("onDoubleClick", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onDoubleClick_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onEventDoubleClick($event));
    })("onRightClick", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onRightClick_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._onEventRightClick($event));
    })("onDragEnd", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onDragEnd_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.state.popoverHost ? ctx_r1.state.popoverHost._onEventDragEnd($event) : ctx_r1._onLabelUpdateEnd($event));
    })("onDragModeOff", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onDragModeOff_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.state.popoverHost ? ctx_r1.state.popoverHost._onEventDragModeOff($event) : ctx_r1._onLabelUpdateModeOff($event));
    })("onDragModeOn", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onDragModeOn_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.state.popoverHost ? ctx_r1.state.popoverHost._onEventDragModeOn($event) : ctx_r1._onLabelUpdateModeOn($event));
    })("onDragMove", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onDragMove_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.state.popoverHost ? ctx_r1.state.popoverHost._onEventDragMove($event) : ctx_r1._onLabelUpdateMove($event));
    })("onDragStart", function MbscEventcalendar_mbsc_event_list_item_8_Template_mbsc_event_list_item_onDragStart_0_listener($event) {
      ɵɵrestoreView(_r11);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.state.popoverHost ? ctx_r1.state.popoverHost._onEventDragStart($event) : ctx_r1._onLabelUpdateStart($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const event_r12 = ctx2.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("actionable", ctx_r1.s.actionableEvents)("cssClass", event_r12.original.cssClass)("date", ctx_r1.state.popoverDate)("event", event_r12.original)("eventContentTemplate", ctx_r1.eventContentTemplate)("eventData", event_r12)("hasDate", !!ctx_r1.state.popoverHost)("rtl", ctx_r1.s.rtl)("selected", !!(ctx_r1._selectedEventsMap[event_r12.uid] || ctx_r1._selectedEventsMap[event_r12.id]))("showColor", !ctx_r1._colorEventList)("template", ctx_r1.eventTemplate)("theme", ctx_r1.s.theme)("themeVariant", ctx_r1.s.themeVariant)("drag", (ctx_r1._showEventLabels || ctx_r1.state.popoverHost) && (ctx_r1.s.dragToMove || ctx_r1.s.externalDrag));
  }
}
function MbscEventcalendar_div_9_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelement(0, "div", 32);
  }
}
function MbscCheckbox_span_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-form-control-label" + ctx_r1._theme + (ctx_r1._disabled ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.label);
  }
}
function MbscCheckbox_span_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-description" + ctx_r1._theme + (ctx_r1._disabled ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.description);
  }
}
function MbscRadio_span_3_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-form-control-label" + ctx_r1._theme + (ctx_r1._disabled ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.label);
  }
}
function MbscRadio_span_4_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-description" + ctx_r1._theme + (ctx_r1._disabled ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.description);
  }
}
function MbscStepper_span_1_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-stepper-label" + ctx_r1._theme + (ctx_r1._disabled ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.label);
  }
}
function MbscStepper_span_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap("mbsc-description" + ctx_r1._theme + (ctx_r1._disabled ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.s.description);
  }
}
var _c76 = ["handle"];
var _c77 = ["handleCont"];
function MbscSwitch_label_0_span_2_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵclassMap("mbsc-description" + ctx_r0._theme + (ctx_r0._disabled ? " mbsc-disabled" : ""));
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.s.description);
  }
}
function MbscSwitch_label_0_Template(rf, ctx2) {
  if (rf & 1) {
    ɵɵelementStart(0, "label", 5);
    ɵɵtext(1);
    ɵɵtemplate(2, MbscSwitch_label_0_span_2_Template, 2, 3, "span", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassMap("mbsc-form-control-label" + ctx_r0._theme + (ctx_r0._disabled ? " mbsc-disabled" : ""));
    ɵɵproperty("for", ctx_r0.id || ctx_r0._id);
    ɵɵadvance();
    ɵɵtextInterpolate1("", ctx_r0.s.label, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.s.description);
  }
}
var remote = {
  apiKey: "807cd035",
  apiUrl: "https://trial.mobiscroll.com/"
};
var arrowBack = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M217.9 256L345 129c9.4-9.4 9.4-24.6 0-33.9-9.4-9.4-24.6-9.3-34 0L167 239c-9.1 9.1-9.3 23.7-.7 33.1L310.9 417c4.7 4.7 10.9 7 17 7s12.3-2.3 17-7c9.4-9.4 9.4-24.6 0-33.9L217.9 256z"/></svg>';
var arrowDown$1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 294.1L383 167c9.4-9.4 24.6-9.4 33.9 0s9.3 24.6 0 34L273 345c-9.1 9.1-23.7 9.3-33.1.7L95 201.1c-4.7-4.7-7-10.9-7-17s2.3-12.3 7-17c9.4-9.4 24.6-9.4 33.9 0l127.1 127z"/></svg>';
var arrowForward = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M294.1 256L167 129c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.3 34 0L345 239c9.1 9.1 9.3 23.7.7 33.1L201.1 417c-4.7 4.7-10.9 7-17 7s-12.3-2.3-17-7c-9.4-9.4-9.4-24.6 0-33.9l127-127.1z"/></svg>';
var arrowUp$1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 217.9L383 345c9.4 9.4 24.6 9.4 33.9 0 9.4-9.4 9.3-24.6 0-34L273 167c-9.1-9.1-23.7-9.3-33.1-.7L95 310.9c-4.7 4.7-7 10.9-7 17s2.3 12.3 7 17c9.4 9.4 24.6 9.4 33.9 0l127.1-127z"/></svg>';
var clear$1 = '<svg xmlns="http://www.w3.org/2000/svg" height="17" viewBox="0 0 17 17" width="17"><path d="M8.5 0a8.5 8.5 0 110 17 8.5 8.5 0 010-17zm3.364 5.005a.7.7 0 00-.99 0l-2.44 2.44-2.439-2.44-.087-.074a.7.7 0 00-.903 1.064l2.44 2.439-2.44 2.44-.074.087a.7.7 0 001.064.903l2.439-2.441 2.44 2.441.087.074a.7.7 0 00.903-1.064l-2.441-2.44 2.441-2.439.074-.087a.7.7 0 00-.074-.903z" fill="currentColor" fill-rule="evenodd"/></svg>';
var dragHandle = '<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px"><path d="M360-160q-33 0-56.5-23.5T280-240q0-33 23.5-56.5T360-320q33 0 56.5 23.5T440-240q0 33-23.5 56.5T360-160Zm240 0q-33 0-56.5-23.5T520-240q0-33 23.5-56.5T600-320q33 0 56.5 23.5T680-240q0 33-23.5 56.5T600-160ZM360-400q-33 0-56.5-23.5T280-480q0-33 23.5-56.5T360-560q33 0 56.5 23.5T440-480q0 33-23.5 56.5T360-400Zm240 0q-33 0-56.5-23.5T520-480q0-33 23.5-56.5T600-560q33 0 56.5 23.5T680-480q0 33-23.5 56.5T600-400ZM360-640q-33 0-56.5-23.5T280-720q0-33 23.5-56.5T360-800q33 0 56.5 23.5T440-720q0 33-23.5 56.5T360-640Zm240 0q-33 0-56.5-23.5T520-720q0-33 23.5-56.5T600-800q33 0 56.5 23.5T680-720q0 33-23.5 56.5T600-640Z"/></svg>';
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar2; i < l; i++) {
    if (ar2 || !(i in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i);
      ar2[i] = from[i];
    }
  }
  return to.concat(ar2 || Array.prototype.slice.call(from));
}
var Observable = function() {
  function Observable2() {
    this.nr = 0;
    this._keys = 1;
    this._subscribers = {};
  }
  Observable2.prototype.subscribe = function(handler) {
    var key = this._keys++;
    this._subscribers[key] = handler;
    this.nr++;
    return key;
  };
  Observable2.prototype.unsubscribe = function(key) {
    this.nr--;
    delete this._subscribers[key];
  };
  Observable2.prototype.next = function(value) {
    var subscribers = this._subscribers;
    for (var _i = 0, _a = Object.keys(subscribers); _i < _a.length; _i++) {
      var key = _a[_i];
      if (subscribers[key]) {
        subscribers[key](value);
      }
    }
  };
  return Observable2;
}();
var os;
var version$1 = [];
var touchUi = false;
var isBrowser = typeof window !== "undefined";
var isDarkQuery = isBrowser && window.matchMedia && window.matchMedia("(prefers-color-scheme:dark)");
var userAgent = isBrowser ? navigator.userAgent : "";
var platform$1 = isBrowser ? navigator.platform : "";
var maxTouchPoints = isBrowser ? navigator.maxTouchPoints : 0;
var isSafari = userAgent && /Safari/.test(userAgent);
if (/Android/i.test(userAgent)) {
  os = "android";
  touchUi = true;
  vers = userAgent.match(/Android\s+([\d.]+)/i);
  if (vers) {
    version$1 = vers[0].replace("Android ", "").split(".");
  }
} else if (/iPhone|iPad|iPod/i.test(userAgent) || /iPhone|iPad|iPod/i.test(platform$1) || platform$1 === "MacIntel" && maxTouchPoints > 1) {
  os = "ios";
  touchUi = true;
  vers = userAgent.match(/OS\s+([\d_]+)/i);
  if (vers) {
    version$1 = vers[0].replace(/_/g, ".").replace("OS ", "").split(".");
  }
} else if (/Windows Phone/i.test(userAgent)) {
  os = "wp";
  touchUi = true;
} else if (/Windows|MSIE/i.test(userAgent)) {
  os = "windows";
}
var vers;
var majorVersion = +version$1[0];
var minorVersion = +version$1[1];
var options = {};
var util = {};
var themes = {};
var autoDetect = {};
var globalChanges = new Observable();
function getAutoTheme() {
  var autoTheme = "";
  var theme = "";
  var firstTheme = "";
  if (os === "android") {
    theme = "material";
  } else if (os === "wp" || os === "windows") {
    theme = "windows";
  } else {
    theme = "ios";
  }
  for (var key in themes) {
    if (themes[key].baseTheme === theme && themes[key].auto !== false && key !== theme + "-dark") {
      autoTheme = key;
      break;
    } else if (key === theme) {
      autoTheme = key;
    } else if (!firstTheme) {
      firstTheme = key;
    }
  }
  return autoTheme || firstTheme;
}
function setOptions(local) {
  for (var _i = 0, _a = Object.keys(local); _i < _a.length; _i++) {
    var k = _a[_i];
    options[k] = local[k];
  }
  if (isBrowser) {
    globalChanges.next(options);
  }
}
function createCustomTheme(name, baseTheme, auto) {
  var base = themes[baseTheme];
  themes[name] = __assign(__assign({}, base), {
    auto,
    baseTheme
  });
  autoDetect.theme = getAutoTheme();
}
var platform = {
  majorVersion,
  minorVersion,
  name: os
};
var textFieldOpt$2 = {
  clearIcon: clear$1,
  labelStyle: "inline"
};
var themeName$2 = "ios";
themes[themeName$2] = {
  Calendar: {
    nextIconH: arrowForward,
    nextIconV: arrowDown$1,
    prevIconH: arrowBack,
    prevIconV: arrowUp$1
  },
  Checkbox: {
    position: "end"
  },
  Datepicker: {
    clearIcon: clear$1,
    display: "bottom"
  },
  Dropdown: textFieldOpt$2,
  Eventcalendar: {
    chevronIconDown: arrowDown$1,
    dragIcon: dragHandle,
    nextIconH: arrowForward,
    nextIconV: arrowDown$1,
    prevIconH: arrowBack,
    prevIconV: arrowUp$1
  },
  Input: textFieldOpt$2,
  Radio: {
    position: "end"
  },
  Scroller: {
    itemHeight: 34,
    minWheelWidth: 55,
    rows: 5,
    scroll3d: true
  },
  SegmentedGroup: {
    drag: true
  },
  Select: {
    clearIcon: clear$1,
    display: "bottom"
  },
  Textarea: textFieldOpt$2
};
createCustomTheme("ios-dark", themeName$2);
var arrowDropDown = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>';
var arrowDropUp = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M7 14l5-5 5 5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>';
var chevronLeft = '<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 36 36"><path d="M23.12 11.12L21 9l-9 9 9 9 2.12-2.12L16.24 18z"/></svg>';
var chevronRight = '<svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 36 36"><path d="M15 9l-2.12 2.12L19.76 18l-6.88 6.88L15 27l9-9z"/></svg>';
var clear = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"/></svg>';
var keyboardArrowDown = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/><path fill="none" d="M0 0h24v24H0V0z"/></svg>';
var keyboardArrowUp = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/><path d="M0 0h24v24H0z" fill="none"/></svg>';
var textFieldOpt$1 = {
  clearIcon: clear,
  dropdownIcon: arrowDropDown,
  inputStyle: "box",
  labelStyle: "floating",
  notch: true,
  ripple: true
};
var themeName$1 = "material";
themes[themeName$1] = {
  Button: {
    ripple: true
  },
  Calendar: {
    downIcon: arrowDropDown,
    nextIconH: chevronRight,
    nextIconV: keyboardArrowDown,
    prevIconH: chevronLeft,
    prevIconV: keyboardArrowUp,
    upIcon: arrowDropUp
  },
  Datepicker: {
    clearIcon: clear,
    display: "center"
  },
  Dropdown: textFieldOpt$1,
  Eventcalendar: {
    chevronIconDown: keyboardArrowDown,
    colorEventList: true,
    downIcon: arrowDropDown,
    dragIcon: dragHandle,
    nextIconH: chevronRight,
    nextIconV: keyboardArrowDown,
    prevIconH: chevronLeft,
    prevIconV: keyboardArrowUp,
    upIcon: arrowDropUp
  },
  Input: textFieldOpt$1,
  ListItem: {
    ripple: true
  },
  Scroller: {
    rows: 3
  },
  Select: {
    clearIcon: clear,
    display: "center",
    rows: 3
  },
  Textarea: textFieldOpt$1
};
createCustomTheme("material-dark", themeName$1);
var angleDown = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M4.22 10.78l-1.44 1.44 12.5 12.5.72.686.72-.687 12.5-12.5-1.44-1.44L16 22.564 4.22 10.78z"/></svg>';
var angleLeft = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19.03 4.28l-11 11-.686.72.687.72 11 11 1.44-1.44L10.187 16l10.28-10.28-1.437-1.44z"/></svg>';
var angleRight = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M12.97 4.28l-1.44 1.44L21.814 16 11.53 26.28l1.44 1.44 11-11 .686-.72-.687-.72-11-11z"/></svg>';
var arrowDown = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M15 4v20.063L8.22 17.28l-1.44 1.44 8.5 8.5.72.686.72-.687 8.5-8.5-1.44-1.44L17 24.063V4h-2z"/></svg>';
var arrowUp = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M16 4.094l-.72.687-8.5 8.5 1.44 1.44L15 7.936V28h2V7.937l6.78 6.782 1.44-1.44-8.5-8.5-.72-.686z"/></svg>';
var close = '<svg fill="#000000" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="32px" height="32px"><path d="M 7.21875 5.78125 L 5.78125 7.21875 L 14.5625 16 L 5.78125 24.78125 L 7.21875 26.21875 L 16 17.4375 L 24.78125 26.21875 L 26.21875 24.78125 L 17.4375 16 L 26.21875 7.21875 L 24.78125 5.78125 L 16 14.5625 Z"/></svg>';
var textFieldOpt = {
  clearIcon: close,
  inputStyle: "box",
  labelStyle: "stacked"
};
var themeName = "windows";
themes[themeName] = {
  Calendar: {
    nextIconH: angleRight,
    nextIconV: arrowDown,
    prevIconH: angleLeft,
    prevIconV: arrowUp
  },
  Checkbox: {
    position: "start"
  },
  Datepicker: {
    clearIcon: close,
    display: "center"
  },
  Dropdown: textFieldOpt,
  Eventcalendar: {
    chevronIconDown: angleDown,
    dragIcon: dragHandle,
    nextIconH: angleRight,
    nextIconV: arrowDown,
    prevIconH: angleLeft,
    prevIconV: arrowUp
  },
  Input: textFieldOpt,
  Scroller: {
    itemHeight: 44,
    minWheelWidth: 88,
    rows: 6
  },
  Select: {
    clearIcon: close,
    display: "center",
    rows: 6
  },
  Textarea: textFieldOpt
};
createCustomTheme("windows-dark", themeName);
autoDetect.theme = getAutoTheme();
var ar = {
  rtl: true,
  setText: "تعيين",
  cancelText: "إلغاء",
  clearText: "مسح",
  closeText: "إغلاق",
  selectedText: "{count} المحدد",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD. D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"],
  dayNamesShort: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
  dayNamesMin: ["ح", "ن", "ث", "ر", "خ", "ج", "س"],
  dayText: "يوم",
  hourText: "ساعات",
  minuteText: "الدقائق",
  fromText: "يبدا",
  monthNames: ["يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"],
  monthNamesShort: ["يناير", "فبراير", "مارس", "ابريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"],
  monthText: "شهر",
  secondText: "ثواني",
  amText: "ص",
  pmText: "م",
  timeFormat: "hh:mm A",
  yearText: "عام",
  timeWheels: "Ammhh",
  toText: "ينتهي",
  nowText: "الآن",
  firstDay: 0,
  dateText: "تاريخ",
  timeText: "وقت",
  todayText: "اليوم",
  allDayText: "اليوم كله",
  noEventsText: "لا توجد احداث",
  eventText: "الحدث",
  eventsText: "أحداث",
  moreEventsText: "واحد آخر",
  moreEventsPluralText: "اثنان آخران {count}",
  weekText: "أسبوع {count}",
  rangeEndHelp: "أختر",
  rangeEndLabel: "ينتهي",
  rangeStartHelp: "أختر",
  rangeStartLabel: "يبدا",
  filterEmptyText: "لا نتيجة",
  filterPlaceholderText: "بحث"
};
var bg = {
  setText: "Задаване",
  cancelText: "Отмяна",
  clearText: "Изчистване",
  closeText: "затвори",
  selectedText: "{count} подбран",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMMM YYYY",
  dateWheelFormat: "|DDD MM.DD|",
  dayNames: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"],
  dayNamesShort: ["Нед", "Пон", "Вто", "Сря", "Чет", "Пет", "Съб"],
  dayNamesMin: ["Не", "По", "Вт", "Ср", "Че", "Пе", "Съ"],
  dayText: "ден",
  hourText: "час",
  minuteText: "минута",
  fromText: "ОТ",
  monthNames: ["Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"],
  monthNamesShort: ["Яну", "Фев", "Мар", "Апр", "Май", "Юни", "Юли", "Авг", "Сеп", "Окт", "Нов", "Дек"],
  monthText: "месец",
  secondText: "секунди",
  timeFormat: "H:mm",
  toText: "ДО",
  nowText: "Сега",
  pmText: "pm",
  amText: "am",
  yearText: "година",
  firstDay: 1,
  dateText: "Дата",
  timeText: "път",
  todayText: "днес",
  eventText: "Събитие",
  eventsText: "Събития",
  allDayText: "Цял ден",
  noEventsText: "Няма събития",
  moreEventsText: "Още {count}",
  weekText: "Седмица {count}",
  rangeStartLabel: "ОТ",
  rangeEndLabel: "ДО",
  rangeStartHelp: "Избирам",
  rangeEndHelp: "Избирам",
  filterEmptyText: "Без резултат",
  filterPlaceholderText: "Търсене"
};
var ca = {
  setText: "Acceptar",
  cancelText: "Cancel·lar",
  clearText: "Esborrar",
  closeText: "Tancar",
  selectedText: "{count} seleccionat",
  selectedPluralText: "{count} seleccionats",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"],
  dayNamesShort: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
  dayNamesMin: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
  dayText: "Dia",
  hourText: "Hores",
  minuteText: "Minuts",
  fromText: "Iniciar",
  monthNames: ["Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"],
  monthNamesShort: ["Gen", "Feb", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Des"],
  monthText: "Mes",
  secondText: "Segons",
  timeFormat: "H:mm",
  yearText: "Any",
  toText: "Final",
  nowText: "Ara",
  pmText: "pm",
  amText: "am",
  todayText: "Avui",
  firstDay: 1,
  dateText: "Data",
  timeText: "Temps",
  allDayText: "Tot el dia",
  noEventsText: "Cap esdeveniment",
  eventText: "Esdeveniments",
  eventsText: "Esdeveniments",
  moreEventsText: "{count} més",
  weekText: "Setmana {count}",
  rangeStartLabel: "Iniciar",
  rangeEndLabel: "Final",
  rangeStartHelp: "Seleccionar",
  rangeEndHelp: "Seleccionar",
  filterEmptyText: "Cap resultat",
  filterPlaceholderText: "Buscar"
};
var cs = {
  setText: "Zadej",
  cancelText: "Storno",
  clearText: "Vymazat",
  closeText: "Zavřít",
  selectedText: "Označený: {count}",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D. MMMM YYYY",
  dateFormatLong: "DDD, D.M.YYYY",
  dateWheelFormat: "|DDD D. M.|",
  dayNames: ["Neděle", "Pondělí", "Úterý", "Středa", "Čtvrtek", "Pátek", "Sobota"],
  dayNamesShort: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"],
  dayNamesMin: ["N", "P", "Ú", "S", "Č", "P", "S"],
  dayText: "Den",
  hourText: "Hodiny",
  minuteText: "Minuty",
  fromText: "Začátek",
  monthNames: ["Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"],
  monthNamesShort: ["Led", "Úno", "Bře", "Dub", "Kvě", "Čer", "Čvc", "Spr", "Zář", "Říj", "Lis", "Pro"],
  monthText: "Měsíc",
  secondText: "Sekundy",
  timeFormat: "H:mm",
  yearText: "Rok",
  toText: "Konec",
  nowText: "Teď",
  amText: "am",
  pmText: "pm",
  todayText: "Dnes",
  firstDay: 1,
  dateText: "Datum",
  timeText: "Čas",
  allDayText: "Celý den",
  noEventsText: "Žádné události",
  eventText: "Událostí",
  eventsText: "Události",
  moreEventsText: "{count} další",
  weekText: "{count}. týden",
  rangeStartLabel: "Začátek",
  rangeEndLabel: "Konec",
  rangeStartHelp: "Vybrat",
  rangeEndHelp: "Vybrat",
  filterEmptyText: "Žádné výsledky",
  filterPlaceholderText: "Hledat"
};
var da = {
  setText: "Sæt",
  cancelText: "Annuller",
  clearText: "Ryd",
  closeText: "Luk",
  selectedText: "{count} valgt",
  selectedPluralText: "{count} valgt",
  dateFormat: "DD/MM/YYY",
  dateFormatFull: "DDDD, D. MMMM YYYY",
  dateFormatLong: "DDD. D. MMM. YYYY.",
  dateWheelFormat: "|DDD. D. MMM.|",
  dayNames: ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"],
  dayNamesShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
  dayNamesMin: ["S", "M", "T", "O", "T", "F", "L"],
  dayText: "Dag",
  hourText: "Timer",
  minuteText: "Minutter",
  fromText: "Start",
  monthNames: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"],
  monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
  monthText: "Måned",
  secondText: "Sekunder",
  amText: "am",
  pmText: "pm",
  timeFormat: "HH.mm",
  yearText: "År",
  toText: "Slut",
  nowText: "Nu",
  todayText: "I dag",
  firstDay: 1,
  dateText: "Dato",
  timeText: "Tid",
  allDayText: "Hele dagen",
  noEventsText: "Ingen begivenheder",
  eventText: "Begivenheder",
  eventsText: "Begivenheder",
  moreEventsText: "{count} mere",
  weekText: "Uge {count}",
  rangeStartLabel: "Start",
  rangeEndLabel: "Slut",
  rangeStartHelp: "Vælg",
  rangeEndHelp: "Vælg",
  filterEmptyText: "Ingen resultater",
  filterPlaceholderText: "Søg"
};
var de = {
  setText: "OK",
  cancelText: "Abbrechen",
  clearText: "Löschen",
  closeText: "Schließen",
  selectedText: "{count} ausgewählt",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D. MMMM YYYY",
  dateFormatLong: "DDD. D. MMM. YYYY",
  dateWheelFormat: "|DDD. D. MMM.|",
  dayNames: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
  dayNamesShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
  dayNamesMin: ["S", "M", "D", "M", "D", "F", "S"],
  dayText: "Tag",
  hourText: "Stunde",
  minuteText: "Minuten",
  fromText: "Von",
  monthNames: ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
  monthNamesShort: ["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
  monthText: "Monat",
  secondText: "Sekunden",
  timeFormat: "HH:mm",
  yearText: "Jahr",
  nowText: "Jetzt",
  pmText: "pm",
  amText: "am",
  todayText: "Heute",
  toText: "Bis",
  firstDay: 1,
  dateText: "Datum",
  timeText: "Zeit",
  allDayText: "Ganztägig",
  noEventsText: "Keine Ereignisse",
  eventText: "Ereignis",
  eventsText: "Ereignisse",
  moreEventsText: "{count} weiteres Element",
  moreEventsPluralText: "{count} weitere Elemente",
  weekText: "Woche {count}",
  rangeStartLabel: "Von",
  rangeEndLabel: "Bis",
  rangeStartHelp: "Auswählen",
  rangeEndHelp: "Auswählen",
  filterEmptyText: "Keine Treffer",
  filterPlaceholderText: "Suchen"
};
var el = {
  setText: "Ορισμος",
  cancelText: "Ακυρωση",
  clearText: "Διαγραφη",
  closeText: "Κλείσιμο",
  selectedText: "{count} επιλεγμένα",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"],
  dayNamesShort: ["Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"],
  dayNamesMin: ["Κυ", "Δε", "Τρ", "Τε", "Πε", "Πα", "Σα"],
  dayText: "ημέρα",
  hourText: "ώρα",
  minuteText: "λεπτό",
  fromText: "Αρχή",
  monthNames: ["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"],
  monthNamesShort: ["Ιαν", "Φεβ", "Μαρ", "Απρ", "Μαι", "Ιουν", "Ιουλ", "Αυγ", "Σεπ", "Οκτ", "Νοε", "Δεκ"],
  monthText: "Μήνας",
  secondText: "δευτερόλεπτα",
  timeFormat: "H:mm",
  yearText: "έτος",
  toText: "Τέλος",
  nowText: "τώρα",
  pmText: "μμ",
  amText: "πμ",
  firstDay: 1,
  dateText: "Ημερομηνία",
  timeText: "φορά",
  todayText: "Σήμερα",
  eventText: "Γεγονότα",
  eventsText: "Γεγονότα",
  allDayText: "Ολοήμερο",
  noEventsText: "Δεν υπάρχουν γεγονότα",
  moreEventsText: "{count} ακόμη",
  weekText: "Εβδομάδα {count}",
  rangeStartLabel: "Αρχή",
  rangeEndLabel: "Τέλος",
  rangeStartHelp: "Επιλογή",
  rangeEndHelp: "Επιλογή",
  filterEmptyText: "Κανένα αποτέλεσμα",
  filterPlaceholderText: "Αναζήτηση"
};
var enGB = {
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  timeFormat: "H:mm"
};
var es = {
  setText: "Aceptar",
  cancelText: "Cancelar",
  clearText: "Borrar",
  closeText: "Cerrar",
  selectedText: "{count} seleccionado",
  selectedPluralText: "{count} seleccionados",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, MMMM D. YYYY",
  dateFormatLong: "DDD, MMM. D. YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"],
  dayNamesShort: ["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "Sá"],
  dayNamesMin: ["D", "L", "M", "M", "J", "V", "S"],
  dayText: "Día",
  hourText: "Horas",
  minuteText: "Minutos",
  fromText: "Iniciar",
  monthNames: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
  monthNamesShort: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
  monthText: "Mes",
  secondText: "Segundos",
  timeFormat: "H:mm",
  yearText: "A&ntilde;o",
  toText: "Final",
  nowText: "Ahora",
  pmText: "pm",
  amText: "am",
  todayText: "Hoy",
  firstDay: 1,
  dateText: "Fecha",
  timeText: "Tiempo",
  allDayText: "Todo el día",
  noEventsText: "No hay eventos",
  eventText: "Evento",
  eventsText: "Eventos",
  moreEventsText: "{count} más",
  weekText: "Semana {count}",
  rangeStartLabel: "Iniciar",
  rangeEndLabel: "Final",
  rangeStartHelp: "Seleccionar",
  rangeEndHelp: "Seleccionar",
  filterEmptyText: "Sin resultados",
  filterPlaceholderText: "Buscar"
};
var UNDEFINED = void 0;
getArray(3);
getArray(4);
var ARRAY7 = getArray(7);
var ARRAY24 = getArray(24);
function constrain(val, min, max) {
  return Math.max(min, Math.min(val, max));
}
function extend(obj1, obj2) {
  return __assign(__assign({}, obj1), obj2);
}
function isArray(obj) {
  return Array.isArray(obj);
}
function isNumeric(a) {
  return a - parseFloat(a) >= 0;
}
function isNumber(a) {
  return typeof a === "number";
}
function isString(s) {
  return typeof s === "string";
}
function isEmpty(v) {
  return v === UNDEFINED || v === null || v === "";
}
function isUndefined(v) {
  return typeof v === "undefined";
}
function isObject(v) {
  return typeof v === "object";
}
function emptyOrTrue(value) {
  return value !== null && value !== UNDEFINED && "".concat(value) !== "false";
}
function getArray(nr) {
  return Array.apply(0, Array(Math.max(0, nr)));
}
function addPixel(value) {
  return value !== UNDEFINED ? value + (isNumeric(value) ? "px" : "") : "";
}
function noop() {
  return;
}
function pad(num, size) {
  if (size === void 0) {
    size = 2;
  }
  var str = num + "";
  while (str.length < size) {
    str = "0" + str;
  }
  return str;
}
function round(nr) {
  return Math.round(nr);
}
function step(value, st) {
  return floor(value / st) * st;
}
function floor(nr) {
  return Math.floor(nr);
}
function throttle(fn, threshhold) {
  if (threshhold === void 0) {
    threshhold = 100;
  }
  var last;
  var timer;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var now = +/* @__PURE__ */ new Date();
    if (last && now < last + threshhold) {
      clearTimeout(timer);
      timer = setTimeout(function() {
        last = now;
        fn.apply(void 0, args);
      }, threshhold);
    } else {
      last = now;
      fn.apply(void 0, args);
    }
  };
}
function debounce(fn, threshhold) {
  var timer;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(void 0, args);
    }, threshhold);
  };
}
function arrayContentEquals(arr1, arr2) {
  if (arr1 === arr2) {
    return true;
  }
  if (arr1 && !arr2 || arr2 && !arr1) {
    return false;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (var i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function ngSetTimeout(inst, cb) {
  if (inst._cdr) {
    setTimeout(cb);
  } else {
    cb();
  }
}
function find(arr, fn) {
  return findItemOrIndex(arr, fn);
}
function findIndex(arr, fn) {
  return findItemOrIndex(arr, fn, true);
}
function findItemOrIndex(arr, fn, index) {
  var len = arr.length;
  for (var i = 0; i < len; i++) {
    var item = arr[i];
    if (fn(item, i)) {
      return index ? i : item;
    }
  }
  return index ? -1 : UNDEFINED;
}
function map(v, fn) {
  if (isArray(v)) {
    return v.map(fn);
  } else {
    return fn(v, 0, [v]);
  }
}
function toArray(m) {
  var arr = [];
  if (m) {
    for (var _i = 0, _a = Object.keys(m); _i < _a.length; _i++) {
      var key = _a[_i];
      arr.push(m[key]);
    }
  }
  return arr;
}
var gDaysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var jDaysInMonth = [31, 31, 31, 31, 31, 31, 30, 30, 30, 30, 30, 29];
function jalaliToGregorian(jY, jM, jD) {
  var i;
  var jy = jY - 979;
  var jm = jM - 1;
  var jd = jD - 1;
  var jDayNo = 365 * jy + floor(jy / 33) * 8 + floor((jy % 33 + 3) / 4);
  for (i = 0; i < jm; ++i) {
    jDayNo += jDaysInMonth[i];
  }
  jDayNo += jd;
  var gDayNo = jDayNo + 79;
  var gy = 1600 + 400 * floor(gDayNo / 146097);
  gDayNo = gDayNo % 146097;
  var leap = true;
  if (gDayNo >= 36525) {
    gDayNo--;
    gy += 100 * floor(gDayNo / 36524);
    gDayNo = gDayNo % 36524;
    if (gDayNo >= 365) {
      gDayNo++;
    } else {
      leap = false;
    }
  }
  gy += 4 * floor(gDayNo / 1461);
  gDayNo %= 1461;
  if (gDayNo >= 366) {
    leap = false;
    gDayNo--;
    gy += floor(gDayNo / 365);
    gDayNo = gDayNo % 365;
  }
  for (i = 0; gDayNo >= gDaysInMonth[i] + (i === 1 && leap ? 1 : 0); i++) {
    gDayNo -= gDaysInMonth[i] + (i === 1 && leap ? 1 : 0);
  }
  var gm = i + 1;
  var gd = gDayNo + 1;
  return [gy, gm, gd];
}
function checkDate(jY, jM, jD) {
  return !(jY < 0 || jY > 32767 || jM < 1 || jM > 12 || jD < 1 || jD > jDaysInMonth[jM - 1] + (jM === 12 && (jY - 979) % 33 % 4 === 0 ? 1 : 0));
}
function gregorianToJalali(gY, gM, gD) {
  var i;
  var gy = gY - 1600;
  var gm = gM - 1;
  var gd = gD - 1;
  var gDayNo = 365 * gy + floor((gy + 3) / 4) - floor((gy + 99) / 100) + floor((gy + 399) / 400);
  for (i = 0; i < gm; ++i) {
    gDayNo += gDaysInMonth[i];
  }
  if (gm > 1 && (gy % 4 === 0 && gy % 100 !== 0 || gy % 400 === 0)) {
    ++gDayNo;
  }
  gDayNo += gd;
  var jDayNo = gDayNo - 79;
  var jNp = floor(jDayNo / 12053);
  jDayNo %= 12053;
  var jy = 979 + 33 * jNp + 4 * floor(jDayNo / 1461);
  jDayNo %= 1461;
  if (jDayNo >= 366) {
    jy += floor((jDayNo - 1) / 365);
    jDayNo = (jDayNo - 1) % 365;
  }
  for (i = 0; i < 11 && jDayNo >= jDaysInMonth[i]; ++i) {
    jDayNo -= jDaysInMonth[i];
  }
  var jm = i + 1;
  var jd = jDayNo + 1;
  return [jy, jm, jd];
}
var jalaliCalendar = {
  getYear: function(date) {
    return gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];
  },
  getMonth: function(date) {
    return --gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];
  },
  getDay: function(date) {
    return gregorianToJalali(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];
  },
  getDate: function(y, m, d, h, i, s, u) {
    if (m < 0) {
      y += floor(m / 12);
      m = m % 12 ? 12 + m % 12 : 0;
    }
    if (m > 11) {
      y += floor(m / 12);
      m = m % 12;
    }
    var gregorianDate = jalaliToGregorian(y, +m + 1, d);
    return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);
  },
  getMaxDayOfMonth: function(y, m) {
    var maxdays = 31;
    if (m < 0) {
      y += floor(m / 12);
      m = m % 12 ? 12 + m % 12 : 0;
    }
    if (m > 11) {
      y += floor(m / 12);
      m = m % 12;
    }
    while (!checkDate(y, m + 1, maxdays) && maxdays > 29) {
      maxdays--;
    }
    return maxdays;
  }
};
var fa = {
  setText: "تاييد",
  cancelText: "انصراف",
  clearText: "واضح ",
  closeText: "نزدیک",
  selectedText: "{count} منتخب",
  rtl: true,
  calendarSystem: jalaliCalendar,
  dateFormat: "YYYY/MM/DD",
  dateFormatFull: "DDDD D MMMM YYYY",
  dateFormatLong: "DDD D MMM YYYY",
  dateWheelFormat: "|DDDD MMM D|",
  dayNames: ["يکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنج‌شنبه", "جمعه", "شنبه"],
  dayNamesShort: ["ی", "د", "س", "چ", "پ", "ج", "ش"],
  dayNamesMin: ["ی", "د", "س", "چ", "پ", "ج", "ش"],
  dayText: "روز",
  hourText: "ساعت",
  minuteText: "دقيقه",
  fromText: "شروع ",
  monthNames: ["فروردين", "ارديبهشت", "خرداد", "تير", "مرداد", "شهريور", "مهر", "آبان", "آذر", "دی", "بهمن", "اسفند"],
  monthNamesShort: ["فروردين", "ارديبهشت", "خرداد", "تير", "مرداد", "شهريور", "مهر", "آبان", "آذر", "دی", "بهمن", "اسفند"],
  monthText: "ماه",
  secondText: "ثانيه",
  timeFormat: "HH:mm",
  timeWheels: "mmHH",
  yearText: "سال",
  toText: "پایان",
  nowText: "اکنون",
  amText: "ب",
  pmText: "ص",
  todayText: "امروز",
  firstDay: 6,
  dateText: "تاریخ ",
  timeText: "زمان ",
  allDayText: "تمام روز",
  noEventsText: "هیچ رویداد",
  eventText: "رویداد",
  eventsText: "رویدادها",
  moreEventsText: "{count} مورد دیگر",
  weekText: "{count} هفته",
  rangeStartLabel: "شروع ",
  rangeEndLabel: "پایان",
  rangeStartHelp: "انتخاب کنید",
  rangeEndHelp: "انتخاب کنید",
  filterEmptyText: "نتیجه ای ندارد",
  filterPlaceholderText: "جستجو کردن"
};
var fi = {
  setText: "Aseta",
  cancelText: "Peruuta",
  clearText: "Tyhjennä",
  closeText: "Sulje",
  selectedText: "{count} valita",
  dateFormat: "D. MMMM YYYY",
  dateFormatFull: "DDDD, D. MMMM YYYY",
  dateFormatLong: "DDD, D. MMMM, YYYY",
  dateWheelFormat: "|DDD D. M.|",
  dayNames: ["Sunnuntai", "Maanantai", "Tiistai", "Keskiviiko", "Torstai", "Perjantai", "Lauantai"],
  dayNamesShort: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
  dayNamesMin: ["S", "M", "T", "K", "T", "P", "L"],
  dayText: "Päivä",
  hourText: "Tuntia",
  minuteText: "Minuutti",
  fromText: "Alkaa",
  monthNames: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"],
  monthNamesShort: ["Tam", "Hel", "Maa", "Huh", "Tou", "Kes", "Hei", "Elo", "Syy", "Lok", "Mar", "Jou"],
  monthText: "Kuukausi",
  secondText: "Sekunda",
  timeFormat: "H:mm",
  yearText: "Vuosi",
  toText: "Päättyy",
  nowText: "Nyt",
  pmText: "pm",
  amText: "am",
  firstDay: 1,
  dateText: "Päiväys",
  timeText: "Aika",
  todayText: "Tänään",
  eventText: "Tapahtumia",
  eventsText: "Tapahtumia",
  allDayText: "Koko päivä",
  noEventsText: "Ei tapahtumia",
  moreEventsText: "{count} muu",
  moreEventsPluralText: "{count} muuta",
  weekText: "Viikko {count}",
  rangeStartLabel: "Alkaa",
  rangeEndLabel: "Päättyy",
  rangeStartHelp: "Valitse",
  rangeEndHelp: "Valitse",
  filterEmptyText: "Ei tuloksia",
  filterPlaceholderText: "Haku"
};
var fr = {
  setText: "Terminer",
  cancelText: "Annuler",
  clearText: "Effacer",
  closeText: "Fermer",
  selectedText: "{count} sélectionné",
  selectedPluralText: "{count} sélectionnés",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD D MMMM YYYY",
  dateFormatLong: "DDD D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
  dayNamesShort: ["Dim.", "Lun.", "Mar.", "Mer.", "Jeu.", "Ven.", "Sam."],
  dayNamesMin: ["D", "L", "M", "M", "J", "V", "S"],
  dayText: "Jour",
  monthText: "Mois",
  fromText: "Démarrer",
  monthNames: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
  monthNamesShort: ["Janv.", "Févr.", "Mars", "Avril", "Mai", "Juin", "Juil.", "Août", "Sept.", "Oct.", "Nov.", "Déc."],
  hourText: "Heures",
  minuteText: "Minutes",
  secondText: "Secondes",
  timeFormat: "HH:mm",
  yearText: "Année",
  toText: "Fin",
  nowText: "Maintenant",
  pmText: "pm",
  amText: "am",
  todayText: "Aujourd'hui",
  firstDay: 1,
  dateText: "Date",
  timeText: "Heure",
  allDayText: "Toute la journée",
  noEventsText: "Aucun événement",
  eventText: "Événement",
  eventsText: "Événements",
  moreEventsText: "{count} autre",
  moreEventsPluralText: "{count} autres",
  weekText: "Semaine {count}",
  rangeStartLabel: "Début",
  rangeEndLabel: "Fin",
  rangeStartHelp: "Choisir",
  rangeEndHelp: "Choisir",
  filterEmptyText: "Aucun résultat",
  filterPlaceholderText: "Rechercher"
};
var he = {
  rtl: true,
  setText: "שמירה",
  cancelText: "ביטול",
  clearText: "נקה",
  closeText: "סגירה",
  selectedText: "{count} נבחר",
  selectedPluralText: "{count} נבחרו",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, D בMMMM YYYY",
  dateFormatLong: "DDD, D בMMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"],
  dayNamesShort: ["א'", "ב'", "ג'", "ד'", "ה'", "ו'", "ש'"],
  dayNamesMin: ["א", "ב", "ג", "ד", "ה", "ו", "ש"],
  dayText: "יום",
  hourText: "שעות",
  minuteText: "דקות",
  fromText: "התחלה",
  monthNames: ["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"],
  monthNamesShort: ["ינו", "פבר", "מרץ", "אפר", "מאי", "יונ", "יול", "אוג", "ספט", "אוק", "נוב", "דצמ"],
  monthText: "חודש",
  secondText: "שניות",
  amText: "am",
  pmText: "pm",
  timeFormat: "H:mm",
  timeWheels: "mmH",
  yearText: "שנה",
  toText: "סיום",
  nowText: "עכשיו",
  firstDay: 0,
  dateText: "תאריך",
  timeText: "זמן",
  todayText: "היום",
  allDayText: "כל היום",
  noEventsText: "אין אירועים",
  eventText: "מִקרֶה",
  eventsText: "מִקרֶה",
  moreEventsText: "אירוע אחד נוסף",
  moreEventsPluralText: "{count} אירועים נוספים",
  weekText: "{count} שבוע",
  rangeStartLabel: "התחלה",
  rangeEndLabel: "סיום",
  rangeStartHelp: "בחר",
  rangeEndHelp: "בחר",
  filterEmptyText: "אין תוצאוה",
  filterPlaceholderText: "לחפש"
};
var hi = {
  setText: "सैट करें",
  cancelText: "रद्द करें",
  clearText: "साफ़ को",
  closeText: "बंद",
  selectedText: "{count} चयनित",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["रविवार", "सोमवार", "मंगलवार", "बुधवार", "गुरुवार", "शुक्रवार", "शनिवार"],
  dayNamesShort: ["रवि", "सोम", "मंगल", "बुध", "गुरु", "शुक्र", "शनि"],
  dayNamesMin: ["रवि", "सोम", "मंगल", "बुध", "गुरु", "शुक्र", "शनि"],
  dayText: "दिन",
  hourText: "घंटा",
  minuteText: "मिनट",
  fromText: "से",
  monthNames: ["जनवरी ", "फरवरी", "मार्च", "अप्रेल", "मई", "जून", "जूलाई", "अगस्त ", "सितम्बर", "अक्टूबर", "नवम्बर", "दिसम्बर"],
  monthNamesShort: ["जन", "फर", "मार्च", "अप्रेल", "मई", "जून", "जूलाई", "अग", "सित", "अक्ट", "नव", "दि"],
  monthText: "महीना",
  secondText: "सेकंड",
  timeFormat: "H:mm",
  yearText: "साल",
  toText: "तक",
  nowText: "अब",
  pmText: "अपराह्न",
  amText: "पूर्वाह्न",
  firstDay: 1,
  dateText: "तिथि",
  timeText: "समय",
  todayText: "आज",
  eventText: "इवेट३",
  eventsText: "इवेट३",
  allDayText: "पूरे दिन",
  noEventsText: "Ei tapahtumia",
  moreEventsText: "{count} और",
  weekText: "सप्ताह {count}",
  rangeStartLabel: "से",
  rangeEndLabel: "तक",
  rangeStartHelp: "चुनें",
  rangeEndHelp: "चुनें",
  filterEmptyText: "कोई परिणाम नही",
  filterPlaceholderText: "खोज"
};
var hr = {
  setText: "Postavi",
  cancelText: "Izlaz",
  clearText: "Izbriši",
  closeText: "Zatvori",
  selectedText: "{count} odabran",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D. MMMM YYYY.",
  dateFormatLong: "DDD, D. MMM. YYYY.",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"],
  dayNamesShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
  dayNamesMin: ["Ne", "Po", "Ut", "Sr", "Če", "Pe", "Su"],
  dayText: "Dan",
  hourText: "Sat",
  minuteText: "Minuta",
  fromText: "Počinje",
  monthNames: ["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"],
  monthNamesShort: ["Sij", "Velj", "Ožu", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"],
  monthText: "Mjesec",
  secondText: "Sekunda",
  timeFormat: "H:mm",
  yearText: "Godina",
  toText: "Završava",
  nowText: "Sada",
  pmText: "pm",
  amText: "am",
  firstDay: 1,
  dateText: "Datum",
  timeText: "Vrijeme",
  todayText: "Danas",
  eventText: "Događaj",
  eventsText: "događaja",
  allDayText: "Cijeli dan",
  noEventsText: "Bez događaja",
  moreEventsText: "Još {count}",
  weekText: "{count}. tjedan",
  rangeStartLabel: "Počinje",
  rangeEndLabel: "Završava",
  rangeStartHelp: "Odaberite",
  rangeEndHelp: "Odaberite",
  filterEmptyText: "Bez rezultata",
  filterPlaceholderText: "Traži"
};
var hu = {
  setText: "OK",
  cancelText: "Mégse",
  clearText: "Törlés",
  closeText: "Bezár",
  selectedText: "{count} kiválasztva",
  dateFormat: "YYYY.MM.DD.",
  dateFormatFull: "YYYY. MMMM D., DDDD",
  dateFormatLong: "YYYY. MMM. D., DDD",
  dateWheelFormat: "|MMM. D. DDD|",
  dayNames: ["Vasárnap", "Hétfő", "Kedd", "Szerda", "Csütörtök", "Péntek", "Szombat"],
  dayNamesShort: ["Va", "Hé", "Ke", "Sze", "Csü", "Pé", "Szo"],
  dayNamesMin: ["V", "H", "K", "Sz", "Cs", "P", "Sz"],
  dayText: "Nap",
  hourText: "Óra",
  minuteText: "Perc",
  fromText: "Eleje",
  monthNames: ["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"],
  monthNamesShort: ["Jan", "Feb", "Már", "Ápr", "Máj", "Jún", "Júl", "Aug", "Szep", "Okt", "Nov", "Dec"],
  monthText: "Hónap",
  secondText: "Másodperc",
  timeFormat: "H:mm",
  yearText: "Év",
  toText: "Vége",
  nowText: "Most",
  pmText: "pm",
  amText: "am",
  firstDay: 1,
  dateText: "Dátum",
  timeText: "Idő",
  todayText: "Ma",
  eventText: "esemény",
  eventsText: "esemény",
  allDayText: "Egész nap",
  noEventsText: "Nincs esemény",
  moreEventsText: "{count} további",
  weekText: "{count}. hét",
  rangeStartLabel: "Eleje",
  rangeEndLabel: "Vége",
  rangeStartHelp: "Válasszon",
  rangeEndHelp: "Válasszon",
  filterEmptyText: "Nincs találat",
  filterPlaceholderText: "Keresés"
};
var it = {
  setText: "OK",
  cancelText: "Annulla",
  clearText: "Chiarire",
  closeText: "Chiudere",
  selectedText: "{count} selezionato",
  selectedPluralText: "{count} selezionati",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD D MMMM YYYY",
  dateFormatLong: "DDD D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"],
  dayNamesShort: ["Do", "Lu", "Ma", "Me", "Gi", "Ve", "Sa"],
  dayNamesMin: ["D", "L", "M", "M", "G", "V", "S"],
  dayText: "Giorno",
  hourText: "Ore",
  minuteText: "Minuti",
  fromText: "Inizio",
  monthNames: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
  monthNamesShort: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
  monthText: "Mese",
  secondText: "Secondi",
  timeFormat: "HH:mm",
  yearText: "Anno",
  toText: "Fine",
  nowText: "Ora",
  pmText: "pm",
  amText: "am",
  todayText: "Oggi",
  firstDay: 1,
  dateText: "Data",
  timeText: "Volta",
  allDayText: "Tutto il giorno",
  noEventsText: "Nessun evento",
  eventText: "Evento",
  eventsText: "Eventi",
  moreEventsText: "{count} altro",
  moreEventsPluralText: "altri {count}",
  weekText: "Settimana {count}",
  rangeStartLabel: "Inizio",
  rangeEndLabel: "Fine",
  rangeStartHelp: "Scegli",
  rangeEndHelp: "Scegli",
  filterEmptyText: "Nessun risultato",
  filterPlaceholderText: "Cerca"
};
var ja = {
  setText: "セット",
  cancelText: "キャンセル",
  clearText: "クリア",
  closeText: "クローズ",
  selectedText: "{count} 選択",
  dateFormat: "YYYY年MM月DD日",
  dateFormatFull: "YYYY年MM月DD日",
  dateFormatLong: "YYYY年MM月DD日",
  dateWheelFormat: "|M月D日 DDD|",
  dayNames: ["日", "月", "火", "水", "木", "金", "土"],
  dayNamesShort: ["日", "月", "火", "水", "木", "金", "土"],
  dayNamesMin: ["日", "月", "火", "水", "木", "金", "土"],
  dayText: "日",
  hourText: "時",
  minuteText: "分",
  fromText: "開始",
  monthNames: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
  monthNamesShort: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
  monthText: "月",
  secondText: "秒",
  timeFormat: "H:mm",
  yearText: "年",
  toText: "終わり",
  nowText: "今",
  pmText: "午後",
  amText: "午前",
  yearSuffix: "年",
  monthSuffix: "月",
  daySuffix: "日",
  todayText: "今日",
  dateText: "日付",
  timeText: "時間",
  allDayText: "終日",
  noEventsText: "イベントはありません",
  eventText: "イベント",
  eventsText: "イベント",
  moreEventsText: "他 {count} 件",
  weekText: "{count}週目",
  rangeStartLabel: "開始",
  rangeEndLabel: "終わり",
  rangeStartHelp: "選択",
  rangeEndHelp: "選択",
  filterEmptyText: "検索結果はありません",
  filterPlaceholderText: "探す"
};
var ko = {
  setText: "설정",
  cancelText: "취소",
  clearText: "삭제",
  closeText: "닫기",
  selectedText: "{count} 선택된",
  dateFormat: "YYYY년MM월DD일",
  dateFormatFull: "YYYY년MM월DD일",
  dateFormatLong: "YYYY년MM월DD일",
  dateWheelFormat: "|M월 D일 DDD|",
  dayNames: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"],
  dayNamesShort: ["일", "월", "화", "수", "목", "금", "토"],
  dayNamesMin: ["일", "월", "화", "수", "목", "금", "토"],
  dayText: "일",
  hourText: "시간",
  minuteText: "분",
  fromText: "시작",
  monthNames: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
  monthNamesShort: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
  monthText: "달",
  secondText: "초",
  timeFormat: "H:mm",
  yearText: "년",
  toText: "종료",
  nowText: "지금",
  pmText: "오후",
  amText: "오전",
  yearSuffix: "년",
  monthSuffix: "월",
  daySuffix: "일",
  firstDay: 0,
  dateText: "날짜",
  timeText: "시간",
  todayText: "오늘",
  eventText: "이벤트",
  eventsText: "이벤트",
  allDayText: "종일",
  noEventsText: "이벤트 없음",
  moreEventsText: "{count}개 더보기",
  weekText: "{count}주차",
  rangeStartLabel: "시작",
  rangeEndLabel: "종료",
  rangeStartHelp: "선택",
  rangeEndHelp: "선택",
  filterEmptyText: "결과가 없다",
  filterPlaceholderText: "찾다"
};
var lt = {
  setText: "OK",
  cancelText: "Atšaukti",
  clearText: "Išvalyti",
  closeText: "Uždaryti",
  selectedText: "Pasirinktas {count}",
  selectedPluralText: "Pasirinkti {count}",
  dateFormat: "YYYY-MM-DD",
  dateFormatFull: "YYYY MMMM D DDDD",
  dateFormatLong: "YYYY-MM-DD",
  dateWheelFormat: "|MM-DD DDD|",
  dayNames: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"],
  dayNamesShort: ["S", "Pr", "A", "T", "K", "Pn", "Š"],
  dayNamesMin: ["S", "Pr", "A", "T", "K", "Pn", "Š"],
  dayText: "Diena",
  hourText: "Valanda",
  minuteText: "Minutes",
  fromText: "Nuo",
  monthNames: ["Sausis", "Vasaris", "Kovas", "Balandis", "Gegužė", "Birželis", "Liepa", "Rugpjūtis", "Rugsėjis", "Spalis", "Lapkritis", "Gruodis"],
  monthNamesShort: ["Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rugp", "Rugs", "Spa", "Lap", "Gruo"],
  monthText: "Mėnuo",
  secondText: "Sekundes",
  amText: "am",
  pmText: "pm",
  timeFormat: "HH:mm",
  yearText: "Metai",
  toText: "Iki",
  nowText: "Dabar",
  todayText: "Šiandien",
  firstDay: 1,
  dateText: "Data",
  timeText: "Laikas",
  allDayText: "Visą dieną",
  noEventsText: "Nėra įvykių",
  eventText: "Įvykių",
  eventsText: "Įvykiai",
  moreEventsText: "Dar {count}",
  weekText: "{count} savaitė",
  rangeStartLabel: "Nuo",
  rangeEndLabel: "Iki",
  rangeStartHelp: "Pasirinkti",
  rangeEndHelp: "Pasirinkti",
  filterEmptyText: "Nėra rezultatų",
  filterPlaceholderText: "Paieška"
};
var nl = {
  setText: "Instellen",
  cancelText: "Annuleren",
  clearText: "Leegmaken",
  closeText: "Sluiten",
  selectedText: "{count} gekozen",
  dateFormat: "DD-MM-YYYY",
  dateFormatFull: "DDDD D MMMM YYYY",
  dateFormatLong: "DD-MM-YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Zondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrijdag", "Zaterdag"],
  dayNamesShort: ["Zo", "Ma", "Di", "Wo", "Do", "Vr", "Za"],
  dayNamesMin: ["Z", "M", "D", "W", "D", "V", "Z"],
  dayText: "Dag",
  hourText: "Uur",
  minuteText: "Minuten",
  fromText: "Start",
  monthNames: ["Januari", "Februari", "Maart", "April", "Mei", "Juni", "Juli", "Augustus", "September", "Oktober", "November", "December"],
  monthNamesShort: ["Jan", "Feb", "Mrt", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
  monthText: "Maand",
  secondText: "Seconden",
  timeFormat: "HH:mm",
  yearText: "Jaar",
  toText: "Einde",
  nowText: "Nu",
  pmText: "pm",
  amText: "am",
  todayText: "Vandaag",
  firstDay: 1,
  dateText: "Datum",
  timeText: "Tijd",
  allDayText: "Hele dag",
  noEventsText: "Geen activiteiten",
  eventText: "Activiteit",
  eventsText: "Activiteiten",
  moreEventsText: "nog {count}",
  weekText: "Week {count}",
  rangeStartLabel: "Start",
  rangeEndLabel: "Einde",
  rangeStartHelp: "Kies",
  rangeEndHelp: "Kies",
  filterEmptyText: "Niets gevonden",
  filterPlaceholderText: "Zoek"
};
var no = {
  setText: "OK",
  cancelText: "Avbryt",
  clearText: "Tømme",
  closeText: "Lukk",
  selectedText: "{count} valgt",
  dateFormat: "DD.MM.YYY",
  dateFormatFull: "DDDD D. MMMM YYYY",
  dateFormatLong: "DDD. D. MMM. YYYY",
  dateWheelFormat: "|DDD. D. MMM.|",
  dayNames: ["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"],
  dayNamesShort: ["Sø", "Ma", "Ti", "On", "To", "Fr", "Lø"],
  dayNamesMin: ["S", "M", "T", "O", "T", "F", "L"],
  dayText: "Dag",
  hourText: "Time",
  minuteText: "Minutt",
  fromText: "Start",
  monthNames: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
  monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
  monthText: "Måned",
  secondText: "Sekund",
  timeFormat: "HH:mm",
  yearText: "År",
  toText: "End",
  nowText: "Nå",
  pmText: "pm",
  amText: "am",
  todayText: "I dag",
  firstDay: 1,
  dateText: "Dato",
  timeText: "Tid",
  allDayText: "Hele dagen",
  noEventsText: "Ingen hendelser",
  eventText: "Hendelse",
  eventsText: "Hendelser",
  moreEventsText: "{count} mere",
  weekText: "Uke {count}",
  rangeStartLabel: "Start",
  rangeEndLabel: "End",
  rangeStartHelp: "Velg",
  rangeEndHelp: "Velg",
  filterEmptyText: "Ingen treff",
  filterPlaceholderText: "Søk"
};
var pl = {
  setText: "Zestaw",
  cancelText: "Anuluj",
  clearText: "Oczyścić",
  closeText: "Zakończenie",
  selectedText: "Wybór: {count}",
  dateFormat: "YYYY-MM-DD",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMM YYYY",
  dateWheelFormat: "|DDD D.MM|",
  dayNames: ["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"],
  dayNamesShort: ["Nie.", "Pon.", "Wt.", "Śr.", "Czw.", "Pt.", "Sob."],
  dayNamesMin: ["N", "P", "W", "Ś", "C", "P", "S"],
  dayText: "Dzień",
  hourText: "Godziny",
  minuteText: "Minuty",
  fromText: "Rozpoczęcie",
  monthNames: ["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"],
  monthNamesShort: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Paź", "Lis", "Gru"],
  monthText: "Miesiąc",
  secondText: "Sekundy",
  timeFormat: "HH:mm",
  yearText: "Rok",
  toText: "Koniec",
  nowText: "Teraz",
  amText: "am",
  pmText: "pm",
  todayText: "Dzisiaj",
  firstDay: 1,
  dateText: "Data",
  timeText: "Czas",
  allDayText: "Cały dzień",
  noEventsText: "Brak wydarzeń",
  eventText: "Wydarzeń",
  eventsText: "Wydarzenia",
  moreEventsText: "Jeszcze {count}",
  weekText: "Tydzień {count}",
  rangeStartLabel: "Rozpoczęcie",
  rangeEndLabel: "Koniec",
  rangeStartHelp: "Wybierz",
  rangeEndHelp: "Wybierz",
  filterEmptyText: "Brak wyników",
  filterPlaceholderText: "Szukaj"
};
var ptPT = {
  setText: "Seleccionar",
  cancelText: "Cancelar",
  clearText: "Claro",
  closeText: "Fechar",
  selectedText: "{count} selecionado",
  selectedPluralText: "{count} selecionados",
  dateFormat: "DD-MM-YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMM, YYYY",
  dateWheelFormat: "|DDD D de MMM|",
  dayNames: ["Domingo", "Segunda-feira", "Terça-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sábado"],
  dayNamesShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
  dayNamesMin: ["D", "S", "T", "Q", "Q", "S", "S"],
  dayText: "Dia",
  hourText: "Horas",
  minuteText: "Minutos",
  fromText: "Início",
  monthNames: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
  monthNamesShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
  monthText: "Mês",
  secondText: "Segundo",
  timeFormat: "HH:mm",
  yearText: "Ano",
  toText: "Fim",
  nowText: "Actualizar",
  pmText: "pm",
  amText: "am",
  todayText: "Hoje",
  firstDay: 1,
  dateText: "Data",
  timeText: "Tempo",
  allDayText: "Todo o dia",
  noEventsText: "Nenhum evento",
  eventText: "Evento",
  eventsText: "Eventos",
  moreEventsText: "Mais {count}",
  weekText: "Semana {count}",
  rangeStartLabel: "Início",
  rangeEndLabel: "Fim",
  rangeStartHelp: "Escolha",
  rangeEndHelp: "Escolha",
  filterEmptyText: "Nenhum resultado",
  filterPlaceholderText: "Pesquisa"
};
var ptBR = {
  setText: "Selecionar",
  dateFormat: "DD/MM/YYYY",
  nowText: "Agora",
  allDayText: "Dia inteiro",
  filterPlaceholderText: "Buscar"
};
var localePtBR = extend(ptPT, ptBR);
var ro = {
  setText: "Setare",
  cancelText: "Anulare",
  clearText: "Ştergere",
  closeText: "Închidere",
  selectedText: "{count} selectat",
  selectedPluralText: "{count} selectate",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD., D MMM YYYY",
  dateWheelFormat: "|DDD. D MMM|",
  dayNames: ["Duminică", "Luni", "Marți", "Miercuri", "Joi", "Vineri", "Sâmbătă"],
  dayNamesShort: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"],
  dayNamesMin: ["D", "L", "M", "M", "J", "V", "S"],
  dayText: " Ziua",
  hourText: " Ore ",
  minuteText: "Minute",
  fromText: "Start",
  monthNames: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"],
  monthNamesShort: ["Ian.", "Feb.", "Mar.", "Apr.", "Mai", "Iun.", "Iul.", "Aug.", "Sept.", "Oct.", "Nov.", "Dec."],
  monthText: "Luna",
  secondText: "Secunde",
  timeFormat: "HH:mm",
  yearText: "Anul",
  toText: "Final",
  nowText: "Acum",
  amText: "am",
  pmText: "pm",
  todayText: "Astăzi",
  eventText: "Eveniment",
  eventsText: "Evenimente",
  allDayText: "Toată ziua",
  noEventsText: "Niciun eveniment",
  moreEventsText: "Încă unul",
  moreEventsPluralText: "Încă {count}",
  firstDay: 1,
  dateText: "Data",
  timeText: "Ora",
  weekText: "Săptămâna {count}",
  rangeStartLabel: "Start",
  rangeEndLabel: "Final",
  rangeStartHelp: "Selectare",
  rangeEndHelp: "Selectare",
  filterEmptyText: "Niciun rezultat",
  filterPlaceholderText: "Căutare"
};
var ru = {
  setText: "Установить",
  cancelText: "Отмена",
  clearText: "Очистить",
  closeText: "Закрыть",
  selectedText: "{count} Выбрать",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"],
  dayNamesShort: ["вс", "пн", "вт", "ср", "чт", "пт", "сб"],
  dayNamesMin: ["в", "п", "в", "с", "ч", "п", "с"],
  dayText: "День",
  hourText: "Час",
  minuteText: "Минут",
  fromText: "Начало",
  monthNames: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"],
  monthNamesShort: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"],
  monthText: "Месяц",
  secondText: "Секунд",
  timeFormat: "HH:mm",
  yearText: "Год",
  toText: "Конец",
  nowText: "Сейчас",
  amText: "am",
  pmText: "pm",
  todayText: "Cегодня",
  firstDay: 1,
  dateText: "Дата",
  timeText: "Время",
  allDayText: "Весь день",
  noEventsText: "Нет событий",
  eventText: "Мероприятия",
  eventsText: "Мероприятия",
  moreEventsText: "Ещё {count}",
  weekText: "Неделя {count}",
  rangeStartLabel: "Начало",
  rangeEndLabel: "Конец",
  rangeStartHelp: "выбирать",
  rangeEndHelp: "выбирать",
  filterEmptyText: "Нет результатов",
  filterPlaceholderText: "Поиск"
};
var ruUA = {
  cancelText: "Отменить",
  clearText: "Очиститьr",
  selectedText: "{count} Вібрать",
  monthNamesShort: ["Янв.", "Февр.", "Март", "Апр.", "Май", "Июнь", "Июль", "Авг.", "Сент.", "Окт.", "Нояб.", "Дек."],
  filterEmptyText: "Ніякага выніку",
  filterPlaceholderText: "Пошук"
};
var localeRuUA = extend(ru, ruUA);
var sk = {
  setText: "Zadaj",
  cancelText: "Zrušiť",
  clearText: "Vymazať",
  closeText: "Zavrieť",
  selectedText: "Označený: {count}",
  dateFormat: "D.M.YYYY",
  dateFormatFull: "DDDD D. MMMM YYYY",
  dateFormatLong: "DDD D. MMM YYYY",
  dateWheelFormat: "|DDD D. MMM|",
  dayNames: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"],
  dayNamesShort: ["Ne", "Po", "Ut", "St", "Št", "Pi", "So"],
  dayNamesMin: ["N", "P", "U", "S", "Š", "P", "S"],
  dayText: "Ďeň",
  hourText: "Hodiny",
  minuteText: "Minúty",
  fromText: "Začiatok",
  monthNames: ["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"],
  monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "Máj", "Jún", "Júl", "Aug", "Sep", "Okt", "Nov", "Dec"],
  monthText: "Mesiac",
  secondText: "Sekundy",
  timeFormat: "H:mm",
  yearText: "Rok",
  toText: "Koniec",
  nowText: "Teraz",
  amText: "am",
  pmText: "pm",
  todayText: "Dnes",
  firstDay: 1,
  dateText: "Datum",
  timeText: "Čas",
  allDayText: "Celý deň",
  noEventsText: "Žiadne udalosti",
  eventText: "Udalostí",
  eventsText: "Udalosti",
  moreEventsText: "{count} ďalšia",
  moreEventsPluralText: "{count} ďalšie",
  weekText: "{count}. týždeň",
  rangeStartLabel: "Začiatok",
  rangeEndLabel: "Koniec",
  rangeStartHelp: "Vybrať",
  rangeEndHelp: "Vybrať",
  filterEmptyText: "Žiadne výsledky",
  filterPlaceholderText: "Vyhľadávanie"
};
var sr = {
  setText: "Постави",
  cancelText: "Откажи",
  clearText: "Обриши",
  selectedText: "{count} изабрана",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D. MMMM YYYY.",
  dateFormatLong: "DDD, D. MMM YYYY.",
  dateWheelFormat: "|DDD D. MMM|",
  dayNames: ["Недеља", "Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"],
  dayNamesShort: ["Нед", "Пон", "Уто", "Сре", "Чет", "Пет", "Суб"],
  dayNamesMin: ["Не", "По", "Ут", "Ср", "Че", "Пе", "Су"],
  dayText: "Дан",
  hourText: "Час",
  minuteText: "Минут",
  fromText: "Од",
  monthNames: ["Јануар", "Фебруар", "Март", "Април", "Мај", "Јун", "Јул", "Август", "Септембар", "Октобар", "Новембар", "Децембар"],
  monthNamesShort: ["Јан", "Феб", "Мар", "Апр", "Мај", "Јун", "Јул", "Авг", "Сеп", "Окт", "Нов", "Дец"],
  monthText: "месец",
  secondText: "Секунд",
  timeFormat: "HH:mm",
  yearText: "година",
  toText: "До",
  nowText: "сада",
  pmText: "pm",
  amText: "am",
  firstDay: 1,
  dateText: "Датум",
  timeText: "време",
  todayText: "Данас",
  closeText: "Затвори",
  eventText: "Догађај",
  eventsText: "Догађаји",
  allDayText: "Цео дан",
  noEventsText: "Нема догађаја",
  moreEventsText: "Још {count}",
  weekText: "{count}. недеља",
  rangeStartLabel: "Од",
  rangeEndLabel: "До",
  rangeStartHelp: "Изаберите",
  rangeEndHelp: "Изаберите",
  filterEmptyText: "Без резултата",
  filterPlaceholderText: "Претрага"
};
var sv = {
  setText: "OK",
  cancelText: "Avbryt",
  clearText: "Klara",
  closeText: "Stäng",
  selectedText: "{count} vald",
  dateFormat: "YYYY-MM-DD",
  dateFormatFull: "DDDD D MMMM YYYY",
  dateFormatLong: "DDD D MMM. YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"],
  dayNamesShort: ["Sö", "Må", "Ti", "On", "To", "Fr", "Lö"],
  dayNamesMin: ["S", "M", "T", "O", "T", "F", "L"],
  dayText: "Dag",
  hourText: "Timme",
  minuteText: "Minut",
  fromText: "Start",
  monthNames: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
  monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
  monthText: "Månad",
  secondText: "Sekund",
  timeFormat: "HH:mm",
  yearText: "År",
  toText: "Slut",
  nowText: "Nu",
  pmText: "pm",
  amText: "am",
  todayText: "I dag",
  firstDay: 1,
  dateText: "Datum",
  timeText: "Tid",
  allDayText: "Heldag",
  noEventsText: "Inga aktiviteter",
  eventText: "Händelse",
  eventsText: "Händelser",
  moreEventsText: "{count} till",
  weekText: "Vecka {count}",
  rangeStartLabel: "Start",
  rangeEndLabel: "Slut",
  rangeStartHelp: "Välj",
  rangeEndHelp: "Välj",
  filterEmptyText: "Inga träffar",
  filterPlaceholderText: "Sök"
};
var th = {
  setText: "ตั้งค่า",
  cancelText: "ยกเลิก",
  clearText: "ล้าง",
  closeText: "ปิด",
  selectedText: "{count} เลือก",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "วันDDDDที่ D MMMM YYYY",
  dateFormatLong: "วันDDDที่ D MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์"],
  dayNamesShort: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
  dayNamesMin: ["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."],
  dayText: "วัน",
  hourText: "ชั่วโมง",
  minuteText: "นาที",
  fromText: "จาก",
  monthNames: ["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม"],
  monthNamesShort: ["ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค."],
  monthText: "เดือน",
  secondText: "วินาที",
  timeFormat: "HH:mm",
  yearText: "ปี",
  toText: "ถึง",
  nowText: "ตอนนี้",
  pmText: "pm",
  amText: "am",
  firstDay: 0,
  dateText: "วัน",
  timeText: "เวลา",
  todayText: "วันนี้",
  eventText: "เหตุการณ์",
  eventsText: "เหตุการณ์",
  allDayText: "ตลอดวัน",
  noEventsText: "ไม่มีกิจกรรม",
  moreEventsText: "อีก {count} กิจกรรม",
  weekText: "สัปดาห์ที่ {count}",
  rangeStartLabel: "จาก",
  rangeEndLabel: "ถึง",
  rangeStartHelp: "เลือก",
  rangeEndHelp: "เลือก",
  filterEmptyText: "ไม่มีผลลัพธ์",
  filterPlaceholderText: "ค้นหา"
};
var tr = {
  setText: "Seç",
  cancelText: "İptal",
  clearText: "Temizleyin",
  closeText: "Kapatmak",
  selectedText: "{count} seçilmiş",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "D MMMM DDDD YYYY",
  dateFormatLong: "D MMMM DDD, YYYY",
  dateWheelFormat: "|D MMM DDD|",
  dayNames: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"],
  dayNamesShort: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"],
  dayNamesMin: ["P", "P", "S", "Ç", "P", "C", "C"],
  dayText: "Gün",
  hourText: "Saat",
  minuteText: "Dakika",
  fromText: "Başla",
  monthNames: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"],
  monthNamesShort: ["Oca", "Şub", "Mar", "Nis", "May", "Haz", "Tem", "Ağu", "Eyl", "Eki", "Kas", "Ara"],
  monthText: "Ay",
  secondText: "Saniye",
  timeFormat: "HH:mm",
  yearText: "Yıl",
  toText: "Son",
  nowText: "Şimdi",
  pmText: "pm",
  amText: "am",
  todayText: "Bugün",
  firstDay: 1,
  dateText: "Tarih",
  timeText: "Zaman",
  allDayText: "Tüm gün",
  noEventsText: "Etkinlik Yok",
  eventText: "Etkinlik",
  eventsText: "Etkinlikler",
  moreEventsText: "{count} tane daha",
  weekText: "{count}. Hafta",
  rangeStartLabel: "Başla",
  rangeEndLabel: "Son",
  rangeStartHelp: "Seç",
  rangeEndHelp: "Seç",
  filterEmptyText: "Sonuç Yok",
  filterPlaceholderText: "Arayın"
};
var ua = {
  setText: "встановити",
  cancelText: "відміна",
  clearText: "очистити",
  closeText: "Закрити",
  selectedText: "{count} вибрані",
  dateFormat: "DD.MM.YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD, D MMM. YYYY",
  dateWheelFormat: "|DDD D MMM.|",
  dayNames: ["неділя", "понеділок", "вівторок", "середа", "четвер", "п’ятниця", "субота"],
  dayNamesShort: ["нед", "пнд", "вів", "срд", "чтв", "птн", "сбт"],
  dayNamesMin: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
  dayText: "День",
  hourText: "година",
  minuteText: "хвилина",
  fromText: "від",
  monthNames: ["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"],
  monthNamesShort: ["Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"],
  monthText: "Місяць",
  secondText: "Секунд",
  timeFormat: "H:mm",
  yearText: "Рік",
  toText: "кінець",
  nowText: "Зараз",
  pmText: "pm",
  amText: "am",
  firstDay: 1,
  dateText: "дата",
  timeText: "Час",
  todayText: "Сьогодні",
  eventText: "подія",
  eventsText: "події",
  allDayText: "Увесь день",
  noEventsText: "Жодної події",
  moreEventsText: "та ще {count}",
  weekText: "{count} тиждень",
  rangeStartLabel: "від",
  rangeEndLabel: "кінець",
  rangeEndHelp: "Обрати",
  rangeStartHelp: "Обрати",
  filterEmptyText: "Ніякого результату",
  filterPlaceholderText: "Пошук"
};
var vi = {
  setText: "Đặt",
  cancelText: "Hủy bò",
  clearText: "Xóa",
  closeText: "Đóng",
  selectedText: "{count} chọn",
  dateFormat: "DD/MM/YYYY",
  dateFormatFull: "DDDD, D MMMM YYYY",
  dateFormatLong: "DDD D, MMM YYYY",
  dateWheelFormat: "|DDD D MMM|",
  dayNames: ["Chủ Nhật", "Thứ Hai", "Thứ Ba", "Thứ Tư", "Thứ Năm", "Thứ Sáu", "Thứ Bảy"],
  dayNamesShort: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
  dayNamesMin: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
  dayText: "",
  hourText: "Giờ",
  minuteText: "Phút",
  fromText: "Từ",
  monthNames: ["Tháng Một", "Tháng Hai", "Tháng Ba", "Tháng Tư", "Tháng Năm", "Tháng Sáu", "Tháng Bảy", "Tháng Tám", "Tháng Chín", "Tháng Mười", "Tháng Mười Một", "Tháng Mười Hai"],
  monthNamesShort: ["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"],
  monthText: "Tháng",
  secondText: "Giây",
  timeFormat: "H:mm",
  yearText: "Năm",
  toText: "Tới",
  nowText: "Bây giờ",
  pmText: "pm",
  amText: "am",
  firstDay: 0,
  dateText: "Ngày",
  timeText: "Hồi",
  todayText: "Hôm nay",
  eventText: "Sự kiện",
  eventsText: "Sự kiện",
  allDayText: "Cả ngày",
  noEventsText: "Không có sự kiện",
  moreEventsText: "{count} thẻ khác",
  weekText: "Tuần {count}",
  rangeStartLabel: "Từ",
  rangeEndLabel: "Tới",
  rangeStartHelp: "Chọn",
  rangeEndHelp: "Chọn",
  filterEmptyText: "Không kết quả",
  filterPlaceholderText: "Tìm kiếm"
};
var zh = {
  setText: "确定",
  cancelText: "取消",
  clearText: "明确",
  closeText: "关闭",
  selectedText: "{count} 选",
  dateFormat: "YYYY年M月D日",
  dateFormatFull: "YYYY年M月D日",
  dateFormatLong: "YYYY年M月D日",
  dateWheelFormat: "|M月D日 DDD|",
  dayNames: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
  dayNamesShort: ["日", "一", "二", "三", "四", "五", "六"],
  dayNamesMin: ["日", "一", "二", "三", "四", "五", "六"],
  dayText: "日",
  hourText: "时",
  minuteText: "分",
  fromText: "开始时间",
  monthNames: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
  monthNamesShort: ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"],
  monthText: "月",
  secondText: "秒",
  timeFormat: "H:mm",
  yearText: "年",
  toText: "结束时间",
  nowText: "当前",
  pmText: "下午",
  amText: "上午",
  yearSuffix: "年",
  monthSuffix: "月",
  daySuffix: "日",
  todayText: "今天",
  dateText: "日",
  timeText: "时间",
  allDayText: "全天",
  noEventsText: "无事件",
  eventText: "活动",
  eventsText: "活动",
  moreEventsText: "他 {count} 件",
  weekText: "第 {count} 週",
  rangeStartLabel: "开始时间",
  rangeEndLabel: "结束时间",
  rangeStartHelp: "选取",
  rangeEndHelp: "选取",
  filterEmptyText: "没有结果",
  filterPlaceholderText: "搜索"
};
function intPart(floatNum) {
  if (floatNum < -1e-7) {
    return Math.ceil(floatNum - 1e-7);
  }
  return Math.floor(floatNum + 1e-7);
}
function hijriToGregorian(hY, hM, hD) {
  var l;
  var j;
  var n;
  var i;
  var k;
  var gregDate = new Array(3);
  var jd = intPart((11 * hY + 3) / 30) + 354 * hY + 30 * hM - intPart((hM - 1) / 2) + hD + 1948440 - 385;
  if (jd > 2299160) {
    l = jd + 68569;
    n = intPart(4 * l / 146097);
    l = l - intPart((146097 * n + 3) / 4);
    i = intPart(4e3 * (l + 1) / 1461001);
    l = l - intPart(1461 * i / 4) + 31;
    j = intPart(80 * l / 2447);
    hD = l - intPart(2447 * j / 80);
    l = intPart(j / 11);
    hM = j + 2 - 12 * l;
    hY = 100 * (n - 49) + i + l;
  } else {
    j = jd + 1402;
    k = intPart((j - 1) / 1461);
    l = j - 1461 * k;
    n = intPart((l - 1) / 365) - intPart(l / 1461);
    i = l - 365 * n + 30;
    j = intPart(80 * i / 2447);
    hD = i - intPart(2447 * j / 80);
    i = intPart(j / 11);
    hM = j + 2 - 12 * i;
    hY = 4 * k + n + i - 4716;
  }
  gregDate[2] = hD;
  gregDate[1] = hM;
  gregDate[0] = hY;
  return gregDate;
}
function gregorianToHijri(gY, gM, gD) {
  var jd;
  var l;
  var hijriDate = [0, 0, 0];
  if (gY > 1582 || gY === 1582 && gM > 10 || gY === 1582 && gM === 10 && gD > 14) {
    jd = intPart(1461 * (gY + 4800 + intPart((gM - 14) / 12)) / 4) + intPart(367 * (gM - 2 - 12 * intPart((gM - 14) / 12)) / 12) - intPart(3 * intPart((gY + 4900 + intPart((gM - 14) / 12)) / 100) / 4) + gD - 32075;
  } else {
    jd = 367 * gY - intPart(7 * (gY + 5001 + intPart((gM - 9) / 7)) / 4) + intPart(275 * gM / 9) + gD + 1729777;
  }
  l = jd - 1948440 + 10632;
  var n = intPart((l - 1) / 10631);
  l = l - 10631 * n + 354;
  var j = intPart((10985 - l) / 5316) * intPart(50 * l / 17719) + intPart(l / 5670) * intPart(43 * l / 15238);
  l = l - intPart((30 - j) / 15) * intPart(17719 * j / 50) - intPart(j / 16) * intPart(15238 * j / 43) + 29;
  gM = intPart(24 * l / 709);
  gD = l - intPart(709 * gM / 24);
  gY = 30 * n + j - 30;
  hijriDate[2] = gD;
  hijriDate[1] = gM;
  hijriDate[0] = gY;
  return hijriDate;
}
var hijriCalendar = {
  getYear: function(date) {
    return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[0];
  },
  getMonth: function(date) {
    return --gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[1];
  },
  getDay: function(date) {
    return gregorianToHijri(date.getFullYear(), date.getMonth() + 1, date.getDate())[2];
  },
  getDate: function(y, m, d, h, i, s, u) {
    if (m < 0) {
      y += Math.floor(m / 12);
      m = m % 12 ? 12 + m % 12 : 0;
    }
    if (m > 11) {
      y += Math.floor(m / 12);
      m = m % 12;
    }
    var gregorianDate = hijriToGregorian(y, +m + 1, d);
    return new Date(gregorianDate[0], gregorianDate[1] - 1, gregorianDate[2], h || 0, i || 0, s || 0, u || 0);
  },
  getMaxDayOfMonth: function(hY, hM) {
    if (hM < 0) {
      hY += Math.floor(hM / 12);
      hM = hM % 12 ? 12 + hM % 12 : 0;
    }
    if (hM > 11) {
      hY += Math.floor(hM / 12);
      hM = hM % 12;
    }
    var daysPerMonth = [30, 29, 30, 29, 30, 29, 30, 29, 30, 29, 30, 29];
    var leapYear = (hY * 11 + 14) % 30 < 11;
    return daysPerMonth[hM] + (hM === 11 && leapYear ? 1 : 0);
  }
};
var localeEn = {};
var locale = {
  ar,
  bg,
  ca,
  cs,
  da,
  de,
  el,
  en: localeEn,
  "en-GB": enGB,
  es,
  fa,
  fi,
  fr,
  he,
  hi,
  hr,
  hu,
  it,
  ja,
  ko,
  lt,
  nl,
  no,
  pl,
  "pt-BR": localePtBR,
  "pt-PT": ptPT,
  ro,
  ru,
  "ru-UA": localeRuUA,
  sk,
  sr,
  sv,
  th,
  tr,
  ua,
  vi,
  zh
};
var MBSC_OPTIONS = new InjectionToken("MbscOptions");
var MbscOptionsService = function() {
  function MbscOptionsService2(_staticOptions, _parentService) {
    this._staticOptions = _staticOptions;
    this._parentService = _parentService;
    this.change = new Observable();
    this._options = {};
  }
  Object.defineProperty(MbscOptionsService2.prototype, "options", {
    get: function() {
      return this._options;
    },
    enumerable: false,
    configurable: true
  });
  MbscOptionsService2.prototype.setOptions = function(newOptions) {
    this._options = this._parentService ? __assign(__assign(__assign({}, this._staticOptions), this._parentService.options), newOptions) : __assign(__assign({}, this._staticOptions), newOptions);
    this.change.next(this.options);
  };
  MbscOptionsService2.ɵfac = function MbscOptionsService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscOptionsService2)(ɵɵinject(MBSC_OPTIONS, 8), ɵɵinject(forwardRef(function() {
      return MbscOptionsService2;
    }), 12));
  };
  MbscOptionsService2.ɵprov = ɵɵdefineInjectable({
    token: MbscOptionsService2,
    factory: MbscOptionsService2.ɵfac
  });
  return MbscOptionsService2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscOptionsService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MBSC_OPTIONS]
      }]
    }, {
      type: MbscOptionsService,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }, {
        type: Inject,
        args: [forwardRef(function() {
          return MbscOptionsService;
        })]
      }]
    }];
  }, null);
})();
function updateValue(inst, val) {
  inst._val = val;
  if (inst._onValueChange) {
    inst._onValueChange(val);
  }
  inst.setState({
    value: val
  });
}
var Base = function() {
  function Base2(_cdr, _elr, _zone, _sanitizer, _injector, _vcf, _ctrl, _optp, _globals) {
    var _this = this;
    this._cdr = _cdr;
    this._elr = _elr;
    this._zone = _zone;
    this._sanitizer = _sanitizer;
    this._injector = _injector;
    this._vcf = _vcf;
    this._ctrl = _ctrl;
    this._optp = _optp;
    this.valueChange = new EventEmitter();
    this.onDestroy = new EventEmitter();
    this.onInit = new EventEmitter(true);
    this.state = {};
    this.props = {};
    this._onFormChange = noop;
    this._onFormTouch = noop;
    if (_optp) {
      this._opt = _optp.options;
      this._ctxChange = _optp.change.subscribe(function(nextOptions) {
        _this._opt = nextOptions;
        _this.forceUpdate();
      });
    } else if (_globals) {
      this._opt = _globals;
    }
    if (_ctrl) {
      _ctrl.valueAccessor = this;
    }
    this._ctor();
  }
  Object.defineProperty(Base2.prototype, "value", {
    get: function() {
      return this._val;
    },
    set: function(val) {
      if (this._val !== val) {
        updateValue(this, val);
        this._onFormChange(val);
        this.valueChange.emit(val);
      }
    },
    enumerable: false,
    configurable: true
  });
  Base2.prototype.ngOnChanges = function(changes) {
    var optionsKey = "options";
    var optionsChange = changes[optionsKey];
    if (optionsChange) {
      var opt = optionsChange.currentValue;
      if (opt) {
        for (var _i = 0, _a = Object.keys(opt); _i < _a.length; _i++) {
          var key = _a[_i];
          this.props[key] = opt[key];
        }
      }
    }
    for (var _b = 0, _c = Object.keys(changes); _b < _c.length; _b++) {
      var key = _c[_b];
      this.props[key] = changes[key].currentValue;
    }
    this._doCheck = true;
  };
  Base2.prototype.ngDoCheck = function() {
    if (this._doCheck) {
      this._willUpdate();
    }
  };
  Base2.prototype.ngAfterViewChecked = function() {
    if (this._doCheck) {
      this._updated();
    }
    this._doCheck = false;
  };
  Base2.prototype.ngOnInit = function() {
    this._doCheck = true;
    this._init();
  };
  Base2.prototype.ngAfterViewInit = function() {
    this._el = this._el || this._elr.nativeElement;
    this._baseInit();
    this._mounted();
  };
  Base2.prototype.ngOnDestroy = function() {
    if (this._optp) {
      this._optp.change.unsubscribe(this._ctxChange);
    }
    this._destroy();
    this._baseDestroy();
  };
  Base2.prototype._getKey = function(index) {
    return index;
  };
  Base2.prototype.forceUpdate = function() {
    var _this = this;
    if (NgZone.isInAngularZone()) {
      this._doCheck = true;
      this._cdr.markForCheck();
    } else {
      this._zone.run(function() {
        _this._doCheck = true;
        _this._cdr.markForCheck();
      });
    }
  };
  Base2.prototype.setState = function(newState) {
    var changed;
    for (var _i = 0, _a = Object.keys(newState); _i < _a.length; _i++) {
      var key = _a[_i];
      if (this.state[key] !== newState[key]) {
        this.state[key] = newState[key];
        changed = true;
      }
    }
    if (changed) {
      this.forceUpdate();
    }
  };
  Base2.prototype._emit = function(name, args) {
    var emitter = this[name];
    if (emitter && emitter instanceof EventEmitter) {
      emitter.emit(args);
    }
  };
  Base2.prototype._safeHtml = function(html) {
    return this._sanitizer.bypassSecurityTrustHtml(html);
  };
  Base2.prototype._ctor = function() {
  };
  Base2.prototype._init = function() {
  };
  Base2.prototype._baseInit = function() {
  };
  Base2.prototype._mounted = function() {
  };
  Base2.prototype._updated = function() {
  };
  Base2.prototype._destroy = function() {
  };
  Base2.prototype._baseDestroy = function() {
  };
  Base2.prototype._willUpdate = function() {
  };
  Base2.ɵfac = function Base_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Base2)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(MbscOptionsService, 8), ɵɵdirectiveInject(MBSC_OPTIONS, 8));
  };
  Base2.ɵdir = ɵɵdefineDirective({
    type: Base2,
    selectors: [["", "mbsc-b", ""]],
    inputs: {
      class: "class",
      context: "context",
      locale: "locale",
      modules: "modules",
      options: "options",
      responsive: "responsive",
      rtl: "rtl",
      theme: "theme",
      themeVariant: "themeVariant",
      touchUi: "touchUi",
      value: "value"
    },
    outputs: {
      valueChange: "valueChange",
      onDestroy: "onDestroy",
      onInit: "onInit"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature]
  });
  return Base2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Base, [{
    type: Directive,
    args: [{
      selector: "[mbsc-b]"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: DomSanitizer
    }, {
      type: Injector
    }, {
      type: ViewContainerRef
    }, {
      type: NgControl,
      decorators: [{
        type: Optional
      }, {
        type: Self
      }]
    }, {
      type: MbscOptionsService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MBSC_OPTIONS]
      }]
    }];
  }, {
    class: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    locale: [{
      type: Input
    }],
    modules: [{
      type: Input
    }],
    options: [{
      type: Input
    }],
    responsive: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    themeVariant: [{
      type: Input
    }],
    touchUi: [{
      type: Input
    }],
    valueChange: [{
      type: Output
    }],
    onDestroy: [{
      type: Output
    }],
    onInit: [{
      type: Output
    }],
    value: [{
      type: Input
    }]
  });
})();
var REF_DATE = new Date(1970, 0, 1);
var ONE_MIN = 6e4;
var ONE_HOUR = 60 * ONE_MIN;
var ONE_DAY = 24 * ONE_HOUR;
function isMBSCDate(d) {
  return !!d._mbsc;
}
function convertTimezone(d, s, tz) {
  var timezone = tz || s.dataTimezone || s.displayTimezone;
  var timezonePlugin = s.timezonePlugin;
  if (timezone && timezonePlugin && isMBSCDate(d)) {
    var clone = d.clone();
    clone.setTimezone(timezone);
    return clone.toISOString();
  }
  return d;
}
var dateTimeLocale = {
  amText: "am",
  dateFormat: "MM/DD/YYYY",
  dateFormatFull: "DDDD, MMMM D, YYYY",
  dateFormatLong: "D DDD MMM YYYY",
  dateText: "Date",
  dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  dayNamesMin: ["S", "M", "T", "W", "T", "F", "S"],
  dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  daySuffix: "",
  dayText: "Day",
  firstDay: 0,
  fromText: "Start",
  getDate: adjustedDate,
  hourText: "Hour",
  minuteText: "Minute",
  monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  monthSuffix: "",
  monthText: "Month",
  pmText: "pm",
  quarterText: "Q{count}",
  secondText: "Second",
  separator: " ",
  shortYearCutoff: "+10",
  timeFormat: "h:mm A",
  timeText: "Time",
  toText: "End",
  todayText: "Today",
  weekText: "Week {count}",
  yearSuffix: "",
  yearText: "Year",
  getMonth: function(d) {
    return d.getMonth();
  },
  getDay: function(d) {
    return d.getDate();
  },
  getYear: function(d) {
    return d.getFullYear();
  },
  getMaxDayOfMonth: function(y, m) {
    return 32 - new Date(y, m, 32, 12).getDate();
  },
  getWeekNumber: function(dt) {
    var d = /* @__PURE__ */ new Date(+dt);
    d.setHours(0, 0, 0);
    d.setDate(d.getDate() + 4 - (d.getDay() || 7));
    var yearStart = new Date(d.getFullYear(), 0, 1);
    return Math.ceil(((d - yearStart) / 864e5 + 1) / 7);
  }
};
var ISO_8601_FULL = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[T\s](\d{2}):?(\d{2})(?::?(\d{2})(?:\.(\d{3}))?)?((Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
var ISO_8601_TIME = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function setISOParts(parsed, offset, parts) {
  var part;
  var v;
  var p = {
    y: 1,
    m: 2,
    d: 3,
    h: 4,
    i: 5,
    s: 6,
    u: 7,
    tz: 8
  };
  if (parts) {
    for (var _i = 0, _a = Object.keys(p); _i < _a.length; _i++) {
      part = _a[_i];
      v = parsed[p[part] - offset];
      if (v) {
        parts[part] = part === "tz" ? v : 1;
      }
    }
  }
}
function getISOString(d, parts) {
  var ret = "";
  var time = "";
  if (d) {
    if (parts.h) {
      time += pad(d.getHours()) + ":" + pad(d.getMinutes());
      if (parts.s) {
        time += ":" + pad(d.getSeconds());
      }
      if (parts.u) {
        time += "." + pad(d.getMilliseconds(), 3);
      }
      if (parts.tz) {
        time += parts.tz;
      }
    }
    if (parts.y) {
      ret += d.getFullYear();
      if (parts.m) {
        ret += "-" + pad(d.getMonth() + 1);
        if (parts.d) {
          ret += "-" + pad(d.getDate());
        }
        if (parts.h) {
          ret += "T" + time;
        }
      }
    } else if (parts.h) {
      ret = time;
    }
  }
  return ret;
}
function getDayMilliseconds(d) {
  var dd = new Date(1970, 0, 1, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
  return +dd - +REF_DATE;
}
function checkDateRangeOverlap(start1, end1, start2, end2, adjust) {
  var aStart = +start1;
  var bStart = +start2;
  var aEnd = adjust && aStart === +end1 ? +end1 + 1 : +end1;
  var bEnd = adjust && bStart === +end2 ? +end2 + 1 : +end2;
  return aStart < bEnd && aEnd > bStart;
}
function getDayStart(s, d) {
  var newDate = createDate$1(s, d);
  newDate.setHours(0, 0, 0, 0);
  return newDate;
}
function getDayEnd(s, d) {
  var newDate = createDate$1(s, d);
  newDate.setHours(23, 59, 59, 999);
  return newDate;
}
function getEndDate(s, allDay, start, end, isList) {
  var exclusive = allDay || isList ? s.exclusiveEndDates : true;
  var tzOpt = allDay ? UNDEFINED : s;
  return exclusive && start && end && start < end ? createDate$1(tzOpt, +end - 1) : end;
}
function getDateStr(d) {
  return d.getFullYear() + "-" + pad(d.getMonth() + 1) + "-" + pad(d.getDate());
}
function getDateOnly(d, nativeDate) {
  if (isMBSCDate(d) && !nativeDate) {
    return d.createDate(d.getFullYear(), d.getMonth(), d.getDate());
  } else {
    return adjustedDate(d.getFullYear(), d.getMonth(), d.getDate());
  }
}
function getUTCDateOnly(d) {
  return Date.UTC(d.getFullYear(), d.getMonth(), d.getDate());
}
function getDayDiff(d1, d2) {
  return round((getUTCDateOnly(d2) - getUTCDateOnly(d1)) / ONE_DAY);
}
function getGridDayDiff(from, to, startDay, endDay) {
  var dayIndex = -1;
  for (var d = getDateOnly(from); d <= getDateOnly(to); d.setDate(d.getDate() + 1)) {
    if (isInWeek(d.getDay(), startDay, endDay)) {
      dayIndex++;
    }
  }
  return dayIndex;
}
function getFirstDayOfWeek(d, s, w2) {
  var y = d.getFullYear();
  var m = d.getMonth();
  var weekDay = d.getDay();
  var firstWeekDay = w2 === UNDEFINED ? s.firstDay : w2;
  var offset = firstWeekDay - weekDay > 0 ? 7 : 0;
  return new Date(y, m, firstWeekDay - offset - weekDay + d.getDate());
}
function isSameDay(d1, d2) {
  return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth() && d1.getDate() === d2.getDate();
}
function isSameMonth(d1, d2, s) {
  return s.getYear(d1) === s.getYear(d2) && s.getMonth(d1) === s.getMonth(d2);
}
function adjustedDate(y, m, d, h, i, s, u) {
  var date = new Date(y, m, d, h || 0, i || 0, s || 0, u || 0);
  if (date.getHours() === 23 && (h || 0) === 0) {
    date.setHours(date.getHours() + 2);
  }
  return date;
}
function isDate(d) {
  return d.getTime;
}
function isTime(d) {
  return isString(d) && ISO_8601_TIME.test(d);
}
function addTimezone(s, d) {
  return createDate$1(s, d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
}
function removeTimezone(d) {
  if (!d) {
    return d;
  } else {
    return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
  }
}
function createDate$1(s, yearOrStamp, month, date, h, min, sec, ms) {
  if (yearOrStamp === null) {
    return null;
  }
  if (yearOrStamp && (isNumber(yearOrStamp) || isString(yearOrStamp)) && isUndefined(month)) {
    return makeDate(yearOrStamp, s);
  }
  if (s && s.timezonePlugin) {
    return s.timezonePlugin.createDate(s, yearOrStamp, month, date, h, min, sec, ms);
  }
  if (isObject(yearOrStamp)) {
    return new Date(yearOrStamp);
  }
  if (isUndefined(yearOrStamp)) {
    return /* @__PURE__ */ new Date();
  }
  return new Date(yearOrStamp, month || 0, date || 1, h || 0, min || 0, sec || 0, ms || 0);
}
function makeDate(d, s, format, parts, skipTimezone) {
  var parse;
  if (isString(d)) {
    d = d.trim();
  }
  if (!d) {
    return null;
  }
  var plugin = s && s.timezonePlugin;
  if (plugin && !skipTimezone) {
    var parsedDate = isMBSCDate(d) ? d : plugin.parse(d, s);
    parsedDate.setTimezone(s.displayTimezone);
    return parsedDate;
  }
  if (isDate(d)) {
    return d;
  }
  if (d._isAMomentObject) {
    return d.toDate();
  }
  if (isNumber(d)) {
    return new Date(d);
  }
  parse = ISO_8601_TIME.exec(d);
  var defVal = s && s.defaultValue;
  var def = makeDate((isArray(defVal) ? defVal[0] : defVal) || /* @__PURE__ */ new Date());
  var defYear = def.getFullYear();
  var defMonth = def.getMonth();
  var defDay = def.getDate();
  if (parse) {
    setISOParts(parse, 2, parts);
    return new Date(defYear, defMonth, defDay, parse[2] ? +parse[2] : 0, parse[3] ? +parse[3] : 0, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0);
  }
  parse = ISO_8601_FULL.exec(d);
  if (parse) {
    setISOParts(parse, 0, parts);
    return new Date(parse[1] ? +parse[1] : defYear, parse[2] ? parse[2] - 1 : defMonth, parse[3] ? +parse[3] : defDay, parse[4] ? +parse[4] : 0, parse[5] ? +parse[5] : 0, parse[6] ? +parse[6] : 0, parse[7] ? +parse[7] : 0);
  }
  return parseDate(format, d, s);
}
function returnDate(d, s, displayFormat, isoParts, hasTimePart) {
  var moment = isBrowser && window.moment || s.moment;
  var timezone = s.timezonePlugin && (s.dataTimezone || s.displayTimezone);
  var format = timezone ? "iso8601" : s.returnFormat;
  if (timezone && hasTimePart) {
    return convertTimezone(d, s);
  }
  if (d) {
    if (format === "moment" && moment) {
      return moment(d);
    }
    if (format === "locale") {
      return formatDate(displayFormat, d, s);
    }
    if (format === "iso8601") {
      return getISOString(d, isoParts);
    }
  }
  return d;
}
function formatDatePublic(format, date, options$1) {
  var s = __assign(__assign(__assign({}, dateTimeLocale), options.locale), options$1);
  return formatDate(format, date, s);
}
function formatDate(format, date, s) {
  var i;
  var year;
  var output = "";
  var literal = false;
  var c;
  var peekAhead = function(symbol) {
    var nr = 0;
    var j = i;
    while (j + 1 < format.length && format.charAt(j + 1) === symbol) {
      nr++;
      j++;
    }
    return nr;
  };
  var lookAhead = function(symbol) {
    var nr = peekAhead(symbol);
    i += nr;
    return nr;
  };
  var formatNumber = function(symbol, val, len) {
    var ret = "" + val;
    if (lookAhead(symbol)) {
      while (ret.length < len) {
        ret = "0" + ret;
      }
    }
    return ret;
  };
  var formatName = function(symbol, val, short, long) {
    return lookAhead(symbol) === 3 ? long[val] : short[val];
  };
  for (i = 0; i < format.length; i++) {
    if (literal) {
      if (format.charAt(i) === "'" && !lookAhead("'")) {
        literal = false;
      } else {
        output += format.charAt(i);
      }
    } else {
      switch (format.charAt(i)) {
        case "D":
          c = peekAhead("D");
          if (c > 1) {
            output += formatName("D", date.getDay(), s.dayNamesShort, s.dayNames);
          } else {
            output += formatNumber("D", s.getDay(date), 2);
          }
          break;
        case "M":
          c = peekAhead("M");
          if (c > 1) {
            output += formatName("M", s.getMonth(date), s.monthNamesShort, s.monthNames);
          } else {
            output += formatNumber("M", s.getMonth(date) + 1, 2);
          }
          break;
        case "Y":
          year = s.getYear(date);
          output += lookAhead("Y") === 3 ? year : (year % 100 < 10 ? "0" : "") + year % 100;
          break;
        case "h": {
          var h = date.getHours();
          output += formatNumber("h", h > 12 ? h - 12 : h === 0 ? 12 : h, 2);
          break;
        }
        case "H":
          output += formatNumber("H", date.getHours(), 2);
          break;
        case "m":
          output += formatNumber("m", date.getMinutes(), 2);
          break;
        case "s":
          output += formatNumber("s", date.getSeconds(), 2);
          break;
        case "a":
          output += date.getHours() > 11 ? s.pmText : s.amText;
          break;
        case "A":
          output += date.getHours() > 11 ? s.pmText.toUpperCase() : s.amText.toUpperCase();
          break;
        case "'":
          if (lookAhead("'")) {
            output += "'";
          } else {
            literal = true;
          }
          break;
        default:
          output += format.charAt(i);
      }
    }
  }
  return output;
}
function parseDate(format, value, options2) {
  var s = __assign(__assign({}, dateTimeLocale), options2);
  var defVal = s.defaultValue;
  var def = makeDate((isArray(defVal) ? defVal[0] : defVal) || /* @__PURE__ */ new Date());
  if (!value) {
    return def;
  }
  if (!format) {
    format = s.dateFormat + s.separator + s.timeFormat;
  }
  var shortYearCutoff = s.shortYearCutoff;
  var year = s.getYear(def);
  var month = s.getMonth(def) + 1;
  var day = s.getDay(def);
  var hours = def.getHours();
  var minutes = def.getMinutes();
  var seconds = 0;
  var ampm = -1;
  var literal = false;
  var iValue = 0;
  var iFormat;
  var peekAhead = function(symbol) {
    var nr = 0;
    var j = iFormat;
    while (j + 1 < format.length && format.charAt(j + 1) === symbol) {
      nr++;
      j++;
    }
    return nr;
  };
  var lookAhead = function(match) {
    var matches2 = peekAhead(match);
    iFormat += matches2;
    return matches2;
  };
  var getNumber = function(match) {
    var count2 = lookAhead(match);
    var size = count2 >= 2 ? 4 : 2;
    var digits = new RegExp("^\\d{1," + size + "}");
    var num = value.substr(iValue).match(digits);
    if (!num) {
      return 0;
    }
    iValue += num[0].length;
    return parseInt(num[0], 10);
  };
  var getName = function(match, shortNames, longNames) {
    var count2 = lookAhead(match);
    var names = count2 === 3 ? longNames : shortNames;
    for (var i = 0; i < names.length; i++) {
      if (value.substr(iValue, names[i].length).toLowerCase() === names[i].toLowerCase()) {
        iValue += names[i].length;
        return i + 1;
      }
    }
    return 0;
  };
  var checkLiteral = function() {
    iValue++;
  };
  for (iFormat = 0; iFormat < format.length; iFormat++) {
    if (literal) {
      if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
        literal = false;
      } else {
        checkLiteral();
      }
    } else {
      switch (format.charAt(iFormat)) {
        case "Y":
          year = getNumber("Y");
          break;
        case "M": {
          var p = peekAhead("M");
          if (p < 2) {
            month = getNumber("M");
          } else {
            month = getName("M", s.monthNamesShort, s.monthNames);
          }
          break;
        }
        case "D": {
          var p = peekAhead("D");
          if (p < 2) {
            day = getNumber("D");
          } else {
            getName("D", s.dayNamesShort, s.dayNames);
          }
          break;
        }
        case "H":
          hours = getNumber("H");
          break;
        case "h":
          hours = getNumber("h");
          break;
        case "m":
          minutes = getNumber("m");
          break;
        case "s":
          seconds = getNumber("s");
          break;
        case "a":
          ampm = getName("a", [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
          break;
        case "A":
          ampm = getName("A", [s.amText, s.pmText], [s.amText, s.pmText]) - 1;
          break;
        case "'":
          if (lookAhead("'")) {
            checkLiteral();
          } else {
            literal = true;
          }
          break;
        default:
          checkLiteral();
      }
    }
  }
  if (year < 100) {
    var cutoffYear = void 0;
    if (!isString(shortYearCutoff)) {
      cutoffYear = +shortYearCutoff;
    } else {
      cutoffYear = (/* @__PURE__ */ new Date()).getFullYear() % 100 + parseInt(shortYearCutoff, 10);
    }
    var addedCentury = void 0;
    if (year <= cutoffYear) {
      addedCentury = 0;
    } else {
      addedCentury = -100;
    }
    year += (/* @__PURE__ */ new Date()).getFullYear() - (/* @__PURE__ */ new Date()).getFullYear() % 100 + addedCentury;
  }
  hours = ampm === -1 ? hours : ampm && hours < 12 ? hours + 12 : !ampm && hours === 12 ? 0 : hours;
  var date = s.getDate(year, month - 1, day, hours, minutes, seconds);
  if (s.getYear(date) !== year || s.getMonth(date) + 1 !== month || s.getDay(date) !== day) {
    return def;
  }
  return date;
}
function dateValueEquals(v1, v2, s) {
  if (v1 === v2) {
    return true;
  }
  if (isArray(v1) && !v1.length && v2 === null || isArray(v2) && !v2.length && v1 === null) {
    return true;
  }
  if (v1 === null || v2 === null || v1 === UNDEFINED || v2 === UNDEFINED) {
    return false;
  }
  if (isString(v1) && isString(v2)) {
    return v1 === v2;
  }
  var dateFormat = s && s.dateFormat;
  if (isArray(v1) || isArray(v2)) {
    if (v1.length !== v2.length) {
      return false;
    }
    for (var i = 0; i < v1.length; i++) {
      var eq = true;
      var a = v1[i];
      var b = v2[i];
      if (isString(a) && isString(b)) {
        eq = a === b;
      } else {
        eq = +makeDate(a, s, dateFormat) === +makeDate(b, s, dateFormat);
      }
      if (!eq) {
        return false;
      }
    }
    return true;
  }
  return +makeDate(v1, s, dateFormat) === +makeDate(v2, s, dateFormat);
}
function cloneDate(date) {
  return isMBSCDate(date) ? date.clone() : new Date(date);
}
function addDays(date, days) {
  var copy = cloneDate(date);
  copy.setDate(copy.getDate() + days);
  return copy;
}
function addMonths(date, months, s) {
  var year = s.getYear(date);
  var month = s.getMonth(date) + months;
  var maxDays = s.getMaxDayOfMonth(year, month);
  return addTimezone(s, s.getDate(year, month, Math.min(s.getDay(date), maxDays), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
}
function addTime(date, time, s) {
  var d1 = addTimezone(s, date);
  var d2 = createDate$1(s, +d1 + time);
  var diff = d2.getTimezoneOffset() - d1.getTimezoneOffset();
  return diff ? createDate$1(s, +d2 + diff * ONE_MIN) : d2;
}
function isInWeek(day, startDay, endDay) {
  return startDay > endDay ? day <= endDay || day >= startDay : day >= startDay && day <= endDay;
}
function roundTime(date, step2) {
  var ms = ONE_MIN * step2;
  var copy = cloneDate(date).setHours(0, 0, 0, 0);
  var rounded = copy + Math.round((+date - +copy) / ms) * ms;
  return isMBSCDate(date) ? date.createDate(rounded) : new Date(rounded);
}
function constrainDate(date, min, max) {
  return min && date < min ? new Date(min) : max && date > max ? new Date(max) : date;
}
if (isBrowser && typeof Symbol === "undefined") {
  window.Symbol = {
    toPrimitive: "toPrimitive"
  };
}
var doc = isBrowser ? document : UNDEFINED;
var win = isBrowser ? window : UNDEFINED;
var prefixes = ["Webkit", "Moz"];
var elem = doc && doc.createElement("div").style;
var canvas = doc && doc.createElement("canvas");
var ctx = canvas && canvas.getContext && canvas.getContext("2d", {
  willReadFrequently: true
});
var css = win && win.CSS;
var cssSupports = css && css.supports;
var textColors = {};
var raf = win && win.requestAnimationFrame || function(func) {
  return setTimeout(func, 20);
};
var rafc = win && win.cancelAnimationFrame || function(id2) {
  clearTimeout(id2);
};
var hasAnimation = elem && elem.animationName !== UNDEFINED;
var isWebView = os === "ios" && !isSafari;
var isWkWebView = isWebView && win && win.webkit && win.webkit.messageHandlers;
var hasGhostClick = elem && elem.touchAction === UNDEFINED || isWebView && !isWkWebView;
var jsPrefix = getPrefix();
var cssPrefix = jsPrefix ? "-" + jsPrefix.toLowerCase() + "-" : "";
var has3d = cssSupports && cssSupports("(transform-style: preserve-3d)");
var hasSticky = cssSupports && (cssSupports("position", "sticky") || cssSupports("position", "-webkit-sticky"));
function getPrefix() {
  if (!elem || elem.transform !== UNDEFINED) {
    return "";
  }
  for (var _i = 0, prefixes_1 = prefixes; _i < prefixes_1.length; _i++) {
    var prefix = prefixes_1[_i];
    if (elem[prefix + "Transform"] !== UNDEFINED) {
      return prefix;
    }
  }
  return "";
}
function listen(el2, event, handler, opt) {
  if (el2) {
    el2.addEventListener(event, handler, opt);
  }
}
function unlisten(el2, event, handler, opt) {
  if (el2) {
    el2.removeEventListener(event, handler, opt);
  }
}
function getDocument(el2) {
  if (!isBrowser) {
    return UNDEFINED;
  }
  return el2 && el2.ownerDocument ? el2.ownerDocument : doc;
}
function getDimension(el2, property) {
  return parseFloat(getComputedStyle(el2)[property] || "0");
}
function getContext(context, docu) {
  var contextElm = isString(context) ? docu.querySelector(context) : context;
  if (!contextElm) {
    contextElm = docu.body;
  }
  return contextElm;
}
function getScrollLeft(el2) {
  return el2.scrollLeft !== UNDEFINED ? el2.scrollLeft : el2.pageXOffset;
}
function getScrollTop(el2) {
  return el2.scrollTop !== UNDEFINED ? el2.scrollTop : el2.pageYOffset;
}
function setScrollLeft(el2, val) {
  if (el2.scrollTo) {
    el2.scrollTo(val, el2.scrollY);
  } else {
    el2.scrollLeft = val;
  }
}
function setScrollTop(el2, val) {
  if (el2.scrollTo) {
    el2.scrollTo(el2.scrollX, val);
  } else {
    el2.scrollTop = val;
  }
}
function getWindow(el2) {
  if (!isBrowser) {
    return UNDEFINED;
  }
  return el2 && el2.ownerDocument && el2.ownerDocument.defaultView ? el2.ownerDocument.defaultView : win;
}
function getPosition(el2, vertical) {
  var style = getComputedStyle(el2);
  var transform = jsPrefix ? style[jsPrefix + "Transform"] : style.transform;
  var matrix = transform.split(")")[0].split(", ");
  var px = vertical ? matrix[13] || matrix[5] : matrix[12] || matrix[4];
  return +px || 0;
}
function getTextColor(color) {
  if (!ctx || !color) {
    return "#000";
  }
  if (textColors[color]) {
    return textColors[color];
  }
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, 1, 1);
  var img = ctx.getImageData(0, 0, 1, 1);
  var rgb = img ? img.data : [0, 0, 0];
  var delta = +rgb[0] * 0.299 + +rgb[1] * 0.587 + +rgb[2] * 0.114;
  var textColor = delta < 130 ? "#fff" : "#000";
  textColors[color] = textColor;
  return textColor;
}
function smoothScroll(elm, toX, toY, animate, rtl, callback) {
  function scrollStep() {
    var elapsed = Math.min(1, (+/* @__PURE__ */ new Date() - startTime) / 468);
    var eased = 0.5 * (1 - Math.cos(Math.PI * elapsed));
    var currentX = round(fromX + (targetX - fromX) * eased);
    var currentY = round(fromY + (targetY - fromY) * eased);
    elm.scrollLeft = currentX;
    elm.scrollTop = currentY;
    if (currentX !== targetX || currentY !== targetY) {
      raf(function() {
        scrollStep();
      });
    } else if (callback) {
      running = false;
      callback();
    }
  }
  var startTime = +/* @__PURE__ */ new Date();
  var fromX = round(elm.scrollLeft);
  var fromY = round(elm.scrollTop);
  var targetX = toX === UNDEFINED ? fromX : Math.max(0, round(toX)) * (rtl ? -1 : 1);
  var targetY = toY === UNDEFINED ? fromY : Math.max(0, round(toY));
  var running;
  if (animate) {
    running = true;
    scrollStep();
  } else {
    elm.scrollLeft = targetX;
    elm.scrollTop = targetY;
    if (callback) {
      callback();
    }
  }
  return function(newX, newY) {
    targetX = newX === UNDEFINED ? targetX : Math.max(0, round(newX)) * (rtl ? -1 : 1);
    targetY = newY === UNDEFINED ? targetY : Math.max(0, round(newY));
    if (!animate || !running) {
      elm.scrollLeft = targetX;
      elm.scrollTop = targetY;
    }
  };
}
function htmlToText(htmlString) {
  if (doc && htmlString) {
    var tempElm = doc.createElement("div");
    tempElm.innerHTML = htmlString;
    return tempElm.textContent.trim();
  }
  return htmlString || "";
}
function getOffset(el2) {
  var bRect = el2.getBoundingClientRect();
  var ret = {
    left: bRect.left,
    top: bRect.top
  };
  var window2 = getWindow(el2);
  if (window2 !== UNDEFINED) {
    ret.top += getScrollTop(window2);
    ret.left += getScrollLeft(window2);
  }
  return ret;
}
function matches(elm, selector) {
  var matchesSelector = elm && (elm.matches || elm.msMatchesSelector);
  return matchesSelector && matchesSelector.call(elm, selector);
}
function closest(elm, selector, context) {
  while (elm && !matches(elm, selector)) {
    if (elm === context || elm.nodeType === elm.DOCUMENT_NODE) {
      return null;
    }
    elm = elm.parentNode;
  }
  return elm;
}
function contains(container, elm) {
  var currentElm = elm;
  while (currentElm && currentElm.parentNode) {
    if (currentElm.parentNode === container) {
      return true;
    } else {
      currentElm = currentElm.parentNode;
    }
    if (currentElm instanceof DocumentFragment) {
      currentElm = currentElm.host;
    }
  }
  return false;
}
function trigger(elm, name, data) {
  var evt;
  try {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true,
      detail: data
    });
  } catch (e) {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
    evt.detail = data;
  }
  elm.dispatchEvent(evt);
}
function forEach(items, func) {
  for (var i = 0; i < items.length; i++) {
    func(items[i], i);
  }
}
var w = win;
var id$1 = +/* @__PURE__ */ new Date();
var trialError;
var logData = {};
var logTimer;
var textParam = {};
function sendLog(comp) {
  if (comp._logged || remote.apiKey === "mbscdemo" || !doc) {
    return;
  }
  comp._logged = true;
  logData.components = logData.components || [];
  logData.components.push(comp.constructor._name.toLowerCase());
  clearTimeout(logTimer);
  logTimer = setTimeout(function() {
    if (!remote.fwv) {
      var vers = void 0;
      switch (remote.fw) {
        case "angular": {
          var vEl = doc.querySelector("[ng-version]");
          vers = vEl ? vEl.getAttribute("ng-version") : "N/A";
          break;
        }
        case "jquery":
          vers = w.$.fn && w.$.fn.jquery;
          break;
      }
      remote.fwv = vers || "N/A";
    }
    logData.demo = !!w.isMbscDemo;
    logData.fw = remote.fw;
    logData.fwv = remote.fwv;
    logData.theme = comp.s.theme;
    logData.trialCode = remote.apiKey;
    logData.v = comp._v.version;
    jsonp$1("log", null, logData, function() {
      logData = {};
    });
  }, 5e3);
}
function showMessage(notification) {
  if (notification && doc) {
    var byId = doc.getElementById("trial-message");
    if (!byId) {
      var div_1 = doc.createElement("div");
      div_1.setAttribute("id", "trial-message");
      div_1.setAttribute("style", "position: absolute;width: 100%; bottom: 0;left: 0; padding: 10px;box-sizing: border-box;");
      div_1.setAttribute("class", "mbsc-font");
      var innerDiv = doc.createElement("div");
      innerDiv.setAttribute("style", "padding: 15px 25px; max-width: 400px; margin: 0 auto 10px auto; border-radius: 16px; line-height: 25px; background: #cacaca59; font-size: 15px; color: #151515;");
      innerDiv.innerHTML = notification.message + " ";
      var button = doc.createElement("a");
      button.innerHTML = notification.button.text;
      button.setAttribute("style", "color: #FF4080;font-weight: 600;");
      button.setAttribute("href", "https://mobiscroll.com/pricing?ref=trialapp");
      innerDiv.appendChild(button);
      div_1.appendChild(innerDiv);
      doc.body.appendChild(div_1);
      setTimeout(function() {
        doc.body.removeChild(div_1);
      }, 6e3);
    }
  }
}
function jsonp$1(method, inst, data, callback, uniqueId, attempts) {
  if (!win || !doc) {
    callback({});
    return;
  }
  var script = doc.createElement("script");
  var unique = "mbsc_jsonp_" + (uniqueId ? uniqueId : ++id$1);
  unique = win[unique] ? "mbsc_jsonp_" + ++id$1 : unique;
  var att = attempts || 1;
  function onError() {
    if (win && win[unique]) {
      win[unique](null, true);
    }
    if (method === "remote") {
      if (att < 4) {
        jsonp$1(method, inst, data, callback, uniqueId, att + 1);
      } else if (!trialError) {
        trialError = true;
        sendError();
      }
    }
  }
  win[unique] = function(resp, error) {
    clearTimeout(timer);
    script.parentNode.removeChild(script);
    delete win[unique];
    resp = resp ? JSON.parse(resp, function(key, value) {
      if (typeof value !== "string") {
        return value;
      }
      if (value.substring(0, 9) === "function_" && inst) {
        return inst[value.replace("function_", "")];
      }
      if (value.match(ISO_8601_FULL)) {
        return makeDate(value);
      }
      return value;
    }) : {};
    if (method === "remote") {
      textParam.txt = resp.__e;
      delete resp.__e;
    }
    if (!error) {
      callback(resp);
    }
  };
  var timer = setTimeout(onError, 6e3);
  script.onerror = onError;
  script.src = remote.apiUrl + remote.apiKey + "/" + method + "?callback=" + unique + "&data=" + encodeURIComponent(JSON.stringify(data));
  doc.body.appendChild(script);
}
function sendError() {
  var sessionID = doc.cookie.replace(/(?:(?:^|.*;\s*)ASP.NET_SessionId\s*=\s*([^;]*).*$)|^.*$/, "$1");
  doc.cookie = "mobiscrollClientError=1; expires=" + new Date((/* @__PURE__ */ new Date()).getTime() + 1e3 * 60 * 60 * 24).toUTCString() + "; path=/; SameSite=Strict";
  try {
    win.name = (win.name || "") + ";mobiscrollClientError";
  } catch (e) {
  }
  jsonp$1("error", null, {
    sessionID,
    trialCode: remote.apiKey
  }, function() {
    doc.cookie = "mobiscrollClientError=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/";
    try {
      win.name = (win.name || "").replace(/;mobiscrollClientError/g, "");
    } catch (e) {
    }
  });
}
if (doc && (doc.cookie.replace(/(?:(?:^|.*;\s*)mobiscrollClientError\s*=\s*([^;]*).*$)|^.*$/, "$1") || /mobiscrollClientError/.test(win.name || ""))) {
  doc.addEventListener("DOMContentLoaded", function() {
    sendError();
  });
}
var getText = new Function("textParam,p", function() {
  function getKey(encryptKey) {
    var a2 = encryptKey[0];
    for (var i = 0; i < 16; ++i) {
      if (a2 * i % 16 == 1) {
        return [i, encryptKey[1]];
      }
    }
  }
  function affine(enc, str, a2, b2) {
    var alfb = "0123456789abcdef";
    var len = str.length;
    var newstr = "";
    for (var i = 0; i < len; ++i) {
      newstr += alfb[((a2 * alfb.indexOf(str[i]) - a2 * b2) % 16 + 16) % 16];
    }
    return newstr;
  }
  function decrypt(str, encryptKey) {
    var decryptKey = getKey(encryptKey);
    var decryptedStr = affine(0, str, decryptKey[0], decryptKey[1]);
    var len = decryptedStr.length;
    var arr = [];
    for (var i = 0; i < len; i += 2) {
      arr.push(decryptedStr[i] + decryptedStr[i + 1]);
    }
    return arr;
  }
  var a = decrypt("7c7a797b7ce5707c58e17ae1eda67ee1e43d313b7ae57c757ae6a0cde17ce0a67ae1e6ecefeda0a934cde17ce0a6ede170a038a6383ea478a9aeaea17ce5707c58e17ae1eda67c707c3fa734ece97ea8737c79e4e53daaa7abee75e6e37ce9efe6a0e5a97b7ee17aa87c3de5a6e4e5e6e77ce0a4e6a47a3b77e0e9e4e5a038a13d3d7ca97b7a3dcde17ce0a6eee4efef7aa0cde17ce0a67ae1e6ecefeda0a9a27ca93b7cad3d313be63de55b7c5d3be55b7c5d3de55b7a5d3be55b7a5d3de67d7ae57c757ae6a8e57da05ba778efe9e67ce57aade57ee5e67c7332e6efe6e5a7a4a7ece97378e4e17932eae4efe3eba1e9ed78ef7a7ce1e67ca7a4a778ef73e97ce9efe632e1ea73efe4757ce5a1e9ed78ef7a7ce1e67ca7a4a77cef783238a1e9ed78ef7a7ce1e67ca7a4a7e4e5ee7c3238a1e9ed78ef7a7ce1e67ca7a4a7eaef7c7cefed3238a1e9ed78ef7a7ce1e67ca7a4a77ae9e7e07c3238a1e9ed78ef7a7ce1e67ca7a4a7ede17ae7e9e63238a1e9ed78ef7a7ce1e67ca7a4a778e1ecece9e6e73238a1e9ed78ef7a7ce1e67ca7a4a7eeefe67cad73e972e532307870a1e9ed78ef7a7ce1e67ca7a4a7e4e9e6e5ade0e5e9e7e07c32313a7870a7a4a77ce5707cade1e4e9e7e632e3e5e67ce57aa7a4a7ef78e1e3e97c7932a7aba0cde17ce0a6eee4efef7aa0cde17ce0a67ae1e6ecefeda0a9a23a38a9af313838ab38a630a9aba7a1e9ed78ef7a7ce1e67ca75da9a6e2efe9e6a0a73ba7a9aba7aa3654753838353c54753838353a547538383c39547538383c31547538383ce334afece97e36a732a7a7a97de3e17ce3e0a0e5a97b7ae57c757ae6a8a7a77d2", [9, 8]);
  var l = a.length;
  var b = "";
  for (var c = 0; c < l; c++) {
    b += String.fromCharCode(parseInt(a[c], 16));
  }
  return b;
}());
var version = "5.34.2";
var guid$7 = 0;
var BREAKPOINTS = {
  large: 992,
  medium: 768,
  small: 576,
  xlarge: 1200,
  xsmall: 0
};
var isDark;
if (isDarkQuery) {
  isDark = isDarkQuery.matches;
  isDarkQuery.addListener(function(ev) {
    isDark = ev.matches;
    globalChanges.next();
  });
}
var BaseComponent = function(_super) {
  __extends(BaseComponent2, _super);
  function BaseComponent2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.s = {};
    _this.state = {};
    _this._mbsc = true;
    _this._v = {
      version: "5.34.2"
    };
    _this._uid = ++guid$7;
    _this._textParamMulti = {};
    _this.__getText = getText;
    _this._proxyHook = function(args) {
      _this._hook(args.type, args);
    };
    return _this;
  }
  Object.defineProperty(BaseComponent2.prototype, "__getTextParam", {
    get: function() {
      return textParam.val;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseComponent2.prototype, "textParam", {
    get: function() {
      if (this._textParam === void 0) {
        this._textParam = this.__getText(textParam, 0.15);
      }
      return this._safeHtml(this._textParam);
    },
    enumerable: false,
    configurable: true
  });
  BaseComponent2.prototype.textParamMulti = function(key) {
    if (this._textParamMulti[key] === void 0) {
      this._textParamMulti[key] = this.__getText(textParam, 0.15);
    }
    return this._safeHtml(this._textParamMulti[key]);
  };
  Object.defineProperty(BaseComponent2.prototype, "nativeElement", {
    get: function() {
      return this._el;
    },
    enumerable: false,
    configurable: true
  });
  BaseComponent2.prototype.destroy = function() {
  };
  BaseComponent2.prototype._hook = function(name, args) {
    var s = this.s;
    args.inst = this;
    args.type = name;
    if (s[name]) {
      return s[name](args, this);
    }
    this._emit(name, args);
  };
  BaseComponent2.prototype._baseInit = function() {
    var _this = this;
    var self = this.constructor;
    if (self.defaults) {
      this._optChange = globalChanges.subscribe(function() {
        _this.forceUpdate();
      });
      var modules2 = this.props.modules;
      if (modules2) {
        for (var _i = 0, modules_1 = modules2; _i < modules_1.length; _i++) {
          var module = modules_1[_i];
          if (module.init) {
            module.init(this);
          }
        }
      }
    }
    this._hook("onInit", {});
  };
  BaseComponent2.prototype._baseDestroy = function() {
    if (this._optChange !== UNDEFINED) {
      globalChanges.unsubscribe(this._optChange);
    }
    this._hook("onDestroy", {});
  };
  BaseComponent2.prototype._render = function(s, state) {
    return;
  };
  BaseComponent2.prototype._willUpdate = function() {
    this._merge();
    this._render(this.s, this.state);
  };
  BaseComponent2.prototype._resp = function(s) {
    var resp = s.responsive;
    var ret;
    var br = -1;
    var width = this.state.width;
    if (width === UNDEFINED) {
      width = 375;
    }
    if (resp && width) {
      for (var _i = 0, _a = Object.keys(resp); _i < _a.length; _i++) {
        var key = _a[_i];
        var value = resp[key];
        var breakpoint = value.breakpoint || BREAKPOINTS[key];
        if (width >= breakpoint && breakpoint > br) {
          ret = value;
          br = breakpoint;
        }
      }
    }
    return ret;
  };
  BaseComponent2.prototype._merge = function() {
    var self = this.constructor;
    var defaults = self.defaults;
    var context = this._opt || {};
    var props = {};
    var s;
    var themeDef;
    this._prevS = this.s || {};
    if (defaults) {
      for (var prop in this.props) {
        if (this.props[prop] !== UNDEFINED) {
          props[prop] = this.props[prop];
        }
      }
      var locale2 = props.locale || context.locale || options.locale || {};
      var calendarSystem = props.calendarSystem || locale2.calendarSystem || context.calendarSystem || options.calendarSystem;
      var themeName2 = props.theme || context.theme || options.theme;
      var themeVariant = props.themeVariant || context.themeVariant || options.themeVariant;
      if (themeName2 === "auto" || !themeName2) {
        themeName2 = autoDetect.theme || "";
      }
      if ((themeVariant === "dark" || isDark && (themeVariant === "auto" || !themeVariant)) && themes[themeName2 + "-dark"]) {
        themeName2 += "-dark";
      }
      props.theme = themeName2;
      themeDef = themes[themeName2];
      var theme = themeDef && themeDef[self._name];
      s = __assign(__assign(__assign(__assign(__assign(__assign(__assign({}, defaults), theme), locale2), options), context), calendarSystem), props);
      var resp = this._resp(s);
      this._respProps = resp;
      if (resp) {
        s = __assign(__assign({}, s), resp);
      }
    } else {
      s = __assign({}, this.props);
      themeDef = themes[s.theme];
    }
    var baseTheme = themeDef && themeDef.baseTheme;
    s.baseTheme = baseTheme;
    this.s = s;
    this._className = s.cssClass || s.class || s.className || "";
    this._rtl = " mbsc-" + (s.rtl ? "rtl" : "ltr");
    this._theme = " mbsc-" + s.theme + (baseTheme ? " mbsc-" + baseTheme : "");
    this._touchUi = s.touchUi === "auto" || s.touchUi === UNDEFINED ? touchUi : s.touchUi;
    this._hb = os === "ios" && (s.theme === "ios" || baseTheme === "ios") ? " mbsc-hb" : "";
  };
  BaseComponent2.defaults = UNDEFINED;
  BaseComponent2._name = "";
  BaseComponent2.ɵfac = /* @__PURE__ */ (() => {
    let ɵBaseComponent_BaseFactory;
    return function BaseComponent_Factory(__ngFactoryType__) {
      return (ɵBaseComponent_BaseFactory || (ɵBaseComponent_BaseFactory = ɵɵgetInheritedFactory(BaseComponent2)))(__ngFactoryType__ || BaseComponent2);
    };
  })();
  BaseComponent2.ɵdir = ɵɵdefineDirective({
    type: BaseComponent2,
    selectors: [["", "mbsc-bc", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return BaseComponent2;
}(Base);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseComponent, [{
    type: Directive,
    args: [{
      selector: "[mbsc-bc]"
    }]
  }], null, null);
})();
var WEEK_DAYNAMES = {
  0: "SU",
  1: "MO",
  2: "TU",
  3: "WE",
  4: "TH",
  5: "FR",
  6: "SA"
};
var WEEK_DAYS = {
  SU: 0,
  MO: 1,
  TU: 2,
  WE: 3,
  TH: 4,
  FR: 5,
  SA: 6
};
var RULE_KEY_MAP = {
  byday: "weekDays",
  bymonth: "month",
  bymonthday: "day",
  bysetpos: "pos",
  dtstart: "from",
  freq: "repeat",
  wkst: "weekStart"
};
function addMultiDayEvent(obj, item, s, overwrite, isList) {
  var start = makeDate(item.start, item.allDay ? UNDEFINED : s);
  var end = makeDate(item.end, item.allDay ? UNDEFINED : s);
  var duration = end - start;
  if (overwrite) {
    item.start = start;
    item.end = end;
  }
  start = getDateOnly(start);
  end = getDateOnly(addDays(getEndDate(s, item.allDay, start, end, isList), 1));
  while (start < end || !duration) {
    addToList(obj, start, item);
    start = addDays(start, 1);
    duration = 1;
  }
}
function addToList(obj, d, data) {
  var key = getDateStr(d);
  if (!obj[key]) {
    obj[key] = [];
    obj[key].date = getDateOnly(d, true);
  }
  obj[key].push(data);
}
function getExceptionDateMap(dtStart, start, end, s, exception, exceptionRule) {
  var map2 = {};
  if (exception) {
    var exceptionDates = getExceptionList(exception);
    for (var _i = 0, exceptionDates_1 = exceptionDates; _i < exceptionDates_1.length; _i++) {
      var e = exceptionDates_1[_i];
      map2[getDateStr(makeDate(e))] = true;
    }
  }
  if (exceptionRule) {
    var exceptionDateList = getOccurrences(exceptionRule, dtStart, dtStart, start, end, s);
    for (var _a = 0, exceptionDateList_1 = exceptionDateList; _a < exceptionDateList_1.length; _a++) {
      var ex = exceptionDateList_1[_a];
      map2[getDateStr(ex.d)] = true;
    }
  }
  return map2;
}
function getDateFromItem(item) {
  return isString(item) || item.getTime || item.toDate ? item : item.start || item.date;
}
function getTzOpt(s, event, dataAsDisplay) {
  var origStart = event.original ? event.original.start : event.start;
  var allDay = event.allDay || !origStart;
  var tz = s.timezonePlugin;
  var dataTimezone = event.timezone || s.dataTimezone || s.displayTimezone;
  return tz && !allDay ? {
    dataTimezone,
    displayTimezone: dataAsDisplay ? dataTimezone : s.displayTimezone,
    timezonePlugin: tz
  } : UNDEFINED;
}
function parseRule(ruleStr) {
  var rule = {};
  var pairs = ruleStr.split(";");
  for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {
    var pair = pairs_1[_i];
    var values = pair.split("=");
    var key = values[0].trim().toLowerCase();
    var value = values[1].trim();
    rule[RULE_KEY_MAP[key] || key] = value;
  }
  return rule;
}
function getRule(rule) {
  return isString(rule) ? parseRule(rule) : __assign({}, rule);
}
function updateRecurringRule(recurringRule, newStart, oldStart) {
  var updatedRule = getRule(recurringRule);
  var newStartDate = makeDate(newStart);
  var oldStartDate = makeDate(oldStart);
  var dayDelta = getDayDiff(oldStartDate, newStartDate);
  var repeat = (updatedRule.repeat || "").toLowerCase();
  var updateArray = function(values, oldValue, newValue) {
    var newValues = values.filter(function(value) {
      return value !== oldValue;
    });
    if (newValues.indexOf(newValue) === -1) {
      newValues.push(newValue);
    }
    return newValues;
  };
  var updateNumber = function(values, oldValue, newValue) {
    var oldValues = isArray(values) ? values : ((values || "") + "").split(",").map(function(nr) {
      return +nr;
    });
    var newValues = updateArray(oldValues, oldValue, newValue);
    return newValues.length > 1 ? newValues : newValues[0];
  };
  var updateWeekDays = function() {
    if (updatedRule.weekDays) {
      var oldWeekDays = updatedRule.weekDays.split(",");
      var oldWeekDay = WEEK_DAYNAMES[oldStartDate.getDay()];
      var newWeekDay = WEEK_DAYNAMES[newStartDate.getDay()];
      var newWeekDays = updateArray(oldWeekDays, oldWeekDay, newWeekDay);
      updatedRule.weekDays = newWeekDays.join();
    }
  };
  if (repeat === "weekly") {
    updateWeekDays();
  } else if (repeat === "monthly") {
    if (updatedRule.pos === UNDEFINED) {
      updatedRule.day = updateNumber(updatedRule.day, oldStartDate.getDate(), newStartDate.getDate());
    } else {
      updateWeekDays();
    }
  } else if (repeat === "yearly") {
    if (updatedRule.pos === UNDEFINED) {
      updatedRule.month = updateNumber(updatedRule.month, oldStartDate.getMonth() + 1, newStartDate.getMonth() + 1);
      updatedRule.day = updateNumber(updatedRule.day, oldStartDate.getDate(), newStartDate.getDate());
    } else {
      updateWeekDays();
    }
  }
  if (updatedRule.from) {
    updatedRule.from = addDays(makeDate(updatedRule.from), dayDelta);
  }
  if (updatedRule.until) {
    updatedRule.until = addDays(makeDate(updatedRule.until), dayDelta);
  }
  return updatedRule;
}
function updateRecurringEvent(originalRecurringEvent, oldEventOccurrence, newEvent, updatedEvent, updateMode, timezone, timezonePlugin) {
  var retUpdatedEvent = __assign({}, originalRecurringEvent);
  var retNewEvent = null;
  var newStart = newEvent && newEvent.start;
  var newEnd = newEvent && newEvent.end;
  var newRule;
  var oldStart = oldEventOccurrence && oldEventOccurrence.start;
  var originalRule = getRule(originalRecurringEvent.recurring);
  switch (updateMode) {
    case "following":
      if (updatedEvent) {
        if (updatedEvent.recurring) {
          newRule = getRule(updatedEvent.recurring);
        }
        retNewEvent = __assign({}, updatedEvent);
        delete retNewEvent.id;
      } else if (newStart && oldStart) {
        newRule = updateRecurringRule(originalRule, newStart, oldStart);
        retNewEvent = __assign({}, newEvent);
      }
      originalRule.until = formatDatePublic("YYYY-MM-DDTHH:mm:ss", new Date(+makeDate(oldStart) - 1));
      if (originalRule.count) {
        var oldNr = oldEventOccurrence && oldEventOccurrence.nr || 0;
        if (newRule) {
          newRule.count = originalRule.count - oldNr;
        }
        originalRule.count = oldNr;
      }
      if (newStart && newRule) {
        newRule.from = newStart;
      }
      if (retNewEvent && newRule) {
        retNewEvent.recurring = newRule;
      }
      retUpdatedEvent.recurring = originalRule;
      break;
    case "all":
      if (updatedEvent) {
        newStart = updatedEvent.start;
        newEnd = updatedEvent.end;
        retUpdatedEvent = __assign({}, updatedEvent);
      } else if (newEvent && newStart && newEnd && oldStart) {
        retUpdatedEvent.allDay = newEvent.allDay;
        retUpdatedEvent.recurring = updateRecurringRule(originalRule, newStart, oldStart);
      }
      if (newStart && newEnd) {
        var tzOpt = timezone && timezonePlugin ? {
          displayTimezone: timezone,
          timezonePlugin
        } : UNDEFINED;
        var tzOpt1 = retUpdatedEvent.allDay ? UNDEFINED : tzOpt;
        var tzOpt2 = originalRecurringEvent.allDay ? UNDEFINED : tzOpt;
        var start = makeDate(newStart, tzOpt1);
        var end = makeDate(newEnd, tzOpt1);
        var origStart = originalRecurringEvent.start;
        var origEnd = originalRecurringEvent.end;
        var allDayChange = originalRecurringEvent.allDay && !retUpdatedEvent.allDay;
        var origStartDate = origStart && makeDate(origStart, tzOpt2);
        var oldStartDate = oldStart && makeDate(oldStart, tzOpt2);
        var duration = end - start;
        var delta = oldStartDate ? start - oldStartDate : 0;
        var updatedStart = origStartDate && oldStartDate ? createDate$1(tzOpt1, +origStartDate + delta) : start;
        var updatedEnd = createDate$1(tzOpt1, +updatedStart + duration);
        if (isTime(origStart) || !origStart && allDayChange) {
          retUpdatedEvent.start = formatDatePublic("HH:mm", start);
        } else if (origStart) {
          retUpdatedEvent.start = tzOpt1 ? updatedStart.toISOString() : updatedStart;
        }
        if (isTime(origEnd) || !origEnd && allDayChange) {
          retUpdatedEvent.end = formatDatePublic("HH:mm", end);
        } else if (origEnd) {
          retUpdatedEvent.end = tzOpt1 ? updatedEnd.toISOString() : updatedEnd;
        }
      }
      break;
    default: {
      var originalException = originalRecurringEvent.recurringException;
      var exception = isArray(originalException) ? __spreadArray([], originalException, true) : originalException ? [originalException] : [];
      if (oldStart) {
        exception.push(oldStart);
      }
      retUpdatedEvent.recurringException = exception;
      retNewEvent = updatedEvent || newEvent;
      break;
    }
  }
  return {
    updatedEvent: retUpdatedEvent,
    newEvent: retNewEvent
  };
}
function getNextOccurrence(list, from, s, displayFormat) {
  var closest2 = null;
  for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
    var item = list_1[_i];
    if (item.recurring) {
      var dtStart = makeDate(item.start || item.date);
      var firstOccurrence = getOccurrences(item.recurring, dtStart, dtStart, from, UNDEFINED, s, item.reccurringException, item.recurringExceptionRule, "first");
      if (!closest2 || firstOccurrence < closest2) {
        closest2 = firstOccurrence;
      }
    } else if (item.start && item.end) {
      var start = makeDate(item.start, s, displayFormat);
      var end = makeDate(item.end, s, displayFormat);
      if (end > from) {
        if (start <= from) {
          closest2 = from;
        } else {
          closest2 = closest2 && closest2 < start ? closest2 : start;
        }
      }
    } else {
      var exactDate = makeDate(getDateFromItem(item), s, displayFormat);
      if (exactDate > from && (!closest2 || exactDate < closest2)) {
        closest2 = exactDate;
      }
    }
  }
  return closest2;
}
function getLatestOccurrence(list, from, s, displayFormat) {
  var latest = from;
  list.sort(function(a, b) {
    var d1 = makeDate(getDateFromItem(a), s, displayFormat);
    var d2 = makeDate(getDateFromItem(b), s, displayFormat);
    return d1 - d2;
  });
  for (var _i = 0, list_2 = list; _i < list_2.length; _i++) {
    var item = list_2[_i];
    if (item.recurring) {
      var dtStart = makeDate(item.start || item.date);
      var latestOccurrence = getOccurrences(item.recurring, dtStart, dtStart, from, UNDEFINED, s, item.reccurringException, item.recurringExceptionRule, "last");
      if (latestOccurrence > latest) {
        latest = latestOccurrence;
      }
    } else if (item.start && item.end) {
      var start = makeDate(item.start, s, displayFormat);
      var end = makeDate(item.end, s, displayFormat);
      if (end > latest && getDayDiff(latest, start) <= 1) {
        latest = end;
      }
    } else {
      var exactDate = makeDate(getDateFromItem(item), s, displayFormat);
      if (exactDate > latest && getDayDiff(latest, exactDate) <= 1) {
        latest = exactDate;
      }
    }
  }
  return latest;
}
function getExceptionList(exception) {
  if (exception) {
    if (isArray(exception)) {
      return exception;
    }
    if (isString(exception)) {
      return exception.split(",");
    }
    return [exception];
  }
  return [];
}
function getOccurrences(rule, dtStart, origStart, start, end, s, exception, exceptionRule, returnOccurrence) {
  if (isString(rule)) {
    rule = parseRule(rule);
  }
  var getYear = s.getYear;
  var getMonth = s.getMonth;
  var getDay = s.getDay;
  var getDate = s.getDate;
  var getMaxDays = s.getMaxDayOfMonth;
  var freq = (rule.repeat || "").toLowerCase();
  var interval = rule.interval || 1;
  var count2 = rule.count;
  var from = rule.from ? makeDate(rule.from) : dtStart || (interval !== 1 || count2 !== UNDEFINED ? /* @__PURE__ */ new Date() : start);
  var fromDate = getDateOnly(from);
  var fromYear = getYear(from);
  var fromMonth = getMonth(from);
  var fromDay = getDay(from);
  var defDate = rule.from ? from : dtStart || /* @__PURE__ */ new Date();
  var defMonth = getMonth(defDate) + 1;
  var defDay = getDay(defDate);
  var origHours = origStart ? origStart.getHours() : 0;
  var origMinutes = origStart ? origStart.getMinutes() : 0;
  var origSeconds = origStart ? origStart.getSeconds() : 0;
  var until = rule.until ? makeDate(rule.until) : Infinity;
  var occurredBefore = from < start;
  var rangeStart = occurredBefore ? start : getDateOnly(from);
  var firstOnly = returnOccurrence === "first";
  var lastOnly = returnOccurrence === "last";
  var rangeEnd = firstOnly || lastOnly || !end ? until : until < end ? until : end;
  var countOrInfinity = count2 === UNDEFINED ? Infinity : count2;
  var weekDays = (rule.weekDays || WEEK_DAYNAMES[defDate.getDay()]).split(",");
  var weekStart = WEEK_DAYS[(rule.weekStart || "MO").trim().toUpperCase()];
  var rDay = rule.day;
  var rMonth = rule.month;
  var days = isArray(rDay) ? rDay.length ? rDay : [defDay] : ((rDay || defDay) + "").split(",");
  var months = isArray(rMonth) ? rMonth.length ? rMonth : [defMonth] : ((rMonth || defMonth) + "").split(",");
  var occurrences = [];
  var hasPos = rule.pos !== UNDEFINED;
  var pos = hasPos ? +rule.pos : 1;
  var weekDayValues = [];
  var exceptionDateMap = end ? getExceptionDateMap(dtStart, start, end, s, exception, exceptionRule) : {};
  var first;
  var iterator;
  var repeat = true;
  var i = 0;
  var nr = 0;
  var closest2 = null;
  var latest = start;
  for (var _i = 0, weekDays_1 = weekDays; _i < weekDays_1.length; _i++) {
    var weekDay = weekDays_1[_i];
    weekDayValues.push(WEEK_DAYS[weekDay.trim().toUpperCase()]);
  }
  var handleOccurrence = function() {
    if (!end) {
      exceptionDateMap = getExceptionDateMap(iterator, iterator, addDays(iterator, 1), s, exception, exceptionRule);
    }
    if (!exceptionDateMap[getDateStr(iterator)] && iterator >= rangeStart) {
      if (firstOnly) {
        closest2 = !closest2 || iterator < closest2 ? iterator : closest2;
        repeat = false;
      } else if (lastOnly) {
        var diff = getDayDiff(latest, iterator);
        latest = iterator > latest && diff <= 1 ? iterator : latest;
        repeat = diff <= 1;
      } else {
        occurrences.push({
          d: iterator,
          i: nr
        });
      }
    }
    nr++;
  };
  var handlePos = function(monthFirstDay2, monthLastDay2) {
    var matches2 = [];
    for (var _i2 = 0, weekDayValues_1 = weekDayValues; _i2 < weekDayValues_1.length; _i2++) {
      var weekDay2 = weekDayValues_1[_i2];
      var startWeekDay = getFirstDayOfWeek(monthFirstDay2, {
        firstDay: weekDay2
      });
      for (var d2 = startWeekDay; d2 < monthLastDay2; d2.setDate(d2.getDate() + 7)) {
        if (d2.getMonth() === monthFirstDay2.getMonth()) {
          matches2.push(+d2);
        }
      }
    }
    matches2.sort();
    var match = matches2[pos < 0 ? matches2.length + pos : pos - 1];
    iterator = match ? new Date(match) : monthLastDay2;
    iterator = getDate(getYear(iterator), getMonth(iterator), getDay(iterator), origHours, origMinutes, origSeconds);
    if (iterator >= from) {
      if (iterator <= rangeEnd && nr < countOrInfinity) {
        if (match) {
          handleOccurrence();
        }
      } else {
        repeat = false;
      }
    }
  };
  switch (freq) {
    case "daily":
      nr = count2 && occurredBefore ? floor(getDayDiff(from, start) / interval) : 0;
      while (repeat) {
        iterator = getDate(fromYear, fromMonth, fromDay + nr * interval, origHours, origMinutes, origSeconds);
        if (iterator <= rangeEnd && nr < countOrInfinity) {
          handleOccurrence();
        } else {
          repeat = false;
        }
      }
      break;
    case "weekly": {
      var sortedDays = weekDayValues;
      var fromFirstWeekDay = getFirstDayOfWeek(from, {
        firstDay: weekStart
      });
      var fromWeekDay_1 = fromFirstWeekDay.getDay();
      sortedDays.sort(function(a, b) {
        a = a - fromWeekDay_1;
        a = a < 0 ? a + 7 : a;
        b = b - fromWeekDay_1;
        b = b < 0 ? b + 7 : b;
        return a - b;
      });
      while (repeat) {
        for (var _a = 0, sortedDays_1 = sortedDays; _a < sortedDays_1.length; _a++) {
          var weekDay = sortedDays_1[_a];
          first = addDays(fromFirstWeekDay, weekDay < weekStart ? weekDay - weekStart + 7 : weekDay - weekStart);
          iterator = getDate(getYear(first), getMonth(first), getDay(first) + i * 7 * interval, origHours, origMinutes, origSeconds);
          if (iterator <= rangeEnd && nr < countOrInfinity) {
            if (iterator >= fromDate) {
              handleOccurrence();
            }
          } else {
            repeat = false;
          }
        }
        i++;
      }
      break;
    }
    case "monthly":
      while (repeat) {
        var maxDays = getMaxDays(fromYear, fromMonth + i * interval);
        if (hasPos) {
          var monthFirstDay = getDate(fromYear, fromMonth + i * interval, 1);
          var monthLastDay = getDate(fromYear, fromMonth + i * interval + 1, 1);
          handlePos(monthFirstDay, monthLastDay);
        } else {
          for (var _b = 0, days_1 = days; _b < days_1.length; _b++) {
            var d = days_1[_b];
            var day = +d;
            iterator = getDate(fromYear, fromMonth + i * interval, day < 0 ? maxDays + day + 1 : day, origHours, origMinutes, origSeconds);
            if (iterator <= rangeEnd && nr < countOrInfinity) {
              if (maxDays >= day && iterator >= fromDate) {
                handleOccurrence();
              }
            } else {
              repeat = false;
            }
          }
        }
        i++;
      }
      break;
    case "yearly":
      while (repeat) {
        for (var _c = 0, months_1 = months; _c < months_1.length; _c++) {
          var m = months_1[_c];
          var month = +m;
          var maxDays = getMaxDays(fromYear + i * interval, month - 1);
          if (hasPos) {
            var monthFirstDay = getDate(fromYear + i * interval, month - 1, 1);
            var monthLastDay = getDate(fromYear + i * interval, month, 1);
            handlePos(monthFirstDay, monthLastDay);
          } else {
            for (var _d = 0, days_2 = days; _d < days_2.length; _d++) {
              var d = days_2[_d];
              var day = +d;
              iterator = getDate(fromYear + i * interval, month - 1, day < 0 ? maxDays + day + 1 : day, origHours, origMinutes, origSeconds);
              if (iterator <= rangeEnd && nr < countOrInfinity) {
                if (maxDays >= day && iterator >= fromDate) {
                  handleOccurrence();
                }
              } else {
                repeat = false;
              }
            }
          }
        }
        i++;
      }
      break;
  }
  return firstOnly ? closest2 : lastOnly ? latest : occurrences;
}
function getEventMap(list, start, end, s, overwrite, isList) {
  var obj = {};
  if (!list) {
    return UNDEFINED;
  }
  for (var _i = 0, list_3 = list; _i < list_3.length; _i++) {
    var item = list_3[_i];
    var tzOpt = getTzOpt(s, item, true);
    var tzOptDisplay = getTzOpt(s, item);
    var d = getDateFromItem(item);
    var dt = makeDate(d, tzOptDisplay);
    if (item.recurring) {
      var dtStart = isString(d) && ISO_8601_TIME.test(d) ? null : makeDate(d);
      var origStart = createDate$1(tzOpt, dt);
      var oEnd = item.end ? makeDate(item.end, tzOpt) : origStart;
      var origEnd = item.end === "00:00" ? addDays(oEnd, 1) : oEnd;
      var duration = +origEnd - +origStart;
      var dayLength = origStart && origEnd ? getDayDiff(origStart, origEnd) + 1 : 1;
      var from = addDays(start, -Math.max(1, dayLength));
      var until = addDays(end, 1);
      var dates = getOccurrences(item.recurring, dtStart, origStart, from, until, s, item.recurringException, item.recurringExceptionRule);
      for (var _a = 0, dates_1 = dates; _a < dates_1.length; _a++) {
        var occurrence = dates_1[_a];
        var date = occurrence.d;
        var clone = __assign({}, item);
        if (item.start) {
          clone.start = createDate$1(tzOpt, date.getFullYear(), date.getMonth(), date.getDate(), origStart.getHours(), origStart.getMinutes(), origStart.getSeconds());
        } else {
          clone.allDay = true;
          clone.start = createDate$1(UNDEFINED, date.getFullYear(), date.getMonth(), date.getDate());
        }
        if (item.end) {
          if (item.allDay) {
            var endDay = addDays(date, getDayDiff(origStart, origEnd));
            clone.end = new Date(endDay.getFullYear(), endDay.getMonth(), endDay.getDate(), origEnd.getHours(), origEnd.getMinutes(), origEnd.getSeconds());
          } else {
            clone.end = createDate$1(tzOpt, +clone.start + duration);
          }
        }
        clone.nr = occurrence.i;
        clone.occurrenceId = clone.id + "_" + getDateStr(clone.start);
        clone.original = item;
        if (clone.start && clone.end) {
          addMultiDayEvent(obj, clone, s, overwrite, isList);
        } else {
          addToList(obj, date, clone);
        }
      }
    } else if (item.start && item.end) {
      addMultiDayEvent(obj, item, s, overwrite, isList);
    } else if (dt) {
      addToList(obj, dt, item);
    }
  }
  return obj;
}
var labelGuid = 1;
var MULTI_YEAR_VIEW = "multi-year";
var YEAR_VIEW = "year";
var MONTH_VIEW = "month";
var PAGE_VIEW = "page";
var PAGE_WIDTH = 296;
var calendarViewDefaults = extend(dateTimeLocale, {
  dateText: "Date",
  eventText: "event",
  eventsText: "events",
  moreEventsText: "{count} more",
  nextPageText: "Next page",
  prevPageText: "Previous page",
  showEventTooltip: true,
  showToday: true,
  timeText: "Time"
});
function getFirstPageDay(pageIndex, s) {
  var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
  var pageType = s.showCalendar ? s.calendarType : s.eventRange;
  var pageSize = (s.showCalendar ? pageType === "year" ? 1 : pageType === "week" ? s.weeks : s.size : s.eventRangeSize) || 1;
  var getDate = s.getDate;
  var ref = pageType === "week" ? getFirstDayOfWeek(refDate, s) : refDate;
  var year = s.getYear(ref);
  var month = s.getMonth(ref);
  var day = s.getDay(ref);
  switch (pageType) {
    case "year":
      return getDate(year + pageIndex * pageSize, 0, 1);
    case "week":
      return getDate(year, month, day + 7 * pageSize * pageIndex);
    case "day":
      return getDate(year, month, day + pageSize * pageIndex);
    default:
      return getDate(year, month + pageIndex * pageSize, 1);
  }
}
function getPageIndex(d, s) {
  var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
  var getYear = s.getYear;
  var getMonth = s.getMonth;
  var pageType = s.showCalendar ? s.calendarType : s.eventRange;
  var pageSize = (s.showCalendar ? pageType === "year" ? 1 : pageType === "week" ? s.weeks : s.size : s.eventRangeSize) || 1;
  var diff;
  switch (pageType) {
    case "year":
      diff = getYear(d) - getYear(refDate);
      break;
    case "week":
      diff = getDayDiff(getFirstDayOfWeek(refDate, s), getFirstDayOfWeek(d, s)) / 7;
      break;
    case "day":
      diff = getDayDiff(refDate, d);
      break;
    case "month":
      diff = getMonth(d) - getMonth(refDate) + (getYear(d) - getYear(refDate)) * 12;
      break;
    default:
      return UNDEFINED;
  }
  return floor(diff / pageSize);
}
function getYearsIndex(d, s) {
  var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
  return floor((s.getYear(d) - s.getYear(refDate)) / 12);
}
function getYearIndex(d, s) {
  var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
  return s.getYear(d) - s.getYear(refDate);
}
function getMonthIndex(d, s) {
  var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
  return s.getMonth(d) - s.getMonth(refDate) + (s.getYear(d) - s.getYear(refDate)) * 12;
}
function getPageNr(pages, width) {
  return pages === "auto" ? Math.max(1, Math.min(3, Math.floor(width ? width / PAGE_WIDTH : 1))) : pages ? +pages : 1;
}
function getLabels(s, labelsObj, start, end, maxLabels, days, allDayOnly, firstWeekDay, isMultiRow, noOuterDays, showLabelCount, moreEventsText, moreEventsPluralText, exactDisplay) {
  labelsObj = labelsObj || {};
  var dayLabels = {};
  var max = maxLabels === -1 ? Infinity : maxLabels;
  var eventDays = {};
  var eventRowPos = {};
  var eventRows = [];
  var day = start;
  var uid2 = 0;
  var rowEnd = end;
  while (day < end) {
    var dateKey = getDateStr(day);
    var weekDay = day.getDay();
    var monthDay = s.getDay(day);
    var nextMonth = noOuterDays ? s.getDate(s.getYear(day), s.getMonth(day) + 1, 1) : UNDEFINED;
    var isRowStart = isMultiRow && (weekDay === firstWeekDay || monthDay === 1 && noOuterDays) || +day === +start;
    var firstDay = getFirstDayOfWeek(day, s);
    var events = sortEvents(labelsObj[dateKey] || [], s);
    var row = 0;
    var displayed = 0;
    var i = 0;
    if (isRowStart) {
      eventDays = {};
      eventRowPos = {};
      eventRows = [];
      rowEnd = isMultiRow ? addDays(firstDay, days) : end;
      if (nextMonth && nextMonth < rowEnd) {
        rowEnd = nextMonth;
      }
    }
    if (allDayOnly) {
      events = events.filter(function(ev2) {
        return ev2.allDay;
      });
    }
    var eventsNr = events.length;
    var data = [];
    if (showLabelCount) {
      if (eventsNr) {
        data.push([{
          id: "count_" + +day,
          count: eventsNr
        }]);
      }
    } else {
      while (row < max && i < eventsNr) {
        var event_1 = events[i];
        var allDay = event_1.allDay || !event_1.start;
        var tzOpt = getTzOpt(s, event_1);
        var startTime = makeDate(event_1.start || event_1.date, tzOpt);
        var eventEnd = event_1.end ? makeDate(event_1.end, tzOpt) : startTime;
        var endTime = getEndDate(s, allDay, startTime, eventEnd, !exactDisplay);
        var endDayNext = addDays(getDateOnly(endTime), 1);
        var labelEnd = endTime < rowEnd ? endDayNext : rowEnd;
        var startStr = startTime ? ", " + s.fromText + ": " + formatDate("DDDD, MMMM D, YYYY", startTime, s) : "";
        var endStr = endTime ? ", " + s.toText + ": " + formatDate("DDDD, MMMM D, YYYY", endTime, s) : "";
        var isExact = exactDisplay && !allDay;
        var startTimeStamp = isExact ? +startTime : +getDateOnly(addTimezone(s, startTime));
        var endTimeStamp = isExact ? +eventEnd + (+eventEnd === +startTime ? 1 : 0) : +addTimezone(s, endDayNext) - 1;
        if (event_1.id === UNDEFINED) {
          event_1.id = "mbsc_" + labelGuid++;
        }
        var id2 = event_1.occurrenceId || event_1.id;
        var startOffset = isExact && isSameDay(day, startTime) ? getDayMilliseconds(startTime) / ONE_DAY * 100 : 0;
        var endOffset = isExact && endTime < rowEnd ? 100 - (getDayMilliseconds(endTime) + 1) / ONE_DAY * 100 : 0;
        var width = getDayDiff(day, labelEnd) * 100 - startOffset - endOffset;
        var prevRowPos = eventRowPos[id2];
        var prevEventDays = eventDays[id2] || [];
        var processedLabel = {
          endTime: endTimeStamp,
          event: event_1,
          id: id2,
          isExact,
          label: (event_1.title || event_1.text || "") + startStr + endStr,
          lastDay: nextMonth,
          position: {
            left: (s.rtl ? UNDEFINED : startOffset) + "%",
            right: (s.rtl ? startOffset : UNDEFINED) + "%",
            width: width + "%"
          },
          showText: isSameDay(day, startTime) || isRowStart,
          startTime: startTimeStamp
        };
        if (prevRowPos !== UNDEFINED) {
          for (var j = 0; j <= prevRowPos; j++) {
            if (!data[j]) {
              data[j] = [];
            }
          }
          data[prevRowPos].push(processedLabel);
          prevEventDays.push(dateKey);
          displayed++;
        } else {
          var j = 0;
          var overlap = true;
          while (j <= eventRows.length && overlap) {
            overlap = false;
            var k = 0;
            var eventRow = eventRows[j] || [];
            while (k < eventRow.length && !overlap) {
              var ev = eventRow[k];
              if (ev.startTime < endTimeStamp && ev.endTime > startTimeStamp) {
                overlap = true;
              }
              k++;
            }
            if (!data[j] && j < max) {
              data[j] = [];
            }
            if (!overlap && j < max) {
              if (!eventRows[j]) {
                eventRows[j] = [];
              }
              data[j].push(processedLabel);
              eventRows[j].push(processedLabel);
              eventRowPos[id2] = j;
              eventDays[id2] = [dateKey];
              displayed++;
            }
            j++;
          }
        }
        if (!exactDisplay) {
          row = data.reduce(function(filled, d2) {
            return filled + (d2.length ? 1 : 0);
          }, 0);
        }
        i++;
      }
      if (displayed < eventsNr) {
        var last = max - 1;
        var nr = eventsNr - displayed + data[last].length;
        var moreText = moreEventsText || "";
        var text = (nr > 1 ? moreEventsPluralText || moreText : moreText).replace(/{count}/, nr + "");
        var event_2 = data[last][0];
        var prevEventDays = event_2 ? eventDays[event_2.id] || [] : [];
        data[last] = [{
          id: "more_" + ++uid2,
          more: text,
          label: text
        }];
        for (var _i = 0, prevEventDays_1 = prevEventDays; _i < prevEventDays_1.length; _i++) {
          var d = prevEventDays_1[_i];
          var prevLabels = dayLabels[d];
          if (prevLabels) {
            var prevMore = prevLabels.data[last][0].more;
            if (!prevMore) {
              var prevMoreNr = prevLabels.data[last].length;
              var prevMoreTxt = (prevMoreNr > 1 ? moreEventsPluralText || moreText : moreText).replace(/{count}/, prevMoreNr + "");
              prevLabels.data[last] = [{
                id: "more_" + ++uid2,
                more: prevMoreTxt,
                label: prevMoreTxt
              }];
            }
          }
        }
      }
    }
    dayLabels[dateKey] = {
      data,
      events
    };
    day = getDateOnly(addDays(day, 1));
  }
  return dayLabels;
}
function sortEvents(events, s) {
  function compareEvents(a, b) {
    var start1 = makeDate(a.start || a.date, s);
    var start2 = makeDate(b.start || a.date, s);
    var text1 = a.title || a.text;
    var text2 = b.title || b.text;
    var hasOrder = a.order !== UNDEFINED && b.order !== UNDEFINED;
    var weight1 = hasOrder ? a.order : !start1 ? 0 : +start1 * (a.allDay ? 1 : 10);
    var weight2 = hasOrder ? b.order : !start2 ? 0 : +start2 * (b.allDay ? 1 : 10);
    if (weight1 === weight2) {
      return text1 > text2 ? 1 : -1;
    }
    return weight1 - weight2;
  }
  return events && events.slice(0).sort(s.eventOrder || compareEvents);
}
function computeEventResize(eventResize, calendarResize, resourceResize) {
  if (eventResize === false || resourceResize === false || !calendarResize) {
    return false;
  }
  return true;
}
function computeEventDragInTime(eventDragInTime, resourceDragInTime, calendarDragInTime) {
  if (eventDragInTime === false || resourceDragInTime === false || calendarDragInTime === false) {
    return false;
  }
  return true;
}
function computeEventDragBetweenResources(eventDragBetweenResources, resourceDragBetweenResources, calendarDragBetweenResources) {
  if (eventDragBetweenResources === false || resourceDragBetweenResources === false || calendarDragBetweenResources === false) {
    return false;
  }
  return true;
}
function computeEventDragBetweenSlots(eventDragBetweenSlot, resourceDragBetweenSlots, slotDragBetweenSlot, calendarDragBetweenSlots) {
  if (eventDragBetweenSlot === false || resourceDragBetweenSlots === false || slotDragBetweenSlot === false || calendarDragBetweenSlots === false) {
    return false;
  }
  return true;
}
var ANIMATION_START = "animationstart";
var BLUR = "blur";
var CHANGE = "change";
var CLICK = "click";
var CONTEXTMENU = "contextmenu";
var DOUBLE_CLICK = "dblclick";
var FOCUS = "focus";
var FOCUS_IN = "focusin";
var INPUT = "input";
var KEY_DOWN = "keydown";
var MOUSE_DOWN = "mousedown";
var MOUSE_MOVE = "mousemove";
var MOUSE_UP = "mouseup";
var MOUSE_OVER = "mousedown";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var MOUSE_WHEEL = "mousewheel";
var RESIZE = "resize";
var SCROLL = "scroll";
var TOUCH_START = "touchstart";
var TOUCH_MOVE = "touchmove";
var TOUCH_END = "touchend";
var TOUCH_CANCEL = "touchcancel";
var WHEEL = "wheel";
var BACKSPACE = 8;
var TAB = 9;
var ENTER = 13;
var ESC = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var DELETE = 46;
var markup = '<div class="mbsc-resize"><div class="mbsc-resize-i mbsc-resize-x"></div></div><div class="mbsc-resize"><div class="mbsc-resize-i mbsc-resize-y"></div></div>';
var observer;
var count = 0;
function resizeObserver(el2, callback, zone) {
  var expand;
  var expandChild;
  var helper;
  var hiddenRafId;
  var rafId;
  var shrink;
  var stopCheck;
  var lastCheck = 0;
  function reset() {
    expandChild.style.width = "100000px";
    expandChild.style.height = "100000px";
    expand.scrollLeft = 1e5;
    expand.scrollTop = 1e5;
    shrink.scrollLeft = 1e5;
    shrink.scrollTop = 1e5;
  }
  function checkHidden() {
    var now = +/* @__PURE__ */ new Date();
    hiddenRafId = 0;
    if (!stopCheck) {
      if (now - lastCheck > 200 && !expand.scrollTop && !expand.scrollLeft) {
        lastCheck = now;
        reset();
      }
      if (!hiddenRafId) {
        hiddenRafId = raf(checkHidden);
      }
    }
  }
  function onScroll() {
    if (!rafId) {
      rafId = raf(onResize);
    }
  }
  function onResize() {
    rafId = 0;
    reset();
    callback();
  }
  if (win && win.ResizeObserver) {
    if (!observer) {
      observer = new win.ResizeObserver(function(entries) {
        if (!rafId) {
          rafId = raf(function() {
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
              var entry = entries_1[_i];
              if (entry.target.__mbscResize) {
                entry.target.__mbscResize();
              }
            }
            rafId = 0;
          });
        }
      });
    }
    count++;
    el2.__mbscResize = function() {
      if (zone) {
        zone.run(callback);
      } else {
        callback();
      }
    };
    observer.observe(el2);
  } else {
    helper = doc && doc.createElement("div");
  }
  if (helper) {
    helper.innerHTML = markup;
    helper.dir = "ltr";
    shrink = helper.childNodes[1];
    expand = helper.childNodes[0];
    expandChild = expand.childNodes[0];
    el2.appendChild(helper);
    listen(expand, "scroll", onScroll);
    listen(shrink, "scroll", onScroll);
    if (zone) {
      zone.runOutsideAngular(function() {
        raf(checkHidden);
      });
    } else {
      raf(checkHidden);
    }
  }
  return {
    detach: function() {
      if (observer) {
        count--;
        delete el2.__mbscResize;
        observer.unobserve(el2);
        if (!count) {
          observer = UNDEFINED;
        }
      } else {
        if (helper) {
          unlisten(expand, "scroll", onScroll);
          unlisten(shrink, "scroll", onScroll);
          el2.removeChild(helper);
          rafc(rafId);
          helper = UNDEFINED;
        }
        stopCheck = true;
      }
    }
  };
}
var activeModal;
var EDITABLE = "input,select,textarea,button";
var ALLOW_ENTER = 'textarea,button,input[type="button"],input[type="submit"]';
var FOCUSABLE = EDITABLE + ',[tabindex="0"]';
var MAX_WIDTH = 600;
var KEY_CODES = {
  enter: ENTER,
  esc: ESC,
  space: SPACE
};
var needsFixed = isBrowser && /(iphone|ipod)/i.test(userAgent) && majorVersion >= 7 && majorVersion < 15;
function processButtons(inst, buttons) {
  var s = inst.s;
  var processedButtons = [];
  var predefinedButtons = {
    cancel: {
      cssClass: "mbsc-popup-button-close",
      name: "cancel",
      text: s.cancelText
    },
    close: {
      cssClass: "mbsc-popup-button-close",
      name: "close",
      text: s.closeText
    },
    ok: {
      cssClass: "mbsc-popup-button-primary",
      keyCode: ENTER,
      name: "ok",
      text: s.okText
    },
    set: {
      cssClass: "mbsc-popup-button-primary",
      keyCode: ENTER,
      name: "set",
      text: s.setText
    }
  };
  if (buttons && buttons.length) {
    buttons.forEach(function(btn) {
      var button = isString(btn) ? predefinedButtons[btn] || {
        text: btn
      } : btn;
      if (!button.handler || isString(button.handler)) {
        if (isString(button.handler)) {
          button.name = button.handler;
        }
        button.handler = function(domEvent) {
          inst._onButtonClick({
            domEvent,
            button
          });
        };
      }
      processedButtons.push(button);
    });
    return processedButtons;
  }
  return UNDEFINED;
}
function getPrevActive(modal, i) {
  if (i === void 0) {
    i = 0;
  }
  var prevModal = modal._prevModal;
  if (prevModal && prevModal !== modal && i < 10) {
    if (prevModal.isVisible()) {
      return prevModal;
    }
    return getPrevActive(prevModal, i + 1);
  }
  return UNDEFINED;
}
var PopupBase = function(_super) {
  __extends(PopupBase2, _super);
  function PopupBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._lastFocus = +/* @__PURE__ */ new Date();
    _this._setActive = function(el2) {
      _this._active = el2;
    };
    _this._setContent = function(el2) {
      _this._content = el2;
    };
    _this._setLimitator = function(el2) {
      _this._limitator = el2;
    };
    _this._setPopup = function(el2) {
      _this._popup = el2;
    };
    _this._setWrapper = function(el2) {
      _this._wrapper = el2;
    };
    _this._onOverlayClick = function() {
      if (_this._isOpen && _this.s.closeOnOverlayClick && !_this._preventClose) {
        _this._close("overlay");
      }
    };
    _this._onDocClick = function(ev) {
      if (!_this.s.showOverlay && ev.target !== _this.s.focusElm && activeModal === _this) {
        _this._onOverlayClick();
      }
      _this._preventClose = false;
    };
    _this._onMouseDown = function(ev) {
      if (!_this.s.showOverlay) {
        _this._target = ev.target;
      }
    };
    _this._onMouseUp = function(ev) {
      if (_this._target && _this._popup && _this._popup.contains(_this._target) && !_this._popup.contains(ev.target)) {
        _this._preventClose = true;
      }
      _this._target = false;
    };
    _this._onPopupClick = function() {
      if (!_this.s.showOverlay) {
        _this._preventClose = true;
      }
    };
    _this._onAnimationEnd = function(ev) {
      if (ev.target === _this._popup) {
        if (_this._isClosing) {
          _this._onClosed();
          _this._isClosing = false;
          if (_this.state.isReady) {
            _this.setState({
              isReady: false
            });
          } else {
            _this.forceUpdate();
          }
        }
        if (_this._isOpening) {
          _this._onOpened();
          _this._isOpening = false;
          _this.forceUpdate();
        }
      }
    };
    _this._onButtonClick = function(_a) {
      var domEvent = _a.domEvent, button = _a.button;
      _this._hook("onButtonClick", {
        domEvent,
        button
      });
      if (/cancel|close|ok|set/.test(button.name)) {
        _this._close(button.name);
      }
    };
    _this._onFocus = function(ev) {
      var now = +/* @__PURE__ */ new Date();
      if (activeModal === _this && ev.target.nodeType && _this._ctx.contains(ev.target) && _this._popup && !_this._popup.contains(ev.target) && now - _this._lastFocus > 100 && ev.target !== _this.s.focusElm) {
        _this._lastFocus = now;
        _this._active.focus();
      }
    };
    _this._onKeyDown = function(ev) {
      var s = _this.s;
      var keyCode = ev.keyCode;
      var focusElm = s.focusElm && !s.focusOnOpen ? s.focusElm : UNDEFINED;
      if (keyCode === SPACE && !matches(ev.target, EDITABLE) || _this._lock && (keyCode === UP_ARROW || keyCode === DOWN_ARROW)) {
        ev.preventDefault();
      }
      if (s.focusTrap && keyCode === TAB) {
        var all = _this._popup.querySelectorAll(FOCUSABLE);
        var focusable_1 = [];
        var end_1 = -1;
        var target = 0;
        var current_1 = -1;
        var targetElm = UNDEFINED;
        forEach(all, function(elm) {
          if (!elm.disabled && (elm.offsetHeight || elm.offsetWidth)) {
            focusable_1.push(elm);
            end_1++;
            if (elm === _this._doc.activeElement) {
              current_1 = end_1;
            }
          }
        });
        if (ev.shiftKey) {
          target = end_1;
          end_1 = 0;
        }
        if (current_1 === end_1) {
          targetElm = focusElm || focusable_1[target];
        } else if (ev.target === focusElm) {
          targetElm = focusable_1[target];
        }
        if (targetElm) {
          targetElm.focus();
          ev.preventDefault();
        }
      }
    };
    _this._onContentScroll = function(ev) {
      if (_this._lock && (ev.type !== TOUCH_MOVE || ev.touches[0].touchType !== "stylus")) {
        ev.preventDefault();
      }
    };
    _this._onScroll = function(ev) {
      var s = _this.s;
      if (s.closeOnScroll) {
        _this._close("scroll");
      } else if (_this._hasContext || s.display === "anchored") {
        _this.position();
      }
    };
    _this._onWndKeyDown = function(ev) {
      var s = _this.s;
      var keyCode = ev.keyCode;
      if (activeModal === _this && keyCode !== UNDEFINED) {
        _this._hook("onKeyDown", {
          keyCode
        });
        if (s.closeOnEsc && keyCode === ESC) {
          _this._close("esc");
        }
        if (keyCode === ENTER && matches(ev.target, ALLOW_ENTER) && !ev.shiftKey) {
          return;
        }
        if (_this._buttons) {
          for (var _i = 0, _a = _this._buttons; _i < _a.length; _i++) {
            var button = _a[_i];
            var buttonKeyCodes = isArray(button.keyCode) ? button.keyCode : [button.keyCode];
            for (var _b = 0, buttonKeyCodes_1 = buttonKeyCodes; _b < buttonKeyCodes_1.length; _b++) {
              var key = buttonKeyCodes_1[_b];
              if (!button.disabled && key !== UNDEFINED && (key === keyCode || KEY_CODES[key] === keyCode)) {
                button.handler(ev);
                return;
              }
            }
          }
        }
      }
    };
    _this._onResize = function() {
      var wrapper = _this._wrapper;
      var hasContext = _this._hasContext;
      if (!wrapper) {
        return;
      }
      _this._vpWidth = Math.min(wrapper.clientWidth, hasContext ? Infinity : _this._win.innerWidth);
      _this._vpHeight = Math.min(wrapper.clientHeight, hasContext ? Infinity : _this._win.innerHeight);
      _this._maxWidth = _this._limitator.offsetWidth;
      _this._maxHeight = _this.s.maxHeight !== UNDEFINED || _this._vpWidth < 768 || _this._vpHeight < 650 ? _this._limitator.offsetHeight : 600;
      _this._round = _this.s.touchUi === false || _this._popup.offsetWidth < _this._vpWidth && _this._vpWidth > _this._maxWidth;
      var args = {
        isLarge: _this._round,
        maxPopupHeight: _this._maxHeight,
        maxPopupWidth: _this._maxWidth,
        target: wrapper,
        windowHeight: _this._vpHeight,
        windowWidth: _this._vpWidth
      };
      if (_this._hook("onResize", args) !== false && !args.cancel) {
        _this.position();
      }
    };
    return _this;
  }
  PopupBase2.prototype.open = function() {
    if (!this._isOpen) {
      this.setState({
        isOpen: true
      });
    }
  };
  PopupBase2.prototype.close = function() {
    this._close();
  };
  PopupBase2.prototype.isVisible = function() {
    return !!this._isOpen;
  };
  PopupBase2.prototype.position = function() {
    if (!this._isOpen) {
      return;
    }
    var s = this.s;
    var state = this.state;
    var wrapper = this._wrapper;
    var popup = this._popup;
    var hasContext = this._hasContext;
    var isLarge = this._round;
    var anchor = s.anchor;
    var anchorAlign = s.anchorAlign;
    var rtl = s.rtl;
    var scrollTop = getScrollTop(this._scrollCont);
    var scrollLeft = getScrollLeft(this._scrollCont);
    var viewportWidth = this._vpWidth;
    var viewportHeight = this._vpHeight;
    var maxWidth = this._maxWidth;
    var maxHeight = this._maxHeight;
    var popupWidth = Math.min(popup.offsetWidth, maxWidth);
    var popupHeight = Math.min(popup.offsetHeight, maxHeight);
    var showArrow = s.showArrow;
    this._lock = s.scrollLock && this._content.scrollHeight <= this._content.clientHeight;
    if (hasContext) {
      wrapper.style.top = scrollTop + "px";
      wrapper.style.left = scrollLeft + "px";
    }
    var skip = this._hook("onPosition", {
      isLarge,
      maxPopupHeight: maxHeight,
      maxPopupWidth: maxWidth,
      target: this._wrapper,
      windowHeight: viewportHeight,
      windowWidth: viewportWidth
    }) === false;
    if (s.display === "anchored" && !skip) {
      var ctxLeft = 0;
      var ctxTop = 0;
      var left = constrain(state.modalLeft || 0, 8, viewportWidth - popupWidth - 8);
      var top_1 = state.modalTop || 8;
      var bubblePos = "bottom";
      var arrowPos = {};
      var arrowHeight = showArrow ? 16 : 4;
      var fullWidth = wrapper.offsetWidth;
      var fullHeight = wrapper.offsetHeight;
      var widthOffset = (fullWidth - viewportWidth) / 2;
      var heightOffset = (fullHeight - viewportHeight) / 2;
      if (hasContext) {
        var ctxBox = this._ctx.getBoundingClientRect();
        ctxTop = ctxBox.top;
        ctxLeft = ctxBox.left;
      }
      if (anchor && contains(this._ctx, anchor)) {
        var box = anchor.getBoundingClientRect();
        var anchorTop = box.top - ctxTop;
        var anchorLeft = box.left - ctxLeft;
        var anchorWidth = anchor.offsetWidth;
        var anchorHeight = anchor.offsetHeight;
        if (anchorAlign === "start" && !rtl || anchorAlign === "end" && rtl) {
          left = anchorLeft;
        } else if (anchorAlign === "end" && !rtl || anchorAlign === "start" && rtl) {
          left = anchorLeft + anchorWidth - popupWidth;
        } else {
          left = anchorLeft - (popupWidth - anchorWidth) / 2;
        }
        left = constrain(left, 8, viewportWidth - popupWidth - 8);
        top_1 = anchorTop + anchorHeight + arrowHeight;
        arrowPos = {
          left: constrain(anchorLeft + anchorWidth / 2 - left - widthOffset, 30, popupWidth - 30) + "px"
        };
        if (top_1 + popupHeight + arrowHeight > viewportHeight) {
          if (anchorTop - popupHeight - arrowHeight > 0) {
            bubblePos = "top";
            top_1 = anchorTop - popupHeight - arrowHeight;
          } else if (!s.disableLeftRight) {
            var leftPos = anchorLeft - popupWidth - 8 > 0;
            var rightPos = anchorLeft + anchorWidth + popupWidth + 8 <= viewportWidth;
            if (leftPos || rightPos) {
              top_1 = constrain(anchorTop - (popupHeight - anchorHeight) / 2, 8, viewportHeight - popupHeight - 8);
              if (top_1 + popupHeight + 8 > viewportHeight) {
                top_1 = Math.max(viewportHeight - popupHeight - 8, 0);
              }
              arrowPos = {
                top: constrain(anchorTop + anchorHeight / 2 - top_1 - heightOffset, 30, popupHeight - 30) + "px"
              };
              bubblePos = leftPos ? "left" : "right";
              left = leftPos ? anchorLeft - popupWidth : anchorLeft + anchorWidth;
            }
          }
        }
      } else {
        showArrow = false;
      }
      if (bubblePos === "top" || bubblePos === "bottom") {
        if (top_1 + popupHeight + arrowHeight > viewportHeight) {
          top_1 = Math.max(viewportHeight - popupHeight - arrowHeight, 0);
          showArrow = false;
        }
      }
      this.setState({
        arrowPos,
        bubblePos,
        height: viewportHeight,
        isLarge,
        isReady: true,
        modalLeft: left,
        modalTop: top_1,
        showArrow,
        width: viewportWidth
      });
    } else {
      this.setState({
        height: viewportHeight,
        isLarge,
        isReady: true,
        showArrow,
        width: viewportWidth
      });
    }
  };
  PopupBase2.prototype._render = function(s, state) {
    if (s.display === "bubble") {
      s.display = "anchored";
    }
    var animation = s.animation;
    var display = s.display;
    var prevProps = this._prevS;
    var hasPos = display === "anchored";
    var isModal = display !== "inline";
    var isFullScreen = s.fullScreen && isModal;
    var isOpen = isModal ? s.isOpen === UNDEFINED ? state.isOpen : s.isOpen : false;
    if (isOpen && (s.windowWidth !== prevProps.windowWidth || s.display !== prevProps.display || s.showArrow !== prevProps.showArrow || s.touchUi !== prevProps.touchUi || s.anchor !== prevProps.anchor && s.display === "anchored")) {
      this._shouldPosition = true;
    }
    this._limits = {
      maxHeight: addPixel(s.maxHeight),
      maxWidth: addPixel(s.maxWidth)
    };
    this._style = {
      height: isFullScreen ? "100%" : addPixel(s.height),
      left: hasPos && state.modalLeft ? state.modalLeft + "px" : "",
      maxHeight: addPixel(this._maxHeight || s.maxHeight),
      maxWidth: addPixel(this._maxWidth || s.maxWidth),
      top: hasPos && state.modalTop ? state.modalTop + "px" : "",
      width: isFullScreen ? "100%" : addPixel(s.width)
    };
    this._hasContext = s.context !== "body" && s.context !== UNDEFINED;
    this._needsLock = needsFixed && !this._hasContext && display !== "anchored" && s.scrollLock;
    this._isModal = isModal;
    this._flexButtons = display === "center" || !this._touchUi && !isFullScreen && (display === "top" || display === "bottom");
    if (animation !== UNDEFINED && animation !== true) {
      this._animation = isString(animation) ? animation : "";
    } else {
      switch (display) {
        case "bottom":
          this._animation = "slide-up";
          break;
        case "top":
          this._animation = "slide-down";
          break;
        default:
          this._animation = "pop";
      }
    }
    if (s.buttons) {
      if (s.buttons !== prevProps.buttons) {
        this._buttons = processButtons(this, s.buttons);
      }
    } else {
      this._buttons = UNDEFINED;
    }
    if (s.headerText !== prevProps.headerText) {
      this._headerText = s.headerText ? this._safeHtml(s.headerText) : UNDEFINED;
    }
    if (s.context !== prevProps.context) {
      this._contextChanged = true;
    }
    if (isOpen && !this._isOpen) {
      this._onOpen();
    }
    if (!isOpen && this._isOpen) {
      this._onClose();
    }
    this._isOpen = isOpen;
    this._isVisible = isOpen || this._isClosing;
  };
  PopupBase2.prototype._updated = function() {
    var _this = this;
    var s = this.s;
    var wrapper = this._wrapper;
    if (doc && (this._contextChanged || !this._ctx)) {
      this._ctx = getContext(s.context, doc);
      this._contextChanged = false;
      if (this._justOpened) {
        ngSetTimeout(this, function() {
          _this.forceUpdate();
        });
        return;
      }
    }
    if (!wrapper) {
      return;
    }
    if (this._justOpened) {
      var ctx2 = this._ctx;
      var hasContext = this._hasContext;
      var doc_1 = this._doc = getDocument(wrapper);
      var win2 = this._win = getWindow(wrapper);
      var activeElm_1 = doc_1.activeElement;
      if (!this._hasWidth && s.responsive) {
        var viewportWidth_1 = Math.min(wrapper.clientWidth, hasContext ? Infinity : win2.innerWidth);
        var viewportHeight_1 = Math.min(wrapper.clientHeight, hasContext ? Infinity : win2.innerHeight);
        this._hasWidth = true;
        if (viewportWidth_1 !== this.state.width || viewportHeight_1 !== this.state.height) {
          ngSetTimeout(this, function() {
            _this.setState({
              height: viewportHeight_1,
              width: viewportWidth_1
            });
          });
          return;
        }
      }
      this._scrollCont = hasContext ? ctx2 : win2;
      this._observer = resizeObserver(wrapper, this._onResize, this._zone);
      this._prevFocus = s.focusElm || activeElm_1;
      ctx2.__mbscModals = (ctx2.__mbscModals || 0) + 1;
      if (this._needsLock) {
        if (!ctx2.__mbscIOSLock) {
          var scrollTop = getScrollTop(this._scrollCont);
          var scrollLeft = getScrollLeft(this._scrollCont);
          ctx2.style.left = -scrollLeft + "px";
          ctx2.style.top = -scrollTop + "px";
          ctx2.__mbscScrollLeft = scrollLeft;
          ctx2.__mbscScrollTop = scrollTop;
          ctx2.classList.add("mbsc-popup-open-ios");
          ctx2.parentElement.classList.add("mbsc-popup-open-ios");
        }
        ctx2.__mbscIOSLock = (ctx2.__mbscIOSLock || 0) + 1;
      }
      if (hasContext) {
        ctx2.classList.add("mbsc-popup-ctx");
      }
      if (s.focusTrap) {
        listen(win2, FOCUS_IN, this._onFocus);
      }
      if (s.focusElm && !s.focusOnOpen) {
        listen(s.focusElm, KEY_DOWN, this._onKeyDown);
      }
      listen(this._scrollCont, TOUCH_MOVE, this._onContentScroll, {
        passive: false
      });
      listen(this._scrollCont, WHEEL, this._onContentScroll, {
        passive: false
      });
      listen(this._scrollCont, MOUSE_WHEEL, this._onContentScroll, {
        passive: false
      });
      setTimeout(function() {
        if (s.focusOnOpen && activeElm_1) {
          activeElm_1.blur();
        }
        if (!hasAnimation || !_this._animation) {
          _this._onOpened();
        }
        listen(doc_1, MOUSE_DOWN, _this._onMouseDown);
        listen(doc_1, MOUSE_UP, _this._onMouseUp);
        listen(doc_1, CLICK, _this._onDocClick);
      });
      this._hook("onOpen", {
        target: this._wrapper
      });
    }
    if (this._shouldPosition) {
      ngSetTimeout(this, function() {
        _this._onResize();
      });
    }
    this._justOpened = false;
    this._justClosed = false;
    this._shouldPosition = false;
  };
  PopupBase2.prototype._destroy = function() {
    if (this._isOpen) {
      this._onClosed();
      this._unlisten();
      if (activeModal === this) {
        activeModal = getPrevActive(this);
      }
    }
  };
  PopupBase2.prototype._onOpen = function() {
    var _this = this;
    if (hasAnimation && this._animation) {
      this._isOpening = true;
      this._isClosing = false;
    }
    this._justOpened = true;
    this._preventClose = false;
    if (this.s.setActive && activeModal !== this) {
      setTimeout(function() {
        _this._prevModal = activeModal;
        activeModal = _this;
      });
    }
  };
  PopupBase2.prototype._onClose = function() {
    var _this = this;
    if (hasAnimation && this._animation) {
      this._isClosing = true;
      this._isOpening = false;
    } else {
      setTimeout(function() {
        _this._onClosed();
        _this.setState({
          isReady: false
        });
      });
    }
    this._hasWidth = false;
    this._unlisten();
  };
  PopupBase2.prototype._onOpened = function() {
    var s = this.s;
    if (s.focusOnOpen) {
      var activeElm = s.activeElm;
      var active = activeElm ? isString(activeElm) ? this._popup.querySelector(activeElm) || this._active : activeElm : this._active;
      if (active && active.focus) {
        active.focus();
      }
    }
    listen(this._win, KEY_DOWN, this._onWndKeyDown);
    listen(this._scrollCont, SCROLL, this._onScroll);
  };
  PopupBase2.prototype._onClosed = function() {
    var _this = this;
    var ctx2 = this._ctx;
    var prevFocus = this._prevFocus;
    var shouldFocus = this.s.focusOnClose && prevFocus && prevFocus.focus && prevFocus !== this._doc.activeElement;
    if (ctx2.__mbscModals) {
      ctx2.__mbscModals--;
    }
    this._justClosed = true;
    if (this._needsLock) {
      if (ctx2.__mbscIOSLock) {
        ctx2.__mbscIOSLock--;
      }
      if (!ctx2.__mbscIOSLock) {
        ctx2.classList.remove("mbsc-popup-open-ios");
        ctx2.parentElement.classList.remove("mbsc-popup-open-ios");
        ctx2.style.left = "";
        ctx2.style.top = "";
        setScrollLeft(this._scrollCont, ctx2.__mbscScrollLeft || 0);
        setScrollTop(this._scrollCont, ctx2.__mbscScrollTop || 0);
      }
    }
    if (this._hasContext && !ctx2.__mbscModals) {
      ctx2.classList.remove("mbsc-popup-ctx");
    }
    this._hook("onClosed", {
      focus: shouldFocus
    });
    if (shouldFocus) {
      prevFocus.focus();
    }
    setTimeout(function() {
      if (activeModal === _this) {
        activeModal = getPrevActive(_this);
      }
    });
  };
  PopupBase2.prototype._unlisten = function() {
    unlisten(this._win, KEY_DOWN, this._onWndKeyDown);
    unlisten(this._scrollCont, SCROLL, this._onScroll);
    unlisten(this._scrollCont, TOUCH_MOVE, this._onContentScroll, {
      passive: false
    });
    unlisten(this._scrollCont, WHEEL, this._onContentScroll, {
      passive: false
    });
    unlisten(this._scrollCont, MOUSE_WHEEL, this._onContentScroll, {
      passive: false
    });
    unlisten(this._doc, MOUSE_DOWN, this._onMouseDown);
    unlisten(this._doc, MOUSE_UP, this._onMouseUp);
    unlisten(this._doc, CLICK, this._onDocClick);
    if (this.s.focusTrap) {
      unlisten(this._win, FOCUS_IN, this._onFocus);
    }
    if (this.s.focusElm) {
      unlisten(this.s.focusElm, KEY_DOWN, this._onKeyDown);
    }
    if (this._observer) {
      this._observer.detach();
      this._observer = null;
    }
  };
  PopupBase2.prototype._close = function(source) {
    if (this._isOpen) {
      if (this.s.isOpen === UNDEFINED) {
        this.setState({
          isOpen: false
        });
      }
      this._hook("onClose", {
        source
      });
    }
  };
  PopupBase2.defaults = {
    buttonVariant: "flat",
    cancelText: "Cancel",
    closeOnEsc: true,
    closeOnOverlayClick: true,
    closeText: "Close",
    contentPadding: true,
    display: "center",
    focusOnClose: true,
    focusOnOpen: true,
    focusTrap: true,
    maxWidth: MAX_WIDTH,
    okText: "Ok",
    scrollLock: true,
    setActive: true,
    setText: "Set",
    showArrow: true,
    showOverlay: true
  };
  PopupBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵPopupBase_BaseFactory;
    return function PopupBase_Factory(__ngFactoryType__) {
      return (ɵPopupBase_BaseFactory || (ɵPopupBase_BaseFactory = ɵɵgetInheritedFactory(PopupBase2)))(__ngFactoryType__ || PopupBase2);
    };
  })();
  PopupBase2.ɵdir = ɵɵdefineDirective({
    type: PopupBase2,
    selectors: [["", "mbsc-popup-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return PopupBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PopupBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-popup-b]"
    }]
  }], null, null);
})();
function getIonInput(el2, cb, nr) {
  if (nr === void 0) {
    nr = 0;
  }
  if (nr > 10) {
    delete el2.__mbscTimer;
    cb(el2);
  } else {
    clearTimeout(el2.__mbscTimer);
    el2.__mbscTimer = setTimeout(function() {
      if (el2.getInputElement) {
        el2.getInputElement().then(function(inp) {
          if (inp) {
            delete el2.__mbscTimer;
            cb(inp);
          } else {
            getIonInput(el2, cb, nr + 1);
          }
        });
      } else {
        getIonInput(el2, cb, nr + 1);
      }
    }, 10);
  }
}
function isIonInput(el2) {
  return el2.getInputElement || el2.tagName && el2.tagName.toLowerCase() === "ion-input";
}
function getNativeElement(input, callback) {
  if (input) {
    if (isIonInput(input)) {
      getIonInput(input, callback);
    } else if (input.vInput) {
      callback(input.vInput.nativeElement);
    } else if (input._el) {
      callback(input._el);
    } else if (input.instance && input.instance._el) {
      callback(input.instance._el);
    } else if (input.nodeType === 1) {
      callback(input);
    } else if (isString(input)) {
      var inputElement = doc.querySelector(input);
      if (inputElement) {
        callback(inputElement);
      }
    }
  }
}
function initPickerElement(el2, inst, handleChange, handleClick) {
  if (!el2 || el2.nodeType !== 1) {
    return noop;
  }
  var setReadOnly = function() {
    if ((inst.s.showOnClick || inst.s.showOnFocus) && isInput && !inst._allowTyping) {
      input.readOnly = true;
    }
  };
  var onClick = function(ev) {
    var s = inst.s;
    setReadOnly();
    if (handleClick) {
      handleClick(ev);
    }
    if (s.showOnClick && !s.disabled && (!inst._popup._isVisible || el2 !== inst._popup._prevFocus)) {
      setTimeout(function() {
        inst._focusElm = el2;
        inst._anchor = s.anchor || el2;
        inst.open();
      });
    }
  };
  var onMouseDown = function(ev) {
    if (inst.s.showOnClick) {
      if (inst.s.showOnFocus) {
        inst._preventShow = true;
      }
      if (!inst._allowTyping) {
        ev.preventDefault();
      }
    }
  };
  var onKeyDown = function(ev) {
    if (inst.s.showOnClick) {
      if (inst._isOpen) {
        if (ev.keyCode === ENTER && inst._allowTyping) {
          ev.stopPropagation();
        }
      } else {
        if (ev.keyCode === SPACE) {
          ev.preventDefault();
        }
        if (ev.keyCode === ENTER || ev.keyCode === SPACE) {
          onClick(ev);
        }
      }
    }
  };
  var onFocus = function(ev) {
    setReadOnly();
    if (inst.s.showOnFocus) {
      if (inst._preventShow) {
        inst._preventShow = false;
      } else {
        onClick(ev);
      }
    }
  };
  var onBlur = function() {
    if (isInput) {
      input.readOnly = readOnly;
    }
  };
  var onChange = function(ev) {
    if (handleChange) {
      handleChange(ev);
    }
  };
  var onWinFocus = function() {
    if (win2.document.activeElement === el2) {
      setReadOnly();
      inst._preventShow = true;
    }
  };
  var win2 = getWindow(el2);
  var isInput = matches(el2, "input,select");
  var input = el2;
  var readOnly;
  if (isInput) {
    input.autocomplete = "off";
    readOnly = input.readOnly;
  }
  listen(el2, CLICK, onClick);
  listen(el2, MOUSE_DOWN, onMouseDown);
  listen(el2, KEY_DOWN, onKeyDown);
  listen(el2, FOCUS, onFocus);
  listen(el2, BLUR, onBlur);
  listen(el2, CHANGE, onChange);
  listen(win2, FOCUS, onWinFocus);
  return function() {
    if (isInput) {
      input.readOnly = readOnly;
    }
    unlisten(el2, CLICK, onClick);
    unlisten(el2, MOUSE_DOWN, onMouseDown);
    unlisten(el2, KEY_DOWN, onKeyDown);
    unlisten(el2, FOCUS, onFocus);
    unlisten(el2, BLUR, onBlur);
    unlisten(el2, CHANGE, onChange);
    unlisten(win2, FOCUS, onWinFocus);
  };
}
var PickerBase = function(_super) {
  __extends(PickerBase2, _super);
  function PickerBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._nullSupport = true;
    _this._onInputChange = function(ev, val) {
      var value = ev.detail || (val !== UNDEFINED ? val : ev.target.value);
      if (value !== _this._tempValueText && !_this._preventChange) {
        _this._readValue(value, true);
        _this._valueTextChange = value !== _this._tempValueText;
        var newValue = isEmpty(value) ? null : _this._get(_this._tempValueRep);
        _this.value = newValue;
        _this._valueChange(newValue);
      }
      _this._preventChange = false;
    };
    _this._onResize = function(args) {
      _this._hook("onResize", args);
    };
    _this._onWrapperResize = function() {
      if (_this._wrapper) {
        _this._onResize({
          windowWidth: _this._wrapper.offsetWidth
        });
      }
    };
    _this._onPopupClose = function(args) {
      if (/cancel|esc|overlay|scroll/.test(args.source)) {
        _this._hook("onCancel", {
          value: _this.value,
          valueText: _this._valueText
        });
      }
      _this.close();
    };
    _this._onPopupClosed = function(args) {
      if (args.focus) {
        _this._preventShow = true;
      }
      _this._hook("onClosed", args);
      _this._onClosed();
    };
    _this._onPopupKey = function(args) {
      if (args.keyCode === 13) {
        _this._onEnterKey(args);
      }
    };
    _this._onPopupOpen = function(args) {
      args.value = _this.value;
      args.valueText = _this._valueText;
      _this._hook("onOpen", args);
    };
    _this._onButtonClick = function(_a) {
      var domEvent = _a.domEvent, button = _a.button;
      if (button.name === "set") {
        _this.set();
      }
      if (_this._popup) {
        _this._popup._onButtonClick({
          domEvent,
          button
        });
      }
    };
    _this._setInput = function(inp) {
      _this._el = inp && inp.nativeElement ? inp.nativeElement : inp;
    };
    _this._setPopup = function(popup) {
      _this._popup = popup;
    };
    _this._setWrapper = function(wrapper) {
      _this._wrapper = wrapper;
    };
    _this._shouldValidate = function(s, prevS) {
      return false;
    };
    _this._valueEquals = function(v1, v2) {
      return v1 === v2;
    };
    _this._copy = function(value) {
      return value;
    };
    _this._format = function(value) {
      return value;
    };
    _this._get = function(value) {
      return value;
    };
    _this._parse = function(valueText, fromInput) {
      return valueText;
    };
    return _this;
  }
  PickerBase2.prototype.open = function() {
    if (this._inst) {
      this._inst.open();
      return;
    }
    if (this.s.isOpen === UNDEFINED) {
      this.setState({
        isOpen: true
      });
    }
  };
  PickerBase2.prototype.close = function() {
    if (this.s.display === "inline") {
      return;
    }
    if (this._inst) {
      this._inst.close();
      return;
    }
    var args = {
      value: this.value,
      valueText: this._valueText
    };
    if (this.s.isOpen === UNDEFINED) {
      this.setState({
        isOpen: false
      });
    }
    this._hook("onClose", args);
  };
  PickerBase2.prototype.set = function() {
    this._valueRep = this._copy(this._tempValueRep);
    this._valueText = this._tempValueText;
    this._value = this.value = this._get(this._valueRep);
    this._valueChange(this.value);
  };
  PickerBase2.prototype.position = function() {
    if (this._inst) {
      this._inst.position();
      return;
    }
    if (this._popup) {
      this._popup.position();
    }
  };
  PickerBase2.prototype.isVisible = function() {
    if (this._inst) {
      return this._inst.isVisible();
    }
    return !!this._popup && this._popup.isVisible();
  };
  PickerBase2.prototype.getVal = function() {
    return this._nullSupport && isEmpty(this._value) ? this.s.selectMultiple ? [] : null : this._get(this._valueRep);
  };
  PickerBase2.prototype.setVal = function(value) {
    this.value = value;
    this.setState({
      value
    });
  };
  PickerBase2.prototype.getTempVal = function() {
    return this._get(this._tempValueRep);
  };
  PickerBase2.prototype.setTempVal = function(value) {
    this._tempValueSet = true;
    this._tempValueRep = this._parse(value);
    this._setOrUpdate(true);
  };
  PickerBase2.prototype._change = function(value) {
  };
  PickerBase2.prototype._render = function(s, state) {
    var _this = this;
    var props = this.props || {};
    var resp = this._respProps || {};
    var ctx2 = this._opt || {};
    var prevS = this._prevS;
    if (!this._touchUi) {
      s.display = resp.display || props.display || ctx2.display || options.display || "anchored";
      s.showArrow = resp.showArrow || props.showArrow || false;
    }
    if (s.display === "bubble") {
      s.display = "anchored";
    }
    this._scrollLock = s.scrollLock;
    var isOpen = s.isOpen !== UNDEFINED ? s.isOpen : state.isOpen;
    var modelValue = s.modelValue !== UNDEFINED ? s.modelValue : s.value;
    var value = modelValue !== UNDEFINED ? modelValue : state.value === UNDEFINED ? s.defaultValue : state.value;
    this._showInput = s.showInput !== UNDEFINED ? s.showInput : s.display !== "inline" && s.element === UNDEFINED;
    if (!this._buttons || s.buttons !== prevS.buttons || s.display !== prevS.display || s.setText !== prevS.setText || s.cancelText !== prevS.cancelText || s.closeText !== prevS.closeText || s.touchUi !== prevS.touchUi) {
      this._buttons = processButtons(this, s.buttons || (s.display !== "inline" && (s.display !== "anchored" || this._touchUi) ? ["cancel", "set"] : []));
      this._live = true;
      if (this._buttons && this._buttons.length) {
        for (var _i = 0, _a = this._buttons; _i < _a.length; _i++) {
          var b = _a[_i];
          if (b.name === "ok" || b.name === "set") {
            this._live = false;
          }
        }
      }
    }
    this._onRender(s);
    var valueChange = !this._valueEquals(value, this._value);
    var needParse = valueChange || this._tempValueRep === UNDEFINED || this._shouldValidate(s, prevS);
    if (needParse || s.defaultSelection !== prevS.defaultSelection || s.invalid !== prevS.invalid || s.valid !== prevS.valid) {
      if (needParse) {
        this._readValue(value);
      } else {
        this._validateTemp(value);
      }
      var newValue_1 = this._get(this._tempValueRep);
      var validationChange_1 = !this._valueEquals(value, newValue_1) && (!this._nullSupport || !isEmpty(value));
      this._setHeader();
      clearTimeout(this._handler);
      this._handler = setTimeout(function() {
        _this.value = value;
        if (validationChange_1) {
          _this._valueChange(newValue_1);
        }
        if (!_this._valueEquals(_this._tempValue, newValue_1) && _this._inst === UNDEFINED) {
          _this._hook("onTempChange", {
            value: newValue_1
          });
        }
      });
    }
    if (s.headerText !== prevS.headerText) {
      this._setHeader();
    }
    if (isOpen && !this._isOpen) {
      if (!this._tempValueSet || this._live) {
        var tempValue = this._get(this._tempValueRep);
        var parsedValue_1 = this._get(this._valueRep);
        this._tempValueRep = this._copy(this._valueRep);
        this._tempValueText = this._format(this._tempValueRep);
        this._tempValue = tempValue;
        this._setHeader();
        if (!this._valueEquals(tempValue, parsedValue_1)) {
          setTimeout(function() {
            _this._hook("onTempChange", {
              value: parsedValue_1
            });
          });
        }
      }
      this._onOpen();
    }
    this._allowTyping = s.inputTyping && !touchUi && !this._touchUi;
    this._anchorAlign = s.anchorAlign || (this._touchUi ? "center" : "start");
    this._cssClass = "mbsc-picker " + (s.cssClass || "");
    this._isOpen = isOpen;
    this._maxWidth = s.maxWidth;
    this._valueTextChange = this._valueTextChange || this._oldValueText !== this._valueText;
    this._oldValueText = this._valueText;
    this._value = value;
    this._shouldInitInput = this._shouldInitInput || prevS.display === UNDEFINED || s.display === "inline" && prevS.display !== "inline" || s.display !== "inline" && prevS.display === "inline" || s.element !== prevS.element;
  };
  PickerBase2.prototype._updated = function() {
    var _this = this;
    var s = this.s;
    var input = this._input;
    if (this._shouldInitInput && !this._inst) {
      this._unlisten();
      if (this._wrapper && s.display === "inline") {
        this._observer = resizeObserver(this._wrapper, this._onWrapperResize, this._zone);
      }
      getNativeElement(s.element || this._el, function(el2) {
        _this._el = el2;
        if (s.display !== "inline") {
          _this._resetEl = initPickerElement(el2, _this, _this._onInputChange);
        }
        if (matches(el2, "input,select")) {
          _this._input = el2;
          _this._write(el2);
        }
      });
    }
    if (this._valueTextChange && input) {
      this._write(input);
    }
    setTimeout(function() {
      if (s.responsive && s.display !== "inline" && win && _this.state.width === UNDEFINED) {
        _this._onResize({
          windowWidth: win.innerWidth
        });
      }
    });
    this._shouldInitInput = false;
    this._valueTextChange = false;
    this._anchor = s.anchor || this._focusElm || s.element || this._el;
  };
  PickerBase2.prototype._writeValue = function(elm, text, value) {
    var oldValue = elm.value;
    elm.value = text;
    return oldValue !== text;
  };
  PickerBase2.prototype._destroy = function() {
    this._unlisten();
    this._shouldInitInput = true;
  };
  PickerBase2.prototype._setHeader = function() {
    var headerText = this.s.headerText;
    this._headerText = headerText ? headerText.replace(/\{value\}/i, this._tempValueText || "&nbsp;") : UNDEFINED;
  };
  PickerBase2.prototype._setOrUpdate = function(preventChange) {
    var value = this._get(this._tempValueRep);
    this._tempValue = value;
    this._tempValueText = this._format(this._tempValueRep);
    this._setHeader();
    if (!preventChange) {
      this._hook("onTempChange", {
        value
      });
    }
    if (this._live) {
      this.set();
    } else {
      this.forceUpdate();
    }
  };
  PickerBase2.prototype._validate = function() {
  };
  PickerBase2.prototype._onRender = function(s) {
  };
  PickerBase2.prototype._onClosed = function() {
  };
  PickerBase2.prototype._onOpen = function() {
  };
  PickerBase2.prototype._onEnterKey = function(args) {
    this.set();
    this.close();
  };
  PickerBase2.prototype._valueChange = function(value) {
    if (this.s.value === UNDEFINED) {
      this.setState({
        value
      });
    }
    this._change(value);
    this._hook("onChange", {
      value,
      valueText: this._tempValueText
    });
  };
  PickerBase2.prototype._readValue = function(value, fromInput) {
    this._tempValueRep = this._parse(value, fromInput);
    this._validateTemp(value);
  };
  PickerBase2.prototype._validateTemp = function(value) {
    this._validate();
    this._tempValueText = this._format(this._tempValueRep);
    this._valueRep = this._copy(this._tempValueRep);
    this._valueText = !isEmpty(value) ? this._tempValueText : "";
  };
  PickerBase2.prototype._unlisten = function() {
    if (this._resetEl) {
      this._resetEl();
      this._resetEl = UNDEFINED;
    }
    if (this._observer) {
      this._observer.detach();
      this._observer = UNDEFINED;
    }
  };
  PickerBase2.prototype._write = function(input) {
    var _this = this;
    var value = this._value;
    var changed = this._writeValue(input, this._valueText || "", value);
    if (changed) {
      setTimeout(function() {
        _this._preventChange = true;
        trigger(input, INPUT);
        trigger(input, CHANGE);
      });
    }
    var mbscInput = input.__mbscFormInst;
    if (mbscInput) {
      mbscInput.setOptions({
        pickerMap: this._valueMap,
        pickerValue: value
      });
    }
  };
  PickerBase2.defaults = {
    cancelText: "Cancel",
    closeText: "Close",
    focusOnClose: os !== "android",
    okText: "Ok",
    setText: "Set",
    showOnFocus: touchUi
  };
  PickerBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵPickerBase_BaseFactory;
    return function PickerBase_Factory(__ngFactoryType__) {
      return (ɵPickerBase_BaseFactory || (ɵPickerBase_BaseFactory = ɵɵgetInheritedFactory(PickerBase2)))(__ngFactoryType__ || PickerBase2);
    };
  })();
  PickerBase2.ɵdir = ɵɵdefineDirective({
    type: PickerBase2,
    selectors: [["", "mbsc-p-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return PickerBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PickerBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-p-b]"
    }]
  }], null, null);
})();
function isInvalid(s, d, invalids, valids, min, max) {
  var key = getDateStr(d);
  if (min && +d < min || max && +d > max) {
    return true;
  }
  if (valids && valids[key]) {
    return false;
  }
  var invalidsForDay = invalids && invalids[key];
  if (invalidsForDay) {
    for (var _i = 0, invalidsForDay_1 = invalidsForDay; _i < invalidsForDay_1.length; _i++) {
      var invalid = invalidsForDay_1[_i];
      var start = invalid.start, end = invalid.end, allDay = invalid.allDay;
      if (start && end && !allDay) {
        var endDate = getEndDate(s, allDay, start, end);
        var dayStart = getDayStart(s, d);
        var dayEnd = getDayEnd(s, endDate);
        if (!isSameDay(start, end) && (+start === +dayStart || +endDate === +dayEnd || !isSameDay(d, start) && !isSameDay(d, end) && d > start && d < end)) {
          return invalid;
        }
      } else {
        return invalid;
      }
    }
  }
  return false;
}
function getClosestValidDate(d, s, min, max, invalids, valids, dir) {
  var next;
  var prev;
  var nextInvalid = true;
  var prevInvalid = true;
  var up = 0;
  var down = 0;
  if (+d < min) {
    d = createDate$1(s, min);
  }
  if (+d > max) {
    d = createDate$1(s, max);
  }
  var year = s.getYear(d);
  var month = s.getMonth(d);
  var start = s.getDate(year, month - 1, 1);
  var end = s.getDate(year, month + 2, 1);
  var from = +start > min ? +start : min;
  var until = +end < max ? +end : max;
  if (!invalids) {
    valids = getEventMap(s.valid, start, end, s, true, true);
    invalids = getEventMap(s.invalid, start, end, s, true, true);
  }
  if (!isInvalid(s, d, invalids, valids, min, max)) {
    return d;
  }
  next = d;
  prev = d;
  while (nextInvalid && +next < until && up < 100) {
    next = addDays(next, 1);
    nextInvalid = isInvalid(s, next, invalids, valids, min, max);
    up++;
  }
  while (prevInvalid && +prev > from && down < 100) {
    prev = addDays(prev, -1);
    prevInvalid = isInvalid(s, prev, invalids, valids, min, max);
    down++;
  }
  if (nextInvalid && prevInvalid) {
    return d;
  }
  if (dir === 1 && !nextInvalid) {
    return next;
  }
  if (dir === -1 && !prevInvalid) {
    return prev;
  }
  if (isSameMonth(d, next, s) && !nextInvalid) {
    return next;
  }
  if (isSameMonth(d, prev, s) && !prevInvalid) {
    return prev;
  }
  return prevInvalid || down >= up && !nextInvalid ? next : prev;
}
var modules = {};
var RANGE_SEPARATOR = " - ";
var CALENDAR_CTRL = ["calendar"];
var INVALID_ALL = [{
  recurring: {
    repeat: "daily"
  }
}];
function notActive(active) {
  return active === "start" ? "end" : "start";
}
function getPresetRange(timestamp, s) {
  var date = new Date(timestamp);
  var firstSelectDay = s.firstSelectDay !== UNDEFINED ? s.firstSelectDay : s.firstDay;
  var start = getFirstDayOfWeek(date, s, firstSelectDay);
  var end = new Date(start.getFullYear(), start.getMonth(), start.getDate() + s.selectSize - 1);
  return {
    start,
    end
  };
}
var DatepickerBase = function(_super) {
  __extends(DatepickerBase2, _super);
  function DatepickerBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._iso = {};
    _this._tempDate = null;
    _this._remote = 0;
    _this._onActiveChange = function(ev) {
      _this._active = ev.date;
      _this.forceUpdate();
    };
    _this._onResize = function(ev) {
      var viewportWidth = ev.windowWidth;
      ev.cancel = _this.state.width !== viewportWidth;
      _this.setState({
        isLarge: ev.isLarge,
        maxPopupWidth: ev.maxPopupWidth,
        width: viewportWidth,
        widthType: viewportWidth > 600 ? "md" : "sm"
      });
    };
    _this._onDayHoverIn = function(_a) {
      var date = _a.date, hidden = _a.hidden;
      _this.setState({
        hoverDate: hidden ? UNDEFINED : +date
      });
    };
    _this._onDayHoverOut = function(_a) {
      var date = _a.date;
      if (_this.state.hoverDate === +date) {
        _this.setState({
          hoverDate: UNDEFINED
        });
      }
    };
    _this._onCellClick = function(args) {
      _this._lastSelected = addTimezone(_this.s, args.date);
      args.active = _this._activeSelect;
      _this._hook("onCellClick", args);
    };
    _this._onCalendarChange = function(ev) {
      _this._tempValueSet = false;
      var s = _this.s;
      var tempValueRep = _this._copy(_this._tempValueRep);
      var date = map(ev.value, function(item) {
        return addTimezone(s, item);
      });
      var isPreset = s.select === "preset-range";
      var isRange = s.select === "range";
      var newSelection = isRange && _this._newSelection;
      var slide = (isRange || isPreset) && s.exclusiveEndDates && !_this._hasTime;
      if (slide && tempValueRep.end) {
        tempValueRep.end = +getDayStart(s, createDate$1(s, tempValueRep.end - 1));
      }
      if (_this._hasTime && _this._selectedTime && !isRange) {
        if (_this.s.selectMultiple) {
          var lastSelection = date[date.length - 1];
          if (lastSelection) {
            lastSelection.setHours(_this._selectedTime.getHours(), _this._selectedTime.getMinutes());
          }
        } else {
          date.setHours(_this._selectedTime.getHours(), _this._selectedTime.getMinutes());
        }
      }
      if (isRange || isPreset) {
        var oldValue = _this._getDate(tempValueRep);
        var oldRangeDate = oldValue.filter(function(v) {
          return v !== null;
        });
        var oldRange = oldRangeDate.map(function(dateValue) {
          return +dateValue;
        });
        var oldRangeCut_1 = oldRangeDate.map(function(v) {
          return +getDateOnly(v);
        });
        var newValue = date.filter(function(v) {
          return oldRangeCut_1.indexOf(+v) < 0;
        })[0];
        if (isPreset) {
          if (newValue) {
            var _a = getPresetRange(+newValue, s), start = _a.start, end = _a.end;
            tempValueRep.start = +start;
            tempValueRep.end = +end;
          }
        } else {
          var cycle = !_this._hasTime;
          var cycleAndLabels = _this._renderControls;
          var activeSelect = _this._activeSelect;
          var notActiveSelect = notActive(activeSelect);
          if (newValue) {
            if (_this._hasTime && _this._selectedTime) {
              newValue.setHours(_this._selectedTime.getHours(), _this._selectedTime.getMinutes(), _this._selectedTime.getSeconds(), _this._selectedTime.getMilliseconds());
            }
            switch (oldRange.length) {
              case 0: {
                tempValueRep = {};
                tempValueRep[activeSelect] = +newValue;
                break;
              }
              case 1: {
                if (cycleAndLabels) {
                  tempValueRep[activeSelect] = +newValue;
                  break;
                }
                if (oldRange[0] > +newValue || _this._activeSelect === "start") {
                  if (_this._hasTime) {
                    tempValueRep[activeSelect] = +newValue;
                  } else {
                    tempValueRep = {
                      start: +newValue
                    };
                    cycle = false;
                  }
                } else {
                  tempValueRep.end = +newValue;
                }
                break;
              }
              case 2: {
                if (cycleAndLabels) {
                  tempValueRep[activeSelect] = +newValue;
                  break;
                }
                if (oldRange[0] > +newValue || _this._activeSelect === "start") {
                  if (_this._hasTime) {
                    tempValueRep[activeSelect] = +newValue;
                  } else {
                    tempValueRep = {
                      start: +newValue
                    };
                    if (_this._activeSelect === "end") {
                      cycle = false;
                    }
                  }
                } else if (_this._activeSelect === "end") {
                  tempValueRep.end = +newValue;
                }
                break;
              }
            }
            if (cycleAndLabels && tempValueRep.start && tempValueRep.end && tempValueRep.start > tempValueRep.end) {
              tempValueRep = {
                start: +newValue
              };
              _this._setActiveSelect("end");
            }
          } else {
            var newDate = void 0;
            if (oldRange.length === 1) {
              newDate = createDate$1(s, oldRange[0]);
            } else {
              newDate = _this._lastSelected;
            }
            if (_this._hasTime && _this._selectedTime) {
              newDate.setHours(_this._selectedTime.getHours(), _this._selectedTime.getMinutes(), _this._selectedTime.getSeconds(), _this._selectedTime.getMilliseconds());
            } else if (!s.exclusiveEndDates && !_this._hasTime && _this._activeSelect === "end" && oldValue[0] && isSameDay(newDate, oldValue[0])) {
              newDate.setHours(23, 59, 59, 999);
            }
            if (cycleAndLabels || _this._hasTime) {
              tempValueRep[activeSelect] = +newDate;
            } else if (_this._activeSelect === "start") {
              tempValueRep = {
                start: +newDate
              };
            } else {
              tempValueRep.end = +newDate;
            }
          }
          if (tempValueRep.start && tempValueRep.end) {
            if (tempValueRep.start > tempValueRep.end) {
              var st = createDate$1(s, tempValueRep.start);
              var ed = createDate$1(s, tempValueRep.end);
              if (isSameDay(st, ed)) {
                ed.setHours(st.getHours(), st.getMinutes(), st.getSeconds(), st.getMilliseconds());
                tempValueRep.end = +ed;
              } else {
                tempValueRep.end = UNDEFINED;
              }
            }
            if (s.minRange && tempValueRep.end) {
              var newEnd = _this._hasTime ? tempValueRep.start + s.minRange : +addDays(createDate$1(s, tempValueRep.start), s.minRange - 1);
              if (tempValueRep.end < newEnd && (!_this._hasTime || activeSelect === "start")) {
                tempValueRep.end = UNDEFINED;
              }
            }
            if (s.maxRange && tempValueRep.end) {
              var newEnd = _this._hasTime ? tempValueRep.start + s.maxRange : +addDays(createDate$1(s, tempValueRep.start), s.maxRange) - 1;
              if (tempValueRep.end > newEnd && (!_this._hasTime || activeSelect === "start")) {
                tempValueRep.end = UNDEFINED;
              }
            }
            if (tempValueRep.end && activeSelect === "start" && !s.inRangeInvalid) {
              var nextInvalid = s.valid ? addDays(getLatestOccurrence(s.valid, createDate$1(s, tempValueRep.start), s), 1) : getNextOccurrence(s.invalid || [], createDate$1(s, tempValueRep.start), s);
              if (nextInvalid !== null && +nextInvalid < tempValueRep.end) {
                tempValueRep.end = UNDEFINED;
              }
            }
          }
          if (cycle && (_this._newSelection || !_this._renderControls || _this._newSelection === UNDEFINED && _this.s.display === "inline")) {
            _this._setActiveSelect(notActiveSelect);
            _this._newSelection = false;
          }
        }
      } else {
        tempValueRep = {
          date: {}
        };
        if (_this.s.selectMultiple) {
          for (var _i = 0, date_1 = date; _i < date_1.length; _i++) {
            var dateVal = date_1[_i];
            tempValueRep.date[+dateVal] = dateVal;
          }
        } else {
          if (_this._hasTime) {
            var time = _this._selectedTime || /* @__PURE__ */ new Date();
            date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
          }
          tempValueRep.date[+date] = date;
        }
      }
      _this._tempValueRep = tempValueRep;
      if (slide && tempValueRep.end) {
        tempValueRep.end = +getDayStart(s, addDays(createDate$1(s, tempValueRep.end), 1));
      }
      _this._setOrUpdate();
      if (_this._live && (!_this.s.selectMultiple || isRange) && !_this._hasTime && (!isRange || tempValueRep.start && tempValueRep.end && !newSelection)) {
        _this.close();
      }
    };
    _this._onDatetimeChange = function(ev) {
      var s = _this.s;
      var isRange = s.select === "range";
      var value = addTimezone(s, ev.value);
      var date = _this._hasTime ? value : getDateOnly(value);
      var d = +date;
      _this._tempValueSet = false;
      var tempValueRep = _this._copy(_this._tempValueRep);
      var slide = isRange && s.exclusiveEndDates && !_this._hasTime;
      if (slide && tempValueRep.end) {
        tempValueRep.end = +getDayStart(s, createDate$1(s, tempValueRep.end - 1));
      }
      if (isRange) {
        if (_this._activeSelect === "start") {
          if (_this._hasTime && _this._selectedTime) {
            date.setHours(_this._selectedTime.getHours(), _this._selectedTime.getMinutes(), _this._selectedTime.getSeconds(), _this._selectedTime.getMilliseconds());
          }
          tempValueRep.start = d;
          if (tempValueRep.end) {
            var minRange = s.minRange && !_this._hasTime ? (s.minRange - 1) * 24 * 60 * 60 * 1e3 - 1 : s.minRange || 0;
            var range = tempValueRep.end - tempValueRep.start;
            if (range < minRange) {
              tempValueRep.end = UNDEFINED;
            }
          }
        } else {
          if (_this._hasTime) {
            if (_this._selectedTime) {
              date.setHours(_this._selectedTime.getHours(), _this._selectedTime.getMinutes(), _this._selectedTime.getSeconds(), _this._selectedTime.getMilliseconds());
            }
          } else if (tempValueRep.start === +getDateOnly(date) && !s.exclusiveEndDates) {
            date.setHours(23, 59, 59, 999);
          }
          tempValueRep.end = +date;
        }
      } else {
        if (_this._hasTime && _this._hasDate && s.controls.indexOf("datetime") < 0) {
          var time = _this._selectedTime || /* @__PURE__ */ new Date();
          date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
        } else {
          _this._selectedTime = createDate$1(s, date);
        }
        tempValueRep = {
          date: {}
        };
        tempValueRep.date[+date] = date;
      }
      _this._tempValueRep = tempValueRep;
      if (slide && tempValueRep.end) {
        tempValueRep.end = +getDayStart(s, addDays(createDate$1(s, tempValueRep.end), 1));
      }
      _this._setOrUpdate();
    };
    _this._onTempDateChange = function(ev) {
      var date = ev.value;
      if (!_this._selectedTime) {
        var now = createDate$1(_this.s);
        date.setHours(now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds());
      }
      _this._tempDate = date;
    };
    _this._onTimePartChange = function(ev) {
      _this._tempValueSet = false;
      var s = _this.s;
      var isRange = s.select === "range";
      var date = addTimezone(s, ev.value);
      _this._selectedTime = date;
      if (isRange) {
        var values = _this._getDate(_this._tempValueRep);
        var valueIndex = _this._activeSelect === "start" ? 0 : 1;
        if (values[valueIndex]) {
          var value = createDate$1(s, values[valueIndex]);
          value.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
          values[valueIndex] = value;
          if (_this._activeSelect === "start" && +value > +values[1]) {
            values.length = 1;
          }
          _this._tempValueRep = _this._parse(values);
        } else {
          _this._selectedTime.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
        }
      } else if (!s.selectMultiple) {
        var value = _this._getDate(_this._tempValueRep) || _this._tempDate;
        if (value) {
          value.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
          _this._tempValueRep = {
            date: {}
          };
          _this._tempValueRep.date[+value] = value;
        } else {
          _this._selectedTime.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
          if (_this._live) {
            _this.forceUpdate();
            return;
          }
        }
      }
      _this._setOrUpdate();
    };
    _this._changeActiveTab = function(ev) {
      _this.setState({
        activeTab: ev.target.value
      });
    };
    _this._changeActiveSelect = function(ev) {
      var active = ev.target.value;
      _this._setActiveSelect(active);
      _this.setActiveDate(active);
    };
    _this._clearEnd = function() {
      _this._tempValueRep.end = UNDEFINED;
      if (_this._hasTimegrid) {
        _this._selectedTime = UNDEFINED;
      }
      _this._setOrUpdate();
    };
    _this._clearStart = function() {
      _this._tempValueRep = {};
      _this._newSelection = true;
      if (_this._hasTimegrid) {
        _this._selectedTime = UNDEFINED;
      }
      _this._setOrUpdate();
    };
    _this._shouldValidate = function(s, prevS) {
      return s.controls !== prevS.controls || s.dataTimezone !== prevS.dataTimezone || s.displayTimezone !== prevS.displayTimezone || s.dateFormat !== prevS.dateFormat || s.timeFormat !== prevS.timeFormat || s.locale !== prevS.locale || s.min !== prevS.min || s.max !== prevS.max;
    };
    _this._valueEquals = function(v1, v2) {
      var side1 = isArray(v1) && v1.length === 0 || v1 === UNDEFINED || v1 === null;
      var side2 = isArray(v2) && v2.length === 0 || v2 === UNDEFINED || v2 === null;
      return side1 && side1 === side2 || dateValueEquals(v1, v2, _this.s);
    };
    _this._copy = function(value) {
      var date = value.date ? __assign({}, value.date) : value.date;
      return __assign(__assign({}, value), {
        date
      });
    };
    _this._format = function(valueRep) {
      var s = _this.s;
      var ret = [];
      if (!s) {
        return "";
      }
      if (s.select === "date") {
        var vRep = valueRep.date;
        for (var i in vRep) {
          if (vRep[i] !== UNDEFINED && vRep[i] !== null) {
            ret.push(formatDate(_this._valueFormat, vRep[i], s));
          }
        }
        return s.selectMultiple ? ret.join(", ") : ret[0];
      } else {
        if (valueRep.start) {
          ret.push(formatDate(_this._valueFormat, createDate$1(s, valueRep.start), s));
        }
        if (valueRep.end) {
          if (!ret.length) {
            ret.push("");
          }
          var end = createDate$1(s, valueRep.end - (s.exclusiveEndDates && !_this._hasTime ? 1 : 0));
          ret.push(formatDate(_this._valueFormat, end, s));
        }
        _this._tempStartText = ret[0] || "";
        _this._tempEndText = ret[1] || "";
        return ret.join(RANGE_SEPARATOR);
      }
    };
    _this._get = function(value) {
      var s = _this.s;
      var valueFormat = _this._valueFormat;
      var isoParts = _this._iso;
      var valueDate = _this._getDate(value);
      if (isArray(valueDate)) {
        return valueDate.map(function(date) {
          return date ? returnDate(date, s, valueFormat, isoParts, _this._hasTime) : null;
        });
      }
      if (valueDate === null) {
        return null;
      }
      return returnDate(valueDate, s, valueFormat, isoParts, _this._hasTime);
    };
    _this._parse = function(value, fromInput) {
      var s = _this.s;
      var ret = {};
      var isRange = s.select !== "date";
      var isMultiple = s.selectMultiple;
      var values = [];
      if (isEmpty(value)) {
        var def = s.defaultSelection;
        value = isMultiple || isRange ? def : def === null || _this._live && s.display !== "inline" ? null : def || /* @__PURE__ */ new Date();
      }
      if (isString(value) && (isRange || isMultiple)) {
        values = value.split(isRange ? RANGE_SEPARATOR : ",");
      } else if (isArray(value)) {
        values = value;
      } else if (value && !isArray(value)) {
        values = [value];
      }
      if (isRange) {
        var start = values[0], end = values[1];
        var startDate = makeDate(start, s, _this._valueFormat, _this._iso, fromInput);
        var endDate = makeDate(end, s, _this._valueFormat, _this._iso, fromInput);
        if (fromInput && startDate) {
          startDate = addTimezone(s, startDate);
        }
        if (fromInput && endDate) {
          endDate = addTimezone(s, endDate);
        }
        ret.start = startDate ? +startDate : UNDEFINED;
        ret.end = endDate ? +endDate : UNDEFINED;
      } else {
        ret.date = {};
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
          var val = values_1[_i];
          if (!isEmpty(val)) {
            var date = makeDate(val, s, _this._valueFormat, _this._iso, fromInput);
            if (date) {
              if (fromInput) {
                date = addTimezone(s, date);
              }
              var key = +getDateOnly(date);
              ret.date[key] = date;
              if (_this._hasTime) {
                _this._selectedTime = new Date(date);
              }
            }
          }
        }
      }
      return ret;
    };
    _this._onInputClickRange = function(ev) {
      var inp = ev.target;
      var activate = inp === _this._startInput || _this._renderControls ? "start" : "end";
      _this._setActiveSelect(activate);
    };
    _this._onInputChangeRange = function(ev) {
      var startInput = _this._startInput;
      var endInput = _this._endInput;
      var value = (startInput ? startInput.value : "") + (endInput && endInput.value ? RANGE_SEPARATOR + endInput.value : "");
      _this._onInputChange(ev, value);
    };
    return _this;
  }
  DatepickerBase2.prototype.setActiveDate = function(active) {
    var notActiveSelect = notActive(active);
    this._activeSelect = active;
    var activeValue = this._tempValueRep[active];
    var notActiveValue = this._tempValueRep[notActiveSelect];
    if (this._tempValueRep.start && this._tempValueRep.end || !activeValue && notActiveValue) {
      this._newSelection = false;
    } else if (activeValue && !notActiveValue) {
      this._newSelection = true;
    }
    if (activeValue) {
      this._active = activeValue;
    }
    if (!activeValue && this._hasTimegrid) {
      this._selectedTime = UNDEFINED;
    }
    this.forceUpdate();
  };
  DatepickerBase2.prototype.getTempVal = function() {
    return _super.prototype.getTempVal.call(this);
  };
  DatepickerBase2.prototype.setTempVal = function(value) {
    _super.prototype.setTempVal.call(this, value);
  };
  DatepickerBase2.prototype.navigate = function(date) {
    this._active = +makeDate(date);
    this.forceUpdate();
  };
  DatepickerBase2.prototype.setVal = function(value) {
    if (this.s.select === "range" && value) {
      var start = value[0], end = value[1];
      this._savedStartValue = +makeDate(start, this.s, this._valueFormat);
      this._savedEndValue = +makeDate(end, this.s, this._valueFormat);
    }
    _super.prototype.setVal.call(this, value);
  };
  DatepickerBase2.prototype._render = function(s, state) {
    var _this = this;
    if (s.inRangeInvalid) {
      s.rangeEndInvalid = false;
    }
    if (s.select === "preset-range") {
      s.controls = CALENDAR_CTRL;
    }
    if (s.exclusiveEndDates === UNDEFINED) {
      s.exclusiveEndDates = !!s.displayTimezone;
    }
    var hadTime = this._hasTime;
    var hasDate = this._hasDate = !!find(s.controls, function(item) {
      return /date|calendar/.test(item);
    });
    var hasTime = this._hasTime = !!find(s.controls, function(item) {
      return /time/.test(item);
    });
    if (!hasTime) {
      s.timezonePlugin = s.dataTimezone = s.displayTimezone = UNDEFINED;
    }
    if (s.valid && (!s.invalid || hasTime)) {
      s.invalid = INVALID_ALL;
    }
    var prevS = this._prevS;
    s.buttons;
    var calendarSize = s.calendarSize;
    s.children;
    s.className;
    var controls = s.controls;
    s.cssClass;
    s.element;
    s.modelValue;
    s.onDestroy;
    s.onInit;
    s.onTempChange;
    s.responsive;
    var select = s.select, selectMultiple = s.selectMultiple, tabs = s.tabs, other = __rest(s, ["buttons", "calendarSize", "children", "className", "controls", "cssClass", "element", "modelValue", "onDestroy", "onInit", "onTempChange", "responsive", "select", "selectMultiple", "tabs"]);
    var widthType = state.widthType || "sm";
    var isRange = select !== "date";
    this._renderTabs = controls.length > 1 && (tabs === "auto" ? widthType === "sm" : tabs);
    if (select !== prevS.select && this._tempValueRep) {
      if (isRange && this._tempValueRep.date) {
        var _a = Object.keys(this._tempValueRep.date).map(function(v) {
          return +v;
        }).sort(), start = _a[0], end = _a[1];
        this._tempValueRep.start = start;
        this._tempValueRep.end = end;
        this._tempValueRep.date = UNDEFINED;
        this._tempValueText = this._format(this._tempValueRep);
        setTimeout(function() {
          _this.set();
        });
      } else if (!isRange && (this._tempValueRep.start || this._tempValueRep.end)) {
        if (!this._tempValueRep.date) {
          this._tempValueRep.date = {};
        }
        var first = this._tempValueRep.start || this._tempValueRep.end;
        this._tempValueRep.date[first] = new Date(first);
        var second = this._tempValueRep.end || this._tempValueRep.start;
        if (second !== first && s.selectMultiple) {
          this._tempValueRep.date[second] = new Date(second);
        }
        this._tempValueRep.start = UNDEFINED;
        this._tempValueRep.end = UNDEFINED;
        this._tempValueText = this._format(this._tempValueRep);
        setTimeout(function() {
          _this.set();
        });
      }
    }
    if (s.min !== prevS.min) {
      this._min = isEmpty(s.min) ? UNDEFINED : makeDate(s.min, s, s.dateFormat);
    }
    if (s.max !== prevS.max) {
      this._max = isEmpty(s.max) ? UNDEFINED : makeDate(s.max, s, s.dateFormat);
    }
    if (s.minTime !== prevS.minTime) {
      this._minTime = isEmpty(s.minTime) ? UNDEFINED : makeDate(s.minTime, s, s.timeFormat);
    }
    if (s.maxTime !== prevS.maxTime) {
      this._maxTime = isEmpty(s.maxTime) ? UNDEFINED : makeDate(s.maxTime, s, s.timeFormat);
    }
    var tempValueRepEnd = this._tempValueRep && this._tempValueRep.end;
    var tempValueRepStart = this._tempValueRep && this._tempValueRep.start;
    var format = (hasDate ? s.dateFormat : "") + (hasTime ? (hasDate ? s.separator : "") + s.timeFormat : "");
    var controlsChanged = JSON.stringify(controls) !== JSON.stringify(prevS.controls);
    if (controlsChanged) {
      this._controls = [];
      this._controlsClass = "";
      var config = {
        c: "datepicker",
        controls,
        dateFormat: s.dateFormat,
        dateText: s.dateText,
        separator: s.separator,
        timeFormat: s.timeFormat,
        timeText: s.timeText,
        v: version
      };
      this._remote++;
      sendLog(this);
      jsonp$1("remote", this, config, function(data) {
        _this._remote--;
        if (!_this._remote) {
          for (var _i2 = 0, _a2 = Object.keys(data); _i2 < _a2.length; _i2++) {
            var key = _a2[_i2];
            _this[key] = data[key];
          }
          for (var _b2 = 0, _c78 = _this._controls; _b2 < _c78.length; _b2++) {
            var control2 = _c78[_b2];
            control2.Component = modules[control2.name === "calendar" ? "Calendar" : control2.name === "timegrid" ? "Timegrid" : "Datetime"];
            _this._controlsClass += " mbsc-datepicker-control-" + control2.name;
          }
          showMessage(data.notification);
          if (!hasTime) {
            _this._selectedTime = UNDEFINED;
          }
          if (controlsChanged && isRange && s.exclusiveEndDates && hasTime !== hadTime && (tempValueRepEnd || tempValueRepStart)) {
            var savedStart_1 = _this._savedStartValue;
            var savedEnd_1 = _this._savedEndValue;
            setTimeout(function() {
              if (hasTime) {
                _this._tempValueRep.start = savedStart_1 || tempValueRepStart;
                _this._tempValueRep.end = savedEnd_1 || tempValueRepEnd;
              } else {
                _this._savedStartValue = tempValueRepStart;
                _this._savedEndValue = tempValueRepEnd;
                _this._clearSaved = false;
                var ss = __assign(__assign({}, s), {
                  dataTimezone: _this.props.dataTimezone,
                  displayTimezone: _this.props.displayTimezone,
                  timezonePlugin: _this.props.timezonePlugin
                });
                if (tempValueRepStart) {
                  _this._tempValueRep.start = +removeTimezone(getDayStart(ss, createDate$1(ss, tempValueRepStart)));
                }
                if (tempValueRepEnd) {
                  var tzonedEnd = createDate$1(ss, tempValueRepEnd - 1);
                  _this._tempValueRep.end = +removeTimezone(createDate$1(ss, +getDayEnd(ss, tzonedEnd) + 1));
                }
              }
              _this._valueText = _this._tempValueText = _this._format(_this._tempValueRep);
              _this._valueTextChange = true;
              _this.set();
            });
            _this._valueTextChange = false;
          }
          _this.forceUpdate();
        }
      }, "comp_" + this._uid);
      this._hasCalendar = controls.indexOf("calendar") !== -1;
    }
    this._renderControls = isRange && select !== "preset-range" && (s.showRangeLabels !== UNDEFINED ? s.showRangeLabels : true);
    this._nullSupport = s.display !== "inline" || select !== "date" || s.selectMultiple === true;
    this._valueFormat = format;
    this._activeTab = state.activeTab || controls[0];
    _super.prototype._render.call(this, s, state);
    var controlled = s.value !== UNDEFINED;
    var valueChanged = controlled ? s.value !== prevS.value : state.value !== this._prevStateValue;
    if (isRange && this._clearSaved && valueChanged) {
      this._savedEndValue = this._savedStartValue = UNDEFINED;
    }
    this._clearSaved = true;
    if (s.headerText !== prevS.headerText || s.selectCounter !== prevS.selectCounter || s.selectMultiple !== prevS.selectMultiple) {
      this._setHeader();
    }
    this._scrollLock = s.scrollLock !== UNDEFINED ? s.scrollLock : !this._hasTimegrid;
    this._showInput = s.showInput !== UNDEFINED ? s.showInput : this._showInput && (!isRange || !s.startInput && !s.endInput);
    this._shouldInitInputs = this._shouldInitInputs || select !== prevS.select || s.startInput !== prevS.startInput || s.endInput !== prevS.endInput;
    this._shouldInitInput = this._shouldInitInput || this._shouldInitInputs;
    if (controlsChanged || s.dateWheels !== prevS.dateWheels || s.timeWheels !== prevS.timeWheels || s.dateFormat !== prevS.dateFormat || s.timeFormat !== prevS.timeFormat) {
      var dateParts = s.dateWheels || s.dateFormat;
      var timeParts = s.timeWheels || s.timeFormat;
      var isoParts = this._iso = {};
      if (hasDate) {
        if (/y/i.test(dateParts)) {
          isoParts.y = 1;
        }
        if (/M/.test(dateParts)) {
          isoParts.y = 1;
          isoParts.m = 1;
        }
        if (/d/i.test(dateParts)) {
          isoParts.y = 1;
          isoParts.m = 1;
          isoParts.d = 1;
        }
      }
      if (hasTime) {
        if (/h/i.test(timeParts)) {
          isoParts.h = 1;
        }
        if (/m/.test(timeParts)) {
          isoParts.i = 1;
        }
        if (/s/i.test(timeParts)) {
          isoParts.s = 1;
        }
      }
    }
    var setButtonDisabled;
    if (isRange) {
      if (this._activeSelect === UNDEFINED) {
        this._setActiveSelect("start", true);
      }
      setButtonDisabled = this._selectionNotReady();
    } else {
      this._activeSelect = UNDEFINED;
      setButtonDisabled = false;
    }
    if (this._buttons) {
      var setBtn = find(this._buttons, function(btn) {
        return btn.name === "set";
      });
      if (setBtn && setBtn.disabled !== setButtonDisabled) {
        setBtn.disabled = setButtonDisabled;
        this._buttons = __spreadArray([], this._buttons, true);
      }
    }
    var activeSelect = this._activeSelect;
    this._needsWidth = (s.display === "anchored" || s.display === "center" || s.display !== "inline" && state.isLarge || controls.length > 1 && !tabs) && s.width === UNDEFINED;
    var maxDate = s.max !== UNDEFINED ? makeDate(s.max, s, format) : UNDEFINED;
    var minDate = s.min !== UNDEFINED ? makeDate(s.min, s, format) : UNDEFINED;
    this._maxLimited = maxDate;
    this._minLimited = minDate;
    var selectedStart = this._tempValueRep.start;
    if (selectedStart && (this._prevStart !== selectedStart || prevS.valid !== s.valid || prevS.invalid !== s.invalid)) {
      var startDate = createDate$1(s, selectedStart);
      this._nextInvalid = s.valid ? addDays(getLatestOccurrence(s.valid, startDate, s), 1) : getNextOccurrence(s.invalid || [], startDate, s);
    }
    var endSelection = activeSelect === "end" && selectedStart;
    if (endSelection) {
      if (!s.inRangeInvalid) {
        var nextInvalid = this._nextInvalid;
        if (nextInvalid) {
          if (s.rangeEndInvalid) {
            this._maxLimited = createDate$1(s, +addDays(nextInvalid, 1) - 1);
          } else {
            this._maxLimited = createDate$1(s, +nextInvalid - 1);
          }
        }
      }
      if (!this._hasCalendar || hasTime) {
        if (!this._minLimited || makeDate(this._minLimited, s, format) < createDate$1(s, selectedStart)) {
          this._minLimited = createDate$1(s, this._tempValueRep.start);
        }
      }
    }
    this._minTimeLimited = this._minLimited;
    if (endSelection) {
      if (s.minRange) {
        var minLimited = hasTime ? this._tempValueRep.start + s.minRange : +addDays(createDate$1(s, this._tempValueRep.start), s.minRange) - 1;
        if (!this._minLimited || +makeDate(this._minLimited, s, format) < minLimited) {
          this._minLimited = createDate$1(s, minLimited);
          this._minTimeLimited = this._minLimited;
        }
      }
      if (this._minTimeLimited === UNDEFINED && this._tempValueRep.start && this._tempValueRep.end) {
        this._minTimeLimited = createDate$1(s, +this._tempValueRep.start);
      }
      if (s.maxRange !== UNDEFINED) {
        var maxLimited = hasTime ? this._tempValueRep.start + s.maxRange : +addDays(createDate$1(s, this._tempValueRep.start), s.maxRange) - 1;
        if (!this._maxLimited || +makeDate(this._maxLimited, s, format) > maxLimited) {
          this._maxLimited = createDate$1(s, maxLimited);
        }
      }
    }
    for (var _i = 0, _b = this._controls; _i < _b.length; _i++) {
      var control = _b[_i];
      var options2 = __assign(__assign({}, other), {
        display: "inline",
        isOpen: s.isOpen || state.isOpen,
        max: this._maxLimited,
        min: this._minLimited
      });
      if (s.rangeEndInvalid && endSelection && this._nextInvalid) {
        options2.valid = __spreadArray(__spreadArray([], options2.valid || [], true), [this._nextInvalid], false);
      }
      if (control.name === "calendar") {
        options2.min = this._minLimited ? getDateOnly(this._minLimited) : UNDEFINED;
        options2.max = this._maxLimited ? getDateOnly(this._maxLimited) : UNDEFINED;
        options2.selectRange = isRange;
        options2.width = this._needsWidth ? PAGE_WIDTH * getPageNr(s.pages, state.maxPopupWidth) : UNDEFINED;
        if (s.calendarType === "week" && calendarSize) {
          options2.weeks = calendarSize;
        } else {
          options2.size = calendarSize;
        }
        var pages = s.pages === "auto" ? 3 : s.pages || 1;
        this._maxWidth = s.maxWidth || (pages > 2 ? PAGE_WIDTH * pages : UNDEFINED);
        if (isRange) {
          var valueDate = this._getDate(this._tempValueRep);
          var endDate = valueDate[1];
          if (endDate && s.exclusiveEndDates && !hasTime) {
            valueDate[1] = createDate$1(s, +endDate - 1);
          }
          var values = valueDate.filter(function(v) {
            return v !== null;
          }).map(function(v) {
            return +getDateOnly(v);
          }).filter(function(v, ind, arr) {
            return arr.indexOf(v) === ind;
          }).map(function(v) {
            return new Date(v);
          });
          options2.value = values;
          if (s.rangeHighlight) {
            options2.rangeStart = valueDate[0] && +getDateOnly(removeTimezone(valueDate[0]));
            options2.rangeEnd = valueDate[1] && +getDateOnly(removeTimezone(valueDate[1]));
            options2.onDayHoverIn = this._onDayHoverIn;
            options2.onDayHoverOut = this._onDayHoverOut;
            if (select === "preset-range") {
              if (state.hoverDate) {
                var _c = getPresetRange(state.hoverDate, s), start = _c.start, end = _c.end;
                options2.hoverStart = +start;
                options2.hoverEnd = +end;
              }
            } else {
              if (activeSelect === "end" && valueDate[0]) {
                options2.hoverStart = options2.rangeEnd || options2.rangeStart;
                options2.hoverEnd = state.hoverDate;
              }
              if (activeSelect === "start" && valueDate[1] && this._renderControls) {
                options2.hoverStart = state.hoverDate;
                options2.hoverEnd = options2.rangeStart || options2.rangeEnd;
              }
            }
          }
        } else {
          options2.selectMultiple = selectMultiple;
          options2.value = this._getDate(this._tempValueRep);
        }
        var vals = isArray(options2.value) ? options2.value : [options2.value];
        var min = options2.min ? +options2.min : -Infinity;
        var max = options2.max ? +options2.max : Infinity;
        var selected = void 0;
        for (var _d = 0, vals_1 = vals; _d < vals_1.length; _d++) {
          var val = vals_1[_d];
          if (!selected && val >= min && val <= max) {
            selected = +val;
          }
        }
        if (!selected && isRange && vals.length) {
          selected = +vals[0];
        }
        if (selected !== this._selectedDate || this._active === UNDEFINED || s.min !== prevS.min || s.max !== prevS.max) {
          this._selectedDate = selected;
          this._active = selected ? +getDateOnly(new Date(selected)) : constrain(this._active || +getDateOnly(/* @__PURE__ */ new Date()), min, max);
        }
        var viewFormat = s.dateWheels || s.dateFormat;
        var selectedView = /d/i.test(viewFormat) ? PAGE_VIEW : /m/i.test(viewFormat) ? YEAR_VIEW : /y/i.test(viewFormat) ? MULTI_YEAR_VIEW : PAGE_VIEW;
        options2.active = this._active;
        options2.onActiveChange = this._onActiveChange;
        options2.onChange = this._onCalendarChange;
        options2.onCellClick = this._onCellClick;
        options2.onCellHoverIn = this._proxyHook;
        options2.onCellHoverOut = this._proxyHook;
        options2.onLabelClick = this._proxyHook;
        options2.onPageChange = this._proxyHook;
        options2.onPageLoaded = this._proxyHook;
        options2.onPageLoading = this._proxyHook;
        options2.selectView = selectedView;
      } else {
        var tempValueKeys = Object.keys(this._tempValueRep.date || {});
        options2.displayStyle = (s.display === "bottom" || s.display === "top") && (this._hasCalendar || this._renderTabs) ? "center" : s.display;
        options2.mode = control.name;
        if ((control.name === "time" || control.name === "timegrid") && hasDate) {
          options2.onChange = this._onTimePartChange;
          if (isRange) {
            var alreadySelectedOne = this._tempValueRep[activeSelect];
            var selectedTime = void 0;
            if (this._selectedTime) {
              if (!this._minTimeLimited || this._selectedTime > this._minTimeLimited) {
                selectedTime = this._selectedTime;
              } else {
                selectedTime = createDate$1(s, this._minTimeLimited);
                selectedTime.setHours(this._selectedTime.getHours(), this._selectedTime.getMinutes(), this._selectedTime.getSeconds(), this._selectedTime.getMilliseconds());
              }
            }
            var nowTrimmed = createDate$1(s);
            nowTrimmed.setSeconds(0, 0);
            this._selectedTime = alreadySelectedOne ? createDate$1(s, alreadySelectedOne) : selectedTime || (control.name === "time" ? nowTrimmed : UNDEFINED);
            options2.value = this._selectedTime;
          } else if (!s.selectMultiple) {
            var alreadyDate = this._tempValueRep.date && this._tempValueRep.date[tempValueKeys[0]] || (this._hasCalendar ? this._selectedTime : null);
            var tDate = this._tempDate;
            var selTime = this._selectedTime;
            if (!alreadyDate && tDate && selTime) {
              alreadyDate = createDate$1(s, tDate);
              alreadyDate.setHours(selTime.getHours(), selTime.getMinutes(), selTime.getSeconds(), selTime.getMilliseconds());
            }
            this._selectedTime = options2.value = alreadyDate;
          }
          options2.min = this._minTimeLimited;
          options2.max = this._maxLimited;
        } else {
          options2.onChange = this._onDatetimeChange;
          options2.onTempChange = this._onTempDateChange;
          if (isRange) {
            var n = this._tempValueRep[activeSelect];
            var m = this._tempValueRep[notActive(activeSelect)];
            options2.value = n ? createDate$1(s, n) : m && !hasDate ? createDate$1(s, m) : null;
            if (activeSelect === "end" && s.exclusiveEndDates && !hasTime) {
              options2.value = createDate$1(s, +options2.value - 1);
            }
          } else {
            var value = this._tempValueRep.date && this._tempValueRep.date[tempValueKeys[0]];
            var passed = value;
            if (value) {
              if (!hasTime) {
                passed = getDateOnly(value);
              }
            }
            options2.value = passed || null;
          }
        }
        if (control.name === "time" || control.name === "timegrid") {
          var selectedOrDefault = options2.value || constrainDate(/* @__PURE__ */ new Date(), options2.min, options2.max);
          if (this._minTime) {
            var minTime = this._minTime;
            var min = new Date(selectedOrDefault.getFullYear(), selectedOrDefault.getMonth(), selectedOrDefault.getDate(), minTime.getHours(), minTime.getMinutes(), minTime.getSeconds(), minTime.getMilliseconds());
            if (!options2.min || min > options2.min) {
              options2.min = min;
            }
          }
          if (this._maxTime) {
            var maxTime = this._maxTime;
            var max = new Date(selectedOrDefault.getFullYear(), selectedOrDefault.getMonth(), selectedOrDefault.getDate(), maxTime.getHours(), maxTime.getMinutes(), maxTime.getSeconds(), maxTime.getMilliseconds());
            if (!options2.max || max < options2.max) {
              options2.max = max;
            }
          }
        }
      }
      control.options = options2;
    }
    this._prevStart = this._tempValueRep.start;
    this._prevStateValue = state.value;
  };
  DatepickerBase2.prototype._updated = function() {
    var _this = this;
    var s = this.s;
    if (this._shouldInitInputs) {
      this._resetInputs();
      if (s.select === "range") {
        var startInput = s.startInput;
        if (startInput) {
          this._setupInput("start", startInput);
        }
        var endInput = s.endInput;
        if (endInput) {
          this._setupInput("end", endInput);
        }
        if (s.element && (this._startInput === s.element || this._endInput === s.element)) {
          this._shouldInitInput = false;
          clearTimeout(s.element.__mbscTimer);
        }
      }
      this._shouldInitInputs = false;
    }
    var valueTextChange = this._valueTextChange;
    _super.prototype._updated.call(this);
    if (s.select === "range" && valueTextChange) {
      var triggerChange = function(inp, val) {
        inp.value = val;
        setTimeout(function() {
          _this._preventChange = true;
          trigger(inp, INPUT);
          trigger(inp, CHANGE);
        });
      };
      if (this._startInput) {
        triggerChange(this._startInput, this._getValueText("start"));
      }
      if (this._endInput) {
        triggerChange(this._endInput, this._getValueText("end"));
      }
    }
  };
  DatepickerBase2.prototype._onEnterKey = function(args) {
    if (!this._selectionNotReady()) {
      _super.prototype._onEnterKey.call(this, args);
    }
  };
  DatepickerBase2.prototype._setupInput = function(i, input) {
    var _this = this;
    getNativeElement(input, function(inp) {
      var resetElement = initPickerElement(inp, _this, _this._onInputChangeRange, _this._onInputClickRange);
      if (i === "start") {
        _this._startInput = inp;
        _this._resetStartInput = resetElement;
      } else {
        _this._endInput = inp;
        _this._resetEndInput = resetElement;
      }
      var val = _this._getValueText(i);
      var changed = val !== inp.value;
      inp.value = val;
      if (changed) {
        setTimeout(function() {
          _this._preventChange = true;
          trigger(inp, INPUT);
          trigger(inp, CHANGE);
        });
      }
    });
  };
  DatepickerBase2.prototype._destroy = function() {
    this._resetInputs();
    _super.prototype._destroy.call(this);
  };
  DatepickerBase2.prototype._setHeader = function() {
    var s = this.s;
    if (s.selectCounter && s.selectMultiple) {
      var count2 = Object.keys(this._tempValueRep && this._tempValueRep.date || {}).length;
      this._headerText = (count2 > 1 ? s.selectedPluralText || s.selectedText : s.selectedText).replace(/{count}/, "" + count2);
    } else {
      _super.prototype._setHeader.call(this);
    }
  };
  DatepickerBase2.prototype._validate = function() {
    if (this._max <= this._min) {
      return;
    }
    var s = this.s;
    var min = this._min ? +this._min : -Infinity;
    var max = this._max ? +this._max : Infinity;
    if (s.select === "date") {
      var values = this._tempValueRep.date;
      if (!s.selectMultiple) {
        for (var _i = 0, _a = Object.keys(values); _i < _a.length; _i++) {
          var key = _a[_i];
          var d = values[key];
          var validated = getClosestValidDate(d, s, min, max);
          if (+validated !== +d) {
            delete values[key];
            values[+getDateOnly(validated)] = validated;
          }
        }
      }
    } else if (s.select !== "preset-range") {
      var range = this._getDate(this._tempValueRep);
      var startDate = range[0], endDate = range[1];
      if (startDate) {
        startDate = getClosestValidDate(startDate, s, min, max);
        if (!s.inRangeInvalid && (!this._prevStart || this._prevStart !== +startDate || s.invalid !== this._prevS.invalid)) {
          this._nextInvalid = s.valid ? addDays(getLatestOccurrence(s.valid, startDate, s), 1) : getNextOccurrence(s.invalid || [], startDate, s);
        }
      }
      if (endDate) {
        if (!s.inRangeInvalid && this._nextInvalid && this._nextInvalid <= endDate) {
          endDate = s.rangeEndInvalid ? this._nextInvalid : addDays(this._nextInvalid, -1);
        } else {
          endDate = getClosestValidDate(endDate, s, min, max);
        }
      }
      if (startDate && endDate && startDate > endDate) {
        if (this._activeSelect === "end") {
          startDate = endDate;
        } else {
          endDate = startDate;
        }
      }
      if (startDate) {
        this._prevStart = this._tempValueRep.start = +startDate;
      }
      if (endDate) {
        this._tempValueRep.end = +endDate;
      }
    }
  };
  DatepickerBase2.prototype._getDate = function(value) {
    var s = this.s;
    var isRange = s.select !== "date";
    if (isRange) {
      var start = value.start ? createDate$1(s, value.start) : null;
      var end = value.end ? createDate$1(s, value.end) : null;
      if (!start && !end) {
        return [];
      }
      return [start, end];
    }
    if (s.selectMultiple) {
      var valueArray = [];
      var dates = value.date;
      if (dates) {
        for (var _i = 0, _a = Object.keys(dates); _i < _a.length; _i++) {
          var v = _a[_i];
          valueArray.push(createDate$1(s, +v));
        }
      }
      return valueArray;
    }
    var valueKeys = Object.keys(value.date || {});
    if (!valueKeys.length) {
      return null;
    }
    return createDate$1(s, value.date[valueKeys[0]]);
  };
  DatepickerBase2.prototype._onClosed = function() {
    this._active = this._activeSelect = UNDEFINED;
    if (this._hasTimegrid) {
      this._selectedTime = UNDEFINED;
    }
  };
  DatepickerBase2.prototype._onOpen = function() {
    this._newSelection = true;
  };
  DatepickerBase2.prototype._resetInputs = function() {
    if (this._resetStartInput) {
      this._resetStartInput();
      this._resetStartInput = UNDEFINED;
    }
    if (this._resetEndInput) {
      this._resetEndInput();
      this._resetEndInput = UNDEFINED;
    }
  };
  DatepickerBase2.prototype._getValueText = function(input) {
    return this._valueText.split(RANGE_SEPARATOR)[input === "start" ? 0 : 1] || "";
  };
  DatepickerBase2.prototype._selectionNotReady = function() {
    var notReady = false;
    if (this.s.select === "range") {
      var val = (this._get(this._tempValueRep || {}) || []).filter(function(v) {
        return v;
      });
      notReady = !val.length;
      if (!notReady) {
        if (this._hasCalendar && !this._hasTime) {
          notReady = val.length < 2;
        } else {
          if (this._renderControls) {
            notReady = val.length < 2;
          } else {
            notReady = !this._tempValueRep[this._activeSelect];
          }
        }
      }
    }
    return notReady;
  };
  DatepickerBase2.prototype._setActiveSelect = function(active, timeout) {
    var _this = this;
    if (this._activeSelect !== active) {
      if (timeout) {
        setTimeout(function() {
          return _this._hook("onActiveDateChange", {
            active
          });
        });
      } else {
        this._hook("onActiveDateChange", {
          active
        });
      }
    }
    this._activeSelect = active;
  };
  DatepickerBase2.defaults = __assign(__assign(__assign({}, dateTimeLocale), PickerBase.defaults), {
    activeElm: '.mbsc-calendar-cell[tabindex="0"]',
    controls: CALENDAR_CTRL,
    inRangeInvalid: false,
    inputTyping: true,
    rangeEndHelp: "Please select",
    rangeEndLabel: "End",
    rangeHighlight: true,
    rangeStartHelp: "Please select",
    rangeStartLabel: "Start",
    select: "date",
    selectSize: 7,
    selectedText: "{count} selected",
    showOnClick: true
  });
  DatepickerBase2._name = "Datepicker";
  DatepickerBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵDatepickerBase_BaseFactory;
    return function DatepickerBase_Factory(__ngFactoryType__) {
      return (ɵDatepickerBase_BaseFactory || (ɵDatepickerBase_BaseFactory = ɵɵgetInheritedFactory(DatepickerBase2)))(__ngFactoryType__ || DatepickerBase2);
    };
  })();
  DatepickerBase2.ɵdir = ɵɵdefineDirective({
    type: DatepickerBase2,
    selectors: [["", "mbsc-dp-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return DatepickerBase2;
}(PickerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatepickerBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-dp-b]"
    }]
  }], null, null);
})();
var tapped = 0;
var allowQuick;
function getCoord(ev, axis, page) {
  var prop = (page ? "page" : "client") + axis;
  if (ev.targetTouches && ev.targetTouches[0]) {
    return ev.targetTouches[0][prop];
  }
  if (ev.changedTouches && ev.changedTouches[0]) {
    return ev.changedTouches[0][prop];
  }
  return ev[prop];
}
function preventClick() {
  tapped++;
  setTimeout(function() {
    tapped--;
  }, 500);
}
function triggerClick(ev, control) {
  if (control.mbscClick) {
    return;
  }
  var touch = (ev.originalEvent || ev).changedTouches[0];
  var evt = document.createEvent("MouseEvents");
  evt.initMouseEvent("click", true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  evt.isMbscTap = true;
  evt.isIonicTap = true;
  allowQuick = true;
  control.mbscChange = true;
  control.mbscClick = true;
  control.dispatchEvent(evt);
  allowQuick = false;
  preventClick();
  setTimeout(function() {
    delete control.mbscClick;
  });
}
function bustClick(ev) {
  if (tapped && !allowQuick && !ev.isMbscTap && !(ev.target.nodeName === "TEXTAREA" && ev.type === MOUSE_DOWN)) {
    ev.stopPropagation();
    ev.preventDefault();
  }
}
if (isBrowser) {
  [MOUSE_OVER, MOUSE_ENTER, MOUSE_DOWN, MOUSE_UP, CLICK].forEach(function(ev) {
    doc.addEventListener(ev, bustClick, true);
  });
  if (os === "android" && majorVersion < 5) {
    doc.addEventListener(CHANGE, function(ev) {
      var target = ev.target;
      if (tapped && target.type === "checkbox" && !target.mbscChange) {
        ev.stopPropagation();
        ev.preventDefault();
      }
      delete target.mbscChange;
    }, true);
  }
}
var wasTouched;
function setFocusInvisible(ev) {
  var win2 = getWindow(ev.target);
  win2.__mbscFocusVisible = false;
}
function setFocusVisible(ev) {
  var win2 = getWindow(ev.target);
  win2.__mbscFocusVisible = true;
}
function addRipple(elm, x, y) {
  var rect = elm.getBoundingClientRect();
  var left = x - rect.left;
  var top = y - rect.top;
  var width = Math.max(left, elm.offsetWidth - left);
  var height = Math.max(top, elm.offsetHeight - top);
  var size = 2 * Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
  var ripple = doc.createElement("span");
  ripple.classList.add("mbsc-ripple");
  var style = ripple.style;
  style.backgroundColor = getComputedStyle(elm).color;
  style.width = size + "px";
  style.height = size + "px";
  style.top = y - rect.top - size / 2 + "px";
  style.left = x - rect.left - size / 2 + "px";
  elm.appendChild(ripple);
  setTimeout(function() {
    style.opacity = ".2";
    style.transform = "scale(1)";
    style.transition = "opacity linear .1s, transform cubic-bezier(0, 0, 0.2, 1) .4s";
  }, 30);
  return ripple;
}
function removeRipple(r) {
  if (r) {
    setTimeout(function() {
      r.style.opacity = "0";
      r.style.transition = "opacity linear .4s";
      setTimeout(function() {
        if (r && r.parentNode) {
          r.parentNode.removeChild(r);
        }
      }, 400);
    }, 200);
  }
}
function gestureListener(elm, options2) {
  var args = {};
  var win2 = getWindow(elm);
  var document2 = getDocument(elm);
  var active;
  var activeable;
  var activeTimer;
  var ripple;
  var hasFocus;
  var hasHover;
  var hasRipple;
  var moved;
  var startX;
  var startY;
  var endX;
  var endY;
  var deltaX;
  var deltaY;
  var started;
  function skipMouseEvent(ev) {
    if (ev.type === TOUCH_START) {
      wasTouched = true;
    } else if (wasTouched) {
      if (ev.type === MOUSE_DOWN) {
        wasTouched = false;
      }
      return true;
    }
    return false;
  }
  function activate() {
    if (hasRipple) {
      removeRipple(ripple);
      ripple = addRipple(elm, endX, endY);
    }
    options2.onPress();
    active = true;
  }
  function deactivate(r, time) {
    activeable = false;
    removeRipple(r);
    clearTimeout(activeTimer);
    activeTimer = setTimeout(function() {
      if (active) {
        options2.onRelease();
        active = false;
      }
    }, time);
  }
  function onStart(ev) {
    if (skipMouseEvent(ev)) {
      return;
    }
    if (ev.type === MOUSE_DOWN && (ev.button !== 0 || ev.ctrlKey)) {
      return;
    }
    startX = getCoord(ev, "X");
    startY = getCoord(ev, "Y");
    endX = startX;
    endY = startY;
    active = false;
    activeable = false;
    moved = false;
    started = true;
    args.moved = moved;
    args.startX = startX;
    args.startY = startY;
    args.endX = endX;
    args.endY = endY;
    args.deltaX = 0;
    args.deltaY = 0;
    args.domEvent = ev;
    args.isTouch = wasTouched;
    args.target = elm;
    removeRipple(ripple);
    if (options2.onStart) {
      var ret = options2.onStart(args);
      hasRipple = ret && ret.ripple;
    }
    if (options2.onPress) {
      activeable = true;
      clearTimeout(activeTimer);
      activeTimer = setTimeout(activate, 50);
    }
    if (ev.type === MOUSE_DOWN) {
      listen(document2, MOUSE_MOVE, onMove);
      listen(document2, MOUSE_UP, onEnd);
    }
    listen(document2, CONTEXTMENU, onContextMenu);
  }
  function onMove(ev) {
    if (!started) {
      return;
    }
    endX = getCoord(ev, "X");
    endY = getCoord(ev, "Y");
    deltaX = endX - startX;
    deltaY = endY - startY;
    if (!moved && (Math.abs(deltaX) > 9 || Math.abs(deltaY) > 9)) {
      moved = true;
      deactivate(ripple);
    }
    args.moved = moved;
    args.endX = endX;
    args.endY = endY;
    args.deltaX = deltaX;
    args.deltaY = deltaY;
    args.domEvent = ev;
    args.isTouch = ev.type === TOUCH_MOVE;
    if (options2.onMove) {
      options2.onMove(args);
    }
  }
  function onEnd(ev) {
    if (!started) {
      return;
    }
    if (activeable && !active) {
      clearTimeout(activeTimer);
      activeTimer = null;
      activate();
    }
    args.domEvent = ev;
    args.isTouch = ev.type === TOUCH_END;
    if (options2.onEnd) {
      options2.onEnd(args);
    }
    deactivate(ripple, 75);
    started = false;
    if (ev.type === TOUCH_END && options2.click && hasGhostClick && !moved) {
      triggerClick(ev, ev.target);
    }
    if (ev.type === MOUSE_UP) {
      unlisten(document2, MOUSE_MOVE, onMove);
      unlisten(document2, MOUSE_UP, onEnd);
    }
    unlisten(document2, CONTEXTMENU, onContextMenu);
  }
  function onHoverIn(ev) {
    if (skipMouseEvent(ev)) {
      return;
    }
    hasHover = true;
    options2.onHoverIn(ev);
  }
  function onHoverOut(ev) {
    if (hasHover) {
      options2.onHoverOut(ev);
    }
    hasHover = false;
  }
  function onKeyDown(ev) {
    options2.onKeyDown(ev);
  }
  function onFocus(ev) {
    if (options2.keepFocus || win2.__mbscFocusVisible) {
      hasFocus = true;
      options2.onFocus(ev);
    }
  }
  function onBlur(ev) {
    if (hasFocus) {
      options2.onBlur(ev);
    }
    hasFocus = false;
  }
  function onChange(ev) {
    options2.onChange(ev);
  }
  function onInput(ev) {
    options2.onInput(ev);
  }
  function onDoubleClick(ev) {
    args.domEvent = ev;
    if (!wasTouched) {
      options2.onDoubleClick(args);
    }
  }
  function onContextMenu(ev) {
    if (wasTouched) {
      ev.preventDefault();
    }
  }
  listen(elm, MOUSE_DOWN, onStart);
  listen(elm, TOUCH_START, onStart, {
    passive: true
  });
  listen(elm, TOUCH_MOVE, onMove, {
    passive: false
  });
  listen(elm, TOUCH_END, onEnd);
  listen(elm, TOUCH_CANCEL, onEnd);
  if (options2.onChange) {
    listen(elm, CHANGE, onChange);
  }
  if (options2.onInput) {
    listen(elm, INPUT, onInput);
  }
  if (options2.onHoverIn) {
    listen(elm, MOUSE_ENTER, onHoverIn);
  }
  if (options2.onHoverOut) {
    listen(elm, MOUSE_LEAVE, onHoverOut);
  }
  if (options2.onKeyDown) {
    listen(elm, KEY_DOWN, onKeyDown);
  }
  if (options2.onFocus && win2) {
    listen(elm, FOCUS, onFocus);
    if (!options2.keepFocus) {
      var focusCount = win2.__mbscFocusCount || 0;
      if (focusCount === 0) {
        listen(win2, MOUSE_DOWN, setFocusInvisible, true);
        listen(win2, KEY_DOWN, setFocusVisible, true);
      }
      win2.__mbscFocusCount = ++focusCount;
    }
  }
  if (options2.onBlur) {
    listen(elm, BLUR, onBlur);
  }
  if (options2.onDoubleClick) {
    listen(elm, DOUBLE_CLICK, onDoubleClick);
  }
  return function() {
    if (activeTimer) {
      clearTimeout(activeTimer);
    }
    if (options2.onFocus && win2 && !options2.keepFocus) {
      var focusCount2 = win2.__mbscFocusCount || 0;
      win2.__mbscFocusCount = --focusCount2;
      if (focusCount2 <= 0) {
        unlisten(win2, MOUSE_DOWN, setFocusInvisible);
        unlisten(win2, KEY_DOWN, setFocusVisible);
      }
    }
    unlisten(elm, INPUT, onInput);
    unlisten(elm, MOUSE_DOWN, onStart);
    unlisten(elm, TOUCH_START, onStart, {
      passive: true
    });
    unlisten(elm, TOUCH_MOVE, onMove, {
      passive: false
    });
    unlisten(elm, TOUCH_END, onEnd);
    unlisten(elm, TOUCH_CANCEL, onEnd);
    unlisten(document2, MOUSE_MOVE, onMove);
    unlisten(document2, MOUSE_UP, onEnd);
    unlisten(document2, CONTEXTMENU, onContextMenu);
    unlisten(elm, CHANGE, onChange);
    unlisten(elm, MOUSE_ENTER, onHoverIn);
    unlisten(elm, MOUSE_LEAVE, onHoverOut);
    unlisten(elm, KEY_DOWN, onKeyDown);
    unlisten(elm, FOCUS, onFocus);
    unlisten(elm, BLUR, onBlur);
    unlisten(elm, DOUBLE_CLICK, onDoubleClick);
  };
}
var ButtonBase = function(_super) {
  __extends(ButtonBase2, _super);
  function ButtonBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ButtonBase2.prototype._mounted = function() {
    var _this = this;
    this._unlisten = gestureListener(this._el, {
      click: true,
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onFocus: function() {
        _this.setState({
          hasFocus: true
        });
      },
      onHoverIn: function() {
        if (!_this.s.disabled) {
          _this.setState({
            hasHover: true
          });
        }
      },
      onHoverOut: function() {
        _this.setState({
          hasHover: false
        });
      },
      onKeyDown: function(ev) {
        switch (ev.keyCode) {
          case ENTER:
          case SPACE:
            _this._el.click();
            ev.preventDefault();
            break;
        }
      },
      onPress: function() {
        _this.setState({
          isActive: true
        });
      },
      onRelease: function() {
        _this.setState({
          isActive: false
        });
      },
      onStart: function() {
        return {
          ripple: _this.s.ripple && !_this.s.disabled
        };
      }
    });
  };
  ButtonBase2.prototype._render = function(s, state) {
    var _this = this;
    var disabled = s.disabled;
    this._isIconOnly = !!(s.icon || s.iconSvg);
    this._hasStartIcon = !!(s.startIcon || s.startIconSvg);
    this._hasEndIcon = !!(s.endIcon || s.endIconSvg);
    this._tabIndex = disabled || s.hidden ? UNDEFINED : s.tabIndex || 0;
    this._cssClass = this._className + " mbsc-reset mbsc-font mbsc-button" + this._theme + this._rtl + " mbsc-button-" + s.variant + (this._isIconOnly ? " mbsc-icon-button" : "") + (disabled ? " mbsc-disabled" : "") + (s.color ? " mbsc-button-" + s.color : "") + (state.hasFocus && !disabled ? " mbsc-focus" : "") + (state.isActive && !disabled ? " mbsc-active" : "") + (state.hasHover && !disabled ? " mbsc-hover" : "");
    this._iconClass = "mbsc-button-icon" + this._rtl;
    this._startIconClass = this._iconClass + " mbsc-button-icon-start";
    this._endIconClass = this._iconClass + " mbsc-button-icon-end";
    if (s.disabled && state.hasHover) {
      setTimeout(function() {
        _this.setState({
          hasHover: false
        });
      });
    }
  };
  ButtonBase2.prototype._destroy = function() {
    if (this._unlisten) {
      this._unlisten();
    }
  };
  ButtonBase2.defaults = {
    ripple: false,
    role: "button",
    tag: "button",
    variant: "standard"
  };
  ButtonBase2._name = "Button";
  ButtonBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵButtonBase_BaseFactory;
    return function ButtonBase_Factory(__ngFactoryType__) {
      return (ɵButtonBase_BaseFactory || (ɵButtonBase_BaseFactory = ɵɵgetInheritedFactory(ButtonBase2)))(__ngFactoryType__ || ButtonBase2);
    };
  })();
  ButtonBase2.ɵdir = ɵɵdefineDirective({
    type: ButtonBase2,
    selectors: [["", "mbsc-btn-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return ButtonBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-btn-b]"
    }]
  }], null, null);
})();
var IconBase = function(_super) {
  __extends(IconBase2, _super);
  function IconBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  IconBase2.prototype._render = function(s) {
    this._hasChildren = s.name !== UNDEFINED && !isString(s.name);
    this._cssClass = this._className + " mbsc-icon" + this._theme + (s.name && !this._hasChildren ? s.name.indexOf(" ") !== -1 ? " " + s.name : " mbsc-font-icon mbsc-icon-" + s.name : "");
    this._svg = s.svg ? this._safeHtml(s.svg) : UNDEFINED;
  };
  IconBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵIconBase_BaseFactory;
    return function IconBase_Factory(__ngFactoryType__) {
      return (ɵIconBase_BaseFactory || (ɵIconBase_BaseFactory = ɵɵgetInheritedFactory(IconBase2)))(__ngFactoryType__ || IconBase2);
    };
  })();
  IconBase2.ɵdir = ɵɵdefineDirective({
    type: IconBase2,
    selectors: [["", "mbsc-i-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return IconBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-i-b]"
    }]
  }], null, null);
})();
var MbscCustomIcon = function() {
  function MbscCustomIcon2() {
  }
  MbscCustomIcon2.ɵfac = function MbscCustomIcon_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCustomIcon2)();
  };
  MbscCustomIcon2.ɵdir = ɵɵdefineDirective({
    type: MbscCustomIcon2,
    selectors: [["", "mbsc-icon", ""]],
    standalone: false
  });
  return MbscCustomIcon2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCustomIcon, [{
    type: Directive,
    args: [{
      selector: "[mbsc-icon]"
    }]
  }], null, null);
})();
var MbscCustomStartIcon = function() {
  function MbscCustomStartIcon2() {
  }
  MbscCustomStartIcon2.ɵfac = function MbscCustomStartIcon_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCustomStartIcon2)();
  };
  MbscCustomStartIcon2.ɵdir = ɵɵdefineDirective({
    type: MbscCustomStartIcon2,
    selectors: [["", "mbsc-start-icon", ""]],
    standalone: false
  });
  return MbscCustomStartIcon2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCustomStartIcon, [{
    type: Directive,
    args: [{
      selector: "[mbsc-start-icon]"
    }]
  }], null, null);
})();
var MbscCustomEndIcon = function() {
  function MbscCustomEndIcon2() {
  }
  MbscCustomEndIcon2.ɵfac = function MbscCustomEndIcon_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCustomEndIcon2)();
  };
  MbscCustomEndIcon2.ɵdir = ɵɵdefineDirective({
    type: MbscCustomEndIcon2,
    selectors: [["", "mbsc-end-icon", ""]],
    standalone: false
  });
  return MbscCustomEndIcon2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCustomEndIcon, [{
    type: Directive,
    args: [{
      selector: "[mbsc-end-icon]"
    }]
  }], null, null);
})();
var MbscIcon = function(_super) {
  __extends(MbscIcon2, _super);
  function MbscIcon2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscIcon2.prototype._updated = function() {
    if (this.s.svg !== this._prevS.svg) {
      this._el.innerHTML = this.s.svg;
    }
    _super.prototype._updated.call(this);
  };
  MbscIcon2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscIcon_BaseFactory;
    return function MbscIcon_Factory(__ngFactoryType__) {
      return (ɵMbscIcon_BaseFactory || (ɵMbscIcon_BaseFactory = ɵɵgetInheritedFactory(MbscIcon2)))(__ngFactoryType__ || MbscIcon2);
    };
  })();
  MbscIcon2.ɵcmp = ɵɵdefineComponent({
    type: MbscIcon2,
    selectors: [["mbsc-icon"]],
    hostVars: 2,
    hostBindings: function MbscIcon_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      name: "name",
      svg: "svg"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscIcon_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscIcon2;
}(IconBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscIcon, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-icon",
      template: "<ng-content></ng-content>"
    }]
  }], null, {
    name: [{
      type: Input
    }],
    svg: [{
      type: Input
    }]
  });
})();
var MbscButton = function(_super) {
  __extends(MbscButton2, _super);
  function MbscButton2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscButton2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscButton_BaseFactory;
    return function MbscButton_Factory(__ngFactoryType__) {
      return (ɵMbscButton_BaseFactory || (ɵMbscButton_BaseFactory = ɵɵgetInheritedFactory(MbscButton2)))(__ngFactoryType__ || MbscButton2);
    };
  })();
  MbscButton2.ɵcmp = ɵɵdefineComponent({
    type: MbscButton2,
    selectors: [["mbsc-button"]],
    contentQueries: function MbscButton_ContentQueries(rf, ctx2, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MbscCustomIcon, 5);
        ɵɵcontentQuery(dirIndex, MbscCustomStartIcon, 5);
        ɵɵcontentQuery(dirIndex, MbscCustomEndIcon, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2._customIcon = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2._customStartIcon = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2._customEndIcon = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function MbscButton_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx2.disabled ? "true" : void 0)("aria-label", ctx2.ariaLabel)("role", ctx2.s.role)("tabindex", ctx2._tabIndex);
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      ariaLabel: "ariaLabel",
      color: "color",
      disabled: "disabled",
      endIcon: "endIcon",
      endIconSrc: "endIconSrc",
      endIconSvg: "endIconSvg",
      hidden: "hidden",
      icon: "icon",
      iconSvg: "iconSvg",
      iconSrc: "iconSrc",
      ripple: "ripple",
      role: "role",
      startIcon: "startIcon",
      startIconSrc: "startIconSrc",
      startIconSvg: "startIconSvg",
      tabIndex: "tabIndex",
      variant: "variant"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c2,
    decls: 4,
    vars: 3,
    consts: [[3, "class", "name", "svg", "theme", 4, "ngIf"], [3, "name", "svg", "theme"]],
    template: function MbscButton_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef(_c1);
        ɵɵtemplate(0, MbscButton_mbsc_icon_0_Template, 2, 5, "mbsc-icon", 0)(1, MbscButton_mbsc_icon_1_Template, 2, 5, "mbsc-icon", 0);
        ɵɵprojection(2);
        ɵɵtemplate(3, MbscButton_mbsc_icon_3_Template, 2, 5, "mbsc-icon", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2._isIconOnly || ctx2._customIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasStartIcon || ctx2._customStartIcon);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._hasEndIcon || ctx2._customEndIcon);
      }
    },
    dependencies: [MbscIcon, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscButton2;
}(ButtonBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscButton, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[attr.aria-disabled]": 'disabled ? "true" : undefined',
        "[attr.aria-label]": "ariaLabel",
        "[attr.role]": "s.role",
        "[attr.tabindex]": "_tabIndex",
        "[class]": "_cssClass"
      },
      selector: "mbsc-button",
      template: '\n    <mbsc-icon *ngIf="_isIconOnly || _customIcon" [class]="_iconClass" [name]="s.icon" [svg]="s.iconSvg" [theme]="s.theme">\n      <ng-content select="[mbsc-icon]"></ng-content>\n    </mbsc-icon>\n    <mbsc-icon\n      *ngIf="_hasStartIcon || _customStartIcon"\n      [class]="_startIconClass"\n      [name]="s.startIcon"\n      [svg]="s.startIconSvg"\n      [theme]="s.theme"\n    >\n      <ng-content select="[mbsc-start-icon]"></ng-content>\n    </mbsc-icon>\n    <ng-content></ng-content>\n    <mbsc-icon *ngIf="_hasEndIcon || _customEndIcon" [class]="_endIconClass" [name]="s.endIcon" [svg]="s.endIconSvg" [theme]="s.theme">\n      <ng-content select="[mbsc-end-icon]"></ng-content>\n    </mbsc-icon>\n  '
    }]
  }], null, {
    _customIcon: [{
      type: ContentChild,
      args: [MbscCustomIcon, {
        static: false
      }]
    }],
    _customStartIcon: [{
      type: ContentChild,
      args: [MbscCustomStartIcon, {
        static: false
      }]
    }],
    _customEndIcon: [{
      type: ContentChild,
      args: [MbscCustomEndIcon, {
        static: false
      }]
    }],
    ariaLabel: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    endIcon: [{
      type: Input
    }],
    endIconSrc: [{
      type: Input
    }],
    endIconSvg: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    iconSvg: [{
      type: Input
    }],
    iconSrc: [{
      type: Input
    }],
    ripple: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    startIcon: [{
      type: Input
    }],
    startIconSrc: [{
      type: Input
    }],
    startIconSvg: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    variant: [{
      type: Input
    }]
  });
})();
var MbscIconModule = function() {
  function MbscIconModule2() {
  }
  MbscIconModule2.ɵfac = function MbscIconModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscIconModule2)();
  };
  MbscIconModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscIconModule2,
    declarations: [IconBase, MbscIcon, MbscCustomEndIcon, MbscCustomIcon, MbscCustomStartIcon],
    imports: [CommonModule],
    exports: [MbscIcon, MbscCustomEndIcon, MbscCustomIcon, MbscCustomStartIcon]
  });
  MbscIconModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscIconModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscIconModule, [{
    type: NgModule,
    args: [{
      declarations: [IconBase, MbscIcon, MbscCustomEndIcon, MbscCustomIcon, MbscCustomStartIcon],
      exports: [MbscIcon, MbscCustomEndIcon, MbscCustomIcon, MbscCustomStartIcon],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var MbscButtonModule = function() {
  function MbscButtonModule2() {
  }
  MbscButtonModule2.ɵfac = function MbscButtonModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscButtonModule2)();
  };
  MbscButtonModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscButtonModule2,
    declarations: [ButtonBase, MbscButton],
    imports: [CommonModule, MbscIconModule],
    exports: [MbscButton]
  });
  MbscButtonModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscIconModule]]
  });
  return MbscButtonModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscButtonModule, [{
    type: NgModule,
    args: [{
      declarations: [ButtonBase, MbscButton],
      exports: [MbscButton],
      imports: [CommonModule, MbscIconModule]
    }]
  }], null, null);
})();
var InstanceServiceBase = function() {
  function InstanceServiceBase2() {
    this.onInstanceReady = new Observable();
    this.onComponentChange = new Observable();
  }
  Object.defineProperty(InstanceServiceBase2.prototype, "instance", {
    get: function() {
      return this._inst;
    },
    set: function(inst) {
      this._inst = inst;
      this.onInstanceReady.next(inst);
    },
    enumerable: false,
    configurable: true
  });
  return InstanceServiceBase2;
}();
var MbscInstanceService = function(_super) {
  __extends(MbscInstanceService2, _super);
  function MbscInstanceService2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscInstanceService2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscInstanceService_BaseFactory;
    return function MbscInstanceService_Factory(__ngFactoryType__) {
      return (ɵMbscInstanceService_BaseFactory || (ɵMbscInstanceService_BaseFactory = ɵɵgetInheritedFactory(MbscInstanceService2)))(__ngFactoryType__ || MbscInstanceService2);
    };
  })();
  MbscInstanceService2.ɵprov = ɵɵdefineInjectable({
    token: MbscInstanceService2,
    factory: MbscInstanceService2.ɵfac
  });
  return MbscInstanceService2;
}(InstanceServiceBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscInstanceService, [{
    type: Injectable
  }], null, null);
})();
var CalendarSubscriber = function() {
  function CalendarSubscriber2(instanceService, _changeDetector) {
    this._changeDetector = _changeDetector;
    this._cssClass = "";
    if (instanceService) {
      this._setupServices(instanceService);
    }
  }
  Object.defineProperty(CalendarSubscriber2.prototype, "cssClass", {
    get: function() {
      var theme = this._hostInst && this._hostInst._theme || "";
      var newTheme = "" + this._cssClass + theme;
      return newTheme;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(CalendarSubscriber2.prototype, "calendar", {
    set: function(inst) {
      this._setupServices(inst._instanceService);
    },
    enumerable: false,
    configurable: true
  });
  CalendarSubscriber2.prototype.ngOnDestroy = function() {
    this._cleanupService();
  };
  CalendarSubscriber2.prototype._setupServices = function(serv) {
    var _this = this;
    if (serv !== this.instanceService) {
      this._cleanupService();
      this.instanceService = serv;
      this._hostInst = serv.instance;
      if (this._hostInst) {
        this.inst = this._hostInst._calendarView;
      }
      this._readyHandler = serv.onInstanceReady.subscribe(function(inst) {
        setTimeout(function() {
          _this._hostInst = inst;
          _this.inst = inst._calendarView;
          _this._changeDetector.markForCheck();
        });
      });
      this._changeHandler = serv.onComponentChange.subscribe(function() {
        setTimeout(function() {
          _this._changeDetector.markForCheck();
        });
      });
    }
  };
  CalendarSubscriber2.prototype._cleanupService = function() {
    if (this.instanceService !== UNDEFINED) {
      if (this._changeHandler !== UNDEFINED) {
        this.instanceService.onComponentChange.unsubscribe(this._changeHandler);
      }
      if (this._readyHandler !== UNDEFINED) {
        this.instanceService.onInstanceReady.unsubscribe(this._readyHandler);
      }
    }
  };
  CalendarSubscriber2.ɵfac = function CalendarSubscriber_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || CalendarSubscriber2)(ɵɵdirectiveInject(MbscInstanceService, 8), ɵɵdirectiveInject(ChangeDetectorRef));
  };
  CalendarSubscriber2.ɵdir = ɵɵdefineDirective({
    type: CalendarSubscriber2,
    selectors: [["mbsc-cal-s"]],
    inputs: {
      _cssClass: [0, "class", "_cssClass"],
      calendar: "calendar"
    },
    standalone: false
  });
  return CalendarSubscriber2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarSubscriber, [{
    type: Directive,
    args: [{
      selector: "mbsc-cal-s"
    }]
  }], function() {
    return [{
      type: MbscInstanceService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    _cssClass: [{
      type: Input,
      args: ["class"]
    }],
    calendar: [{
      type: Input
    }]
  });
})();
var MbscCalendarPrev = function(_super) {
  __extends(MbscCalendarPrev2, _super);
  function MbscCalendarPrev2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscCalendarPrev2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendarPrev_BaseFactory;
    return function MbscCalendarPrev_Factory(__ngFactoryType__) {
      return (ɵMbscCalendarPrev_BaseFactory || (ɵMbscCalendarPrev_BaseFactory = ɵɵgetInheritedFactory(MbscCalendarPrev2)))(__ngFactoryType__ || MbscCalendarPrev2);
    };
  })();
  MbscCalendarPrev2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarPrev2,
    selectors: [["mbsc-calendar-prev"]],
    hostVars: 2,
    hostBindings: function MbscCalendarPrev_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2.cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["class", "mbsc-calendar-button", "variant", "flat", 3, "ariaLabel", "disabled", "iconSvg", "theme", "themeVariant", "click", 4, "ngIf"], ["variant", "flat", 1, "mbsc-calendar-button", 3, "click", "ariaLabel", "disabled", "iconSvg", "theme", "themeVariant"]],
    template: function MbscCalendarPrev_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscCalendarPrev_mbsc_button_0_Template, 1, 5, "mbsc-button", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2.inst);
      }
    },
    dependencies: [MbscButton, NgIf],
    encapsulation: 2
  });
  return MbscCalendarPrev2;
}(CalendarSubscriber);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarPrev, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cssClass"
      },
      selector: "mbsc-calendar-prev",
      template: ' <mbsc-button\n    *ngIf="inst"\n    [ariaLabel]="inst.s.prevPageText"\n    class="mbsc-calendar-button"\n    (click)="inst.prevPage()"\n    [disabled]="inst._isPrevDisabled()"\n    [iconSvg]="inst._prevIcon"\n    [theme]="inst.s.theme"\n    [themeVariant]="inst.s.themeVariant"\n    variant="flat"\n  >\n  </mbsc-button>'
    }]
  }], null, null);
})();
var MbscCalendarNext = function(_super) {
  __extends(MbscCalendarNext2, _super);
  function MbscCalendarNext2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscCalendarNext2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendarNext_BaseFactory;
    return function MbscCalendarNext_Factory(__ngFactoryType__) {
      return (ɵMbscCalendarNext_BaseFactory || (ɵMbscCalendarNext_BaseFactory = ɵɵgetInheritedFactory(MbscCalendarNext2)))(__ngFactoryType__ || MbscCalendarNext2);
    };
  })();
  MbscCalendarNext2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarNext2,
    selectors: [["mbsc-calendar-next"]],
    hostVars: 2,
    hostBindings: function MbscCalendarNext_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2.cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["class", "mbsc-calendar-button", "variant", "flat", 3, "ariaLabel", "disabled", "iconSvg", "theme", "themeVariant", "click", 4, "ngIf"], ["variant", "flat", 1, "mbsc-calendar-button", 3, "click", "ariaLabel", "disabled", "iconSvg", "theme", "themeVariant"]],
    template: function MbscCalendarNext_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscCalendarNext_mbsc_button_0_Template, 1, 5, "mbsc-button", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2.inst);
      }
    },
    dependencies: [MbscButton, NgIf],
    encapsulation: 2
  });
  return MbscCalendarNext2;
}(CalendarSubscriber);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarNext, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cssClass"
      },
      selector: "mbsc-calendar-next",
      template: ' <mbsc-button\n    *ngIf="inst"\n    [ariaLabel]="inst.s.nextPageText"\n    class="mbsc-calendar-button"\n    (click)="inst.nextPage()"\n    [disabled]="inst._isNextDisabled()"\n    [iconSvg]="inst._nextIcon"\n    [theme]="inst.s.theme"\n    [themeVariant]="inst.s.themeVariant"\n    variant="flat"\n  >\n  </mbsc-button>'
    }]
  }], null, null);
})();
var MbscCalendarToday = function(_super) {
  __extends(MbscCalendarToday2, _super);
  function MbscCalendarToday2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscCalendarToday2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendarToday_BaseFactory;
    return function MbscCalendarToday_Factory(__ngFactoryType__) {
      return (ɵMbscCalendarToday_BaseFactory || (ɵMbscCalendarToday_BaseFactory = ɵɵgetInheritedFactory(MbscCalendarToday2)))(__ngFactoryType__ || MbscCalendarToday2);
    };
  })();
  MbscCalendarToday2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarToday2,
    selectors: [["mbsc-calendar-today"]],
    hostVars: 2,
    hostBindings: function MbscCalendarToday_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2.cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["class", "mbsc-calendar-button mbsc-calendar-button-today", "variant", "flat", 3, "theme", "themeVariant", "click", 4, "ngIf"], ["variant", "flat", 1, "mbsc-calendar-button", "mbsc-calendar-button-today", 3, "click", "theme", "themeVariant"]],
    template: function MbscCalendarToday_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscCalendarToday_mbsc_button_0_Template, 2, 4, "mbsc-button", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2.inst && (ctx2.inst.s.showToday || ctx2.inst.s.headerTemplate));
      }
    },
    dependencies: [MbscButton, NgIf],
    encapsulation: 2
  });
  return MbscCalendarToday2;
}(CalendarSubscriber);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarToday, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cssClass"
      },
      selector: "mbsc-calendar-today",
      template: ' <mbsc-button\n    *ngIf="inst && (inst.s.showToday || inst.s.headerTemplate)"\n    class="mbsc-calendar-button mbsc-calendar-button-today"\n    [attr.aria-label]="inst.s.todayText"\n    [theme]="inst.s.theme"\n    [themeVariant]="inst.s.themeVariant"\n    variant="flat"\n    (click)="inst._onTodayClick($event)"\n  >\n    {{ inst.s.todayText }}\n  </mbsc-button>'
    }]
  }], null, null);
})();
var MbscCalendarNav = function(_super) {
  __extends(MbscCalendarNav2, _super);
  function MbscCalendarNav2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscCalendarNav2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendarNav_BaseFactory;
    return function MbscCalendarNav_Factory(__ngFactoryType__) {
      return (ɵMbscCalendarNav_BaseFactory || (ɵMbscCalendarNav_BaseFactory = ɵɵgetInheritedFactory(MbscCalendarNav2)))(__ngFactoryType__ || MbscCalendarNav2);
    };
  })();
  MbscCalendarNav2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarNav2,
    selectors: [["mbsc-calendar-nav"]],
    hostAttrs: ["aria-live", "polite"],
    hostVars: 2,
    hostBindings: function MbscCalendarNav_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2.cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 1,
    consts: [["pickerBtn", ""], [4, "ngIf"], ["variant", "flat", 3, "class", "theme", "themeVariant", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["variant", "flat", 3, "click", "theme", "themeVariant"], [3, "class", 4, "ngIf"], [3, "svg", "theme", "themeVariant", 4, "ngIf"], [3, "svg", "theme", "themeVariant"]],
    template: function MbscCalendarNav_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscCalendarNav_ng_container_0_Template, 2, 2, "ng-container", 1);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2.inst);
      }
    },
    dependencies: [MbscButton, MbscIcon, NgIf, NgForOf],
    encapsulation: 2
  });
  return MbscCalendarNav2;
}(CalendarSubscriber);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarNav, [{
    type: Component,
    args: [{
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "cssClass",
        "aria-live": "polite"
      },
      selector: "mbsc-calendar-nav",
      template: ` <ng-container *ngIf="inst">
    <mbsc-button
      #pickerBtn
      *ngFor="let item of inst._title; trackBy: inst._getKey"
      [class]="'mbsc-calendar-button' + (inst._pageNr > 1 ? ' mbsc-flex-1-1' : '')"
      (click)="inst._onPickerBtnClick($event)"
      [theme]="inst.s.theme"
      [themeVariant]="inst.s.themeVariant"
      variant="flat"
    >
      <ng-container *ngIf="inst._hasPicker || inst._view === inst.PAGE_VIEW">
        <ng-container *ngIf="!item.title">
          <span *ngIf="inst._yearFirst" [class]="'mbsc-calendar-title mbsc-calendar-year' + inst._theme">
            {{ item.yearTitle }}
          </span>
          <span [class]="'mbsc-calendar-title mbsc-calendar-month' + inst._theme">
            {{ item.monthTitle }}
          </span>
          <span *ngIf="!inst._yearFirst" [class]="'mbsc-calendar-title mbsc-calendar-year' + inst._theme">
            {{ item.yearTitle }}
          </span>
        </ng-container>
        <span *ngIf="item.title" [class]="'mbsc-calendar-title' + inst._theme">
          {{ item.title }}
        </span>
      </ng-container>
      <span *ngIf="!inst._hasPicker && inst._view !== inst.PAGE_VIEW" [class]="'mbsc-calendar-title' + inst._theme">
        {{ inst._viewTitle }}
      </span>
      <mbsc-icon
        *ngIf="inst.s.downIcon && inst._pageNr === 1"
        [svg]="inst._view === inst.PAGE_VIEW ? inst.s.downIcon : inst.s.upIcon"
        [theme]="inst.s.theme"
        [themeVariant]="inst.s.themeVariant"
      >
      </mbsc-icon>
    </mbsc-button>
  </ng-container>`
    }]
  }], null, null);
})();
var MbscCalendarHeaderModule = function() {
  function MbscCalendarHeaderModule2() {
  }
  MbscCalendarHeaderModule2.ɵfac = function MbscCalendarHeaderModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCalendarHeaderModule2)();
  };
  MbscCalendarHeaderModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscCalendarHeaderModule2,
    declarations: [CalendarSubscriber, MbscCalendarNav, MbscCalendarNext, MbscCalendarPrev, MbscCalendarToday],
    imports: [CommonModule, MbscButtonModule, MbscIconModule],
    exports: [MbscCalendarNav, MbscCalendarNext, MbscCalendarPrev, MbscCalendarToday]
  });
  MbscCalendarHeaderModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscButtonModule, MbscIconModule]]
  });
  return MbscCalendarHeaderModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarHeaderModule, [{
    type: NgModule,
    args: [{
      declarations: [CalendarSubscriber, MbscCalendarNav, MbscCalendarNext, MbscCalendarPrev, MbscCalendarToday],
      exports: [MbscCalendarNav, MbscCalendarNext, MbscCalendarPrev, MbscCalendarToday],
      imports: [CommonModule, MbscButtonModule, MbscIconModule]
    }]
  }], null, null);
})();
var MbscPickerModule = function() {
  function MbscPickerModule2() {
  }
  MbscPickerModule2.ɵfac = function MbscPickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscPickerModule2)();
  };
  MbscPickerModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscPickerModule2,
    declarations: [PickerBase],
    imports: [CommonModule]
  });
  MbscPickerModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscPickerModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscPickerModule, [{
    type: NgModule,
    args: [{
      declarations: [PickerBase],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var MbscCalendarNavService = function() {
  function MbscCalendarNavService2() {
    this.pageSize = 0;
    this._prevS = {};
    this._s = {};
  }
  MbscCalendarNavService2.prototype.options = function(news, forcePageLoading) {
    var s = this._s = __assign(__assign({}, this._s), news);
    var prevS = this._prevS;
    var getDate = s.getDate;
    var getYear = s.getYear;
    var getMonth = s.getMonth;
    var showCalendar = s.showCalendar;
    var calendarType = s.calendarType;
    var startDay = s.startDay;
    var endDay = s.endDay;
    var firstWeekDay = s.firstDay;
    var isWeekView = calendarType === "week";
    var weeks = showCalendar ? isWeekView ? s.weeks : 6 : 0;
    var minDate = s.min !== prevS.min || !this.minDate ? !isEmpty(s.min) ? makeDate(s.min) : -Infinity : this.minDate;
    var maxDate = s.max !== prevS.max || !this.maxDate ? !isEmpty(s.max) ? makeDate(s.max) : Infinity : this.maxDate;
    var initialActive = s.activeDate || +/* @__PURE__ */ new Date();
    var activeDate = constrain(initialActive, +minDate, +maxDate);
    var forcePageChange = this.forcePageChange || activeDate !== initialActive && (activeDate < +this.firstDay || activeDate >= +this.lastDay);
    var d = new Date(activeDate);
    var activeChanged = activeDate !== prevS.activeDate;
    var viewChanged = s.calendarType !== prevS.calendarType || s.eventRange !== prevS.eventRange || s.firstDay !== prevS.firstDay || s.eventRangeSize !== prevS.eventRangeSize || s.refDate !== prevS.refDate || showCalendar !== prevS.showCalendar || s.size !== prevS.size || s.weeks !== prevS.weeks;
    var pageIndex = forcePageChange || this.pageIndex === UNDEFINED || viewChanged || !this.preventPageChange && activeChanged && (activeDate < +this.firstDay || activeDate >= +this.lastDay) ? getPageIndex(d, s) : this.pageIndex;
    var size = calendarType === "year" ? 12 : s.size || 1;
    var isGrid = size > 1 && !isWeekView;
    var pageNr = isGrid ? 1 : getPageNr(s.pages, this.pageSize);
    var isVertical = s.calendarScroll === "vertical" && s.pages !== "auto" && (s.pages === UNDEFINED || s.pages === 1);
    var showOuter = s.showOuterDays !== UNDEFINED ? s.showOuterDays : !isVertical && pageNr < 2 && (isWeekView || !size || size < 2);
    var pageBuffer = isGrid ? 0 : 1;
    var firstDay = getFirstPageDay(pageIndex, s);
    var lastDay = getFirstPageDay(pageIndex + pageNr, s);
    if (!showCalendar && s.eventRange === "week" && startDay !== UNDEFINED && endDay !== UNDEFINED) {
      firstDay = addDays(firstDay, startDay - firstWeekDay + (startDay < firstWeekDay ? 7 : 0));
      lastDay = addDays(firstDay, 7 * s.eventRangeSize + endDay - startDay + 1 - (endDay < startDay ? 0 : 7));
    }
    var firstPageDay = showCalendar && showOuter ? getFirstDayOfWeek(firstDay, s) : firstDay;
    var lastPage = isGrid ? getDate(getYear(lastDay), getMonth(lastDay) - 1, 1) : getFirstPageDay(pageIndex + pageNr - 1, s);
    var lastPageDay = showCalendar && showOuter ? addDays(getFirstDayOfWeek(lastPage, s), weeks * 7) : lastDay;
    var start = showCalendar ? getFirstDayOfWeek(getFirstPageDay(pageIndex - pageBuffer, s), s) : firstDay;
    var last = showCalendar ? getFirstDayOfWeek(getFirstPageDay(pageIndex + pageNr + pageBuffer - 1, s), s) : lastDay;
    var end = showCalendar ? addDays(isGrid ? getFirstDayOfWeek(lastPage, s) : last, weeks * 7) : lastDay;
    var initialRun = this.pageIndex === UNDEFINED;
    var viewStart = start;
    var viewEnd = end;
    if (!showCalendar && s.resolution === "week" && (s.eventRange === "year" || s.eventRange === "month")) {
      var length_1 = endDay - startDay + 1 + (endDay < startDay ? 7 : 0);
      if (firstDay.getDay() !== startDay) {
        var weekStart = getFirstDayOfWeek(firstDay, s, startDay);
        var weekEnd = addDays(weekStart, length_1);
        viewStart = weekEnd <= firstDay ? addDays(weekStart, 7) : weekStart;
      }
      if (lastDay.getDay() !== startDay) {
        var weekStart = getFirstDayOfWeek(lastDay, s, startDay);
        var weekEnd = addDays(weekStart, length_1);
        viewEnd = weekStart > lastDay ? addDays(weekEnd, -7) : weekEnd;
      }
    }
    var pageChange = false;
    if (pageIndex !== UNDEFINED) {
      pageChange = +viewStart !== +this.viewStart || +viewEnd !== +this.viewEnd;
      this.pageIndex = pageIndex;
    }
    this.firstDay = firstDay;
    this.lastDay = lastDay;
    this.firstPageDay = firstPageDay;
    this.lastPageDay = lastPageDay;
    this.viewStart = viewStart;
    this.viewEnd = viewEnd;
    this.forcePageChange = false;
    this.preventPageChange = false;
    this.minDate = minDate;
    this.maxDate = maxDate;
    this._prevS = s;
    this._prevS.activeDate = activeDate;
    if (pageIndex !== UNDEFINED && (pageChange || forcePageLoading)) {
      if (pageChange && !initialRun) {
        this._pageChange();
      }
      this._pageLoading(pageChange);
    }
  };
  MbscCalendarNavService2.prototype._pageChange = function() {
    if (this._s.onPageChange) {
      this._s.onPageChange({
        firstDay: this.firstPageDay,
        lastDay: this.lastPageDay,
        month: this._s.calendarType === "month" ? this.firstDay : UNDEFINED,
        type: "onPageChange",
        viewEnd: this.viewEnd,
        viewStart: this.viewStart
      });
    }
  };
  MbscCalendarNavService2.prototype._pageLoading = function(viewChanged) {
    if (this._s.onPageLoading) {
      this._s.onPageLoading({
        firstDay: this.firstPageDay,
        lastDay: this.lastPageDay,
        month: this._s.calendarType === "month" ? this.firstDay : UNDEFINED,
        type: "onPageLoading",
        viewChanged,
        viewEnd: this.viewEnd,
        viewStart: this.viewStart
      });
    }
  };
  return MbscCalendarNavService2;
}();
var CalendarBase = function(_super) {
  __extends(CalendarBase2, _super);
  function CalendarBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._navService = new MbscCalendarNavService();
    _this._update = 0;
    _this._onDayClick = function(args) {
      var s = _this.s;
      var date = addTimezone(s, args.date);
      var d = +date;
      if (args.disabled) {
        return;
      }
      if (s.selectMultiple) {
        var tempValueRep = _this._tempValueRep;
        if (tempValueRep[d]) {
          delete tempValueRep[d];
        } else if (s.selectMax !== UNDEFINED ? Object.keys(tempValueRep).length < s.selectMax : true) {
          tempValueRep[d] = date;
        }
        _this._tempValueRep = __assign({}, tempValueRep);
      } else {
        if (!s.selectRange) {
          _this._tempValueRep = {};
        }
        _this._tempValueRep[d] = date;
      }
      _this._navService.preventPageChange = s.selectRange;
      _this._hook("onCellClick", args);
      _this._hook("onChange", {
        value: _this._get()
      });
    };
    _this._onTodayClick = function() {
      var date = /* @__PURE__ */ new Date();
      var d = +getDateOnly(date);
      if (!_this.s.selectRange && !_this.s.selectMultiple) {
        _this._tempValueRep = {};
        _this._tempValueRep[d] = date;
        _this._hook("onChange", {
          value: _this._get()
        });
      }
    };
    _this._onActiveChange = function(args) {
      _this._navService.forcePageChange = args.pageChange;
      _this._update++;
      _this._hook("onActiveChange", args);
    };
    _this._setCal = function(cal) {
      _this._calendarView = cal;
    };
    return _this;
  }
  CalendarBase2.prototype._render = function(s) {
    var valueRep = {};
    var value = s.value;
    var values = value ? isArray(value) ? value : [value] : [];
    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
      var val = values_1[_i];
      if (val !== null) {
        var date = makeDate(val, s, s.dateFormat);
        valueRep[+getDateOnly(date)] = date;
      }
    }
    this._tempValueRep = valueRep;
    this._navService.options({
      activeDate: s.active,
      calendarType: s.calendarType,
      firstDay: s.firstDay,
      getDate: s.getDate,
      getDay: s.getDay,
      getMonth: s.getMonth,
      getYear: s.getYear,
      max: s.max,
      min: s.min,
      onPageChange: s.onPageChange,
      onPageLoading: s.onPageLoading,
      pages: s.pages,
      refDate: s.refDate,
      showCalendar: true,
      showOuterDays: s.showOuterDays,
      size: s.size,
      weeks: s.weeks
    });
  };
  CalendarBase2.prototype._get = function() {
    var s = this.s;
    var isRange = s.selectRange;
    var valueRep = this._tempValueRep;
    if (s.selectMultiple || isRange) {
      var valueArray = [];
      for (var _i = 0, _a = Object.keys(valueRep); _i < _a.length; _i++) {
        var v = _a[_i];
        valueArray.push(createDate$1(s, +valueRep[v]));
      }
      return valueArray;
    }
    var valueKeys = Object.keys(valueRep || {});
    if (!valueKeys.length) {
      return null;
    }
    return createDate$1(s, valueRep[valueKeys[0]]);
  };
  CalendarBase2.defaults = __assign(__assign({}, calendarViewDefaults), {
    calendarScroll: "horizontal",
    calendarType: "month",
    selectedText: "{count} selected",
    showControls: true,
    weeks: 1
  });
  CalendarBase2._name = "Calendar";
  CalendarBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵCalendarBase_BaseFactory;
    return function CalendarBase_Factory(__ngFactoryType__) {
      return (ɵCalendarBase_BaseFactory || (ɵCalendarBase_BaseFactory = ɵɵgetInheritedFactory(CalendarBase2)))(__ngFactoryType__ || CalendarBase2);
    };
  })();
  CalendarBase2.ɵdir = ɵɵdefineDirective({
    type: CalendarBase2,
    selectors: [["", "mbsc-sc-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return CalendarBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sc-b]"
    }]
  }], null, null);
})();
var CalendarDayBase = function(_super) {
  __extends(CalendarDayBase2, _super);
  function CalendarDayBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onClick = function(ev) {
      _this._cellClick("onDayClick", ev);
    };
    _this._onRightClick = function(ev) {
      _this._cellClick("onDayRightClick", ev);
    };
    _this._onLabelClick = function(args) {
      _this._labelClick("onLabelClick", args);
    };
    _this._onLabelDoubleClick = function(args) {
      _this._labelClick("onLabelDoubleClick", args);
    };
    _this._onLabelRightClick = function(args) {
      _this._labelClick("onLabelRightClick", args);
    };
    _this._onLabelHoverIn = function(args) {
      _this._labelClick("onLabelHoverIn", args);
    };
    _this._onLabelHoverOut = function(args) {
      _this._labelClick("onLabelHoverOut", args);
    };
    _this._setBtn = function(btn) {
      _this._btn = btn;
    };
    return _this;
  }
  CalendarDayBase2.prototype._mounted = function() {
    var _this = this;
    var allowCreate;
    var allowStart;
    var touchTimer;
    this._unlistenBtn = gestureListener(this._btn, {
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onFocus: function() {
        _this.setState({
          hasFocus: true
        });
      }
    });
    this._unlisten = gestureListener(this._el, {
      click: true,
      onDoubleClick: function(args) {
        var s = _this.s;
        if (s.clickToCreate && s.clickToCreate !== "single" && s.labels && !s.disabled && s.display) {
          _this._hook("onLabelUpdateStart", args);
          _this._hook("onLabelUpdateEnd", args);
        }
        _this._cellClick("onDayDoubleClick", args.domEvent);
      },
      onEnd: function(args) {
        if (allowCreate) {
          args.domEvent.preventDefault();
          _this._hook("onLabelUpdateEnd", args);
          allowCreate = false;
        }
        clearTimeout(touchTimer);
        allowCreate = false;
        allowStart = false;
      },
      onHoverIn: function(ev) {
        var s = _this.s;
        if (!s.disabled) {
          _this.setState({
            hasHover: true
          });
        }
        _this._hook("onHoverIn", {
          date: new Date(s.date),
          domEvent: ev,
          hidden: !s.display,
          outer: s.outer,
          target: _this._el
        });
      },
      onHoverOut: function(ev) {
        var s = _this.s;
        _this.setState({
          hasHover: false
        });
        _this._hook("onHoverOut", {
          date: new Date(s.date),
          domEvent: ev,
          hidden: !s.display,
          outer: s.outer,
          target: _this._el
        });
      },
      onKeyDown: function(ev) {
        switch (ev.keyCode) {
          case ENTER:
          case SPACE:
            ev.preventDefault();
            _this._onClick(ev);
            break;
        }
      },
      onMove: function(args) {
        if (allowCreate && _this.s.dragToCreate) {
          args.domEvent.preventDefault();
          _this._hook("onLabelUpdateMove", args);
        } else if (allowStart && _this.s.dragToCreate && (Math.abs(args.deltaX) > 7 || Math.abs(args.deltaY) > 7)) {
          allowCreate = !args.isTouch;
          _this._hook("onLabelUpdateStart", args);
        } else {
          clearTimeout(touchTimer);
        }
      },
      onStart: function(args) {
        var s = _this.s;
        args.create = true;
        if (!s.disabled && (s.dragToCreate || s.clickToCreate) && s.labels && !allowCreate) {
          var label = closest(args.domEvent.target, ".mbsc-calendar-text", _this._el);
          if (!label) {
            if (args.isTouch && s.dragToCreate) {
              touchTimer = setTimeout(function() {
                _this._hook("onLabelUpdateStart", args);
                _this._hook("onLabelUpdateModeOn", args);
                allowCreate = true;
              }, 350);
            } else if (s.clickToCreate === "single") {
              _this._hook("onLabelUpdateStart", args);
              allowCreate = true;
            } else {
              allowStart = !args.isTouch;
            }
          }
        }
      }
    });
  };
  CalendarDayBase2.prototype._render = function(s, state) {
    var now = createDate$1(s);
    var d = s.date;
    var colors = s.colors, display = s.display, dragData = s.dragData, hoverEnd = s.hoverEnd, hoverStart = s.hoverStart, labels = s.labels, rangeEnd = s.rangeEnd, rangeStart = s.rangeStart;
    var date = new Date(d);
    var dateKey = getDateStr(date);
    var isToday = isSameDay(now, date);
    var events = labels && labels.events;
    var color = colors && colors[0];
    var background = color && color.background;
    var highlight = color && color.highlight;
    var cellClass = "";
    var highlightClass = "";
    this._draggedLabel = dragData && dragData.draggedDates && dragData.draggedDates[dateKey];
    this._draggedLabelOrig = dragData && dragData.originDates && dragData.originDates[dateKey];
    this._todayClass = isToday ? " mbsc-calendar-today" : "";
    this._cellStyles = background && display ? {
      backgroundColor: background,
      color: getTextColor(background)
    } : UNDEFINED;
    this._circleStyles = highlight ? {
      backgroundColor: highlight,
      color: getTextColor(color.highlight)
    } : UNDEFINED;
    this._ariaLabel = s.type === "day" ? (isToday ? s.todayText + ", " : "") + s.day + ", " + s.month + " " + s.text + ", " + s.year : s.type === "month" ? s.month : "";
    if (display) {
      if (rangeStart && d >= rangeStart && d <= (rangeEnd || rangeStart) || rangeEnd && d <= rangeEnd && d >= (rangeStart || rangeEnd)) {
        highlightClass = " mbsc-range-day" + (d === (rangeStart || rangeEnd) ? " mbsc-range-day-start" : "") + (d === (rangeEnd || rangeStart) ? " mbsc-range-day-end" : "");
      }
      if (hoverStart && hoverEnd && d >= hoverStart && d <= hoverEnd) {
        highlightClass += " mbsc-range-hover" + (d === hoverStart ? " mbsc-range-hover-start mbsc-hover" : "") + (d === hoverEnd ? " mbsc-range-hover-end mbsc-hover" : "");
      }
    }
    if (s.marks) {
      s.marks.forEach(function(e) {
        cellClass += e.cellCssClass ? " " + e.cellCssClass : "";
      });
    }
    if (colors) {
      colors.forEach(function(e) {
        cellClass += e.cellCssClass ? " " + e.cellCssClass : "";
      });
    }
    if (events) {
      events.forEach(function(e) {
        cellClass += e.cellCssClass ? " " + e.cellCssClass : "";
      });
    }
    this._cssClass = "mbsc-calendar-cell mbsc-flex-1-0-0 mbsc-calendar-" + s.type + this._theme + this._rtl + this._hb + cellClass + (labels ? " mbsc-calendar-day-labels" : "") + (colors ? " mbsc-calendar-day-colors" : "") + (s.outer ? " mbsc-calendar-day-outer" : "") + (s.hasMarks ? " mbsc-calendar-day-marked" : "") + (s.disabled ? " mbsc-disabled" : "") + (display ? "" : " mbsc-calendar-day-empty") + (s.selected ? " mbsc-selected" : "") + (state.hasFocus ? " mbsc-focus" : "") + (state.hasHover && (d === hoverStart || d === hoverEnd || !hoverStart && !hoverEnd) ? " mbsc-hover" : "") + (this._draggedLabel ? " mbsc-calendar-day-highlight" : "") + highlightClass;
    this._data = {
      date,
      events: s.events || [],
      selected: s.selected
    };
  };
  CalendarDayBase2.prototype._destroy = function() {
    if (this._unlistenBtn) {
      this._unlistenBtn();
    }
    if (this._unlisten) {
      this._unlisten();
    }
  };
  CalendarDayBase2.prototype._cellClick = function(name, domEvent) {
    var s = this.s;
    if (s.display) {
      this._hook(name, {
        date: new Date(s.date),
        disabled: s.disabled,
        domEvent,
        outer: s.outer,
        selected: s.selected,
        source: "calendar",
        target: this._el
      });
    }
  };
  CalendarDayBase2.prototype._labelClick = function(name, args) {
    var s = this.s;
    args.date = new Date(s.date);
    args.labels = s.labels.events;
    this._hook(name, args);
  };
  CalendarDayBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵCalendarDayBase_BaseFactory;
    return function CalendarDayBase_Factory(__ngFactoryType__) {
      return (ɵCalendarDayBase_BaseFactory || (ɵCalendarDayBase_BaseFactory = ɵɵgetInheritedFactory(CalendarDayBase2)))(__ngFactoryType__ || CalendarDayBase2);
    };
  })();
  CalendarDayBase2.ɵdir = ɵɵdefineDirective({
    type: CalendarDayBase2,
    selectors: [["", "mbsc-calday-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return CalendarDayBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarDayBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-calday-b]"
    }]
  }], null, null);
})();
var stateObservables$1 = {};
var CalendarLabelBase = function(_super) {
  __extends(CalendarLabelBase2, _super);
  function CalendarLabelBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onClick = function(ev) {
      if (_this._isDrag) {
        ev.stopPropagation();
      } else {
        _this._triggerEvent("onClick", ev);
        var s = _this.s;
        var observable = stateObservables$1[s.id];
        if (observable && s.selected) {
          observable.next({
            hasFocus: false
          });
        }
      }
    };
    _this._onRightClick = function(ev) {
      _this._triggerEvent("onRightClick", ev);
    };
    _this._onDocTouch = function(ev) {
      unlisten(_this._doc, TOUCH_START, _this._onDocTouch);
      unlisten(_this._doc, MOUSE_DOWN, _this._onDocTouch);
      _this._isDrag = false;
      _this._hook("onDragModeOff", {
        domEvent: ev,
        event: _this.s.event
      });
    };
    _this._updateState = function(args) {
      if (_this.s.showText || _this._hasResizeEnd) {
        _this.setState(args);
      }
    };
    _this._triggerEvent = function(name, ev) {
      _this._hook(name, {
        domEvent: ev,
        label: _this.s.event,
        target: _this._el
      });
    };
    return _this;
  }
  CalendarLabelBase2.prototype._mounted = function() {
    var _this = this;
    var opt = this.s;
    var el2 = this._el;
    var id2 = opt.id;
    var isPicker = opt.isPicker;
    var resizeDir;
    var observable = stateObservables$1[id2];
    if (!observable) {
      observable = new Observable();
      stateObservables$1[id2] = observable;
    }
    this._unsubscribe = observable.subscribe(this._updateState);
    this._doc = getDocument(el2);
    this._unlisten = gestureListener(el2, {
      keepFocus: true,
      onBlur: function() {
        if (!isPicker) {
          observable.next({
            hasFocus: false
          });
        }
      },
      onDoubleClick: function(ev) {
        ev.domEvent.stopPropagation();
        _this._hook("onDoubleClick", {
          domEvent: ev.domEvent,
          label: _this.s.event,
          target: el2
        });
      },
      onEnd: function(ev) {
        if (_this._isDrag) {
          var s = _this.s;
          var args = __assign({}, ev);
          args.domEvent.preventDefault();
          args.event = s.event;
          if (s.resize && resizeDir) {
            args.resize = true;
            args.direction = resizeDir;
          } else if (s.drag) {
            args.drag = true;
          }
          _this._hook("onDragEnd", args);
          if (!s.isUpdate) {
            _this._isDrag = false;
          }
          if (el2 && args.moved) {
            el2.blur();
          }
        }
        clearTimeout(_this._touchTimer);
        resizeDir = UNDEFINED;
      },
      onFocus: function() {
        if (!isPicker) {
          observable.next({
            hasFocus: true
          });
        }
      },
      onHoverIn: function(ev) {
        if (_this._isDrag || isPicker) {
          return;
        }
        observable.next({
          hasHover: true
        });
        _this._triggerEvent("onHoverIn", ev);
      },
      onHoverOut: function(ev) {
        observable.next({
          hasHover: false
        });
        _this._triggerEvent("onHoverOut", ev);
      },
      onKeyDown: function(ev) {
        var event = _this.s.event;
        switch (ev.keyCode) {
          case ENTER:
          case SPACE:
            el2.click();
            ev.preventDefault();
            break;
          case BACKSPACE:
          case DELETE:
            if (event && event.editable !== false) {
              _this._hook("onDelete", {
                domEvent: ev,
                event,
                source: "calendar"
              });
            }
            break;
        }
      },
      onMove: function(ev) {
        var s = _this.s;
        var args = __assign({}, ev);
        args.event = s.event;
        if (resizeDir) {
          args.resize = true;
          args.direction = resizeDir;
        } else if (s.drag) {
          args.drag = true;
        } else {
          return;
        }
        if (!s.event || s.event.editable === false) {
          return;
        }
        if (_this._isDrag) {
          args.domEvent.preventDefault();
          _this._hook("onDragMove", args);
        } else if (Math.abs(args.deltaX) > 7 || Math.abs(args.deltaY) > 7) {
          clearTimeout(_this._touchTimer);
          if (!args.isTouch) {
            _this._isDrag = true;
            _this._hook("onDragStart", args);
          }
        }
      },
      onStart: function(ev) {
        var s = _this.s;
        var args = __assign({}, ev);
        var target = args.domEvent.target;
        args.event = s.event;
        if (s.resize && target.classList.contains("mbsc-calendar-label-resize")) {
          resizeDir = target.classList.contains("mbsc-calendar-label-resize-start") ? "start" : "end";
          args.resize = true;
          args.direction = resizeDir;
        } else if (s.drag) {
          args.drag = true;
        } else {
          return;
        }
        if (!s.event || s.event.editable === false) {
          return;
        }
        if (_this._isDrag || !args.isTouch) {
          args.domEvent.stopPropagation();
        }
        if (_this._isDrag) {
          _this._hook("onDragStart", args);
        } else if (args.isTouch) {
          _this._touchTimer = setTimeout(function() {
            _this._hook("onDragModeOn", args);
            _this._hook("onDragStart", args);
            _this._isDrag = true;
          }, 350);
        }
      }
    });
    if (this._isDrag) {
      listen(this._doc, TOUCH_START, this._onDocTouch);
      listen(this._doc, MOUSE_DOWN, this._onDocTouch);
    }
  };
  CalendarLabelBase2.prototype._destroy = function() {
    if (this._el) {
      this._el.blur();
    }
    if (this._unsubscribe) {
      var id2 = this.s.id;
      var observable = stateObservables$1[id2];
      if (observable) {
        observable.unsubscribe(this._unsubscribe);
        if (!observable.nr) {
          delete stateObservables$1[id2];
        }
      }
    }
    if (this._unlisten) {
      this._unlisten();
    }
    unlisten(this._doc, TOUCH_START, this._onDocTouch);
    unlisten(this._doc, MOUSE_DOWN, this._onDocTouch);
  };
  CalendarLabelBase2.prototype._render = function(s, state) {
    var event = s.event;
    var d = new Date(s.date);
    var render = s.render || s.renderContent;
    var start;
    var end;
    var isMultiDay = false;
    var isStart;
    var isEnd;
    var isEndStyle;
    var text;
    this._isDrag = this._isDrag || s.isUpdate;
    this._content = UNDEFINED;
    this._title = s.more || s.count || !s.showEventTooltip ? UNDEFINED : htmlToText(event.tooltip || event.title || event.text);
    this._tabIndex = s.isActiveMonth && s.showText && !s.count && !s.isPicker ? 0 : -1;
    if (event) {
      var allDay = event.allDay;
      var tzOpt = allDay ? UNDEFINED : s;
      start = event.start ? makeDate(event.start, tzOpt) : null;
      end = event.end ? makeDate(event.end, tzOpt) : null;
      var endTime = start && end && getEndDate(s, allDay, start, end, !s.isExact);
      var firstDayOfWeek = getFirstDayOfWeek(d, s);
      var lastDayOfWeek = addDays(firstDayOfWeek, 7);
      var lastDay = s.lastDay && s.lastDay < lastDayOfWeek ? s.lastDay : lastDayOfWeek;
      isMultiDay = start && endTime && !isSameDay(start, endTime);
      isStart = !isMultiDay || start && isSameDay(start, d);
      isEnd = !isMultiDay || endTime && isSameDay(endTime, d);
      isEndStyle = !isMultiDay || (s.showText ? endTime < lastDay : isEnd);
      this._hasResizeStart = s.resize && isStart;
      this._hasResizeEnd = s.resize && isEndStyle;
      var color = event.color;
      if (!color && event.resource && s.resourcesMap) {
        var resource = s.resourcesMap[isArray(event.resource) ? event.resource[0] : event.resource];
        color = resource && resource.color;
      }
      if (s.showText) {
        this._textColor = color ? getTextColor(color) : UNDEFINED;
      }
      this._color = s.render || s.template ? UNDEFINED : event.textColor && !color ? "transparent" : color;
    }
    if (event && s.showText && (render || s.contentTemplate || s.template)) {
      var fillsAllDay = event.allDay || !start || isMultiDay && !isStart && !isEnd;
      this._data = {
        end: !fillsAllDay && isEnd && end ? formatDate(s.timeFormat, end, s) : "",
        id: event.id,
        isMultiDay,
        original: event,
        start: !fillsAllDay && isStart && start ? formatDate(s.timeFormat, start, s) : "",
        title: this._title
      };
      if (render) {
        var content = render(this._data);
        if (isString(content)) {
          text = content;
        } else {
          this._content = content;
        }
      }
    } else {
      text = s.more || s.count || (s.showText ? event.title || event.text || "" : "");
    }
    if (text !== this._text) {
      this._text = text;
      this._html = text ? this._safeHtml(text) : UNDEFINED;
      this._shouldEnhance = text && event && s.showText && !!render;
    }
    this._cssClass = "mbsc-calendar-text" + this._theme + this._rtl + (state.hasFocus && !s.inactive && !s.selected || s.selected && s.showText ? " mbsc-calendar-label-active " : "") + (state.hasHover && !s.inactive && !this._isDrag ? " mbsc-calendar-label-hover" : "") + (s.more ? " mbsc-calendar-text-more" : s.render || s.template ? " mbsc-calendar-custom-label" : " mbsc-calendar-label") + (s.inactive ? " mbsc-calendar-label-inactive" : "") + (s.isUpdate ? " mbsc-calendar-label-dragging" : "") + (s.hidden ? " mbsc-calendar-label-hidden" : "") + (isStart ? " mbsc-calendar-label-start" : "") + (isEndStyle ? " mbsc-calendar-label-end" : "") + (event && event.editable === false ? " mbsc-readonly-event" : "") + (event && event.cssClass ? " " + event.cssClass : "");
  };
  CalendarLabelBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵCalendarLabelBase_BaseFactory;
    return function CalendarLabelBase_Factory(__ngFactoryType__) {
      return (ɵCalendarLabelBase_BaseFactory || (ɵCalendarLabelBase_BaseFactory = ɵɵgetInheritedFactory(CalendarLabelBase2)))(__ngFactoryType__ || CalendarLabelBase2);
    };
  })();
  CalendarLabelBase2.ɵdir = ɵɵdefineDirective({
    type: CalendarLabelBase2,
    selectors: [["", "mbsc-callbl-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return CalendarLabelBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarLabelBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-callbl-b]"
    }]
  }], null, null);
})();
var CalendarViewBase = function(_super) {
  __extends(CalendarViewBase2, _super);
  function CalendarViewBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      height: "sm",
      pageSize: 0,
      pickerSize: 0,
      width: "sm"
    };
    _this._dim = {};
    _this._months = [1, 2, 3];
    _this._title = [];
    _this.PAGE_VIEW = PAGE_VIEW;
    _this.MONTH_VIEW = MONTH_VIEW;
    _this.YEAR_VIEW = YEAR_VIEW;
    _this.MULTI_YEAR_VIEW = MULTI_YEAR_VIEW;
    _this.nextPage = function() {
      _this._prevDocClick();
      switch (_this._view) {
        case MONTH_VIEW:
          _this._activeMonthChange(1);
          break;
        case MULTI_YEAR_VIEW:
          _this._activeYearsChange(1);
          break;
        case YEAR_VIEW:
          _this._activeYearChange(1);
          break;
        default:
          _this._activeChange(1);
      }
    };
    _this.prevPage = function() {
      _this._prevDocClick();
      switch (_this._view) {
        case MONTH_VIEW:
          _this._activeMonthChange(-1);
          break;
        case MULTI_YEAR_VIEW:
          _this._activeYearsChange(-1);
          break;
        case YEAR_VIEW:
          _this._activeYearChange(-1);
          break;
        default:
          _this._activeChange(-1);
      }
    };
    _this._changeView = function(newView) {
      var s = _this.s;
      var view = _this._view;
      var hasPicker = _this._hasPicker;
      var selectView = s.selectView;
      var navView = s.navView;
      var isYearView = s.showCalendar && s.calendarType === "year";
      if (!newView) {
        switch (view) {
          case PAGE_VIEW:
            newView = navView || (isYearView ? MULTI_YEAR_VIEW : YEAR_VIEW);
            break;
          case MONTH_VIEW:
            newView = YEAR_VIEW;
            break;
          case MULTI_YEAR_VIEW:
            newView = isYearView || navView === MULTI_YEAR_VIEW ? PAGE_VIEW : YEAR_VIEW;
            break;
          default:
            newView = hasPicker && navView === YEAR_VIEW || selectView === YEAR_VIEW || _this._prevView !== MULTI_YEAR_VIEW ? MULTI_YEAR_VIEW : navView === MONTH_VIEW ? MONTH_VIEW : PAGE_VIEW;
        }
        if (selectView === MULTI_YEAR_VIEW || navView === MULTI_YEAR_VIEW) {
          newView = MULTI_YEAR_VIEW;
        }
      }
      if (view === PAGE_VIEW) {
        _this._activeMonth = _this._active;
      }
      var skipAnimation = hasPicker && newView === selectView;
      _this._prevView = view;
      _this.setState({
        view: newView,
        viewClosing: skipAnimation ? UNDEFINED : view,
        viewOpening: skipAnimation ? UNDEFINED : newView
      });
    };
    _this._onDayHoverIn = function(ev) {
      if (!_this._disableHover) {
        _this._hook("onDayHoverIn", ev);
        _this._hoverTimer = setTimeout(function() {
          var key = getDateStr(ev.date);
          if (_this._labels) {
            ev.labels = _this._labels[key];
          }
          if (_this._marked) {
            ev.marked = _this._marked[key];
          }
          _this._isHover = true;
          _this._hook("onCellHoverIn", ev);
        }, 150);
      }
    };
    _this._onDayHoverOut = function(ev) {
      if (!_this._disableHover) {
        _this._hook("onDayHoverOut", ev);
        clearTimeout(_this._hoverTimer);
        if (_this._isHover) {
          var key = getDateStr(ev.date);
          if (_this._labels) {
            ev.labels = _this._labels[key];
          }
          if (_this._marked) {
            ev.marked = _this._marked[key];
          }
          _this._isHover = false;
          _this._hook("onCellHoverOut", ev);
        }
      }
    };
    _this._onLabelClick = function(args) {
      _this._isLabelClick = true;
      _this._hook("onLabelClick", args);
    };
    _this._onDayClick = function(args) {
      _this._shouldFocus = !_this._isLabelClick;
      _this._prevAnim = false;
      _this._isLabelClick = false;
      _this._hook("onDayClick", args);
    };
    _this._onTodayClick = function(args) {
      _this._prevAnim = false;
      _this._hook("onActiveChange", {
        date: +removeTimezone(createDate$1(_this.s)),
        today: true
      });
      _this._hook("onTodayClick", {});
    };
    _this._onNavDayClick = function(args) {
      if (args.disabled) {
        return;
      }
      var d = args.date;
      var s = _this.s;
      var newIndex = getPageIndex(d, s);
      _this._prevDocClick();
      _this._changeView(PAGE_VIEW);
      _this._shouldFocus = true;
      _this._prevAnim = !_this._hasPicker;
      _this._hook("onActiveChange", {
        date: +d,
        nav: true,
        pageChange: newIndex !== _this._pageIndex,
        today: true
      });
    };
    _this._onMonthClick = function(args) {
      if (args.disabled) {
        return;
      }
      var s = _this.s;
      var d = new Date(args.date);
      if (s.selectView === YEAR_VIEW) {
        _this._hook("onDayClick", args);
      } else {
        _this._prevDocClick();
        _this._shouldFocus = true;
        _this._prevAnim = !_this._hasPicker;
        _this._activeMonth = +d;
        if (s.navView === YEAR_VIEW || s.navView === UNDEFINED) {
          var newIndex = getPageIndex(d, s);
          _this._changeView(PAGE_VIEW);
          _this._hook("onActiveChange", {
            date: +d,
            nav: true,
            pageChange: newIndex !== _this._pageIndex,
            today: true
          });
        } else {
          _this._changeView(MONTH_VIEW);
        }
      }
    };
    _this._onYearClick = function(args) {
      if (args.disabled) {
        return;
      }
      var d = args.date;
      var s = _this.s;
      var view = s.selectView;
      if (view === MULTI_YEAR_VIEW) {
        _this._hook("onDayClick", args);
      } else {
        _this._shouldFocus = true;
        _this._prevAnim = view === YEAR_VIEW;
        _this._activeMonth = +d;
        _this._prevDocClick();
        if (s.navView === MULTI_YEAR_VIEW || s.calendarType === "year") {
          var newIndex = getPageIndex(d, s);
          _this._changeView(PAGE_VIEW);
          _this._hook("onActiveChange", {
            date: +d,
            pageChange: newIndex !== _this._pageIndex,
            today: true
          });
        } else {
          _this._changeView(YEAR_VIEW);
        }
      }
    };
    _this._onPageChange = function(args) {
      _this._isSwipeChange = true;
      _this._activeChange(args.diff);
    };
    _this._onMonthPageChange = function(args) {
      _this._activeMonthChange(args.diff);
    };
    _this._onYearPageChange = function(args) {
      _this._activeYearChange(args.diff);
    };
    _this._onYearsPageChange = function(args) {
      _this._activeYearsChange(args.diff);
    };
    _this._onAnimationEnd = function(args) {
      _this._disableHover = false;
      if (_this._isIndexChange) {
        _this._pageLoaded();
        _this._isIndexChange = false;
      }
    };
    _this._onStart = function() {
      clearTimeout(_this._hoverTimer);
    };
    _this._onGestureStart = function(args) {
      _this._disableHover = true;
      _this._hook("onGestureStart", args);
    };
    _this._onGestureEnd = function(args) {
      _this._prevDocClick();
    };
    _this._onPickerClose = function() {
      _this.setState({
        view: PAGE_VIEW
      });
    };
    _this._onPickerOpen = function() {
      var pageHeight = _this._pickerCont.clientHeight;
      var pageWidth = _this._pickerCont.clientWidth;
      _this.setState({
        pickerSize: _this._isVertical ? pageHeight : pageWidth
      });
    };
    _this._onPickerBtnClick = function(ev) {
      if (_this._view === PAGE_VIEW) {
        _this._pickerBtn = ev.currentTarget;
      }
      _this._prevDocClick();
      _this._changeView();
    };
    _this._onDocClick = function() {
      var view = _this.s.selectView;
      if (!_this._prevClick && !_this._hasPicker && _this._view !== view) {
        _this._changeView(view);
      }
    };
    _this._onViewAnimationEnd = function() {
      if (_this.state.viewClosing) {
        _this.setState({
          viewClosing: UNDEFINED
        });
      }
      if (_this.state.viewOpening) {
        _this.setState({
          viewOpening: UNDEFINED
        });
      }
    };
    _this._onResize = function() {
      if (!_this._body || !isBrowser) {
        return;
      }
      var s = _this.s;
      var state = _this.state;
      var showCalendar = s.showCalendar;
      var body = showCalendar && _this.__getTextParam ? _this._body.querySelector(".mbsc-calendar-body-inner") : _this._body;
      var totalWidth = _this._el.offsetWidth;
      var totalHeight = _this._el.offsetHeight;
      var pageHeight = body.clientHeight;
      var pageWidth = body.clientWidth;
      var pageSize = _this._isVertical ? pageHeight : pageWidth;
      var pickerSize = _this._hasPicker ? state.pickerSize : pageSize;
      var ready = showCalendar !== UNDEFINED;
      var width = "sm";
      var height = "sm";
      var maxLabels = UNDEFINED;
      var hasScrollY = false;
      var cellTextHeight = 0;
      var labelHeight = 0;
      if (s.responsiveStyle && !_this._isGrid) {
        if (pageHeight > 300) {
          height = "md";
        }
        if (pageWidth > 767) {
          width = "md";
        }
      }
      if (width !== state.width || height !== state.height) {
        _this._shouldCheckSize = true;
        _this.setState({
          width,
          height
        });
      } else {
        if (_this._labels && showCalendar && _this.__getTextParam) {
          var placeholder = body.querySelector(".mbsc-calendar-text");
          var cell = body.querySelector(".mbsc-calendar-day-inner");
          var labelsCont = cell.querySelector(".mbsc-calendar-labels");
          var txtMargin = placeholder ? getDimension(placeholder, "marginBottom") : 2;
          var txtHeight = placeholder ? placeholder.offsetHeight : 18;
          cellTextHeight = labelsCont.offsetTop;
          hasScrollY = body.scrollHeight > body.clientHeight;
          labelHeight = txtHeight + txtMargin;
          maxLabels = Math.max(1, floor((cell.clientHeight - cellTextHeight) / labelHeight));
        }
        _this._hook("onResize", {
          height: totalHeight,
          target: _this._el,
          width: totalWidth
        });
        s.navService.pageSize = pageSize;
        var update = _this._shouldPageLoad ? (state.update || 0) + 1 : state.update;
        _this.setState({
          cellTextHeight,
          hasScrollY,
          labelHeight,
          maxLabels,
          pageSize,
          pickerSize,
          ready,
          update
        });
      }
    };
    _this._onKeyDown = function(ev) {
      var s = _this.s;
      var view = _this._view;
      var active = view === PAGE_VIEW ? _this._active : _this._activeMonth;
      var activeDate = new Date(active);
      var year = s.getYear(activeDate);
      var month = s.getMonth(activeDate);
      var day = s.getDay(activeDate);
      var getDate = s.getDate;
      var weeks = s.weeks;
      var isMonthView = s.calendarType === "month";
      var newDate;
      if (view === MULTI_YEAR_VIEW) {
        var newYear = void 0;
        switch (ev.keyCode) {
          case LEFT_ARROW:
            newYear = year - 1 * _this._rtlNr;
            break;
          case RIGHT_ARROW:
            newYear = year + 1 * _this._rtlNr;
            break;
          case UP_ARROW:
            newYear = year - 3;
            break;
          case DOWN_ARROW:
            newYear = year + 3;
            break;
          case HOME:
            newYear = _this._getPageYears(_this._yearsIndex);
            break;
          case END:
            newYear = _this._getPageYears(_this._yearsIndex) + 11;
            break;
          case PAGE_UP:
            newYear = year - 12;
            break;
          case PAGE_DOWN:
            newYear = year + 12;
            break;
        }
        if (newYear && _this._minYears <= newYear && _this._maxYears >= newYear) {
          ev.preventDefault();
          _this._shouldFocus = true;
          _this._prevAnim = false;
          _this._activeMonth = +getDate(newYear, 0, 1);
          _this.forceUpdate();
        }
      } else if (view === YEAR_VIEW) {
        switch (ev.keyCode) {
          case LEFT_ARROW:
            newDate = getDate(year, month - 1 * _this._rtlNr, 1);
            break;
          case RIGHT_ARROW:
            newDate = getDate(year, month + 1 * _this._rtlNr, 1);
            break;
          case UP_ARROW:
            newDate = getDate(year, month - 3, 1);
            break;
          case DOWN_ARROW:
            newDate = getDate(year, month + 3, 1);
            break;
          case HOME:
            newDate = getDate(year, 0, 1);
            break;
          case END:
            newDate = getDate(year, 11, 1);
            break;
          case PAGE_UP:
            newDate = getDate(year - 1, month, 1);
            break;
          case PAGE_DOWN:
            newDate = getDate(year + 1, month, 1);
            break;
        }
        if (newDate && _this._minYear <= newDate && _this._maxYear >= newDate) {
          ev.preventDefault();
          _this._shouldFocus = true;
          _this._prevAnim = false;
          _this._activeMonth = +newDate;
          _this.forceUpdate();
        }
      } else {
        switch (ev.keyCode) {
          case LEFT_ARROW:
            newDate = getDate(year, month, day - 1 * _this._rtlNr);
            break;
          case RIGHT_ARROW:
            newDate = getDate(year, month, day + 1 * _this._rtlNr);
            break;
          case UP_ARROW:
            newDate = getDate(year, month, day - 7);
            break;
          case DOWN_ARROW:
            newDate = getDate(year, month, day + 7);
            break;
          case HOME:
            newDate = getDate(year, month, 1);
            break;
          case END:
            newDate = getDate(year, month + 1, 0);
            break;
          case PAGE_UP:
            newDate = ev.altKey ? getDate(year - 1, month, day) : isMonthView ? getDate(year, month - 1, day) : getDate(year, month, day - weeks * 7);
            break;
          case PAGE_DOWN:
            newDate = ev.altKey ? getDate(year + 1, month, day) : isMonthView ? getDate(year, month + 1, day) : getDate(year, month, day + weeks * 7);
            break;
        }
        if (newDate && _this._minDate <= newDate && _this._maxDate >= newDate) {
          ev.preventDefault();
          var newIndex = getPageIndex(newDate, s);
          _this._shouldFocus = true;
          _this._prevAnim = false;
          if (view === MONTH_VIEW) {
            _this._activeMonth = +newDate;
            _this.forceUpdate();
          } else {
            _this._pageChange = s.noOuterChange && newIndex !== _this._pageIndex;
            _this._hook("onActiveChange", {
              date: +newDate,
              pageChange: _this._pageChange
            });
          }
        }
      }
    };
    _this._setHeader = function(el2) {
      _this._headerElement = el2;
    };
    _this._setBody = function(el2) {
      _this._body = el2;
    };
    _this._setPickerCont = function(el2) {
      _this._pickerCont = el2;
    };
    return _this;
  }
  CalendarViewBase2.prototype._getPageDay = function(pageIndex) {
    return +getFirstPageDay(pageIndex, this.s);
  };
  CalendarViewBase2.prototype._getPageStyle = function(index, offset, pageIndex, pageNr) {
    var _a;
    return _a = {}, _a[(jsPrefix ? jsPrefix + "T" : "t") + "ransform"] = "translate" + this._axis + "(" + (index - offset) * 100 * this._rtlNr + "%)", _a.position = index === pageIndex ? "relative" : "", _a.width = 100 / (pageNr || 1) + "%", _a;
  };
  CalendarViewBase2.prototype._getPageMonth = function(pageIndex) {
    var s = this.s;
    var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
    var year = s.getYear(refDate);
    var month = s.getMonth(refDate);
    return +s.getDate(year, month + pageIndex, 1);
  };
  CalendarViewBase2.prototype._getPageYear = function(pageIndex) {
    var s = this.s;
    var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
    var year = s.getYear(refDate);
    return year + pageIndex;
  };
  CalendarViewBase2.prototype._getPageYears = function(pageIndex) {
    var s = this.s;
    var refDate = s.refDate ? makeDate(s.refDate) : REF_DATE;
    var year = s.getYear(refDate);
    return year + pageIndex * 12;
  };
  CalendarViewBase2.prototype._getPickerClass = function(view) {
    var animName;
    var pickerName = view === this.s.selectView ? " mbsc-calendar-picker-main" : "";
    var baseName = "mbsc-calendar-picker";
    var hasPicker = this._hasPicker;
    var _a = this.state, viewClosing = _a.viewClosing, viewOpening = _a.viewOpening;
    switch (view) {
      case PAGE_VIEW:
        animName = hasPicker ? "" : (viewOpening === PAGE_VIEW ? "in-down" : "") + (viewClosing === PAGE_VIEW ? "out-down" : "");
        break;
      case MONTH_VIEW:
        animName = hasPicker && viewClosing === PAGE_VIEW ? "" : (viewOpening === MONTH_VIEW ? "in-down" : "") + (viewClosing === MONTH_VIEW ? "out-down" : "");
        break;
      case MULTI_YEAR_VIEW:
        animName = hasPicker && viewClosing === PAGE_VIEW ? "" : (viewOpening === MULTI_YEAR_VIEW ? "in-up" : "") + (viewClosing === MULTI_YEAR_VIEW ? "out-up" : "");
        break;
      default:
        animName = hasPicker && (viewOpening === PAGE_VIEW || viewClosing === PAGE_VIEW) ? "" : (viewOpening === YEAR_VIEW ? viewClosing === MULTI_YEAR_VIEW ? "in-down" : "in-up" : "") + (viewClosing === YEAR_VIEW ? viewOpening === MULTI_YEAR_VIEW ? "out-down" : "out-up" : "");
    }
    return baseName + pickerName + (hasAnimation && animName ? " " + baseName + "-" + animName : "");
  };
  CalendarViewBase2.prototype._isNextDisabled = function(isModalPicker) {
    if (!this._hasPicker || isModalPicker) {
      var view = this._view;
      if (view === MULTI_YEAR_VIEW) {
        return this._yearsIndex + 1 > this._maxYearsIndex;
      }
      if (view === YEAR_VIEW) {
        return this._yearIndex + 1 > this._maxYearIndex;
      }
      if (view === MONTH_VIEW) {
        return this._monthIndex + 1 > this._maxMonthIndex;
      }
    }
    return this._pageIndex + 1 > this._maxIndex;
  };
  CalendarViewBase2.prototype._isPrevDisabled = function(isModalPicker) {
    if (!this._hasPicker || isModalPicker) {
      var view = this._view;
      if (view === MULTI_YEAR_VIEW) {
        return this._yearsIndex - 1 < this._minYearsIndex;
      }
      if (view === YEAR_VIEW) {
        return this._yearIndex - 1 < this._minYearIndex;
      }
      if (view === MONTH_VIEW) {
        return this._monthIndex - 1 < this._minMonthIndex;
      }
    }
    return this._pageIndex - 1 < this._minIndex;
  };
  CalendarViewBase2.prototype._render = function(s, state) {
    var getDate = s.getDate;
    var getYear = s.getYear;
    var getMonth = s.getMonth;
    var showCalendar = s.showCalendar;
    var calendarType = s.calendarType;
    var eventRange = s.eventRange;
    var eventRangeSize = s.eventRangeSize || 1;
    var firstWeekDay = s.firstDay;
    var isWeekView = calendarType === "week";
    var isMonthView = calendarType === "month";
    var isYearView = calendarType === "year";
    var size = isYearView ? 12 : +(s.size || 1);
    var isGrid = size > 1 && !isWeekView;
    var weeks = showCalendar ? isWeekView ? s.weeks : 6 : 0;
    var active = s.activeDate || this._active || +/* @__PURE__ */ new Date();
    var activeChanged = active !== this._active;
    var d = new Date(active);
    var prevProps = this._prevS;
    var dateFormat = s.dateFormat;
    var monthNames = s.monthNames;
    var yearSuffix = s.yearSuffix;
    var variableRow = isNumeric(s.labelList) ? +s.labelList + 1 : s.labelList === "all" ? -1 : 0;
    var labelListingChanged = s.labelList !== prevProps.labelList;
    var navService = s.navService;
    var pageIndex = navService.pageIndex;
    var firstDay = navService.firstDay;
    var lastDay = navService.lastDay;
    var start = navService.viewStart;
    var end = navService.viewEnd;
    this._minDate = navService.minDate;
    this._maxDate = navService.maxDate;
    if (!isEmpty(s.min)) {
      var min = getDateOnly(this._minDate);
      this._minDate = getDateOnly(min);
      this._minYear = getDate(getYear(min), getMonth(min), 1);
      this._minYears = getYear(min);
      this._minIndex = getPageIndex(min, s);
      this._minYearIndex = getYearIndex(min, s);
      this._minYearsIndex = getYearsIndex(min, s);
      this._minMonthIndex = getMonthIndex(min, s);
    } else {
      this._minIndex = -Infinity;
      this._minYears = -Infinity;
      this._minYearsIndex = -Infinity;
      this._minYear = -Infinity;
      this._minYearIndex = -Infinity;
      this._minMonthIndex = -Infinity;
    }
    if (!isEmpty(s.max)) {
      var max = this._maxDate;
      this._maxYear = getDate(getYear(max), getMonth(max) + 1, 1);
      this._maxYears = getYear(max);
      this._maxIndex = getPageIndex(max, s);
      this._maxYearIndex = getYearIndex(max, s);
      this._maxYearsIndex = getYearsIndex(max, s);
      this._maxMonthIndex = getMonthIndex(max, s);
    } else {
      this._maxIndex = Infinity;
      this._maxYears = Infinity;
      this._maxYearsIndex = Infinity;
      this._maxYear = Infinity;
      this._maxYearIndex = Infinity;
      this._maxMonthIndex = Infinity;
    }
    var viewChanged = calendarType !== prevProps.calendarType || eventRange !== prevProps.eventRange || firstWeekDay !== prevProps.firstDay || s.eventRangeSize !== prevProps.eventRangeSize || s.refDate !== prevProps.refDate || s.showCalendar !== prevProps.showCalendar || s.weeks !== prevProps.weeks;
    if (viewChanged && this._pageIndex !== UNDEFINED) {
      this._prevAnim = true;
    }
    if (activeChanged) {
      this._activeMonth = active;
    }
    this._view = state.view || s.selectView;
    this._yearsIndex = getYearsIndex(new Date(this._activeMonth), s);
    this._yearIndex = getYearIndex(new Date(this._activeMonth), s);
    this._monthIndex = getMonthIndex(new Date(this._activeMonth), s);
    var pageNr = isGrid ? 1 : getPageNr(s.pages, state.pageSize);
    var isVertical = s.calendarScroll === "vertical" && s.pages !== "auto" && (s.pages === UNDEFINED || s.pages === 1);
    var showOuter = s.showOuterDays !== UNDEFINED ? s.showOuterDays : !isVertical && pageNr < 2 && (isWeekView || !size || size < 2);
    var monthIndex = dateFormat.search(/m/i);
    var yearIndex = dateFormat.search(/y/i);
    if (this._view === MONTH_VIEW) {
      var date = new Date(this._getPageMonth(this._monthIndex));
      var month = monthNames[getMonth(date)];
      var year = getYear(date) + yearSuffix;
      this._viewTitle = yearIndex < monthIndex ? year + " " + month : month + " " + year;
    } else if (this._view === YEAR_VIEW) {
      this._viewTitle = this._getPageYear(this._yearIndex) + "";
    } else if (this._view === MULTI_YEAR_VIEW) {
      var startYear = this._getPageYears(this._yearsIndex);
      this._viewTitle = startYear + " - " + (startYear + 11);
    }
    if (isGrid) {
      this._monthsMulti = [];
      if (pageIndex !== UNDEFINED) {
        var columns = floor(state.pageSize * 0.96 / (PAGE_WIDTH * 1.1)) || 1;
        while (size % columns) {
          columns--;
        }
        for (var i = 0; i < size / columns; ++i) {
          var rowItems = [];
          for (var j = 0; j < columns; ++j) {
            rowItems.push(+getDate(getYear(firstDay), getMonth(firstDay) + i * columns + j, 1));
          }
          this._monthsMulti.push(rowItems);
        }
      }
    }
    if (calendarType !== prevProps.calendarType || s.theme !== prevProps.theme || s.calendarScroll !== prevProps.calendarScroll || s.hasContent !== prevProps.hasContent || s.showCalendar !== prevProps.showCalendar || s.showSchedule !== prevProps.showSchedule || s.showWeekNumbers !== prevProps.showWeekNumbers || s.weeks !== prevProps.weeks || labelListingChanged) {
      this._shouldCheckSize = true;
    }
    if (prevProps.width !== s.width || prevProps.height !== s.height) {
      this._dim = {
        height: addPixel(s.height),
        width: addPixel(s.width)
      };
    }
    this._cssClass = "mbsc-calendar mbsc-font mbsc-flex-col" + this._theme + this._rtl + (state.ready ? "" : " mbsc-hidden") + (isGrid ? " mbsc-calendar-grid-view" : " mbsc-calendar-height-" + state.height + " mbsc-calendar-width-" + state.width) + " " + s.cssClass;
    this._dayNames = state.width === "sm" || isGrid ? s.dayNamesMin : s.dayNamesShort;
    this._isSwipeChange = false;
    this._yearFirst = yearIndex < monthIndex;
    this._pageNr = pageNr;
    this._variableRow = variableRow;
    var forcePageLoad = s.pageLoad !== prevProps.pageLoad;
    var pageChanged = +start !== +this._viewStart || +end !== +this._viewEnd;
    if (this._pageIndex !== UNDEFINED && pageChanged) {
      this._isIndexChange = !this._isSwipeChange && !viewChanged;
    }
    if (pageIndex !== UNDEFINED) {
      this._pageIndex = pageIndex;
    }
    if (pageIndex !== UNDEFINED && (s.marked !== prevProps.marked || s.colors !== prevProps.colors || s.labels !== prevProps.labels || s.invalid !== prevProps.invalid || s.valid !== prevProps.valid || state.maxLabels !== this._maxLabels || pageChanged || labelListingChanged || forcePageLoad)) {
      this._maxLabels = state.maxLabels;
      this._viewStart = start;
      this._viewEnd = end;
      var labelsMap = s.labelsMap || getEventMap(s.labels, start, end, s, false, !s.eventExact);
      var labels = labelsMap && getLabels(s, labelsMap, start, end, this._variableRow || this._maxLabels || 1, 7, false, firstWeekDay, true, !showOuter, s.showLabelCount, s.moreEventsText, s.moreEventsPluralText, s.eventExact);
      if (labels && !this._labels) {
        this._shouldCheckSize = true;
      }
      if (labels && state.maxLabels || !labels) {
        this._shouldPageLoad = !this._isIndexChange || this._prevAnim || !showCalendar || forcePageLoad || isGrid || !!variableRow;
      }
      this._labelsLayout = labels;
      this._labels = labelsMap;
      this._marked = labelsMap ? UNDEFINED : s.marksMap || getEventMap(s.marked, start, end, s, false, true);
      this._colors = getEventMap(s.colors, start, end, s, false, true);
      this._valid = getEventMap(s.valid, start, end, s, true, true);
      this._invalid = getEventMap(s.invalid, start, end, s, true, true);
    }
    if (pageChanged || activeChanged || eventRange !== prevProps.eventRange || eventRangeSize !== prevProps.eventRangeSize || s.monthNames !== prevProps.monthNames) {
      this._title = [];
      var lDay = addDays(lastDay, -1);
      var titleDate = pageIndex === UNDEFINED ? d : firstDay;
      if (isWeekView) {
        titleDate = d;
        for (var _i = 0, _a = Object.keys(s.selectedDates); _i < _a.length; _i++) {
          var key = _a[_i];
          if (+key >= +firstDay && +key < +lastDay) {
            titleDate = /* @__PURE__ */ new Date(+key);
            break;
          }
        }
      }
      if (this._pageNr > 1) {
        for (var i = 0; i < pageNr; i++) {
          var dt = getDate(getYear(firstDay), getMonth(firstDay) + i, 1);
          var yt = getYear(dt) + yearSuffix;
          var mt = monthNames[getMonth(dt)];
          this._title.push({
            yearTitle: yt,
            monthTitle: mt
          });
        }
      } else {
        var titleObj = {
          yearTitle: getYear(titleDate) + yearSuffix,
          monthTitle: monthNames[getMonth(titleDate)]
        };
        var titleType = s.showSchedule && eventRangeSize === 1 ? eventRange : showCalendar ? calendarType : eventRange;
        var agendaOnly = eventRange && !showCalendar && (!s.showSchedule || eventRangeSize > 1);
        switch (titleType) {
          case "year": {
            titleObj.title = getYear(firstDay) + yearSuffix;
            if (eventRangeSize > 1) {
              titleObj.title += " - " + (getYear(lDay) + yearSuffix);
            }
            break;
          }
          case "month": {
            if (eventRangeSize > 1 && !showCalendar) {
              var monthStart = monthNames[getMonth(firstDay)];
              var yearStart = getYear(firstDay) + yearSuffix;
              var titleStart = this._yearFirst ? yearStart + " " + monthStart : monthStart + " " + yearStart;
              var monthEnd = monthNames[getMonth(lDay)];
              var yearEnd = getYear(lDay) + yearSuffix;
              var titleEnd = this._yearFirst ? yearEnd + " " + monthEnd : monthEnd + " " + yearEnd;
              titleObj.title = titleStart + " - " + titleEnd;
            } else if (isGrid) {
              titleObj.title = getYear(firstDay) + yearSuffix;
            }
            break;
          }
          case "day":
          case "week": {
            if (agendaOnly) {
              var dayIndex = dateFormat.search(/d/i);
              var shortDateFormat = dayIndex < monthIndex ? "D MMM, YYYY" : "MMM D, YYYY";
              titleObj.title = formatDate(shortDateFormat, firstDay, s);
              if (titleType === "week" || eventRangeSize > 1) {
                titleObj.title += " - " + formatDate(shortDateFormat, lDay, s);
              }
            }
            break;
          }
        }
        this._title.push(titleObj);
      }
    }
    this._active = active;
    this._hasPicker = s.hasPicker || isGrid || !isMonthView || !showCalendar || state.width === "md" && s.hasPicker !== false;
    this._axis = isVertical ? "Y" : "X";
    this._rtlNr = !isVertical && s.rtl ? -1 : 1;
    this._weeks = weeks;
    this._nextIcon = isVertical ? s.nextIconV : s.rtl ? s.prevIconH : s.nextIconH;
    this._prevIcon = isVertical ? s.prevIconV : s.rtl ? s.nextIconH : s.prevIconH;
    this._mousewheel = s.mousewheel === UNDEFINED ? isVertical : s.mousewheel;
    this._isGrid = isGrid;
    this._isVertical = isVertical;
    this._showOuter = showOuter;
    this._showDaysTop = isVertical || !!variableRow && size === 1;
  };
  CalendarViewBase2.prototype._mounted = function() {
    this._observer = resizeObserver(this._el, this._onResize, this._zone);
    this._doc = getDocument(this._el);
    listen(this._doc, CLICK, this._onDocClick);
  };
  CalendarViewBase2.prototype._updated = function() {
    var _this = this;
    if (this._shouldCheckSize) {
      setTimeout(function() {
        _this._onResize();
      });
      this._shouldCheckSize = false;
    } else if (this._shouldPageLoad) {
      this._pageLoaded();
      this._shouldPageLoad = false;
    }
    if (this._shouldFocus) {
      setTimeout(function() {
        _this._focusActive();
        _this._shouldFocus = false;
      });
    }
    if (this.s.instanceService) {
      this.s.instanceService.onComponentChange.next({});
    }
    this._pageChange = false;
    if (this._variableRow && this.s.showCalendar) {
      var body = this._body.querySelector(".mbsc-calendar-body-inner");
      var hasScrollY = body.scrollHeight > body.clientHeight;
      if (hasScrollY !== this.state.hasScrollY) {
        this._shouldCheckSize = true;
        this.setState({
          hasScrollY
        });
      }
    }
  };
  CalendarViewBase2.prototype._destroy = function() {
    if (this._observer) {
      this._observer.detach();
    }
    unlisten(this._doc, CLICK, this._onDocClick);
    clearTimeout(this._hoverTimer);
  };
  CalendarViewBase2.prototype._getActiveCell = function() {
    var view = this._view;
    var cont = view === PAGE_VIEW ? this._body : this._pickerCont;
    var cell = view === MULTI_YEAR_VIEW ? "year" : view === YEAR_VIEW ? "month" : "cell";
    return cont && cont.querySelector(".mbsc-calendar-" + cell + ' .mbsc-calendar-cell-text[tabindex="0"]');
  };
  CalendarViewBase2.prototype._focusActive = function() {
    var cell = this._getActiveCell();
    if (cell) {
      cell.focus();
    }
  };
  CalendarViewBase2.prototype._pageLoaded = function() {
    var navService = this.s.navService;
    this._hook("onPageLoaded", {
      activeElm: this._getActiveCell(),
      firstDay: navService.firstPageDay,
      lastDay: navService.lastPageDay,
      month: this.s.calendarType === "month" ? navService.firstDay : UNDEFINED,
      viewEnd: navService.viewEnd,
      viewStart: navService.viewStart
    });
  };
  CalendarViewBase2.prototype._activeChange = function(diff) {
    var nextIndex = this._pageIndex + diff;
    if (diff < 0 && this._minIndex <= nextIndex || diff > 0 && this._maxIndex >= nextIndex && this.__getTextParam) {
      this._prevAnim = false;
      this._pageChange = true;
      this._hook("onActiveChange", {
        date: this._getPageDay(nextIndex),
        dir: diff,
        pageChange: true
      });
    }
  };
  CalendarViewBase2.prototype._activeMonthChange = function(diff) {
    var nextIndex = this._monthIndex + diff;
    if (this._minMonthIndex <= nextIndex && this._maxMonthIndex >= nextIndex) {
      this._prevAnim = false;
      this._activeMonth = this._getPageMonth(nextIndex);
      this.forceUpdate();
    }
  };
  CalendarViewBase2.prototype._activeYearsChange = function(diff) {
    var nextIndex = this._yearsIndex + diff;
    if (this._minYearsIndex <= nextIndex && this._maxYearsIndex >= nextIndex) {
      var newYear = this._getPageYears(nextIndex);
      this._prevAnim = false;
      this._activeMonth = +this.s.getDate(newYear, 0, 1);
      this.forceUpdate();
    }
  };
  CalendarViewBase2.prototype._activeYearChange = function(diff) {
    var nextIndex = this._yearIndex + diff;
    if (this._minYearIndex <= nextIndex && this._maxYearIndex >= nextIndex) {
      var newYear = this._getPageYear(nextIndex);
      this._prevAnim = false;
      this._activeMonth = +this.s.getDate(newYear, 0, 1);
      this.forceUpdate();
    }
  };
  CalendarViewBase2.prototype._prevDocClick = function() {
    var _this = this;
    this._prevClick = true;
    setTimeout(function() {
      _this._prevClick = false;
    });
  };
  CalendarViewBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵCalendarViewBase_BaseFactory;
    return function CalendarViewBase_Factory(__ngFactoryType__) {
      return (ɵCalendarViewBase_BaseFactory || (ɵCalendarViewBase_BaseFactory = ɵɵgetInheritedFactory(CalendarViewBase2)))(__ngFactoryType__ || CalendarViewBase2);
    };
  })();
  CalendarViewBase2.ɵdir = ɵɵdefineDirective({
    type: CalendarViewBase2,
    selectors: [["", "mbsc-calview-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return CalendarViewBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarViewBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-calview-b]"
    }]
  }], null, null);
})();
var MonthViewBase = function(_super) {
  __extends(MonthViewBase2, _super);
  function MonthViewBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MonthViewBase2.prototype._isActive = function(d) {
    return this.s.isActive && d === this.s.activeDate;
  };
  MonthViewBase2.prototype._isInvalid = function(d) {
    var s = this.s;
    var localDate = new Date(d);
    var timezoneDate = addTimezone(s, localDate);
    return isInvalid(s, timezoneDate, s.invalid, s.valid, +s.min, +s.max);
  };
  MonthViewBase2.prototype._isSelected = function(d) {
    var localDate = new Date(d);
    var timezoneDate = addTimezone(this.s, localDate);
    return !!this.s.selectedDates[+timezoneDate];
  };
  MonthViewBase2.prototype._getWeekNr = function(s, date) {
    var d = new Date(date);
    return "" + s.getWeekNumber(s.getDate(d.getFullYear(), d.getMonth(), d.getDate() + (7 - s.firstDay + 1) % 7));
  };
  MonthViewBase2.prototype._render = function(s) {
    var weeks = s.weeks || 6;
    var firstWeekDay = s.firstDay;
    var firstDay = new Date(s.firstPageDay);
    var year = s.getYear(firstDay);
    var month = s.getMonth(firstDay);
    var day = s.getDay(firstDay);
    var weekDay = s.getDate(year, month, day).getDay();
    var offset = firstWeekDay - weekDay > 0 ? 7 : 0;
    var row = [];
    var maxLabels = 0;
    this._rowHeights = [];
    this._rows = [];
    this._days = ARRAY7;
    for (var i = 0; i < 7 * weeks; i++) {
      var curr = s.getDate(year, month, i + firstWeekDay - offset - weekDay + day);
      var key = getDateStr(curr);
      var displayMonth = s.getMonth(curr);
      var outer = displayMonth !== month && s.calendarType !== "week";
      var marked = s.marked && s.marked[key];
      var marks = marked ? s.showSingleMark ? [{}] : marked : null;
      var labels = s.labels && s.labels[key];
      var labelCount = labels ? labels.data.length : 0;
      var isWeekStart = i % 7 === 0;
      if (s.variableRow) {
        if (isWeekStart && outer && i) {
          break;
        }
        if (labelCount > maxLabels) {
          maxLabels = labelCount;
        }
        if (i % 7 === 6) {
          this._rowHeights.push(maxLabels * (s.labelHeight || 20) + (s.cellTextHeight || 0) + 3);
          maxLabels = 0;
        }
      }
      if (isWeekStart) {
        row = [];
        this._rows.push(row);
      }
      row.push({
        colors: s.colors && s.colors[key],
        date: +curr,
        day: s.dayNames[curr.getDay()],
        display: outer ? s.showOuter : true,
        events: s.events && s.events[key],
        labels,
        marks,
        month: s.monthNames[displayMonth],
        monthShort: s.monthNamesShort[displayMonth],
        outer,
        text: s.getDay(curr),
        year: s.getYear(curr)
      });
    }
  };
  MonthViewBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMonthViewBase_BaseFactory;
    return function MonthViewBase_Factory(__ngFactoryType__) {
      return (ɵMonthViewBase_BaseFactory || (ɵMonthViewBase_BaseFactory = ɵɵgetInheritedFactory(MonthViewBase2)))(__ngFactoryType__ || MonthViewBase2);
    };
  })();
  MonthViewBase2.ɵdir = ɵɵdefineDirective({
    type: MonthViewBase2,
    selectors: [["", "mbsc-mv-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return MonthViewBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthViewBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-mv-b]"
    }]
  }], null, null);
})();
var cloudUpload = '<svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24"><path d="M0 0h24v24H0z" fill="none"/><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"/></svg>';
var resizeObservable = new Observable();
var resizeSubscribers = 0;
var resizeTimer;
function onWindowResize() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function() {
    resizeObservable.next();
  }, 100);
}
function subscribeResize(handler) {
  if (!resizeSubscribers) {
    listen(win, RESIZE, onWindowResize);
  }
  resizeSubscribers++;
  return resizeObservable.subscribe(handler);
}
function unsubscribeResize(id2) {
  resizeSubscribers--;
  resizeObservable.unsubscribe(id2);
  if (!resizeSubscribers) {
    unlisten(win, RESIZE, onWindowResize);
  }
}
function checkAutoFill(el2) {
  try {
    return matches(el2, "*:-webkit-autofill");
  } catch (ex) {
    return false;
  }
}
var InputBase = function(_super) {
  __extends(InputBase2, _super);
  function InputBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._tag = "input";
    _this._onClick = function() {
      _this._hidePass = !_this._hidePass;
    };
    _this._onMouseDown = function(ev) {
      if (_this.s.tags) {
        _this._preventFocus = true;
      }
    };
    _this._onTagClear = function(ev, index) {
      ev.stopPropagation();
      ev.preventDefault();
      if (!_this.s.disabled) {
        var value = __spreadArray([], _this.s.pickerValue, true);
        value.splice(index, 1);
        trigger(_this._el, CHANGE, value);
      }
    };
    _this._sizeTextArea = function() {
      var input = _this._el;
      var rowNr = _this.s.rows;
      var lineHeight = 24;
      var height;
      var lineNr;
      var line;
      if (input.offsetHeight) {
        input.style.height = "";
        line = input.scrollHeight - input.offsetHeight;
        height = input.offsetHeight + (line > 0 ? line : 0);
        lineNr = Math.round(height / lineHeight);
        if (lineNr > rowNr) {
          height = lineHeight * rowNr + (height - lineNr * lineHeight);
          input.style.overflow = "auto";
        } else {
          input.style.overflow = "";
        }
        if (height) {
          input.style.height = height + "px";
        }
      }
    };
    _this._onAutoFill = function() {
      if (_this.s.labelStyle === "floating" && checkAutoFill(_this._el)) {
        _this.setState({
          isFloatingActive: true
        });
      }
    };
    return _this;
  }
  InputBase2.prototype._change = function(val) {
  };
  InputBase2.prototype._checkFloating = function() {
    var _this = this;
    var el2 = this._el;
    var s = this.s;
    var isAutoFill = checkAutoFill(el2);
    var isFloatingActive = this.state.hasFocus || isAutoFill || !isEmpty(this.value);
    if (el2 && s.labelStyle === "floating") {
      if (this._tag === "select") {
        var select = el2;
        var firstOption = select.options[0];
        isFloatingActive = !!(isFloatingActive || select.multiple || select.value || select.selectedIndex > -1 && firstOption && firstOption.label);
      } else if (this.value === UNDEFINED) {
        var input = el2;
        isFloatingActive = !!(isFloatingActive || input.value);
      }
      this._valueChecked = true;
      ngSetTimeout(this, function() {
        _this.setState({
          isFloatingActive
        });
      });
    }
  };
  InputBase2.prototype._mounted = function() {
    var _this = this;
    var s = this.s;
    var input = this._el;
    listen(input, ANIMATION_START, this._onAutoFill);
    if (this._tag === "textarea") {
      listen(input, INPUT, this._sizeTextArea);
      this._unsubscribe = subscribeResize(this._sizeTextArea);
    }
    this._unlisten = gestureListener(input, {
      keepFocus: true,
      onBlur: function() {
        _this.setState({
          hasFocus: false,
          isFloatingActive: !!input.value
        });
      },
      onChange: function(ev) {
        if (s.type === "file") {
          var files = ev.target.files;
          var names = [];
          for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
            var file = files_1[_i];
            names.push(file.name);
          }
          _this.setState({
            files: names.join(", ")
          });
        }
        if (s.tags && s.value === UNDEFINED && s.defaultValue === UNDEFINED) {
          _this.setState({
            value: ev.target.value
          });
        }
        _this._checkFloating();
        _this._change(ev.target.value);
        _this._emit("onChange", ev);
      },
      onFocus: function() {
        if (!_this._preventFocus) {
          _this.setState({
            hasFocus: true,
            isFloatingActive: true
          });
        }
        _this._preventFocus = false;
      },
      onHoverIn: function() {
        if (!_this._disabled) {
          _this.setState({
            hasHover: true
          });
        }
      },
      onHoverOut: function() {
        _this.setState({
          hasHover: false
        });
      },
      onInput: function(ev) {
        _this._change(ev.target.value);
      }
    });
  };
  InputBase2.prototype._render = function(s, state) {
    var hasEndIcon = !!(s.endIconSvg || s.endIcon);
    var pickerValue = s.pickerValue;
    var hasStartIcon = !!(s.startIconSvg || s.startIcon);
    var hasLabel = s.label !== UNDEFINED || s.hasChildren;
    var hasError = s.error;
    var iconStartPosition = s.rtl ? "right" : "left";
    var iconEndPosition = s.rtl ? "left" : "right";
    var inputType = s.inputStyle;
    var labelType = s.labelStyle;
    var isFloating = labelType === "floating";
    var isFloatingActive = !!(isFloating && hasLabel && (state.isFloatingActive || !isEmpty(s.value)));
    var disabled = s.disabled === UNDEFINED ? state.disabled : s.disabled;
    var prevS = this._prevS;
    var modelValue = s.modelValue !== UNDEFINED ? s.modelValue : s.value;
    var value = modelValue !== UNDEFINED ? modelValue : state.value !== UNDEFINED ? state.value : s.defaultValue;
    var commonClasses = this._theme + this._rtl + (hasError ? " mbsc-error" : "") + (disabled ? " mbsc-disabled" : "") + (state.hasHover ? " mbsc-hover" : "") + (state.hasFocus && !disabled ? " mbsc-focus" : "");
    if (s.type === "file" && !hasEndIcon) {
      s.endIconSvg = cloudUpload;
      hasEndIcon = true;
    }
    if (s.tags) {
      if (isEmpty(pickerValue)) {
        pickerValue = [];
      }
      if (!isArray(pickerValue)) {
        pickerValue = [pickerValue];
      }
      this._tagsArray = s.pickerMap ? pickerValue.map(function(val) {
        return s.pickerMap.get(val);
      }) : isEmpty(value) ? [] : value.split(", ");
    }
    if (s.passwordToggle) {
      hasEndIcon = true;
      this._passIconClass = commonClasses + " mbsc-toggle-icon" + " mbsc-textfield-icon mbsc-textfield-icon-".concat(inputType, " mbsc-textfield-icon-").concat(iconEndPosition) + " mbsc-textfield-icon-".concat(inputType, "-").concat(iconEndPosition) + (hasLabel ? " mbsc-textfield-icon-".concat(labelType) : "");
      this._hidePass = this._hidePass === UNDEFINED ? s.type === "password" : this._hidePass;
    }
    this._hasStartIcon = hasStartIcon;
    this._hasEndIcon = hasEndIcon;
    this._hasError = hasError;
    this._disabled = disabled;
    this._value = value;
    this._cssClass = this._className + this._hb + commonClasses + " mbsc-form-control-wrapper mbsc-textfield-wrapper mbsc-font" + " mbsc-textfield-wrapper-".concat(inputType) + (disabled ? " mbsc-disabled" : "") + (hasLabel ? " mbsc-textfield-wrapper-".concat(labelType) : "") + (hasStartIcon ? " mbsc-textfield-wrapper-has-icon-".concat(iconStartPosition, " ") : "") + (hasEndIcon ? " mbsc-textfield-wrapper-has-icon-".concat(iconEndPosition, " ") : "");
    if (hasLabel) {
      this._labelClass = commonClasses + " mbsc-label mbsc-label-".concat(labelType, " mbsc-label-").concat(inputType, "-").concat(labelType) + (hasStartIcon ? " mbsc-label-".concat(inputType, "-").concat(labelType, "-has-icon-").concat(iconStartPosition, " ") : "") + (hasEndIcon ? " mbsc-label-".concat(inputType, "-").concat(labelType, "-has-icon-").concat(iconEndPosition, " ") : "") + (isFloating && this._animateFloating ? " mbsc-label-floating-animate" : "") + (isFloatingActive ? " mbsc-label-floating-active" : "");
    }
    this._innerClass = commonClasses + " mbsc-textfield-inner mbsc-textfield-inner-".concat(inputType) + (hasLabel ? " mbsc-textfield-inner-".concat(labelType) : "");
    if (hasStartIcon) {
      this._startIconClass = commonClasses + " mbsc-textfield-icon mbsc-textfield-icon-".concat(inputType, " mbsc-textfield-icon-").concat(iconStartPosition) + " mbsc-textfield-icon-".concat(inputType, "-").concat(iconStartPosition) + (hasLabel ? " mbsc-textfield-icon-".concat(labelType) : "");
    }
    if (hasEndIcon) {
      this._endIconClass = commonClasses + " mbsc-textfield-icon mbsc-textfield-icon-".concat(inputType, " mbsc-textfield-icon-").concat(iconEndPosition) + " mbsc-textfield-icon-".concat(inputType, "-").concat(iconEndPosition) + (hasLabel ? " mbsc-textfield-icon-".concat(labelType) : "");
    }
    this._nativeElmClass = commonClasses + " " + (s.inputClass || "") + " mbsc-textfield mbsc-textfield-".concat(inputType) + (s.dropdown ? " mbsc-select" : "") + (hasLabel ? " mbsc-textfield-".concat(labelType, " mbsc-textfield-").concat(inputType, "-").concat(labelType) : "") + (isFloatingActive ? " mbsc-textfield-floating-active" : "") + (hasStartIcon ? " mbsc-textfield-has-icon-".concat(iconStartPosition, " mbsc-textfield-").concat(inputType, "-has-icon-").concat(iconStartPosition) + (hasLabel ? " mbsc-textfield-".concat(inputType, "-").concat(labelType, "-has-icon-").concat(iconStartPosition) : "") : "") + (hasEndIcon ? " mbsc-textfield-has-icon-".concat(iconEndPosition, " mbsc-textfield-").concat(inputType, "-has-icon-").concat(iconEndPosition) + (hasLabel ? " mbsc-textfield-".concat(inputType, "-").concat(labelType, "-has-icon-").concat(iconEndPosition) : "") : "");
    if (this._tag === "select" || s.dropdown) {
      this._selectIconClass = "mbsc-select-icon mbsc-select-icon-".concat(inputType) + this._rtl + this._theme + (hasLabel ? " mbsc-select-icon-".concat(labelType) : "") + (hasStartIcon ? " mbsc-select-icon-".concat(iconStartPosition) : "") + (hasEndIcon ? " mbsc-select-icon-".concat(iconEndPosition) : "");
    }
    if (this._tag === "textarea" || s.tags) {
      this._cssClass += " mbsc-textarea-wrapper";
      this._innerClass += " mbsc-textarea-inner";
      this._nativeElmClass += " mbsc-textarea";
      if (this._tag === "textarea" && (value !== this._prevValue || s.inputStyle !== prevS.inputStyle || s.labelStyle !== prevS.labelStyle || s.rows !== prevS.rows || s.theme !== prevS.theme)) {
        this._shouldSize = true;
      }
      this._prevValue = value;
    }
    if (s.tags) {
      this._innerClass += " mbsc-textfield-tags-inner";
    }
    if (s.type === "file") {
      this._dummyElmClass = this._nativeElmClass;
      this._nativeElmClass += " mbsc-textfield-file";
    }
    this._errorClass = this._theme + this._rtl + " mbsc-error-message mbsc-error-message-".concat(inputType) + (hasLabel ? " mbsc-error-message-".concat(labelType) : "") + (hasStartIcon ? " mbsc-error-message-has-icon-".concat(iconStartPosition) : "") + (hasEndIcon ? " mbsc-error-message-has-icon-".concat(iconEndPosition) : "");
    if (s.notch && inputType === "outline") {
      this._fieldSetClass = "mbsc-textfield-fieldset" + commonClasses + (hasStartIcon ? " mbsc-textfield-fieldset-has-icon-".concat(iconStartPosition) : "") + (hasEndIcon ? " mbsc-textfield-fieldset-has-icon-".concat(iconEndPosition) : "");
      this._legendClass = "mbsc-textfield-legend" + this._theme + (isFloatingActive || hasLabel && labelType === "stacked" ? " mbsc-textfield-legend-active" : "");
    }
    if (s.ripple && s.inputStyle !== "outline") {
      this._rippleClass = "mbsc-textfield-ripple" + this._theme + (hasError ? " mbsc-error" : "") + (state.hasFocus ? " mbsc-textfield-ripple-active" : "");
    }
    if (this._valueChecked) {
      this._animateFloating = true;
    }
  };
  InputBase2.prototype._updated = function() {
    var _this = this;
    if (this._shouldSize) {
      this._shouldSize = false;
      ngSetTimeout(this, function() {
        _this._sizeTextArea();
      });
    }
    this._checkFloating();
  };
  InputBase2.prototype._destroy = function() {
    unlisten(this._el, ANIMATION_START, this._onAutoFill);
    unlisten(this._el, INPUT, this._sizeTextArea);
    if (this._unsubscribe) {
      unsubscribeResize(this._unsubscribe);
    }
    if (this._unlisten) {
      this._unlisten();
    }
  };
  InputBase2.defaults = {
    dropdown: false,
    dropdownIcon: arrowDown$1,
    hideIcon: "eye-blocked",
    inputStyle: "underline",
    labelStyle: "stacked",
    placeholder: "",
    ripple: false,
    rows: 6,
    showIcon: "eye",
    type: "text"
  };
  InputBase2._name = "Input";
  InputBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵInputBase_BaseFactory;
    return function InputBase_Factory(__ngFactoryType__) {
      return (ɵInputBase_BaseFactory || (ɵInputBase_BaseFactory = ɵɵgetInheritedFactory(InputBase2)))(__ngFactoryType__ || InputBase2);
    };
  })();
  InputBase2.ɵdir = ɵɵdefineDirective({
    type: InputBase2,
    selectors: [["", "mbsc-inp-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return InputBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-inp-b]"
    }]
  }], null, null);
})();
function FormControl(constructor) {
  var prototype = constructor.prototype;
  prototype.registerOnChange = function(fn) {
    this._onFormChange = fn;
  };
  prototype.registerOnTouched = function(fn) {
    this._onFormTouch = fn;
  };
  prototype.setDisabledState = function(disabled) {
    this.setState({
      disabled
    });
  };
  prototype.writeValue = function(val) {
    updateValue(this, val);
  };
}
var guid$6 = 0;
var MbscInput = function(_super) {
  __extends(MbscInput2, _super);
  function MbscInput2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onChange = new EventEmitter();
    _this._id = "mbsc-textfield-" + guid$6++;
    return _this;
  }
  MbscInput2.prototype._onIconClick = function() {
    this.vLbl.nativeElement.click();
  };
  MbscInput2.prototype._triggerEvent = function(ev) {
    if (this.s.tags && ev.target !== this._el) {
      trigger(this._el, ev.type);
    }
  };
  MbscInput2.prototype._onValueChange = function() {
    this._checkFloating();
  };
  MbscInput2.prototype._mounted = function() {
    this._el = this.vInput.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscInput2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscInput_BaseFactory;
    return function MbscInput_Factory(__ngFactoryType__) {
      return (ɵMbscInput_BaseFactory || (ɵMbscInput_BaseFactory = ɵɵgetInheritedFactory(MbscInput2)))(__ngFactoryType__ || MbscInput2);
    };
  })();
  MbscInput2.ɵcmp = ɵɵdefineComponent({
    type: MbscInput2,
    selectors: [["mbsc-input"]],
    viewQuery: function MbscInput_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
        ɵɵviewQuery(_c4, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vLbl = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscInput_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      ariaExpanded: "ariaExpanded",
      ariaHaspopup: "ariaHaspopup",
      ariaLabel: "ariaLabel",
      accept: "accept",
      autocapitalize: "autocapitalize",
      autocomplete: "autocomplete",
      autocorrect: "autocorrect",
      autofocus: "autofocus",
      disabled: "disabled",
      dropdown: "dropdown",
      endIcon: "endIcon",
      endIconSrc: "endIconSrc",
      endIconSvg: "endIconSvg",
      error: "error",
      errorMessage: "errorMessage",
      hideIcon: "hideIcon",
      hideIconSvg: "hideIconSvg",
      id: "id",
      inputClass: "inputClass",
      inputStyle: "inputStyle",
      label: "label",
      labelStyle: "labelStyle",
      max: "max",
      maxlength: "maxlength",
      min: "min",
      minlength: "minlength",
      multiple: "multiple",
      name: "name",
      passwordToggle: "passwordToggle",
      pattern: "pattern",
      pickerMap: "pickerMap",
      pickerValue: "pickerValue",
      placeholder: "placeholder",
      readonly: "readonly",
      required: "required",
      ripple: "ripple",
      role: "role",
      rows: "rows",
      showIcon: "showIcon",
      showIconSvg: "showIconSvg",
      spellcheck: "spellcheck",
      startIcon: "startIcon",
      startIconSrc: "startIconSrc",
      startIconSvg: "startIconSvg",
      step: "step",
      tags: "tags",
      type: "type"
    },
    outputs: {
      onChange: "onChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c6,
    decls: 16,
    vars: 42,
    consts: [["lbl", ""], ["input", ""], [3, "for"], [3, "click", "keydown"], [3, "ngModelChange", "blur", "ngModel", "disabled", "id", "placeholder", "readonly", "type"], ["type", "text", 3, "class", "disabled", "placeholder", "readonly", "value", 4, "ngIf"], [3, "class", 4, "ngIf"], [3, "class", "svg", "theme", 4, "ngIf"], [3, "class", "name", "svg", "theme", "click", 4, "ngIf"], ["aria-hidden", "true", 3, "class", 4, "ngIf"], ["type", "text", 3, "disabled", "placeholder", "readonly", "value"], [4, "ngFor", "ngForOf"], [1, "mbsc-textfield-tag-clear", 3, "click", "svg", "theme"], [3, "svg", "theme"], [3, "click", "name", "svg", "theme"], ["aria-hidden", "true"]],
    template: function MbscInput_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c5);
        ɵɵelementStart(0, "label", 2, 0);
        ɵɵtext(2);
        ɵɵprojection(3);
        ɵɵelementEnd();
        ɵɵelementStart(4, "span", 3);
        ɵɵlistener("click", function MbscInput_Template_span_click_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._triggerEvent($event));
        })("keydown", function MbscInput_Template_span_keydown_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._triggerEvent($event));
        });
        ɵɵelementStart(5, "input", 4, 1);
        ɵɵtwoWayListener("ngModelChange", function MbscInput_Template_input_ngModelChange_5_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx2.value, $event) || (ctx2.value = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("blur", function MbscInput_Template_input_blur_5_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onFormTouch($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(7, MbscInput_input_7_Template, 1, 6, "input", 5)(8, MbscInput_span_8_Template, 3, 4, "span", 6)(9, MbscInput_mbsc_icon_9_Template, 1, 4, "mbsc-icon", 7)(10, MbscInput_mbsc_icon_10_Template, 1, 5, "mbsc-icon", 8)(11, MbscInput_mbsc_icon_11_Template, 1, 5, "mbsc-icon", 8)(12, MbscInput_mbsc_icon_12_Template, 1, 5, "mbsc-icon", 8)(13, MbscInput_span_13_Template, 2, 3, "span", 6)(14, MbscInput_fieldset_14_Template, 3, 5, "fieldset", 9)(15, MbscInput_span_15_Template, 1, 2, "span", 6);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._labelClass);
        ɵɵproperty("for", ctx2._id);
        ɵɵadvance(2);
        ɵɵtextInterpolate1(" ", ctx2.s.label, " ");
        ɵɵadvance(2);
        ɵɵclassMap(ctx2._innerClass);
        ɵɵadvance();
        ɵɵclassMap(ctx2._nativeElmClass + (ctx2.s.tags ? " mbsc-textfield-hidden" : ""));
        ɵɵtwoWayProperty("ngModel", ctx2.value);
        ɵɵproperty("disabled", ctx2._disabled)("id", ctx2.id || ctx2._id)("placeholder", ctx2.s.placeholder)("readonly", ctx2.readonly)("type", ctx2.s.passwordToggle ? ctx2._hidePass ? "password" : "text" : ctx2.s.type);
        ɵɵattribute("accept", ctx2.accept)("aria-expanded", ctx2.ariaExpanded)("aria-haspopup", ctx2.ariaHaspopup)("aria-label", ctx2.ariaLabel)("autocapitalize", ctx2.autocapitalize)("autocomplete", ctx2.autocomplete)("autocorrect", ctx2.autocorrect)("autofocus", ctx2.autofocus)("max", ctx2.max)("maxlength", ctx2.maxlength)("min", ctx2.min)("minlength", ctx2.minlength)("multiple", ctx2.multiple)("name", ctx2.name)("pattern", ctx2.pattern)("required", ctx2.required)("role", ctx2.role)("spellcheck", ctx2.spellcheck)("step", ctx2.step);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2.s.type === "file");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.tags);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.dropdown);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasStartIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasEndIcon && !ctx2.s.passwordToggle);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.passwordToggle);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasError);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.notch && ctx2.s.inputStyle === "outline");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.ripple && ctx2.s.inputStyle !== "outline");
      }
    },
    dependencies: [MbscIcon, DefaultValueAccessor, NgControlStatus, NgModel, MaxLengthValidator, MinLengthValidator, PatternValidator, RequiredValidator, NgIf, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  MbscInput2 = __decorate([FormControl], MbscInput2);
  return MbscInput2;
}(InputBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscInput, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-input",
      template: `
    <label #lbl [for]="_id" [class]="_labelClass">
      {{ s.label }}
      <ng-content select="[mbsc-label]"></ng-content>
    </label>
    <span [class]="_innerClass" (click)="_triggerEvent($event)" (keydown)="_triggerEvent($event)">
      <input
        #input
        [(ngModel)]="value"
        (blur)="_onFormTouch($event)"
        [attr.accept]="accept"
        [attr.aria-expanded]="ariaExpanded"
        [attr.aria-haspopup]="ariaHaspopup"
        [attr.aria-label]="ariaLabel"
        [attr.autocapitalize]="autocapitalize"
        [attr.autocomplete]="autocomplete"
        [attr.autocorrect]="autocorrect"
        [attr.autofocus]="autofocus"
        [attr.max]="max"
        [attr.maxlength]="maxlength"
        [attr.min]="min"
        [attr.minlength]="minlength"
        [attr.multiple]="multiple"
        [attr.name]="name"
        [attr.pattern]="pattern"
        [attr.required]="required"
        [attr.role]="role"
        [attr.spellcheck]="spellcheck"
        [attr.step]="step"
        [class]="_nativeElmClass + (s.tags ? ' mbsc-textfield-hidden' : '')"
        [disabled]="_disabled"
        [id]="id || _id"
        [placeholder]="s.placeholder"
        [readonly]="readonly"
        [type]="s.passwordToggle ? (_hidePass ? 'password' : 'text') : s.type"
      />
      <input
        *ngIf="s.type === 'file'"
        [class]="_dummyElmClass"
        [disabled]="_disabled"
        [placeholder]="s.placeholder"
        [readonly]="true"
        type="text"
        [value]="state.files || ''"
      />
      <span *ngIf="tags" [class]="'mbsc-textfield-tags' + _nativeElmClass">
        <ng-container *ngFor="let v of _tagsArray; let i = index">
          <span *ngIf="v" [class]="'mbsc-textfield-tag' + _theme + _rtl">
            <span [class]="'mbsc-textfield-tag-text' + _theme">{{ v }}</span>
            <mbsc-icon class="mbsc-textfield-tag-clear" (click)="_onTagClear($event, i)" [svg]="s.clearIcon" [theme]="s.theme"></mbsc-icon>
          </span>
        </ng-container>
        <span *ngIf="!_tagsArray!.length" [class]="'mbsc-textfield-tags-placeholder' + _theme">{{ s.placeholder }}</span>
      </span>
      <mbsc-icon *ngIf="s.dropdown" [class]="_selectIconClass" [svg]="s.dropdownIcon" [theme]="s.theme"></mbsc-icon>
      <mbsc-icon
        *ngIf="_hasStartIcon"
        [class]="_startIconClass"
        [name]="s.startIcon"
        [svg]="s.startIconSvg"
        [theme]="s.theme"
        (click)="_onIconClick()"
      ></mbsc-icon>
      <mbsc-icon
        *ngIf="_hasEndIcon && !s.passwordToggle"
        [class]="_endIconClass"
        [name]="s.endIcon"
        [svg]="s.endIconSvg"
        [theme]="s.theme"
        (click)="_onIconClick()"
      >
      </mbsc-icon>
      <mbsc-icon
        *ngIf="s.passwordToggle"
        (click)="_onClick()"
        [class]="_passIconClass"
        [name]="_hidePass ? s.showIcon : s.hideIcon"
        [svg]="_hidePass ? s.showIconSvg : s.hideIconSvg"
        [theme]="s.theme"
      >
      </mbsc-icon>
      <span *ngIf="_hasError" [class]="_errorClass">{{ s.errorMessage }}</span>
      <fieldset *ngIf="s.notch && s.inputStyle === 'outline'" aria-hidden="true" [class]="_fieldSetClass">
        <legend [class]="_legendClass">{{ s.label && s.labelStyle !== 'inline' ? s.label : '&nbsp;' }}</legend>
      </fieldset>
      <span *ngIf="s.ripple && s.inputStyle !== 'outline'" [class]="_rippleClass"></span>
    </span>
  `
    }]
  }], null, {
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    vLbl: [{
      type: ViewChild,
      args: ["lbl", {
        static: false
      }]
    }],
    ariaExpanded: [{
      type: Input
    }],
    ariaHaspopup: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    accept: [{
      type: Input
    }],
    autocapitalize: [{
      type: Input
    }],
    autocomplete: [{
      type: Input
    }],
    autocorrect: [{
      type: Input
    }],
    autofocus: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    dropdown: [{
      type: Input
    }],
    endIcon: [{
      type: Input
    }],
    endIconSrc: [{
      type: Input
    }],
    endIconSvg: [{
      type: Input
    }],
    error: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    hideIcon: [{
      type: Input
    }],
    hideIconSvg: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    inputClass: [{
      type: Input
    }],
    inputStyle: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    labelStyle: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    maxlength: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minlength: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    passwordToggle: [{
      type: Input
    }],
    pattern: [{
      type: Input
    }],
    pickerMap: [{
      type: Input
    }],
    pickerValue: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    ripple: [{
      type: Input
    }],
    role: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    showIcon: [{
      type: Input
    }],
    showIconSvg: [{
      type: Input
    }],
    spellcheck: [{
      type: Input
    }],
    startIcon: [{
      type: Input
    }],
    startIconSrc: [{
      type: Input
    }],
    startIconSvg: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    tags: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    onChange: [{
      type: Output
    }]
  });
})();
var MbscDropdown = function(_super) {
  __extends(MbscDropdown2, _super);
  function MbscDropdown2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._tag = "select";
    return _this;
  }
  MbscDropdown2._name = "Dropdown";
  MbscDropdown2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDropdown_BaseFactory;
    return function MbscDropdown_Factory(__ngFactoryType__) {
      return (ɵMbscDropdown_BaseFactory || (ɵMbscDropdown_BaseFactory = ɵɵgetInheritedFactory(MbscDropdown2)))(__ngFactoryType__ || MbscDropdown2);
    };
  })();
  MbscDropdown2.ɵcmp = ɵɵdefineComponent({
    type: MbscDropdown2,
    selectors: [["mbsc-dropdown"]],
    hostVars: 2,
    hostBindings: function MbscDropdown_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c8,
    decls: 13,
    vars: 24,
    consts: [["input", ""], [3, "for"], [3, "blur", "change", "disabled", "id", "value"], [3, "svg", "theme"], [3, "class", "name", "svg", "theme", "click", 4, "ngIf"], [3, "class", 4, "ngIf"], ["aria-hidden", "true", 3, "class", 4, "ngIf"], [3, "click", "name", "svg", "theme"], ["aria-hidden", "true"]],
    template: function MbscDropdown_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c7);
        ɵɵelementStart(0, "label", 1);
        ɵɵtext(1);
        ɵɵprojection(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "span")(4, "select", 2, 0);
        ɵɵlistener("blur", function MbscDropdown_Template_select_blur_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onFormTouch($event));
        })("change", function MbscDropdown_Template_select_change_4_listener() {
          ɵɵrestoreView(_r1);
          const input_r2 = ɵɵreference(5);
          return ɵɵresetView(ctx2.value = input_r2.value);
        });
        ɵɵprojection(6, 1);
        ɵɵelementEnd();
        ɵɵelement(7, "mbsc-icon", 3);
        ɵɵtemplate(8, MbscDropdown_mbsc_icon_8_Template, 1, 5, "mbsc-icon", 4)(9, MbscDropdown_mbsc_icon_9_Template, 1, 5, "mbsc-icon", 4)(10, MbscDropdown_span_10_Template, 2, 3, "span", 5)(11, MbscDropdown_fieldset_11_Template, 3, 5, "fieldset", 6)(12, MbscDropdown_span_12_Template, 1, 2, "span", 5);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._labelClass);
        ɵɵproperty("for", ctx2._id);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx2.s.label, " ");
        ɵɵadvance(2);
        ɵɵclassMap(ctx2._innerClass);
        ɵɵadvance();
        ɵɵclassMap("mbsc-select " + ctx2._nativeElmClass);
        ɵɵproperty("disabled", ctx2._disabled)("id", ctx2.id || ctx2._id)("value", ctx2.value);
        ɵɵattribute("autofocus", ctx2.autofocus)("multiple", ctx2.multiple)("name", ctx2.name)("required", ctx2.required);
        ɵɵadvance(3);
        ɵɵclassMap(ctx2._selectIconClass);
        ɵɵproperty("svg", ctx2.s.dropdownIcon)("theme", ctx2.s.theme);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasStartIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasEndIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasError);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.notch && ctx2.s.inputStyle === "outline");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.ripple && ctx2.s.inputStyle !== "outline");
      }
    },
    dependencies: [MbscIcon, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscDropdown2;
}(MbscInput);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDropdown, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-dropdown",
      template: `
    <label [for]="_id" [class]="_labelClass">
      {{ s.label }}
      <ng-content select="[mbsc-label]"></ng-content>
    </label>
    <span [class]="_innerClass">
      <select
        #input
        (blur)="_onFormTouch($event)"
        (change)="value = input.value"
        [attr.autofocus]="autofocus"
        [attr.multiple]="multiple"
        [attr.name]="name"
        [attr.required]="required"
        [class]="'mbsc-select ' + _nativeElmClass"
        [disabled]="_disabled"
        [id]="id || _id"
        [value]="value"
      >
        <ng-content></ng-content>
      </select>
      <mbsc-icon [class]="_selectIconClass" [svg]="s.dropdownIcon" [theme]="s.theme"></mbsc-icon>
      <mbsc-icon
        *ngIf="_hasStartIcon"
        [class]="_startIconClass"
        [name]="s.startIcon"
        [svg]="s.startIconSvg"
        [theme]="s.theme"
        (click)="_onIconClick()"
      ></mbsc-icon>
      <mbsc-icon
        *ngIf="_hasEndIcon"
        [class]="_endIconClass"
        [name]="s.endIcon"
        [svg]="s.endIconSvg"
        [theme]="s.theme"
        (click)="_onIconClick()"
      ></mbsc-icon>
      <span *ngIf="_hasError" [class]="_errorClass">{{ s.errorMessage }}</span>
      <fieldset *ngIf="s.notch && s.inputStyle === 'outline'" aria-hidden="true" [class]="_fieldSetClass">
        <legend [class]="_legendClass">{{ s.label && s.labelStyle !== 'inline' ? s.label : '&nbsp;' }}</legend>
      </fieldset>
      <span *ngIf="s.ripple && s.inputStyle !== 'outline'" [class]="_rippleClass"></span>
    </span>
  `
    }]
  }], null, null);
})();
var MbscTextarea = function(_super) {
  __extends(MbscTextarea2, _super);
  function MbscTextarea2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._tag = "textarea";
    return _this;
  }
  MbscTextarea2._name = "Textarea";
  MbscTextarea2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscTextarea_BaseFactory;
    return function MbscTextarea_Factory(__ngFactoryType__) {
      return (ɵMbscTextarea_BaseFactory || (ɵMbscTextarea_BaseFactory = ɵɵgetInheritedFactory(MbscTextarea2)))(__ngFactoryType__ || MbscTextarea2);
    };
  })();
  MbscTextarea2.ɵcmp = ɵɵdefineComponent({
    type: MbscTextarea2,
    selectors: [["mbsc-textarea"]],
    hostVars: 2,
    hostBindings: function MbscTextarea_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c6,
    decls: 11,
    vars: 30,
    consts: [["input", ""], [3, "for"], [3, "ngModelChange", "blur", "ngModel", "disabled", "id", "readonly", "placeholder"], [3, "class", "name", "svg", "theme", "click", 4, "ngIf"], [3, "class", 4, "ngIf"], ["aria-hidden", "true", 3, "class", 4, "ngIf"], [3, "click", "name", "svg", "theme"], ["aria-hidden", "true"]],
    template: function MbscTextarea_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef(_c5);
        ɵɵelementStart(0, "label", 1);
        ɵɵtext(1);
        ɵɵprojection(2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "span")(4, "textarea", 2, 0);
        ɵɵtwoWayListener("ngModelChange", function MbscTextarea_Template_textarea_ngModelChange_4_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx2.value, $event) || (ctx2.value = $event);
          return ɵɵresetView($event);
        });
        ɵɵlistener("blur", function MbscTextarea_Template_textarea_blur_4_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onFormTouch($event));
        });
        ɵɵelementEnd();
        ɵɵtemplate(6, MbscTextarea_mbsc_icon_6_Template, 1, 5, "mbsc-icon", 3)(7, MbscTextarea_mbsc_icon_7_Template, 1, 5, "mbsc-icon", 3)(8, MbscTextarea_span_8_Template, 2, 3, "span", 4)(9, MbscTextarea_fieldset_9_Template, 3, 5, "fieldset", 5)(10, MbscTextarea_span_10_Template, 1, 2, "span", 4);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._labelClass);
        ɵɵproperty("for", ctx2._id);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx2.s.label, " ");
        ɵɵadvance(2);
        ɵɵclassMap(ctx2._innerClass);
        ɵɵadvance();
        ɵɵclassMap(ctx2._nativeElmClass);
        ɵɵtwoWayProperty("ngModel", ctx2.value);
        ɵɵproperty("disabled", ctx2._disabled)("id", ctx2.id || ctx2._id)("readonly", ctx2.readonly)("placeholder", ctx2.s.placeholder);
        ɵɵattribute("accept", ctx2.accept)("autocapitalize", ctx2.autocapitalize)("autocomplete", ctx2.autocomplete)("autocorrect", ctx2.autocorrect)("autofocus", ctx2.autofocus)("maxlength", ctx2.maxlength)("minlength", ctx2.minlength)("name", ctx2.name)("pattern", ctx2.pattern)("required", ctx2.required)("rows", ctx2.rows)("spellcheck", ctx2.spellcheck);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._hasStartIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasEndIcon);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasError);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.notch && ctx2.s.inputStyle === "outline");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.ripple && ctx2.s.inputStyle !== "outline");
      }
    },
    dependencies: [MbscIcon, DefaultValueAccessor, NgControlStatus, NgModel, MaxLengthValidator, MinLengthValidator, PatternValidator, RequiredValidator, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscTextarea2;
}(MbscInput);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscTextarea, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-textarea",
      template: `
    <label [for]="_id" [class]="_labelClass">
      {{ s.label }}
      <ng-content select="[mbsc-label]"></ng-content>
    </label>
    <span [class]="_innerClass">
      <textarea
        #input
        [(ngModel)]="value"
        (blur)="_onFormTouch($event)"
        [attr.accept]="accept"
        [attr.autocapitalize]="autocapitalize"
        [attr.autocomplete]="autocomplete"
        [attr.autocorrect]="autocorrect"
        [attr.autofocus]="autofocus"
        [attr.maxlength]="maxlength"
        [attr.minlength]="minlength"
        [attr.name]="name"
        [attr.pattern]="pattern"
        [attr.required]="required"
        [attr.rows]="rows"
        [attr.spellcheck]="spellcheck"
        [class]="_nativeElmClass"
        [disabled]="_disabled"
        [id]="id || _id"
        [readonly]="readonly"
        [placeholder]="s.placeholder"
      ></textarea>
      <mbsc-icon
        *ngIf="_hasStartIcon"
        [class]="_startIconClass"
        [name]="s.startIcon"
        [svg]="s.startIconSvg"
        [theme]="s.theme"
        (click)="_onIconClick()"
      ></mbsc-icon>
      <mbsc-icon
        *ngIf="_hasEndIcon"
        [class]="_endIconClass"
        [name]="s.endIcon"
        [svg]="s.endIconSvg"
        [theme]="s.theme"
        (click)="_onIconClick()"
      ></mbsc-icon>
      <span *ngIf="_hasError" [class]="_errorClass">{{ s.errorMessage }}</span>
      <fieldset *ngIf="s.notch && s.inputStyle === 'outline'" aria-hidden="true" [class]="_fieldSetClass">
        <legend [class]="_legendClass">{{ s.label && s.labelStyle !== 'inline' ? s.label : '&nbsp;' }}</legend>
      </fieldset>
      <span *ngIf="s.ripple && s.inputStyle !== 'outline'" [class]="_rippleClass"></span>
    </span>
  `
    }]
  }], null, null);
})();
var MbscInputModule = function() {
  function MbscInputModule2() {
  }
  MbscInputModule2.ɵfac = function MbscInputModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscInputModule2)();
  };
  MbscInputModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscInputModule2,
    declarations: [InputBase, MbscDropdown, MbscInput, MbscTextarea],
    imports: [CommonModule, FormsModule, MbscIconModule],
    exports: [MbscDropdown, MbscInput, MbscTextarea]
  });
  MbscInputModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, FormsModule, MbscIconModule]]
  });
  return MbscInputModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscInputModule, [{
    type: NgModule,
    args: [{
      declarations: [InputBase, MbscDropdown, MbscInput, MbscTextarea],
      exports: [MbscDropdown, MbscInput, MbscTextarea],
      imports: [CommonModule, FormsModule, MbscIconModule]
    }]
  }], null, null);
})();
var MbscPopup = function(_super) {
  __extends(MbscPopup2, _super);
  function MbscPopup2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onButtonClick = new EventEmitter();
    _this.onOverlayClick = new EventEmitter();
    _this.onClose = new EventEmitter();
    _this.onClosed = new EventEmitter();
    _this.onKeyDown = new EventEmitter();
    _this.onOpen = new EventEmitter();
    _this.onPosition = new EventEmitter();
    _this.onResize = new EventEmitter();
    return _this;
  }
  MbscPopup2.prototype._updated = function() {
    var justOpened = this._justOpened;
    if (justOpened) {
      this._active = this.vActive.nativeElement;
      this._content = this.vContent.nativeElement;
      this._limitator = this.vLimit.nativeElement;
      this._wrapper = this.vWrapper.nativeElement;
      this._popup = this.vPopup.nativeElement;
    }
    _super.prototype._updated.call(this);
    if (justOpened && this._ctx && !this._ph) {
      var wrapper = this._wrapper;
      var doc2 = getDocument(wrapper);
      this._ph = doc2.createComment("mbsc-popup");
      wrapper.parentNode.insertBefore(this._ph, wrapper);
      this._ctx.appendChild(wrapper);
    }
  };
  MbscPopup2.prototype._onClosed = function() {
    this._ph.parentNode.replaceChild(this._wrapper, this._ph);
    this._ph = null;
    _super.prototype._onClosed.call(this);
  };
  MbscPopup2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscPopup_BaseFactory;
    return function MbscPopup_Factory(__ngFactoryType__) {
      return (ɵMbscPopup_BaseFactory || (ɵMbscPopup_BaseFactory = ɵɵgetInheritedFactory(MbscPopup2)))(__ngFactoryType__ || MbscPopup2);
    };
  })();
  MbscPopup2.ɵcmp = ɵɵdefineComponent({
    type: MbscPopup2,
    selectors: [["mbsc-popup"]],
    viewQuery: function MbscPopup_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c9, 5);
        ɵɵviewQuery(_c10, 5);
        ɵɵviewQuery(_c11, 5);
        ɵɵviewQuery(_c12, 5);
        ɵɵviewQuery(_c13, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vActive = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vContent = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vLimit = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vWrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vPopup = _t.first);
      }
    },
    inputs: {
      activeElm: "activeElm",
      anchor: "anchor",
      anchorAlign: "anchorAlign",
      animation: "animation",
      ariaLabel: "ariaLabel",
      buttons: "buttons",
      buttonVariant: "buttonVariant",
      closeOnEsc: "closeOnEsc",
      closeOnOverlayClick: "closeOnOverlayClick",
      closeOnScroll: "closeOnScroll",
      contentPadding: "contentPadding",
      cssClass: "cssClass",
      disableLeftRight: "disableLeftRight",
      display: "display",
      focusElm: "focusElm",
      focusOnClose: "focusOnClose",
      focusOnOpen: "focusOnOpen",
      focusTrap: "focusTrap",
      fullScreen: "fullScreen",
      headerText: "headerText",
      height: "height",
      isOpen: "isOpen",
      maxHeight: "maxHeight",
      maxWidth: "maxWidth",
      scrollLock: "scrollLock",
      setActive: "setActive",
      showArrow: "showArrow",
      showOverlay: "showOverlay",
      windowWidth: "windowWidth",
      width: "width",
      cancelText: "cancelText",
      closeText: "closeText",
      okText: "okText",
      setText: "setText"
    },
    outputs: {
      onButtonClick: "onButtonClick",
      onOverlayClick: "onOverlayClick",
      onClose: "onClose",
      onClosed: "onClosed",
      onKeyDown: "onKeyDown",
      onOpen: "onOpen",
      onPosition: "onPosition",
      onResize: "onResize"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 4,
    vars: 2,
    consts: [["ngcontent", ""], ["wrapper", ""], ["limit", ""], ["popup", ""], ["active", ""], ["content", ""], [4, "ngIf"], [3, "ngTemplateOutlet", 4, "ngIf"], [3, "keydown"], [3, "class", "click", 4, "ngIf"], [3, "ngStyle"], ["role", "dialog", "aria-modal", "true", 3, "animationend", "click", "ngStyle"], [3, "class", 4, "ngIf"], ["tabindex", "-1", 1, "mbsc-popup-focus"], [3, "class", "innerHTML", 4, "ngIf"], [3, "ngTemplateOutlet"], [3, "click"], [3, "innerHTML"], [3, "color", "class", "disabled", "icon", "theme", "themeVariant", "variant", "click", 4, "ngFor", "ngForOf"], [3, "click", "color", "disabled", "icon", "theme", "themeVariant", "variant"]],
    template: function MbscPopup_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, MbscPopup_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, MbscPopup_ng_container_2_Template, 17, 18, "ng-container", 6)(3, MbscPopup_ng_container_3_Template, 1, 1, "ng-container", 7);
      }
      if (rf & 2) {
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._isModal && ctx2._isVisible);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2._isModal);
      }
    },
    dependencies: [MbscButton, NgIf, NgStyle, NgTemplateOutlet, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscPopup2;
}(PopupBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscPopup, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-popup",
      template: `
    <ng-template #ngcontent>
      <ng-container *ngIf="_isVisible || !_isModal">
        <ng-content></ng-content>
      </ng-container>
    </ng-template>
    <ng-container *ngIf="_isModal && _isVisible">
      <div
        [class]="
          'mbsc-font mbsc-flex mbsc-popup-wrapper mbsc-popup-wrapper-' +
          s.display +
          _theme +
          _rtl +
          ' ' +
          _className +
          (s.fullScreen ? ' mbsc-popup-wrapper-' + s.display + '-full' : '') +
          (_touchUi ? '' : ' mbsc-popup-pointer') +
          (_round ? ' mbsc-popup-round' : '') +
          (_hasContext ? ' mbsc-popup-wrapper-ctx' : '') +
          (state.isReady ? '' : ' mbsc-popup-hidden')
        "
        (keydown)="_onKeyDown($event)"
        #wrapper
      >
        <div
          *ngIf="s.showOverlay"
          (click)="_onOverlayClick()"
          [class]="
            'mbsc-popup-overlay mbsc-popup-overlay-' +
            s.display +
            _theme +
            (_isClosing ? ' mbsc-popup-overlay-out' : '') +
            (_isOpening && state.isReady ? ' mbsc-popup-overlay-in' : '')
          "
        ></div>
        <div #limit [class]="'mbsc-popup-limits mbsc-popup-limits-' + s.display" [ngStyle]="_limits"></div>
        <div
          #popup
          [attr.aria-label]="ariaLabel"
          [class]="
            'mbsc-flex-col mbsc-popup mbsc-popup-' +
            s.display +
            (s.fullScreen ? '-full' : '') +
            _theme +
            _hb +
            (state.bubblePos && state.showArrow && s.display === 'anchored' ? ' mbsc-popup-anchored-' + state.bubblePos : '') +
            (_isClosing ? ' mbsc-popup-' + _animation + '-out' : '') +
            (_isOpening && state.isReady ? ' mbsc-popup-' + _animation + '-in' : '')
          "
          [ngStyle]="_style"
          (animationend)="_onAnimationEnd($event)"
          (click)="_onPopupClick()"
          role="dialog"
          aria-modal="true"
        >
          <div
            *ngIf="s.display === 'anchored' && state.showArrow"
            [class]="'mbsc-popup-arrow-wrapper mbsc-popup-arrow-wrapper-' + state.bubblePos + _theme"
          >
            <div [class]="'mbsc-popup-arrow mbsc-popup-arrow-' + state.bubblePos + _theme" [ngStyle]="state.arrowPos!"></div>
          </div>
          <div class="mbsc-popup-focus" tabindex="-1" #active></div>
          <div
            [class]="
              'mbsc-flex-col mbsc-flex-1-1 mbsc-popup-body mbsc-popup-body-' +
              s.display +
              this._theme +
              this._hb +
              (s.fullScreen ? ' mbsc-popup-body-' + s.display + '-full' : '') +
              (_round ? ' mbsc-popup-body-round' : '')
            "
          >
            <div
              *ngIf="_headerText"
              [class]="
                'mbsc-flex-none mbsc-popup-header mbsc-popup-header-' +
                s.display +
                _theme +
                _hb +
                (_buttons ? '' : ' mbsc-popup-header-no-buttons')
              "
              [innerHTML]="_headerText"
            ></div>
            <div #content [class]="'mbsc-flex-1-1 mbsc-popup-content' + (s.contentPadding ? ' mbsc-popup-padding' : '')">
              <ng-container [ngTemplateOutlet]="ngcontent"></ng-container>
            </div>
            <div
              *ngIf="_buttons"
              [class]="
                'mbsc-flex-none mbsc-popup-buttons mbsc-popup-buttons-' +
                s.display +
                _theme +
                _rtl +
                _hb +
                (_flexButtons ? ' mbsc-flex' : '') +
                (s.fullScreen ? ' mbsc-popup-buttons-' + s.display + '-full' : '')
              "
            >
              <mbsc-button
                *ngFor="let btn of _buttons"
                [color]="btn.color"
                [class]="
                  'mbsc-popup-button mbsc-popup-button-' +
                  s.display +
                  _rtl +
                  _hb +
                  (_flexButtons ? ' mbsc-popup-button-flex' : '') +
                  ' ' +
                  (btn.cssClass || '')
                "
                [disabled]="btn.disabled"
                [icon]="btn.icon"
                [theme]="s.theme"
                [themeVariant]="s.themeVariant"
                [variant]="btn.variant || s.buttonVariant"
                (click)="!btn.disabled && btn.handler($event)"
              >
                {{ btn.text }}
              </mbsc-button>
            </div>
          </div>
        </div>
      </div>
    </ng-container>
    <ng-container *ngIf="!_isModal" [ngTemplateOutlet]="ngcontent"></ng-container>
  `
    }]
  }], null, {
    vActive: [{
      type: ViewChild,
      args: ["active", {
        static: false
      }]
    }],
    vContent: [{
      type: ViewChild,
      args: ["content", {
        static: false
      }]
    }],
    vLimit: [{
      type: ViewChild,
      args: ["limit", {
        static: false
      }]
    }],
    vWrapper: [{
      type: ViewChild,
      args: ["wrapper", {
        static: false
      }]
    }],
    vPopup: [{
      type: ViewChild,
      args: ["popup", {
        static: false
      }]
    }],
    activeElm: [{
      type: Input
    }],
    anchor: [{
      type: Input
    }],
    anchorAlign: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input
    }],
    buttons: [{
      type: Input
    }],
    buttonVariant: [{
      type: Input
    }],
    closeOnEsc: [{
      type: Input
    }],
    closeOnOverlayClick: [{
      type: Input
    }],
    closeOnScroll: [{
      type: Input
    }],
    contentPadding: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    disableLeftRight: [{
      type: Input
    }],
    display: [{
      type: Input
    }],
    focusElm: [{
      type: Input
    }],
    focusOnClose: [{
      type: Input
    }],
    focusOnOpen: [{
      type: Input
    }],
    focusTrap: [{
      type: Input
    }],
    fullScreen: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    isOpen: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    maxWidth: [{
      type: Input
    }],
    scrollLock: [{
      type: Input
    }],
    setActive: [{
      type: Input
    }],
    showArrow: [{
      type: Input
    }],
    showOverlay: [{
      type: Input
    }],
    windowWidth: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    cancelText: [{
      type: Input
    }],
    closeText: [{
      type: Input
    }],
    okText: [{
      type: Input
    }],
    setText: [{
      type: Input
    }],
    onButtonClick: [{
      type: Output
    }],
    onOverlayClick: [{
      type: Output
    }],
    onClose: [{
      type: Output
    }],
    onClosed: [{
      type: Output
    }],
    onKeyDown: [{
      type: Output
    }],
    onOpen: [{
      type: Output
    }],
    onPosition: [{
      type: Output
    }],
    onResize: [{
      type: Output
    }]
  });
})();
var MbscPrompt = function() {
  function MbscPrompt2() {
    this.value = "";
  }
  MbscPrompt2.ɵfac = function MbscPrompt_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscPrompt2)();
  };
  MbscPrompt2.ɵcmp = ɵɵdefineComponent({
    type: MbscPrompt2,
    selectors: [["mbsc-prompt"]],
    viewQuery: function MbscPrompt_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c13, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.popup = _t.first);
      }
    },
    inputs: {
      inputType: "inputType",
      label: "label",
      message: "message",
      placeholder: "placeholder",
      title: "title",
      props: "props",
      value: "value"
    },
    standalone: false,
    decls: 7,
    vars: 9,
    consts: [["popup", ""], [3, "options"], [1, "mbsc-alert-content"], ["class", "mbsc-alert-title", 4, "ngIf"], [1, "mbsc-alert-message"], [1, "mbsc-prompt-input", 3, "valueChange", "label", "placeholder", "theme", "themeVariant", "type", "value"], [1, "mbsc-alert-title"]],
    template: function MbscPrompt_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "mbsc-popup", 1, 0)(2, "div", 2);
        ɵɵtemplate(3, MbscPrompt_h2_3_Template, 2, 1, "h2", 3);
        ɵɵelementStart(4, "p", 4);
        ɵɵtext(5);
        ɵɵelementEnd();
        ɵɵelementStart(6, "mbsc-input", 5);
        ɵɵtwoWayListener("valueChange", function MbscPrompt_Template_mbsc_input_valueChange_6_listener($event) {
          ɵɵrestoreView(_r1);
          ɵɵtwoWayBindingSet(ctx2.value, $event) || (ctx2.value = $event);
          return ɵɵresetView($event);
        });
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵproperty("options", ctx2.props);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx2.title);
        ɵɵadvance(2);
        ɵɵtextInterpolate(ctx2.message || "");
        ɵɵadvance();
        ɵɵproperty("label", ctx2.label)("placeholder", ctx2.placeholder || "")("theme", ctx2.props.theme)("themeVariant", ctx2.props.themeVariant)("type", ctx2.inputType);
        ɵɵtwoWayProperty("value", ctx2.value);
      }
    },
    dependencies: [MbscPopup, MbscInput, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscPrompt2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscPrompt, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-prompt",
      template: `
    <mbsc-popup #popup [options]="props">
      <div class="mbsc-alert-content">
        <h2 *ngIf="title" class="mbsc-alert-title">{{ title }}</h2>
        <p class="mbsc-alert-message">{{ message || '' }}</p>
        <mbsc-input
          class="mbsc-prompt-input"
          [label]="label"
          [placeholder]="placeholder || ''"
          [theme]="props.theme"
          [themeVariant]="props.themeVariant"
          [type]="inputType"
          [(value)]="value"
        ></mbsc-input>
      </div>
    </mbsc-popup>
  `
    }]
  }], null, {
    popup: [{
      type: ViewChild,
      args: ["popup", {
        static: false
      }]
    }],
    inputType: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    title: [{
      type: Input
    }],
    props: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var MbscSnackbar = function() {
  function MbscSnackbar2() {
  }
  MbscSnackbar2.prototype.onButtonClick = function() {
    this.popup.close();
    if (this.button && this.button.action) {
      this.button.action();
    }
  };
  MbscSnackbar2.ɵfac = function MbscSnackbar_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscSnackbar2)();
  };
  MbscSnackbar2.ɵcmp = ɵɵdefineComponent({
    type: MbscSnackbar2,
    selectors: [["mbsc-snackbar"]],
    viewQuery: function MbscSnackbar_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c13, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.popup = _t.first);
      }
    },
    inputs: {
      button: "button",
      message: "message",
      props: "props"
    },
    standalone: false,
    decls: 6,
    vars: 3,
    consts: [["popup", ""], [3, "options"], [1, "mbsc-snackbar-cont", "mbsc-toast-background", "mbsc-flex"], [1, "mbsc-snackbar-message", "mbsc-flex-1-1"], ["class", "mbsc-snackbar-button", "variant", "flat", 3, "icon", "theme", "themeVariant", "click", 4, "ngIf"], ["variant", "flat", 1, "mbsc-snackbar-button", 3, "click", "icon", "theme", "themeVariant"]],
    template: function MbscSnackbar_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "mbsc-popup", 1, 0)(2, "div", 2)(3, "div", 3);
        ɵɵtext(4);
        ɵɵelementEnd();
        ɵɵtemplate(5, MbscSnackbar_mbsc_button_5_Template, 2, 4, "mbsc-button", 4);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵproperty("options", ctx2.props);
        ɵɵadvance(4);
        ɵɵtextInterpolate(ctx2.message);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.button);
      }
    },
    dependencies: [MbscPopup, MbscButton, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscSnackbar2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSnackbar, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-snackbar",
      template: '\n    <mbsc-popup #popup [options]="props">\n      <div class="mbsc-snackbar-cont mbsc-toast-background mbsc-flex">\n        <div class="mbsc-snackbar-message mbsc-flex-1-1">{{ message }}</div>\n        <mbsc-button\n          *ngIf="button"\n          class="mbsc-snackbar-button"\n          [icon]="button.icon"\n          [theme]="props.theme"\n          [themeVariant]="props.themeVariant"\n          variant="flat"\n          (click)="onButtonClick()"\n        >\n          {{ button.text }}\n        </mbsc-button>\n      </div>\n    </mbsc-popup>\n  '
    }]
  }], null, {
    popup: [{
      type: ViewChild,
      args: ["popup", {
        static: false
      }]
    }],
    button: [{
      type: Input
    }],
    message: [{
      type: Input
    }],
    props: [{
      type: Input
    }]
  });
})();
var MbscPopupModule = function() {
  function MbscPopupModule2() {
  }
  MbscPopupModule2.ɵfac = function MbscPopupModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscPopupModule2)();
  };
  MbscPopupModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscPopupModule2,
    declarations: [MbscPopup, MbscPrompt, MbscSnackbar, PopupBase],
    imports: [CommonModule, MbscButtonModule, MbscInputModule],
    exports: [MbscPopup, MbscPrompt, MbscSnackbar]
  });
  MbscPopupModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscButtonModule, MbscInputModule]]
  });
  return MbscPopupModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscPopupModule, [{
    type: NgModule,
    args: [{
      declarations: [MbscPopup, MbscPrompt, MbscSnackbar, PopupBase],
      entryComponents: [MbscPopup, MbscSnackbar, MbscPrompt],
      exports: [MbscPopup, MbscPrompt, MbscSnackbar],
      imports: [CommonModule, MbscButtonModule, MbscInputModule]
    }]
  }], null, null);
})();
var MbscCalendarLabel = function(_super) {
  __extends(MbscCalendarLabel2, _super);
  function MbscCalendarLabel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscCalendarLabel2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendarLabel_BaseFactory;
    return function MbscCalendarLabel_Factory(__ngFactoryType__) {
      return (ɵMbscCalendarLabel_BaseFactory || (ɵMbscCalendarLabel_BaseFactory = ɵɵgetInheritedFactory(MbscCalendarLabel2)))(__ngFactoryType__ || MbscCalendarLabel2);
    };
  })();
  MbscCalendarLabel2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarLabel2,
    selectors: [["mbsc-calendar-label"]],
    hostAttrs: [1, "mbsc-calendar-label-wrapper"],
    hostVars: 5,
    hostBindings: function MbscCalendarLabel_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("click", function MbscCalendarLabel_click_HostBindingHandler($event) {
          return ctx2._onClick($event);
        })("contextmenu", function MbscCalendarLabel_contextmenu_HostBindingHandler($event) {
          return ctx2._onRightClick($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("role", ctx2.showText ? "button" : null)("tabindex", ctx2._tabIndex)("title", ctx2._title);
        ɵɵstyleMap(ctx2.position);
      }
    },
    inputs: {
      amText: "amText",
      contentTemplate: "contentTemplate",
      count: "count",
      dataTimezone: "dataTimezone",
      date: "date",
      displayTimezone: "displayTimezone",
      drag: "drag",
      hidden: "hidden",
      firstDay: "firstDay",
      event: "event",
      editMode: "editMode",
      exclusiveEndDates: "exclusiveEndDates",
      inactive: "inactive",
      isActiveMonth: "isActiveMonth",
      isExact: "isExact",
      label: "label",
      position: "position",
      resize: "resize",
      hideLabel: "hideLabel",
      id: "id",
      isPicker: "isPicker",
      isUpdate: "isUpdate",
      lastDay: "lastDay",
      more: "more",
      pmText: "pmText",
      resourcesMap: "resourcesMap",
      selected: "selected",
      showEventTooltip: "showEventTooltip",
      showText: "showText",
      template: "template",
      timeFormat: "timeFormat",
      timezonePlugin: "timezonePlugin",
      onClick: "onClick",
      onDoubleClick: "onDoubleClick",
      onRightClick: "onRightClick",
      onHoverIn: "onHoverIn",
      onHoverOut: "onHoverOut",
      onDelete: "onDelete",
      onDragStart: "onDragStart",
      onDragMove: "onDragMove",
      onDragEnd: "onDragEnd",
      onDragModeOn: "onDragModeOn",
      onDragModeOff: "onDragModeOff"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 10,
    consts: [[3, "class", 4, "ngIf"], [3, "class", "color", 4, "ngIf"], [4, "ngIf"], ["aria-hidden", "true", 3, "class", "color", "innerHTML", 4, "ngIf"], ["class", "mbsc-hidden-content", 4, "ngIf"], ["aria-hidden", "true", 3, "innerHTML"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "mbsc-hidden-content"]],
    template: function MbscCalendarLabel_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵtemplate(1, MbscCalendarLabel_div_1_Template, 1, 2, "div", 0)(2, MbscCalendarLabel_div_2_Template, 1, 2, "div", 0)(3, MbscCalendarLabel_div_3_Template, 1, 2, "div", 0)(4, MbscCalendarLabel_div_4_Template, 4, 7, "div", 1)(5, MbscCalendarLabel_5_Template, 1, 4, null, 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
        ɵɵstyleProp("color", ctx2._color);
        ɵɵattribute("data-id", ctx2.showText && ctx2.event ? ctx2.event.id : null);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasResizeStart && ctx2.event && ctx2.event.editable !== false);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasResizeEnd && ctx2.event && ctx2.event.editable !== false);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.showText && !ctx2.more && !ctx2.template);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2.template || !!ctx2.more);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.showText && !ctx2.more && ctx2.template);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscCalendarLabel2;
}(CalendarLabelBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarLabel, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(click)": "_onClick($event)",
        "(contextmenu)": "_onRightClick($event)",
        "[attr.role]": "showText ? 'button' : null",
        "[attr.tabindex]": "_tabIndex",
        "[attr.title]": "_title",
        "[style]": "position",
        class: "mbsc-calendar-label-wrapper"
      },
      selector: "mbsc-calendar-label",
      template: ` <div [attr.data-id]="showText && event ? event.id : null" [class]="_cssClass" [style.color]="_color">
    <div
      *ngIf="_hasResizeStart && event && event.editable !== false"
      [class]="
        'mbsc-calendar-label-resize mbsc-calendar-label-resize-start' + _rtl + (isUpdate ? ' mbsc-calendar-label-resize-start-touch' : '')
      "
    ></div>
    <div
      *ngIf="_hasResizeEnd && event && event.editable !== false"
      [class]="
        'mbsc-calendar-label-resize mbsc-calendar-label-resize-end' + _rtl + (isUpdate ? ' mbsc-calendar-label-resize-start-touch' : '')
      "
    ></div>
    <div *ngIf="showText && !more && !template" [class]="'mbsc-calendar-label-background' + _theme"></div>
    <div *ngIf="!template || !!more" [class]="'mbsc-calendar-label-inner' + _theme" [style.color]="_textColor">
      <div
        *ngIf="_html"
        aria-hidden="true"
        [class]="'mbsc-calendar-label-text' + _theme"
        [style.color]="event && event.textColor"
        [innerHTML]="_html"
      ></div>
      <div *ngIf="!_html" [class]="'mbsc-calendar-label-text' + _theme" [style.color]="event && event.textColor">
        <ng-template [ngTemplateOutlet]="contentTemplate!" [ngTemplateOutletContext]="{ $implicit: _data }"></ng-template>
      </div>
      <div *ngIf="s.label" class="mbsc-hidden-content">{{ s.label }}</div>
    </div>
    <ng-template *ngIf="showText && !more && template" [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ $implicit: _data }">
    </ng-template>
  </div>`
    }]
  }], null, {
    amText: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }],
    count: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    drag: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    event: [{
      type: Input
    }],
    editMode: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    inactive: [{
      type: Input
    }],
    isActiveMonth: [{
      type: Input
    }],
    isExact: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    resize: [{
      type: Input
    }],
    hideLabel: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    isPicker: [{
      type: Input
    }],
    isUpdate: [{
      type: Input
    }],
    lastDay: [{
      type: Input
    }],
    more: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    resourcesMap: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    showEventTooltip: [{
      type: Input
    }],
    showText: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    onClick: [{
      type: Input
    }],
    onDoubleClick: [{
      type: Input
    }],
    onRightClick: [{
      type: Input
    }],
    onHoverIn: [{
      type: Input
    }],
    onHoverOut: [{
      type: Input
    }],
    onDelete: [{
      type: Input
    }],
    onDragStart: [{
      type: Input
    }],
    onDragMove: [{
      type: Input
    }],
    onDragEnd: [{
      type: Input
    }],
    onDragModeOn: [{
      type: Input
    }],
    onDragModeOff: [{
      type: Input
    }]
  });
})();
var MbscCalendarDay = function(_super) {
  __extends(MbscCalendarDay2, _super);
  function MbscCalendarDay2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._computeEventResize = computeEventResize;
    return _this;
  }
  Object.defineProperty(MbscCalendarDay2.prototype, "vBtn", {
    set: function(btn) {
      this._btn = btn && btn.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  MbscCalendarDay2.prototype._getLabelKey = function(index, label) {
    return label.id;
  };
  MbscCalendarDay2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendarDay_BaseFactory;
    return function MbscCalendarDay_Factory(__ngFactoryType__) {
      return (ɵMbscCalendarDay_BaseFactory || (ɵMbscCalendarDay_BaseFactory = ɵɵgetInheritedFactory(MbscCalendarDay2)))(__ngFactoryType__ || MbscCalendarDay2);
    };
  })();
  MbscCalendarDay2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarDay2,
    selectors: [["mbsc-calendar-day"]],
    viewQuery: function MbscCalendarDay_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c15, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vBtn = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function MbscCalendarDay_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("click", function MbscCalendarDay_click_HostBindingHandler($event) {
          return ctx2._onClick($event);
        })("contextmenu", function MbscCalendarDay_contextmenu_HostBindingHandler($event) {
          return ctx2._onRightClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
        ɵɵstyleProp("background-color", ctx2._cellStyles ? ctx2._cellStyles.backgroundColor : "")("color", ctx2._cellStyles ? ctx2._cellStyles.color : "");
      }
    },
    inputs: {
      active: "active",
      amText: "amText",
      clickToCreate: "clickToCreate",
      colors: "colors",
      dataTimezone: "dataTimezone",
      date: "date",
      day: "day",
      dayTemplate: "dayTemplate",
      dayContentTemplate: "dayContentTemplate",
      disabled: "disabled",
      display: "display",
      displayTimezone: "displayTimezone",
      dragToCreate: "dragToCreate",
      dragToResize: "dragToResize",
      dragToMove: "dragToMove",
      eventText: "eventText",
      events: "events",
      eventsText: "eventsText",
      exclusiveEndDates: "exclusiveEndDates",
      firstDay: "firstDay",
      hasMarks: "hasMarks",
      hoverEnd: "hoverEnd",
      hoverStart: "hoverStart",
      isActiveMonth: "isActiveMonth",
      isPicker: "isPicker",
      labels: "labels",
      labelTemplate: "labelTemplate",
      labelContentTemplate: "labelContentTemplate",
      dragData: "dragData",
      marks: "marks",
      month: "month",
      monthShort: "monthShort",
      outer: "outer",
      pmText: "pmText",
      rangeEnd: "rangeEnd",
      rangeStart: "rangeStart",
      resourcesMap: "resourcesMap",
      selected: "selected",
      selectedEventsMap: "selectedEventsMap",
      showEventTooltip: "showEventTooltip",
      text: "text",
      timeFormat: "timeFormat",
      timezonePlugin: "timezonePlugin",
      todayText: "todayText",
      type: "type",
      year: "year",
      onDayClick: "onDayClick",
      onDayDoubleClick: "onDayDoubleClick",
      onDayRightClick: "onDayRightClick",
      onHoverIn: "onHoverIn",
      onHoverOut: "onHoverOut",
      onLabelClick: "onLabelClick",
      onLabelDoubleClick: "onLabelDoubleClick",
      onLabelRightClick: "onLabelRightClick",
      onLabelHoverIn: "onLabelHoverIn",
      onLabelHoverOut: "onLabelHoverOut",
      onLabelDelete: "onLabelDelete",
      onLabelUpdateStart: "onLabelUpdateStart",
      onLabelUpdateMove: "onLabelUpdateMove",
      onLabelUpdateEnd: "onLabelUpdateEnd",
      onLabelUpdateModeOn: "onLabelUpdateModeOn",
      onLabelUpdateModeOff: "onLabelUpdateModeOff"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 9,
    consts: [["btn", ""], [3, "innerHTML"], [4, "ngIf"], ["aria-hidden", "true", 3, "class", 4, "ngIf"], ["role", "button", 3, "class", "ngStyle", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["aria-hidden", "true"], ["role", "button", 3, "ngStyle"], [3, "class", "background", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "class", 4, "ngIf"], [1, "mbsc-calendar-labels"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-calendar-text", "mbsc-calendar-text-placeholder"], [3, "amText", "date", "dataTimezone", "displayTimezone", "drag", "resize", "event", "exclusiveEndDates", "firstDay", "hidden", "isExact", "isUpdate", "position", "pmText", "resourcesMap", "rtl", "showEventTooltip", "showText", "theme", "timeFormat", "timezonePlugin", "template", "contentTemplate", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff"], [3, "amText", "date", "dataTimezone", "displayTimezone", "drag", "resize", "event", "exclusiveEndDates", "firstDay", "isExact", "isUpdate", "pmText", "position", "resourcesMap", "rtl", "showEventTooltip", "showText", "theme", "timeFormat", "timezonePlugin", "template", "contentTemplate", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff"], [1, "mbsc-calendar-labels-row"], ["class", "mbsc-calendar-text mbsc-calendar-text-placeholder", 4, "ngIf"], [3, "count", "id", "isActiveMonth", "label", "more", "position", "rtl", "theme", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "showText", 4, "ngIf"], [3, "amText", "date", "dataTimezone", "displayTimezone", "drag", "resize", "event", "exclusiveEndDates", "firstDay", "id", "inactive", "isActiveMonth", "isExact", "isPicker", "label", "position", "pmText", "resourcesMap", "rtl", "selected", "showText", "showEventTooltip", "theme", "timeFormat", "timezonePlugin", "template", "contentTemplate", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff", 4, "ngIf"], [3, "count", "id", "isActiveMonth", "label", "more", "position", "rtl", "theme", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "showText"], [3, "amText", "date", "dataTimezone", "displayTimezone", "drag", "resize", "event", "exclusiveEndDates", "firstDay", "id", "inactive", "isActiveMonth", "isExact", "isPicker", "label", "position", "pmText", "resourcesMap", "rtl", "selected", "showText", "showEventTooltip", "theme", "timeFormat", "timezonePlugin", "template", "contentTemplate", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff"]],
    template: function MbscCalendarDay_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelement(0, "div", 1);
        ɵɵelementStart(1, "div");
        ɵɵtemplate(2, MbscCalendarDay_2_Template, 1, 4, null, 2)(3, MbscCalendarDay_div_3_Template, 2, 3, "div", 3)(4, MbscCalendarDay_div_4_Template, 3, 9, "div", 4)(5, MbscCalendarDay_div_5_Template, 3, 4, "div", 2)(6, MbscCalendarDay_6_Template, 1, 4, null, 2)(7, MbscCalendarDay_div_7_Template, 6, 5, "div", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("innerHTML", ctx2.textParam, ɵɵsanitizeHtml);
        ɵɵadvance();
        ɵɵclassMap("mbsc-calendar-cell-inner mbsc-calendar-" + ctx2.s.type + "-inner" + ctx2._theme + (ctx2.s.type === "day" ? "" : ctx2._hb) + (ctx2.s.display ? "" : " mbsc-calendar-day-hidden"));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.dayTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.text === 1);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2.dayTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.marks && !ctx2.dayTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.dayContentTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.labels);
      }
    },
    dependencies: [MbscCalendarLabel, NgIf, NgTemplateOutlet, NgStyle, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscCalendarDay2;
}(CalendarDayBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarDay, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(click)": "_onClick($event)",
        "(contextmenu)": "_onRightClick($event)",
        "[class]": "_cssClass",
        "[style.backgroundColor]": '_cellStyles ? _cellStyles.backgroundColor : ""',
        "[style.color]": '_cellStyles ? _cellStyles.color : ""'
      },
      selector: "mbsc-calendar-day",
      template: `<div [innerHTML]="textParam"></div>
    <div
      [class]="
        'mbsc-calendar-cell-inner mbsc-calendar-' +
        s.type +
        '-inner' +
        _theme +
        (s.type === 'day' ? '' : _hb) +
        (s.display ? '' : ' mbsc-calendar-day-hidden')
      "
    >
      <ng-template *ngIf="dayTemplate" [ngTemplateOutlet]="dayTemplate" [ngTemplateOutletContext]="{ $implicit: _data }"></ng-template>

      <div *ngIf="s.text === 1" aria-hidden="true" [class]="'mbsc-calendar-month-name' + _theme + _rtl">
        {{ s.monthShort }}
      </div>
      <div
        #btn
        *ngIf="!dayTemplate"
        [attr.aria-describedby]="s.isActiveMonth ? 'mbsc-calendar-day-desc-' + s.date : null"
        [attr.aria-disabled]="s.disabled ? 'true' : null"
        [attr.aria-label]="_ariaLabel"
        [attr.aria-pressed]="s.selected"
        [attr.tabindex]="s.disabled ? null : s.active ? 0 : -1"
        role="button"
        [class]="'mbsc-calendar-cell-text mbsc-calendar-' + s.type + '-text' + _theme + _todayClass"
        [ngStyle]="_circleStyles"
      >
        {{ s.text }}
      </div>

      <div *ngIf="s.marks && !dayTemplate">
        <div [class]="'mbsc-calendar-marks' + _theme + _rtl">
          <div
            *ngFor="let mark of s.marks; trackBy: _getKey"
            [class]="'mbsc-calendar-mark ' + (mark.markCssClass || '') + _theme"
            [style.background]="mark.color"
          ></div>
        </div>
      </div>

      <ng-template *ngIf="dayContentTemplate" [ngTemplateOutlet]="dayContentTemplate" [ngTemplateOutletContext]="{ $implicit: _data }">
      </ng-template>

      <div *ngIf="s.labels">
        <div *ngIf="_draggedLabelOrig && _draggedLabelOrig.event" [class]="'mbsc-calendar-labels mbsc-calendar-labels-dragging'">
          <mbsc-calendar-label
            [amText]="s.amText"
            [date]="s.date"
            [dataTimezone]="dataTimezone"
            [displayTimezone]="displayTimezone"
            [drag]="s.dragToMove"
            [resize]="_computeEventResize(_draggedLabelOrig.event.resize, s.dragToResize)"
            [event]="_draggedLabelOrig.event"
            [exclusiveEndDates]="exclusiveEndDates"
            [firstDay]="s.firstDay"
            [hidden]="!!s.dragData!.draggedDates"
            [isExact]="_draggedLabelOrig.isExact"
            [isUpdate]="true"
            [position]="_draggedLabelOrig.position"
            [pmText]="s.pmText"
            [resourcesMap]="s.resourcesMap"
            [rtl]="s.rtl"
            [showEventTooltip]="s.showEventTooltip"
            [showText]="true"
            [theme]="s.theme"
            [timeFormat]="s.timeFormat"
            [timezonePlugin]="timezonePlugin"
            [template]="labelTemplate"
            [contentTemplate]="labelContentTemplate"
            [onClick]="_onLabelClick"
            [onDoubleClick]="_onLabelDoubleClick"
            [onRightClick]="_onLabelRightClick"
            [onHoverIn]="_onLabelHoverIn"
            [onHoverOut]="_onLabelHoverOut"
            [onDelete]="s.onLabelDelete"
            [onDragStart]="s.onLabelUpdateStart"
            [onDragMove]="s.onLabelUpdateMove"
            [onDragEnd]="s.onLabelUpdateEnd"
            [onDragModeOn]="s.onLabelUpdateModeOn"
            [onDragModeOff]="s.onLabelUpdateModeOff"
          >
          </mbsc-calendar-label>
        </div>

        <div *ngIf="_draggedLabel && _draggedLabel.event" [class]="'mbsc-calendar-labels mbsc-calendar-labels-dragging'">
          <mbsc-calendar-label
            [amText]="s.amText"
            [date]="s.date"
            [dataTimezone]="dataTimezone"
            [displayTimezone]="displayTimezone"
            [drag]="s.dragToMove"
            [resize]="_computeEventResize(_draggedLabel.event.resize, s.dragToResize)"
            [event]="_draggedLabel.event"
            [exclusiveEndDates]="exclusiveEndDates"
            [firstDay]="s.firstDay"
            [isExact]="_draggedLabel.isExact"
            [isUpdate]="true"
            [pmText]="s.pmText"
            [position]="_draggedLabel.position"
            [resourcesMap]="s.resourcesMap"
            [rtl]="s.rtl"
            [showEventTooltip]="s.showEventTooltip"
            [showText]="true"
            [theme]="s.theme"
            [timeFormat]="s.timeFormat"
            [timezonePlugin]="timezonePlugin"
            [template]="labelTemplate"
            [contentTemplate]="labelContentTemplate"
            [onClick]="_onLabelClick"
            [onDoubleClick]="_onLabelDoubleClick"
            [onRightClick]="_onLabelRightClick"
            [onHoverIn]="_onLabelHoverIn"
            [onHoverOut]="_onLabelHoverOut"
            [onDelete]="s.onLabelDelete"
            [onDragStart]="s.onLabelUpdateStart"
            [onDragMove]="s.onLabelUpdateMove"
            [onDragEnd]="s.onLabelUpdateEnd"
            [onDragModeOn]="s.onLabelUpdateModeOn"
            [onDragModeOff]="s.onLabelUpdateModeOff"
          >
          </mbsc-calendar-label>
        </div>

        <div [attr.id]="s.isActiveMonth ? 'mbsc-calendar-day-desc-' + s.date : null" class="mbsc-calendar-labels">
          <ng-container *ngFor="let labels of s.labels.data; trackBy: _getKey">
            <div class="mbsc-calendar-labels-row">
              <div *ngIf="!labels.length" class="mbsc-calendar-text mbsc-calendar-text-placeholder"></div>
              <ng-container *ngFor="let label of labels; trackBy: _getLabelKey">
                <mbsc-calendar-label
                  *ngIf="label.more || label.count"
                  [count]="label.count ? label.count + ' ' + (label.count > 1 ? s.eventsText : s.eventText) : undefined"
                  [id]="label.id"
                  [isActiveMonth]="isActiveMonth"
                  [label]="label.label"
                  [more]="label.more"
                  [position]="label.position"
                  [rtl]="s.rtl"
                  [theme]="s.theme"
                  [onClick]="_onLabelClick"
                  [onDoubleClick]="_onLabelDoubleClick"
                  [onRightClick]="_onLabelRightClick"
                  [onHoverIn]="_onLabelHoverIn"
                  [onHoverOut]="_onLabelHoverOut"
                  [showText]="true"
                >
                </mbsc-calendar-label>

                <mbsc-calendar-label
                  *ngIf="label.event"
                  [amText]="s.amText"
                  [date]="s.date"
                  [dataTimezone]="dataTimezone"
                  [displayTimezone]="displayTimezone"
                  [drag]="s.dragToMove"
                  [resize]="_computeEventResize(label.event!.resize, s.dragToResize)"
                  [event]="label.event"
                  [exclusiveEndDates]="exclusiveEndDates"
                  [firstDay]="s.firstDay"
                  [id]="label.id"
                  [inactive]="label.event && s.dragData && s.dragData.draggedEvent && label.event.id === s.dragData.draggedEvent.id"
                  [isActiveMonth]="isActiveMonth"
                  [isExact]="label.isExact"
                  [isPicker]="s.isPicker"
                  [label]="label.label"
                  [position]="label.position"
                  [pmText]="s.pmText"
                  [resourcesMap]="s.resourcesMap"
                  [rtl]="s.rtl"
                  [selected]="label.event && selectedEventsMap && !!(selectedEventsMap[label.id] || selectedEventsMap[label.event.id!])"
                  [showText]="label.showText"
                  [showEventTooltip]="s.showEventTooltip"
                  [theme]="s.theme"
                  [timeFormat]="s.timeFormat"
                  [timezonePlugin]="timezonePlugin"
                  [template]="labelTemplate"
                  [contentTemplate]="labelContentTemplate"
                  [onClick]="_onLabelClick"
                  [onDoubleClick]="_onLabelDoubleClick"
                  [onRightClick]="_onLabelRightClick"
                  [onHoverIn]="_onLabelHoverIn"
                  [onHoverOut]="_onLabelHoverOut"
                  [onDelete]="s.onLabelDelete"
                  [onDragStart]="s.onLabelUpdateStart"
                  [onDragMove]="s.onLabelUpdateMove"
                  [onDragEnd]="s.onLabelUpdateEnd"
                  [onDragModeOn]="s.onLabelUpdateModeOn"
                  [onDragModeOff]="s.onLabelUpdateModeOff"
                >
                </mbsc-calendar-label>
              </ng-container>
            </div>
          </ng-container>
        </div>
        <div class="mbsc-calendar-text mbsc-calendar-text-placeholder"></div>
      </div>
    </div> `
    }]
  }], null, {
    active: [{
      type: Input
    }],
    amText: [{
      type: Input
    }],
    clickToCreate: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    date: [{
      type: Input
    }],
    day: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dayContentTemplate: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    display: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    dragToCreate: [{
      type: Input
    }],
    dragToResize: [{
      type: Input
    }],
    dragToMove: [{
      type: Input
    }],
    eventText: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    eventsText: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    hasMarks: [{
      type: Input
    }],
    hoverEnd: [{
      type: Input
    }],
    hoverStart: [{
      type: Input
    }],
    isActiveMonth: [{
      type: Input
    }],
    isPicker: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    labelContentTemplate: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    marks: [{
      type: Input
    }],
    month: [{
      type: Input
    }],
    monthShort: [{
      type: Input
    }],
    outer: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    rangeEnd: [{
      type: Input
    }],
    rangeStart: [{
      type: Input
    }],
    resourcesMap: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    selectedEventsMap: [{
      type: Input
    }],
    showEventTooltip: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    todayText: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    year: [{
      type: Input
    }],
    onDayClick: [{
      type: Input
    }],
    onDayDoubleClick: [{
      type: Input
    }],
    onDayRightClick: [{
      type: Input
    }],
    onHoverIn: [{
      type: Input
    }],
    onHoverOut: [{
      type: Input
    }],
    onLabelClick: [{
      type: Input
    }],
    onLabelDoubleClick: [{
      type: Input
    }],
    onLabelRightClick: [{
      type: Input
    }],
    onLabelHoverIn: [{
      type: Input
    }],
    onLabelHoverOut: [{
      type: Input
    }],
    onLabelDelete: [{
      type: Input
    }],
    onLabelUpdateStart: [{
      type: Input
    }],
    onLabelUpdateMove: [{
      type: Input
    }],
    onLabelUpdateEnd: [{
      type: Input
    }],
    onLabelUpdateModeOn: [{
      type: Input
    }],
    onLabelUpdateModeOff: [{
      type: Input
    }],
    vBtn: [{
      type: ViewChild,
      args: ["btn", {
        static: false,
        read: ElementRef
      }]
    }]
  });
})();
var MbscCalendarWeekDays = function() {
  function MbscCalendarWeekDays2() {
    this.days = ARRAY7;
  }
  MbscCalendarWeekDays2.ɵfac = function MbscCalendarWeekDays_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCalendarWeekDays2)();
  };
  MbscCalendarWeekDays2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarWeekDays2,
    selectors: [["mbsc-calendar-weekdays"]],
    hostAttrs: ["aria-hidden", "true", 1, "mbsc-calendar-week-days", "mbsc-flex"],
    inputs: {
      firstDay: "firstDay",
      hasScroll: "hasScroll",
      dayNamesShort: "dayNamesShort",
      rtl: "rtl",
      showWeekNumbers: "showWeekNumbers",
      theme: "theme"
    },
    standalone: false,
    decls: 3,
    vars: 3,
    consts: [[3, "ngClass", 4, "ngIf"], [3, "ngClass", 4, "ngFor", "ngForOf"], ["class", "mbsc-schedule-fake-scroll-y", 4, "ngIf"], [3, "ngClass"], [1, "mbsc-schedule-fake-scroll-y"]],
    template: function MbscCalendarWeekDays_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscCalendarWeekDays_div_0_Template, 1, 1, "div", 0)(1, MbscCalendarWeekDays_div_1_Template, 2, 2, "div", 1)(2, MbscCalendarWeekDays_div_2_Template, 1, 0, "div", 2);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2.showWeekNumbers);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx2.days);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.hasScroll);
      }
    },
    dependencies: [NgIf, NgClass, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscCalendarWeekDays2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarWeekDays, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "aria-hidden": "true",
        class: "mbsc-calendar-week-days mbsc-flex"
      },
      selector: "mbsc-calendar-weekdays",
      template: `<div *ngIf="showWeekNumbers" [ngClass]="'mbsc-calendar-week-day mbsc-calendar-week-nr mbsc-flex-none' + theme + rtl"></div>
    <div [ngClass]="'mbsc-calendar-week-day mbsc-flex-1-0-0' + theme + rtl" *ngFor="let d of days; index as i">
      {{ dayNamesShort[(i + firstDay) % 7] }}
    </div>
    <div *ngIf="hasScroll" class="mbsc-schedule-fake-scroll-y"></div>`
    }]
  }], null, {
    firstDay: [{
      type: Input
    }],
    hasScroll: [{
      type: Input
    }],
    dayNamesShort: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    showWeekNumbers: [{
      type: Input
    }],
    theme: [{
      type: Input
    }]
  });
})();
var MbscMonthView = function(_super) {
  __extends(MbscMonthView2, _super);
  function MbscMonthView2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscMonthView2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscMonthView_BaseFactory;
    return function MbscMonthView_Factory(__ngFactoryType__) {
      return (ɵMbscMonthView_BaseFactory || (ɵMbscMonthView_BaseFactory = ɵɵgetInheritedFactory(MbscMonthView2)))(__ngFactoryType__ || MbscMonthView2);
    };
  })();
  MbscMonthView2.ɵcmp = ɵɵdefineComponent({
    type: MbscMonthView2,
    selectors: [["mbsc-month-view"]],
    inputs: {
      activeDate: "activeDate",
      amText: "amText",
      calendarType: "calendarType",
      cellTextHeight: "cellTextHeight",
      clickToCreate: "clickToCreate",
      colors: "colors",
      dataTimezone: "dataTimezone",
      dayNames: "dayNames",
      dayNamesMin: "dayNamesMin",
      dayNamesShort: "dayNamesShort",
      dayTemplate: "dayTemplate",
      dayContentTemplate: "dayContentTemplate",
      displayTimezone: "displayTimezone",
      dragToCreate: "dragToCreate",
      dragToResize: "dragToResize",
      dragToMove: "dragToMove",
      eventText: "eventText",
      events: "events",
      eventsText: "eventsText",
      exclusiveEndDates: "exclusiveEndDates",
      firstDay: "firstDay",
      firstPageDay: "firstPageDay",
      hasMarks: "hasMarks",
      hoverEnd: "hoverEnd",
      hoverStart: "hoverStart",
      isActive: "isActive",
      isPicker: "isPicker",
      invalid: "invalid",
      labels: "labels",
      labelHeight: "labelHeight",
      labelTemplate: "labelTemplate",
      labelContentTemplate: "labelContentTemplate",
      dragData: "dragData",
      marked: "marked",
      max: "max",
      min: "min",
      monthNames: "monthNames",
      monthNamesShort: "monthNamesShort",
      pmText: "pmText",
      rangeEnd: "rangeEnd",
      rangeStart: "rangeStart",
      selectedDates: "selectedDates",
      selectedEventsMap: "selectedEventsMap",
      showEventTooltip: "showEventTooltip",
      showOuter: "showOuter",
      showWeekDays: "showWeekDays",
      showWeekNumbers: "showWeekNumbers",
      showSingleMark: "showSingleMark",
      resourcesMap: "resourcesMap",
      todayText: "todayText",
      timeFormat: "timeFormat",
      timezonePlugin: "timezonePlugin",
      valid: "valid",
      variableRow: "variableRow",
      weeks: "weeks",
      weekText: "weekText",
      getDate: "getDate",
      getDay: "getDay",
      getMonth: "getMonth",
      getWeekNumber: "getWeekNumber",
      getYear: "getYear",
      onDayClick: "onDayClick",
      onDayDoubleClick: "onDayDoubleClick",
      onDayRightClick: "onDayRightClick",
      onDayHoverIn: "onDayHoverIn",
      onDayHoverOut: "onDayHoverOut",
      onLabelClick: "onLabelClick",
      onLabelDoubleClick: "onLabelDoubleClick",
      onLabelRightClick: "onLabelRightClick",
      onLabelHoverIn: "onLabelHoverIn",
      onLabelHoverOut: "onLabelHoverOut",
      onLabelDelete: "onLabelDelete",
      onLabelUpdateStart: "onLabelUpdateStart",
      onLabelUpdateMove: "onLabelUpdateMove",
      onLabelUpdateEnd: "onLabelUpdateEnd",
      onLabelUpdateModeOn: "onLabelUpdateModeOn",
      onLabelUpdateModeOff: "onLabelUpdateModeOff"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 3,
    vars: 6,
    consts: [[3, "rtl", "theme", "firstDay", "dayNamesShort", "showWeekNumbers", 4, "ngIf"], ["class", "mbsc-calendar-row mbsc-flex mbsc-flex-1-0", 3, "minHeight", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "rtl", "theme", "firstDay", "dayNamesShort", "showWeekNumbers"], [1, "mbsc-calendar-row", "mbsc-flex", "mbsc-flex-1-0"], [3, "ngClass", 4, "ngIf"], ["type", "day", 3, "active", "amText", "colors", "clickToCreate", "date", "day", "dayTemplate", "dayContentTemplate", "disabled", "display", "dataTimezone", "displayTimezone", "dragToCreate", "dragToResize", "dragToMove", "eventText", "events", "eventsText", "exclusiveEndDates", "firstDay", "hasMarks", "hoverEnd", "hoverStart", "isActiveMonth", "isPicker", "labels", "labelTemplate", "labelContentTemplate", "dragData", "marks", "month", "monthShort", "outer", "pmText", "rangeEnd", "rangeStart", "resourcesMap", "rtl", "selected", "selectedEventsMap", "showEventTooltip", "text", "timeFormat", "timezonePlugin", "todayText", "theme", "year", "onDayClick", "onDayDoubleClick", "onDayRightClick", "onHoverIn", "onHoverOut", "onLabelClick", "onLabelDoubleClick", "onLabelRightClick", "onLabelHoverIn", "onLabelHoverOut", "onLabelDelete", "onLabelUpdateStart", "onLabelUpdateMove", "onLabelUpdateEnd", "onLabelUpdateModeOn", "onLabelUpdateModeOff", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngClass"], ["aria-hidden", "true"], [1, "mbsc-hidden-content"], ["type", "day", 3, "active", "amText", "colors", "clickToCreate", "date", "day", "dayTemplate", "dayContentTemplate", "disabled", "display", "dataTimezone", "displayTimezone", "dragToCreate", "dragToResize", "dragToMove", "eventText", "events", "eventsText", "exclusiveEndDates", "firstDay", "hasMarks", "hoverEnd", "hoverStart", "isActiveMonth", "isPicker", "labels", "labelTemplate", "labelContentTemplate", "dragData", "marks", "month", "monthShort", "outer", "pmText", "rangeEnd", "rangeStart", "resourcesMap", "rtl", "selected", "selectedEventsMap", "showEventTooltip", "text", "timeFormat", "timezonePlugin", "todayText", "theme", "year", "onDayClick", "onDayDoubleClick", "onDayRightClick", "onHoverIn", "onHoverOut", "onLabelClick", "onLabelDoubleClick", "onLabelRightClick", "onLabelHoverIn", "onLabelHoverOut", "onLabelDelete", "onLabelUpdateStart", "onLabelUpdateMove", "onLabelUpdateEnd", "onLabelUpdateModeOn", "onLabelUpdateModeOff"]],
    template: function MbscMonthView_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "div");
        ɵɵtemplate(1, MbscMonthView_mbsc_calendar_weekdays_1_Template, 1, 5, "mbsc-calendar-weekdays", 0)(2, MbscMonthView_div_2_Template, 3, 5, "div", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap("mbsc-calendar-table mbsc-flex-col mbsc-flex-1-1" + (ctx2.s.isActive ? " mbsc-calendar-table-active" : ""));
        ɵɵattribute("aria-hidden", ctx2.s.isActive ? void 0 : "true");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.showWeekDays);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx2._rows)("ngForTrackBy", ctx2._getKey);
      }
    },
    dependencies: [MbscCalendarWeekDays, MbscCalendarDay, NgIf, NgForOf, NgClass],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscMonthView2;
}(MonthViewBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscMonthView, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-month-view",
      template: `
    <div
      [attr.aria-hidden]="s.isActive ? undefined : 'true'"
      [class]="'mbsc-calendar-table mbsc-flex-col mbsc-flex-1-1' + (s.isActive ? ' mbsc-calendar-table-active' : '')"
    >
      <mbsc-calendar-weekdays
        *ngIf="showWeekDays"
        [rtl]="_rtl"
        [theme]="_theme"
        [firstDay]="s.firstDay"
        [dayNamesShort]="s.dayNamesShort"
        [showWeekNumbers]="s.showWeekNumbers"
      >
      </mbsc-calendar-weekdays>
      <div
        *ngFor="let row of _rows; trackBy: _getKey; let i = index"
        [style.minHeight.px]="_rowHeights[i] || 0"
        class="mbsc-calendar-row mbsc-flex mbsc-flex-1-0"
      >
        <div *ngIf="s.showWeekNumbers" [ngClass]="'mbsc-calendar-cell mbsc-flex-none mbsc-calendar-day mbsc-calendar-week-nr' + _theme">
          <div aria-hidden="true">{{ _getWeekNr(s, row[0].date) }}</div>
          <div class="mbsc-hidden-content">{{ s.weekText!.replace('{count}', _getWeekNr(s, row[0].date)) }}</div>
        </div>
        <mbsc-calendar-day
          *ngFor="let cell of row; trackBy: _getKey"
          type="day"
          [active]="cell.display && _isActive(cell.date)"
          [amText]="s.amText"
          [colors]="cell.colors"
          [clickToCreate]="s.clickToCreate"
          [date]="cell.date"
          [day]="cell.day"
          [dayTemplate]="dayTemplate"
          [dayContentTemplate]="dayContentTemplate"
          [disabled]="_isInvalid(cell.date)"
          [display]="cell.display"
          [dataTimezone]="dataTimezone"
          [displayTimezone]="displayTimezone"
          [dragToCreate]="s.dragToCreate"
          [dragToResize]="s.dragToResize"
          [dragToMove]="s.dragToMove"
          [eventText]="s.eventText"
          [events]="cell.events"
          [eventsText]="s.eventsText"
          [exclusiveEndDates]="exclusiveEndDates"
          [firstDay]="s.firstDay"
          [hasMarks]="s.hasMarks"
          [hoverEnd]="s.hoverEnd"
          [hoverStart]="s.hoverStart"
          [isActiveMonth]="s.isActive"
          [isPicker]="s.isPicker"
          [labels]="cell.labels"
          [labelTemplate]="labelTemplate"
          [labelContentTemplate]="labelContentTemplate"
          [dragData]="s.dragData"
          [marks]="cell.marks"
          [month]="cell.month"
          [monthShort]="cell.monthShort"
          [outer]="cell.outer"
          [pmText]="s.pmText"
          [rangeEnd]="s.rangeEnd"
          [rangeStart]="s.rangeStart"
          [resourcesMap]="s.resourcesMap"
          [rtl]="s.rtl"
          [selected]="_isSelected(cell.date)"
          [selectedEventsMap]="s.selectedEventsMap"
          [showEventTooltip]="s.showEventTooltip"
          [text]="cell.text"
          [timeFormat]="s.timeFormat"
          [timezonePlugin]="timezonePlugin"
          [todayText]="s.todayText"
          [theme]="s.theme"
          [year]="cell.year"
          [onDayClick]="s.onDayClick"
          [onDayDoubleClick]="s.onDayDoubleClick"
          [onDayRightClick]="s.onDayRightClick"
          [onHoverIn]="s.onDayHoverIn"
          [onHoverOut]="s.onDayHoverOut"
          [onLabelClick]="s.onLabelClick"
          [onLabelDoubleClick]="s.onLabelDoubleClick"
          [onLabelRightClick]="s.onLabelRightClick"
          [onLabelHoverIn]="s.onLabelHoverIn"
          [onLabelHoverOut]="s.onLabelHoverOut"
          [onLabelDelete]="s.onLabelDelete"
          [onLabelUpdateStart]="s.onLabelUpdateStart"
          [onLabelUpdateMove]="s.onLabelUpdateMove"
          [onLabelUpdateEnd]="s.onLabelUpdateEnd"
          [onLabelUpdateModeOn]="s.onLabelUpdateModeOn"
          [onLabelUpdateModeOff]="s.onLabelUpdateModeOff"
        ></mbsc-calendar-day>
      </div>
    </div>
  `
    }]
  }], null, {
    activeDate: [{
      type: Input
    }],
    amText: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    cellTextHeight: [{
      type: Input
    }],
    clickToCreate: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    dayNames: [{
      type: Input
    }],
    dayNamesMin: [{
      type: Input
    }],
    dayNamesShort: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dayContentTemplate: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    dragToCreate: [{
      type: Input
    }],
    dragToResize: [{
      type: Input
    }],
    dragToMove: [{
      type: Input
    }],
    eventText: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    eventsText: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    firstPageDay: [{
      type: Input
    }],
    hasMarks: [{
      type: Input
    }],
    hoverEnd: [{
      type: Input
    }],
    hoverStart: [{
      type: Input
    }],
    isActive: [{
      type: Input
    }],
    isPicker: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    labelHeight: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    labelContentTemplate: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    marked: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    monthNames: [{
      type: Input
    }],
    monthNamesShort: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    rangeEnd: [{
      type: Input
    }],
    rangeStart: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    selectedEventsMap: [{
      type: Input
    }],
    showEventTooltip: [{
      type: Input
    }],
    showOuter: [{
      type: Input
    }],
    showWeekDays: [{
      type: Input
    }],
    showWeekNumbers: [{
      type: Input
    }],
    showSingleMark: [{
      type: Input
    }],
    resourcesMap: [{
      type: Input
    }],
    todayText: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    valid: [{
      type: Input
    }],
    variableRow: [{
      type: Input
    }],
    weeks: [{
      type: Input
    }],
    weekText: [{
      type: Input
    }],
    getDate: [{
      type: Input
    }],
    getDay: [{
      type: Input
    }],
    getMonth: [{
      type: Input
    }],
    getWeekNumber: [{
      type: Input
    }],
    getYear: [{
      type: Input
    }],
    onDayClick: [{
      type: Input
    }],
    onDayDoubleClick: [{
      type: Input
    }],
    onDayRightClick: [{
      type: Input
    }],
    onDayHoverIn: [{
      type: Input
    }],
    onDayHoverOut: [{
      type: Input
    }],
    onLabelClick: [{
      type: Input
    }],
    onLabelDoubleClick: [{
      type: Input
    }],
    onLabelRightClick: [{
      type: Input
    }],
    onLabelHoverIn: [{
      type: Input
    }],
    onLabelHoverOut: [{
      type: Input
    }],
    onLabelDelete: [{
      type: Input
    }],
    onLabelUpdateStart: [{
      type: Input
    }],
    onLabelUpdateMove: [{
      type: Input
    }],
    onLabelUpdateEnd: [{
      type: Input
    }],
    onLabelUpdateModeOn: [{
      type: Input
    }],
    onLabelUpdateModeOff: [{
      type: Input
    }]
  });
})();
function getItem$1(items, i, min, max) {
  var item;
  if (i < min || i > max) {
    return;
  }
  if (isArray(items)) {
    var len = items.length;
    var index = i % len;
    item = items[index >= 0 ? index : index + len];
  } else {
    item = items(i);
  }
  return item;
}
var ScrollviewBase = function(_super) {
  __extends(ScrollviewBase2, _super);
  function ScrollviewBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._currPos = 0;
    _this._delta = 0;
    _this._endPos = 0;
    _this._lastRaf = 0;
    _this._maxSnapScroll = 0;
    _this._margin = 0;
    _this._scrollEnd = debounce(function() {
      rafc(_this._raf);
      _this._raf = false;
      _this._onEnd();
      _this._hasScrolled = false;
    }, 200);
    _this._setInnerEl = function(el2) {
      _this._innerEl = el2;
    };
    _this._setScrollEl = function(el2) {
      _this._scrollEl = el2;
    };
    _this._setScrollEl3d = function(el2) {
      _this._scrollEl3d = el2;
    };
    _this._setScrollbarEl = function(el2) {
      _this._scrollbarEl = el2;
    };
    _this._setScrollbarContEl = function(el2) {
      _this._scrollbarContEl = el2;
    };
    _this._onStart = function(args) {
      var s = _this.s;
      _this._hook("onStart", {});
      if (s.changeOnEnd && _this._isScrolling || !s.mouseSwipe && !args.isTouch || !s.swipe) {
        return;
      }
      _this._started = true;
      _this._hasScrolled = _this._isScrolling;
      _this._currX = args.startX;
      _this._currY = args.startY;
      _this._delta = 0;
      _this._velocityX = 0;
      _this._velocityY = 0;
      _this._startPos = getPosition(_this._scrollEl, _this._isVertical);
      _this._timestamp = +/* @__PURE__ */ new Date();
      if (_this._isScrolling) {
        rafc(_this._raf);
        _this._raf = false;
        _this._scroll(_this._startPos);
      }
    };
    _this._onMove = function(args) {
      var ev = args.domEvent;
      var s = _this.s;
      if (_this._isVertical || s.scrollLock) {
        if (ev.cancelable) {
          ev.preventDefault();
        }
      } else {
        if (_this._hasScrolled) {
          if (ev.cancelable) {
            ev.preventDefault();
          }
        } else if (ev.type === TOUCH_MOVE && (Math.abs(args.deltaY) > 7 || !s.swipe)) {
          _this._started = false;
        }
      }
      if (!_this._started) {
        return;
      }
      _this._delta = _this._isVertical ? args.deltaY : args.deltaX;
      if (_this._hasScrolled || Math.abs(_this._delta) > _this._threshold) {
        if (!_this._hasScrolled) {
          _this._hook("onGestureStart", {});
        }
        _this._hasScrolled = true;
        _this._isScrolling = true;
        if (!_this._raf) {
          _this._raf = raf(function() {
            return _this._move(args);
          });
        }
      }
    };
    _this._onEnd = function() {
      _this._started = false;
      if (_this._hasScrolled) {
        var s = _this.s;
        var v = (_this._isVertical ? _this._velocityY : _this._velocityX) * 17;
        var maxSnapScroll = _this._maxSnapScroll;
        var delta = _this._delta;
        var time = 0;
        delta += v * v * 0.5 * (v < 0 ? -1 : 1);
        if (maxSnapScroll) {
          delta = constrain(delta, -_this._round * maxSnapScroll, _this._round * maxSnapScroll);
        }
        var pos = constrain(round((_this._startPos + delta) / _this._round) * _this._round, _this._min, _this._max);
        var index = round(-pos * _this._rtlNr / s.itemSize) + _this._offset;
        var direction = delta > 0 ? _this._isVertical ? 270 : 360 : _this._isVertical ? 90 : 180;
        var diff = index - s.selectedIndex;
        time = s.time || Math.max(1e3, Math.abs(pos - _this._currPos) * 3);
        _this._hook("onGestureEnd", {
          direction,
          index
        });
        _this._delta = 0;
        _this._scroll(pos, time);
        if (diff && !s.changeOnEnd) {
          _this._hook("onIndexChange", {
            index,
            diff
          });
          if (s.selectedIndex === _this._prevIndex && s.selectedIndex !== index) {
            _this.forceUpdate();
          }
        }
      }
    };
    _this._onClick = function(ev) {
      if (_this._hasScrolled) {
        _this._hasScrolled = false;
        ev.stopPropagation();
        ev.preventDefault();
      }
    };
    _this._onScroll = function(ev) {
      ev.target.scrollTop = 0;
      ev.target.scrollLeft = 0;
    };
    _this._onMouseWheel = function(ev) {
      var delta = _this._isVertical ? ev.deltaY === UNDEFINED ? ev.wheelDelta || ev.detail : ev.deltaY : ev.deltaX;
      if (delta && _this.s.mousewheel) {
        ev.preventDefault();
        _this._hook("onStart", {});
        if (!_this._started) {
          _this._delta = 0;
          _this._velocityX = 0;
          _this._velocityY = 0;
          _this._startPos = _this._currPos;
          _this._hook("onGestureStart", {});
        }
        if (ev.deltaMode && ev.deltaMode === 1) {
          delta *= 15;
        }
        delta = constrain(-delta, -_this._scrollSnap, _this._scrollSnap);
        _this._delta += delta;
        if (_this._maxSnapScroll && Math.abs(_this._delta) > _this._round * _this._maxSnapScroll) {
          delta = 0;
        }
        if (_this._startPos + _this._delta < _this._min) {
          _this._startPos = _this._min;
          _this._delta = 0;
          delta = 0;
        }
        if (_this._startPos + _this._delta > _this._max) {
          _this._startPos = _this._max;
          _this._delta = 0;
          delta = 0;
        }
        if (!_this._raf) {
          _this._raf = raf(function() {
            return _this._move();
          });
        }
        if (!delta && _this._started) {
          return;
        }
        _this._hasScrolled = true;
        _this._isScrolling = true;
        _this._started = true;
        _this._scrollEnd();
      }
    };
    _this._onTrackStart = function(ev) {
      ev.stopPropagation();
      var args = {
        domEvent: ev,
        startX: getCoord(ev, "X", true),
        startY: getCoord(ev, "Y", true)
      };
      _this._onStart(args);
      _this._trackStartX = args.startX;
      _this._trackStartY = args.startY;
      if (ev.target === _this._scrollbarEl) {
        listen(_this._doc, MOUSE_UP, _this._onTrackEnd);
        listen(_this._doc, MOUSE_MOVE, _this._onTrackMove);
      } else {
        var top_1 = getOffset(_this._scrollbarContEl).top;
        var percent = (args.startY - top_1) / _this._barContSize;
        _this._startPos = _this._currPos = _this._max + (_this._min - _this._max) * percent;
        _this._hasScrolled = true;
        _this._onEnd();
      }
    };
    _this._onTrackMove = function(ev) {
      var barContSize = _this._barContSize;
      var endX = getCoord(ev, "X", true);
      var endY = getCoord(ev, "Y", true);
      var trackDelta = _this._isVertical ? endY - _this._trackStartY : endX - _this._trackStartX;
      var percent = trackDelta / barContSize;
      if (_this._isInfinite) {
        _this._delta = -(_this._maxSnapScroll * _this._round * 2 + barContSize) * percent;
      } else {
        _this._delta = (_this._min - _this._max - barContSize) * percent;
      }
      if (_this._hasScrolled || Math.abs(_this._delta) > _this._threshold) {
        if (!_this._hasScrolled) {
          _this._hook("onGestureStart", {});
        }
        _this._hasScrolled = true;
        _this._isScrolling = true;
        if (!_this._raf) {
          _this._raf = raf(function() {
            return _this._move({
              endX,
              endY
            }, !_this._isInfinite);
          });
        }
      }
    };
    _this._onTrackEnd = function() {
      _this._delta = 0;
      _this._startPos = _this._currPos;
      _this._onEnd();
      unlisten(_this._doc, MOUSE_UP, _this._onTrackEnd);
      unlisten(_this._doc, MOUSE_MOVE, _this._onTrackMove);
    };
    _this._onTrackClick = function(ev) {
      ev.stopPropagation();
    };
    return _this;
  }
  ScrollviewBase2.prototype._render = function(s, state) {
    var prevS = this._prevS;
    var batchSize = s.batchSize;
    var batchSize3d = s.batchSize3d;
    var itemNr = s.itemNr || 1;
    var itemSize = s.itemSize;
    var selectedIndex = s.selectedIndex;
    var prevIndex = prevS.selectedIndex;
    var currIndex = state.index === UNDEFINED ? selectedIndex : state.index;
    var visibleItems = [];
    var visible3dItems = [];
    var diff = selectedIndex - prevIndex;
    var diff2 = currIndex - this._currIndex;
    var minIndex = s.minIndex;
    var maxIndex = s.maxIndex;
    var items = s.items;
    var offset = s.offset;
    this._currIndex = currIndex;
    this._isVertical = s.axis === "Y";
    this._threshold = this._isVertical ? s.thresholdY : s.thresholdX;
    this._rtlNr = !this._isVertical && s.rtl ? -1 : 1;
    this._round = s.snap ? itemSize : 1;
    var scrollSnap = this._round;
    while (scrollSnap > 44) {
      scrollSnap /= 2;
    }
    this._scrollSnap = round(44 / scrollSnap) * scrollSnap;
    if (items) {
      for (var i = currIndex - batchSize; i < currIndex + itemNr + batchSize; i++) {
        visibleItems.push({
          key: i,
          data: getItem$1(items, i, minIndex, maxIndex)
        });
      }
      if (s.scroll3d) {
        for (var i = currIndex - batchSize3d; i < currIndex + itemNr + batchSize3d; i++) {
          visible3dItems.push({
            key: i,
            data: getItem$1(items, i, minIndex, maxIndex)
          });
        }
      }
      this.visibleItems = visibleItems;
      this.visible3dItems = visible3dItems;
      this._maxSnapScroll = batchSize;
      this._isInfinite = typeof items === "function";
    }
    if (this._offset === UNDEFINED) {
      this._offset = selectedIndex;
    }
    var nextPos = -(selectedIndex - this._offset) * itemSize * this._rtlNr;
    if (Math.abs(diff) > batchSize && nextPos !== this._endPos) {
      var off = diff + batchSize * (diff > 0 ? -1 : 1);
      this._offset += off;
      this._margin -= off;
    }
    if (offset && offset !== prevS.offset) {
      this._offset += offset;
      this._margin -= offset;
    }
    if (diff2) {
      this._margin += diff2;
    }
    if (minIndex !== UNDEFINED) {
      this._max = -(minIndex - this._offset) * itemSize * this._rtlNr;
    } else {
      this._max = Infinity;
    }
    if (maxIndex !== UNDEFINED) {
      this._min = -(maxIndex - this._offset - (s.spaceAround ? 0 : itemNr - 1)) * itemSize * this._rtlNr;
    } else {
      this._min = -Infinity;
    }
    if (this._rtlNr === -1) {
      var temp = this._min;
      this._min = this._max;
      this._max = temp;
    }
    if (this._min > this._max) {
      this._min = this._max;
    }
    var visibleSize = s.visibleSize;
    var barContSize = visibleSize * itemSize;
    this._barContSize = barContSize;
    this._barSize = Math.max(20, barContSize * barContSize / (this._max - this._min + barContSize));
    this._cssClass = this._className + " mbsc-ltr";
  };
  ScrollviewBase2.prototype._mounted = function() {
    var el2 = this._el;
    var scrollbar = this._scrollbarContEl;
    this._doc = getDocument(el2);
    listen(this.s.scroll3d ? this._innerEl : el2, SCROLL, this._onScroll);
    listen(el2, CLICK, this._onClick, true);
    listen(el2, MOUSE_WHEEL, this._onMouseWheel, {
      passive: false
    });
    listen(el2, WHEEL, this._onMouseWheel, {
      passive: false
    });
    listen(scrollbar, MOUSE_DOWN, this._onTrackStart);
    listen(scrollbar, CLICK, this._onTrackClick);
    this._unlisten = gestureListener(el2, {
      onEnd: this._onEnd,
      onHoverIn: function() {
        scrollbar.classList.add("mbsc-scroller-bar-hover");
      },
      onHoverOut: function() {
        scrollbar.classList.remove("mbsc-scroller-bar-hover");
      },
      onMove: this._onMove,
      onStart: this._onStart,
      prevDef: true
    });
  };
  ScrollviewBase2.prototype._updated = function() {
    var s = this.s;
    var batchSize = s.batchSize;
    var itemSize = s.itemSize;
    var selectedIndex = s.selectedIndex;
    var prevIndex = this._prevIndex;
    var shouldAnimate = !s.prevAnim && (prevIndex !== UNDEFINED && prevIndex !== selectedIndex || this._isAnimating);
    var newPos = -(selectedIndex - this._offset) * itemSize * this._rtlNr;
    if (s.margin) {
      this._scrollEl.style.marginTop = this._isVertical ? (this._margin - batchSize) * itemSize + "px" : "";
    }
    if (!this._started) {
      this._scroll(newPos, shouldAnimate ? this._isAnimating || s.time || 1e3 : 0);
    }
    this._prevIndex = selectedIndex;
  };
  ScrollviewBase2.prototype._destroy = function() {
    unlisten(this.s.scroll3d ? this._innerEl : this._el, SCROLL, this._onScroll);
    unlisten(this._el, CLICK, this._onClick, true);
    unlisten(this._el, MOUSE_WHEEL, this._onMouseWheel, {
      passive: false
    });
    unlisten(this._el, WHEEL, this._onMouseWheel, {
      passive: false
    });
    unlisten(this._scrollbarContEl, MOUSE_DOWN, this._onTrackStart);
    unlisten(this._scrollbarContEl, CLICK, this._onTrackClick);
    rafc(this._raf);
    this._raf = false;
    this._scroll(0);
    this._unlisten();
  };
  ScrollviewBase2.prototype._anim = function(dir) {
    var _this = this;
    return this._raf = raf(function() {
      var s = _this.s;
      var now = +/* @__PURE__ */ new Date();
      if (!_this._raf) {
        return;
      }
      if ((_this._currPos - _this._endPos) * -dir < 4) {
        _this._currPos = _this._endPos;
        _this._raf = false;
        _this._isAnimating = 0;
        _this._isScrolling = false;
        _this._infinite(_this._currPos);
        _this._hook("onAnimationEnd", {});
        _this._scrollbarContEl.classList.remove("mbsc-scroller-bar-started");
        return;
      }
      if (now - _this._lastRaf > 100) {
        _this._lastRaf = now;
        _this._currPos = getPosition(_this._scrollEl, _this._isVertical);
        if (!s.changeOnEnd) {
          _this._infinite(_this._currPos);
        }
      }
      _this._raf = _this._anim(dir);
    });
  };
  ScrollviewBase2.prototype._infinite = function(pos) {
    var s = this.s;
    if (s.itemSize) {
      var index = round(-pos * this._rtlNr / s.itemSize) + this._offset;
      var diff = index - this._currIndex;
      if (diff) {
        if (s.changeOnEnd) {
          this._hook("onIndexChange", {
            index,
            diff
          });
        } else {
          this.setState({
            index
          });
        }
      }
    }
  };
  ScrollviewBase2.prototype._scroll = function(pos, time) {
    var s = this.s;
    var itemSize = s.itemSize;
    var isVertical = this._isVertical;
    var style = this._scrollEl.style;
    var prefix = jsPrefix ? jsPrefix + "T" : "t";
    var timing = time ? cssPrefix + "transform " + round(time) + "ms " + s.easing : "";
    style[prefix + "ransform"] = "translate3d(" + (isVertical ? "0," + pos + "px," : pos + "px,0,") + "0)";
    style[prefix + "ransition"] = timing;
    this._endPos = pos;
    if (s.scroll3d) {
      var style3d = this._scrollEl3d.style;
      var angle = 360 / (s.batchSize3d * 2);
      style3d[prefix + "ransform"] = "translateY(-50%) rotateX(" + -pos / itemSize * angle + "deg)";
      style3d[prefix + "ransition"] = timing;
    }
    if (this._scrollbarEl) {
      var sbStyle = this._scrollbarEl.style;
      var percent = this._isInfinite ? (this._maxSnapScroll * this._round - this._delta) / (this._maxSnapScroll * this._round * 2) : (pos - this._max) / (this._min - this._max);
      var barPos = constrain((this._barContSize - this._barSize) * percent, 0, this._barContSize - this._barSize);
      sbStyle[prefix + "ransform"] = "translate3d(" + (isVertical ? "0," + barPos + "px," : barPos + "px,0,") + "0)";
      sbStyle[prefix + "ransition"] = timing;
    }
    if (time) {
      rafc(this._raf);
      this._isAnimating = time;
      this._scrollbarContEl.classList.add("mbsc-scroller-bar-started");
      this._raf = this._anim(pos > this._currPos ? 1 : -1);
    } else {
      this._currPos = pos;
      if (!s.changeOnEnd) {
        this._infinite(pos);
      }
    }
  };
  ScrollviewBase2.prototype._move = function(args, preventMaxSnap) {
    var prevX = this._currX;
    var prevY = this._currY;
    var prevT = this._timestamp;
    var maxSnapScroll = this._maxSnapScroll;
    if (args) {
      this._currX = args.endX;
      this._currY = args.endY;
      this._timestamp = +/* @__PURE__ */ new Date();
      var timeDelta = this._timestamp - prevT;
      if (timeDelta > 0 && timeDelta < 100) {
        var velocityX = (this._currX - prevX) / timeDelta;
        var velocityY = (this._currY - prevY) / timeDelta;
        this._velocityX = velocityX * 0.7 + this._velocityX * 0.3;
        this._velocityY = velocityY * 0.7 + this._velocityY * 0.3;
      }
    }
    if (maxSnapScroll && !preventMaxSnap) {
      this._delta = constrain(this._delta, -this._round * maxSnapScroll, this._round * maxSnapScroll);
    }
    this._scroll(constrain(this._startPos + this._delta, this._min - this.s.itemSize, this._max + this.s.itemSize));
    this._raf = false;
  };
  ScrollviewBase2.defaults = {
    axis: "Y",
    batchSize: 40,
    easing: "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
    mouseSwipe: true,
    mousewheel: true,
    prevDef: true,
    selectedIndex: 0,
    spaceAround: true,
    stopProp: true,
    swipe: true,
    thresholdX: 10,
    thresholdY: 5
  };
  ScrollviewBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵScrollviewBase_BaseFactory;
    return function ScrollviewBase_Factory(__ngFactoryType__) {
      return (ɵScrollviewBase_BaseFactory || (ɵScrollviewBase_BaseFactory = ɵɵgetInheritedFactory(ScrollviewBase2)))(__ngFactoryType__ || ScrollviewBase2);
    };
  })();
  ScrollviewBase2.ɵdir = ɵɵdefineDirective({
    type: ScrollviewBase2,
    selectors: [["", "mbsc-sv-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return ScrollviewBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollviewBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sv-b]"
    }]
  }], null, null);
})();
var MbscScrollviewBase = function(_super) {
  __extends(MbscScrollviewBase2, _super);
  function MbscScrollviewBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(MbscScrollviewBase2.prototype, "vEl3d", {
    set: function(el2) {
      this._scrollEl3d = el2 && el2.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  MbscScrollviewBase2.prototype._mounted = function() {
    this._innerEl = this.vInnerEl.nativeElement;
    this._scrollEl = this.vEl.nativeElement;
    this._scrollbarContEl = this.vBarCont.nativeElement;
    this._scrollbarEl = this.vBar.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscScrollviewBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscScrollviewBase_BaseFactory;
    return function MbscScrollviewBase_Factory(__ngFactoryType__) {
      return (ɵMbscScrollviewBase_BaseFactory || (ɵMbscScrollviewBase_BaseFactory = ɵɵgetInheritedFactory(MbscScrollviewBase2)))(__ngFactoryType__ || MbscScrollviewBase2);
    };
  })();
  MbscScrollviewBase2.ɵcmp = ɵɵdefineComponent({
    type: MbscScrollviewBase2,
    selectors: [["mbsc-scrollview-base"]],
    viewQuery: function MbscScrollviewBase_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c16, 7);
        ɵɵviewQuery(_c17, 7);
        ɵɵviewQuery(_c18, 7);
        ɵɵviewQuery(_c19, 7);
        ɵɵviewQuery(_c20, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInnerEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vBarCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vBar = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vEl3d = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscScrollviewBase_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      axis: "axis",
      batchSize: "batchSize",
      batchSize3d: "batchSize3d",
      changeOnEnd: "changeOnEnd",
      easing: "easing",
      innerClass: "innerClass",
      innerStyles: "innerStyles",
      items: "items",
      itemSize: "itemSize",
      itemNr: "itemNr",
      selectedIndex: "selectedIndex",
      margin: "margin",
      maxIndex: "maxIndex",
      minIndex: "minIndex",
      mouseSwipe: "mouseSwipe",
      mousewheel: "mousewheel",
      offset: "offset",
      prevAnim: "prevAnim",
      scroll3d: "scroll3d",
      scrollBar: "scrollBar",
      snap: "snap",
      spaceAround: "spaceAround",
      swipe: "swipe",
      time: "time",
      touchUi: "touchUi",
      visibleSize: "visibleSize",
      onAnimationEnd: "onAnimationEnd",
      onGestureStart: "onGestureStart",
      onGestureEnd: "onGestureEnd",
      onIndexChange: "onIndexChange",
      onStart: "onStart"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c22,
    decls: 10,
    vars: 12,
    consts: [["innerEl", ""], ["el", ""], ["barCont", ""], ["bar", ""], ["el3d", ""], [3, "ngStyle"], ["class", "mbsc-scroller-items-3d", 3, "height", 4, "ngIf"], [1, "mbsc-scroller-items-3d"]],
    template: function MbscScrollviewBase_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef(_c21);
        ɵɵelementStart(0, "div", 5, 0)(2, "div", null, 1);
        ɵɵprojection(4);
        ɵɵelementEnd()();
        ɵɵtemplate(5, MbscScrollviewBase_div_5_Template, 3, 2, "div", 6);
        ɵɵelementStart(6, "div", null, 2);
        ɵɵelement(8, "div", null, 3);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2.s.innerClass || "");
        ɵɵproperty("ngStyle", ctx2.s.innerStyles);
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-scrollview-scroll" + ctx2._rtl);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx2.s.scroll3d);
        ɵɵadvance();
        ɵɵclassMap("mbsc-scroller-bar-cont" + ctx2._rtl + (!ctx2.s.scrollBar || ctx2._barSize === ctx2._barContSize ? " mbsc-scroller-bar-hidden" : "") + (ctx2._started ? " mbsc-scroller-bar-started" : ""));
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-scroller-bar" + ctx2._theme);
        ɵɵstyleProp("height", ctx2._barSize, "px");
      }
    },
    dependencies: [NgStyle, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscScrollviewBase2;
}(ScrollviewBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscScrollviewBase, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-scrollview-base",
      template: `
    <div #innerEl [class]="s.innerClass || ''" [ngStyle]="s.innerStyles">
      <div #el [class]="'mbsc-scrollview-scroll' + _rtl">
        <ng-content></ng-content>
      </div>
    </div>
    <div *ngIf="s.scroll3d" #el3d [style.height.px]="s.itemSize" class="mbsc-scroller-items-3d">
      <ng-content select="[content-3d]"></ng-content>
    </div>
    <div
      [class]="
        'mbsc-scroller-bar-cont' +
        _rtl +
        (!s.scrollBar || _barSize === _barContSize ? ' mbsc-scroller-bar-hidden' : '') +
        (_started ? ' mbsc-scroller-bar-started' : '')
      "
      #barCont
    >
      <div [class]="'mbsc-scroller-bar' + _theme" #bar [style.height.px]="_barSize"></div>
    </div>
  `
    }]
  }], null, {
    vEl: [{
      type: ViewChild,
      args: ["el", {
        static: true
      }]
    }],
    vInnerEl: [{
      type: ViewChild,
      args: ["innerEl", {
        static: true
      }]
    }],
    vBarCont: [{
      type: ViewChild,
      args: ["barCont", {
        static: true
      }]
    }],
    vBar: [{
      type: ViewChild,
      args: ["bar", {
        static: true
      }]
    }],
    axis: [{
      type: Input
    }],
    batchSize: [{
      type: Input
    }],
    batchSize3d: [{
      type: Input
    }],
    changeOnEnd: [{
      type: Input
    }],
    easing: [{
      type: Input
    }],
    innerClass: [{
      type: Input
    }],
    innerStyles: [{
      type: Input
    }],
    items: [{
      type: Input
    }],
    itemSize: [{
      type: Input
    }],
    itemNr: [{
      type: Input
    }],
    selectedIndex: [{
      type: Input
    }],
    margin: [{
      type: Input
    }],
    maxIndex: [{
      type: Input
    }],
    minIndex: [{
      type: Input
    }],
    mouseSwipe: [{
      type: Input
    }],
    mousewheel: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    prevAnim: [{
      type: Input
    }],
    scroll3d: [{
      type: Input
    }],
    scrollBar: [{
      type: Input
    }],
    snap: [{
      type: Input
    }],
    spaceAround: [{
      type: Input
    }],
    swipe: [{
      type: Input
    }],
    time: [{
      type: Input
    }],
    touchUi: [{
      type: Input
    }],
    visibleSize: [{
      type: Input
    }],
    onAnimationEnd: [{
      type: Input
    }],
    onGestureStart: [{
      type: Input
    }],
    onGestureEnd: [{
      type: Input
    }],
    onIndexChange: [{
      type: Input
    }],
    onStart: [{
      type: Input
    }],
    vEl3d: [{
      type: ViewChild,
      args: ["el3d", {
        static: false
      }]
    }]
  });
})();
var MbscMultiYearView = function() {
  function MbscMultiYearView2() {
  }
  MbscMultiYearView2.prototype.ngOnChanges = function() {
    this._rows = [];
    this._selectedYear = this.getYear(new Date(this.active));
    this._activeYear = this.getYear(new Date(this.activeMonth));
    for (var i = 0; i < 4; i++) {
      var row = [];
      for (var j = 0; j < 3; j++) {
        var year = this.firstYear + i * 3 + j;
        var d = +this.getDate(year, 0, 1);
        row.push({
          d,
          year
        });
      }
      this._rows.push(row);
    }
  };
  MbscMultiYearView2.prototype.getKey = function(index, item) {
    return item.key;
  };
  MbscMultiYearView2.ɵfac = function MbscMultiYearView_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscMultiYearView2)();
  };
  MbscMultiYearView2.ɵcmp = ɵɵdefineComponent({
    type: MbscMultiYearView2,
    selectors: [["mbsc-multi-year-view"]],
    hostAttrs: [1, "mbsc-calendar-table", "mbsc-flex-col"],
    inputs: {
      active: "active",
      activeMonth: "activeMonth",
      firstYear: "firstYear",
      getDate: "getDate",
      getYear: "getYear",
      max: "max",
      min: "min",
      rtl: "rtl",
      theme: "theme",
      yearSuffix: "yearSuffix",
      onYearClick: "onYearClick"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 1,
    vars: 2,
    consts: [["class", "mbsc-calendar-row mbsc-flex mbsc-flex-1-0", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-calendar-row", "mbsc-flex", "mbsc-flex-1-0"], ["type", "year", 3, "active", "date", "display", "selected", "disabled", "rtl", "text", "theme", "onDayClick", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["type", "year", 3, "active", "date", "display", "selected", "disabled", "rtl", "text", "theme", "onDayClick"]],
    template: function MbscMultiYearView_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscMultiYearView_div_0_Template, 2, 2, "div", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx2._rows)("ngForTrackBy", ctx2.getKey);
      }
    },
    dependencies: [MbscCalendarDay, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscMultiYearView2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscMultiYearView, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "mbsc-calendar-table mbsc-flex-col"
      },
      selector: "mbsc-multi-year-view",
      template: '<div class="mbsc-calendar-row mbsc-flex mbsc-flex-1-0" *ngFor="let row of _rows; trackBy: getKey">\n    <mbsc-calendar-day\n      *ngFor="let cell of row; trackBy: getKey"\n      [active]="cell.year === _activeYear"\n      [date]="cell.d"\n      [display]="true"\n      [selected]="cell.year === _selectedYear"\n      [disabled]="cell.year < this.min || cell.year > this.max"\n      [rtl]="rtl"\n      [text]="cell.year + yearSuffix"\n      [theme]="theme"\n      type="year"\n      [onDayClick]="onYearClick"\n    ></mbsc-calendar-day>\n  </div>'
    }]
  }], null, {
    active: [{
      type: Input
    }],
    activeMonth: [{
      type: Input
    }],
    firstYear: [{
      type: Input
    }],
    getDate: [{
      type: Input
    }],
    getYear: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    yearSuffix: [{
      type: Input
    }],
    onYearClick: [{
      type: Input
    }]
  });
})();
var MbscYearView = function() {
  function MbscYearView2() {
  }
  MbscYearView2.prototype.ngOnChanges = function() {
    this._rows = [];
    var active = new Date(this.activeMonth);
    var selected = new Date(this.active);
    this._activeYear = this.getYear(active);
    this._activeMonth = this.getMonth(active);
    this._selectedYear = this.getYear(selected);
    this._selectedMonth = this.getMonth(selected);
    for (var i = 0; i < 4; i++) {
      var row = [];
      for (var j = 0; j < 3; j++) {
        var d = this.getDate(this.year, i * 3 + j, 1);
        var y = this.getYear(d);
        var m = this.getMonth(d);
        row.push({
          d,
          y,
          m
        });
      }
      this._rows.push(row);
    }
  };
  MbscYearView2.prototype.getKey = function(index, item) {
    return item.key;
  };
  MbscYearView2.ɵfac = function MbscYearView_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscYearView2)();
  };
  MbscYearView2.ɵcmp = ɵɵdefineComponent({
    type: MbscYearView2,
    selectors: [["mbsc-year-view"]],
    hostAttrs: [1, "mbsc-calendar-table", "mbsc-flex-col"],
    inputs: {
      active: "active",
      activeMonth: "activeMonth",
      getDate: "getDate",
      getMonth: "getMonth",
      getYear: "getYear",
      max: "max",
      min: "min",
      monthNames: "monthNames",
      monthNamesShort: "monthNamesShort",
      rtl: "rtl",
      theme: "theme",
      year: "year",
      onMonthClick: "onMonthClick"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature],
    decls: 1,
    vars: 2,
    consts: [["class", "mbsc-calendar-row mbsc-flex mbsc-flex-1-0", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-calendar-row", "mbsc-flex", "mbsc-flex-1-0"], ["type", "month", 3, "active", "date", "display", "selected", "disabled", "month", "rtl", "text", "theme", "onDayClick", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["type", "month", 3, "active", "date", "display", "selected", "disabled", "month", "rtl", "text", "theme", "onDayClick"]],
    template: function MbscYearView_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscYearView_div_0_Template, 2, 2, "div", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx2._rows)("ngForTrackBy", ctx2.getKey);
      }
    },
    dependencies: [MbscCalendarDay, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscYearView2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscYearView, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "mbsc-calendar-table mbsc-flex-col"
      },
      selector: "mbsc-year-view",
      template: '<div class="mbsc-calendar-row mbsc-flex mbsc-flex-1-0" *ngFor="let row of _rows; trackBy: getKey">\n    <mbsc-calendar-day\n      *ngFor="let cell of row; trackBy: getKey"\n      [active]="cell.y === _activeYear && cell.m === _activeMonth"\n      [date]="cell.d"\n      [display]="true"\n      [selected]="cell.y === _selectedYear && cell.m === _selectedMonth"\n      [disabled]="cell.d < min || cell.d >= max"\n      [month]="monthNames[cell.m]"\n      [rtl]="rtl"\n      [text]="monthNamesShort[cell.m]"\n      [theme]="theme"\n      type="month"\n      [onDayClick]="onMonthClick"\n    ></mbsc-calendar-day>\n  </div>'
    }]
  }], null, {
    active: [{
      type: Input
    }],
    activeMonth: [{
      type: Input
    }],
    getDate: [{
      type: Input
    }],
    getMonth: [{
      type: Input
    }],
    getYear: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    monthNames: [{
      type: Input
    }],
    monthNamesShort: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    year: [{
      type: Input
    }],
    onMonthClick: [{
      type: Input
    }]
  });
})();
var MbscCalendarView = function(_super) {
  __extends(MbscCalendarView2, _super);
  function MbscCalendarView2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._noop = noop;
    return _this;
  }
  MbscCalendarView2.prototype._getFirstDay = function() {
    return +this.s.navService.firstDay;
  };
  MbscCalendarView2.prototype._getMonthName = function(item) {
    return this.s.monthNames[this.s.getMonth(new Date(item))];
  };
  MbscCalendarView2.prototype._mounted = function() {
    this._body = this.vBody.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscCalendarView2.prototype._updated = function() {
    this._pickerCont = this.vPickerCont && this.vPickerCont.nativeElement;
    _super.prototype._updated.call(this);
  };
  MbscCalendarView2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendarView_BaseFactory;
    return function MbscCalendarView_Factory(__ngFactoryType__) {
      return (ɵMbscCalendarView_BaseFactory || (ɵMbscCalendarView_BaseFactory = ɵɵgetInheritedFactory(MbscCalendarView2)))(__ngFactoryType__ || MbscCalendarView2);
    };
  })();
  MbscCalendarView2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendarView2,
    selectors: [["mbsc-calendar-view"]],
    viewQuery: function MbscCalendarView_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c23, 5);
        ɵɵviewQuery(_c24, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vBody = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vPickerCont = _t.first);
      }
    },
    hostVars: 6,
    hostBindings: function MbscCalendarView_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("click", function MbscCalendarView_click_HostBindingHandler() {
          return ctx2._noop;
        });
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
        ɵɵstyleProp("height", ctx2._dim.height)("width", ctx2._dim.width);
      }
    },
    inputs: {
      activeDate: "activeDate",
      cssClass: "cssClass",
      clickToCreate: "clickToCreate",
      colors: "colors",
      dataTimezone: "dataTimezone",
      dayTemplate: "dayTemplate",
      dayContentTemplate: "dayContentTemplate",
      displayTimezone: "displayTimezone",
      dragToCreate: "dragToCreate",
      dragToResize: "dragToResize",
      dragToMove: "dragToMove",
      endDay: "endDay",
      eventExact: "eventExact",
      eventMap: "eventMap",
      eventOrder: "eventOrder",
      eventRange: "eventRange",
      eventRangeSize: "eventRangeSize",
      exclusiveEndDates: "exclusiveEndDates",
      fromText: "fromText",
      hasContent: "hasContent",
      hasPicker: "hasPicker",
      headerTemplate: "headerTemplate",
      height: "height",
      hoverEnd: "hoverEnd",
      hoverStart: "hoverStart",
      invalid: "invalid",
      instanceService: "instanceService",
      isPicker: "isPicker",
      labels: "labels",
      labelsMap: "labelsMap",
      labelTemplate: "labelTemplate",
      labelContentTemplate: "labelContentTemplate",
      dragData: "dragData",
      max: "max",
      marked: "marked",
      marksMap: "marksMap",
      min: "min",
      mouseSwipe: "mouseSwipe",
      mousewheel: "mousewheel",
      navService: "navService",
      navView: "navView",
      noOuterChange: "noOuterChange",
      downIcon: "downIcon",
      nextIconH: "nextIconH",
      nextIconV: "nextIconV",
      nextPageText: "nextPageText",
      prevIconH: "prevIconH",
      prevIconV: "prevIconV",
      prevPageText: "prevPageText",
      upIcon: "upIcon",
      pages: "pages",
      pageLoad: "pageLoad",
      refDate: "refDate",
      resourcesMap: "resourcesMap",
      rangeEnd: "rangeEnd",
      rangeStart: "rangeStart",
      responsiveStyle: "responsiveStyle",
      selectedDates: "selectedDates",
      selectedEventsMap: "selectedEventsMap",
      selectView: "selectView",
      showCalendar: "showCalendar",
      showControls: "showControls",
      showEventTooltip: "showEventTooltip",
      showLabelCount: "showLabelCount",
      showOuterDays: "showOuterDays",
      showSchedule: "showSchedule",
      showToday: "showToday",
      showWeekNumbers: "showWeekNumbers",
      size: "size",
      startDay: "startDay",
      swipe: "swipe",
      labelList: "labelList",
      timeFormat: "timeFormat",
      timezonePlugin: "timezonePlugin",
      update: "update",
      valid: "valid",
      weeks: "weeks",
      width: "width",
      calendarScroll: "calendarScroll",
      calendarType: "calendarType",
      getDate: "getDate",
      getDay: "getDay",
      getMaxDayOfMonth: "getMaxDayOfMonth",
      getMonth: "getMonth",
      getWeekNumber: "getWeekNumber",
      getYear: "getYear",
      amText: "amText",
      dateFormat: "dateFormat",
      dayNames: "dayNames",
      dayNamesMin: "dayNamesMin",
      dayNamesShort: "dayNamesShort",
      eventText: "eventText",
      eventsText: "eventsText",
      firstDay: "firstDay",
      monthNames: "monthNames",
      monthNamesShort: "monthNamesShort",
      moreEventsPluralText: "moreEventsPluralText",
      moreEventsText: "moreEventsText",
      pmText: "pmText",
      todayText: "todayText",
      toText: "toText",
      weekText: "weekText",
      yearSuffix: "yearSuffix",
      onActiveChange: "onActiveChange",
      onCellHoverIn: "onCellHoverIn",
      onCellHoverOut: "onCellHoverOut",
      onDayClick: "onDayClick",
      onDayDoubleClick: "onDayDoubleClick",
      onDayRightClick: "onDayRightClick",
      onDayHoverIn: "onDayHoverIn",
      onDayHoverOut: "onDayHoverOut",
      onGestureStart: "onGestureStart",
      onLabelClick: "onLabelClick",
      onLabelDoubleClick: "onLabelDoubleClick",
      onLabelRightClick: "onLabelRightClick",
      onLabelHoverIn: "onLabelHoverIn",
      onLabelHoverOut: "onLabelHoverOut",
      onLabelDelete: "onLabelDelete",
      onLabelUpdateStart: "onLabelUpdateStart",
      onLabelUpdateMove: "onLabelUpdateMove",
      onLabelUpdateEnd: "onLabelUpdateEnd",
      onLabelUpdateModeOn: "onLabelUpdateModeOn",
      onLabelUpdateModeOff: "onLabelUpdateModeOff",
      onPageChange: "onPageChange",
      onPageLoaded: "onPageLoaded",
      onPageLoading: "onPageLoading",
      onResize: "onResize",
      onTodayClick: "onTodayClick"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 13,
    vars: 10,
    consts: [["monthView", ""], ["body", ""], ["picker", ""], ["defaultHeader", ""], ["scrollview", ""], ["pickerCont", ""], ["multiYearView", ""], ["yearView", ""], ["montView", ""], [3, "class", 4, "ngIf"], [3, "dayNamesShort", "firstDay", "hasScroll", "hidden", "showWeekNumbers", "rtl", "theme", 4, "ngIf"], [3, "keydown"], ["class", "mbsc-calendar-popup", "display", "anchored", 3, "anchor", "closeOnScroll", "contentPadding", "context", "isOpen", "locale", "rtl", "scrollLock", "showOverlay", "theme", "themeVariant", "onClose", "onOpen", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "mbsc-flex", "mbsc-flex-1-1", "mbsc-calendar-title-wrapper"], [1, "mbsc-calendar-header-today"], [3, "dayNamesShort", "firstDay", "hasScroll", "hidden", "showWeekNumbers", "rtl", "theme"], [3, "activeDate", "amText", "calendarType", "cellTextHeight", "clickToCreate", "colors", "dayNames", "dayNamesShort", "dayTemplate", "dayContentTemplate", "dataTimezone", "displayTimezone", "dragData", "dragToCreate", "dragToResize", "dragToMove", "eventText", "events", "eventsText", "exclusiveEndDates", "firstDay", "firstPageDay", "getDate", "getDay", "getMonth", "getYear", "getWeekNumber", "hasMarks", "hoverEnd", "hoverStart", "invalid", "isActive", "isPicker", "labels", "labelHeight", "labelTemplate", "labelContentTemplate", "marked", "max", "min", "monthNames", "monthNamesShort", "onDayClick", "onDayDoubleClick", "onDayRightClick", "onDayHoverIn", "onDayHoverOut", "onLabelClick", "onLabelDoubleClick", "onLabelRightClick", "onLabelHoverIn", "onLabelHoverOut", "onLabelDelete", "onLabelUpdateStart", "onLabelUpdateMove", "onLabelUpdateEnd", "onLabelUpdateModeOn", "onLabelUpdateModeOff", "pmText", "rangeEnd", "rangeStart", "resourcesMap", "rtl", "selectedDates", "selectedEventsMap", "showEventTooltip", "showOuter", "showSingleMark", "showWeekDays", "showWeekNumbers", "theme", "timeFormat", "timezonePlugin", "todayText", "valid", "variableRow", "weeks", "weekText"], [3, "class", "animationend", 4, "ngIf"], [4, "ngIf"], ["class", "mbsc-calendar-grid-row mbsc-flex mbsc-flex-1-1", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-calendar-grid-row", "mbsc-flex", "mbsc-flex-1-1"], [3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "animationend"], ["easing", "ease-out", 1, "mbsc-calendar-scroll-wrapper", 3, "axis", "batchSize", "changeOnEnd", "items", "itemNr", "itemSize", "maxIndex", "minIndex", "mouseSwipe", "mousewheel", "onAnimationEnd", "onGestureStart", "onIndexChange", "onStart", "prevAnim", "rtl", "selectedIndex", "snap", "swipe", "time"], [3, "class", "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngStyle"], [4, "ngTemplateOutlet"], ["display", "anchored", 1, "mbsc-calendar-popup", 3, "onClose", "onOpen", "anchor", "closeOnScroll", "contentPadding", "context", "isOpen", "locale", "rtl", "scrollLock", "showOverlay", "theme", "themeVariant"], ["aria-live", "polite"], ["variant", "flat", 1, "mbsc-calendar-button", 3, "click", "theme", "themeVariant"], ["variant", "flat", 1, "mbsc-calendar-button", 3, "click", "disabled", "iconSvg", "theme", "themeVariant"], [1, "mbsc-calendar-picker-wrapper"], ["easing", "ease-out", 3, "axis", "batchSize", "changeOnEnd", "items", "itemSize", "maxIndex", "minIndex", "mousewheel", "onGestureEnd", "onIndexChange", "prevAnim", "rtl", "selectedIndex", "snap", "time"], [3, "active", "activeMonth", "firstYear", "getDate", "getYear", "max", "min", "rtl", "theme", "yearSuffix", "onYearClick"], [3, "active", "activeMonth", "getDate", "getMonth", "getYear", "max", "min", "monthNames", "monthNamesShort", "onMonthClick", "rtl", "theme", "year"], [3, "activeDate", "dataTimezone", "dayNames", "dayNamesShort", "displayTimezone", "firstDay", "firstPageDay", "getDate", "getDay", "getMonth", "getYear", "isActive", "max", "min", "monthNames", "monthNamesShort", "onDayClick", "rtl", "selectedDates", "showOuter", "showWeekDays", "theme", "timezonePlugin", "todayText"]],
    template: function MbscCalendarView_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵelementStart(0, "div")(1, "div");
        ɵɵtemplate(2, MbscCalendarView_div_2_Template, 4, 3, "div", 9)(3, MbscCalendarView_mbsc_calendar_weekdays_3_Template, 1, 7, "mbsc-calendar-weekdays", 10);
        ɵɵelementEnd();
        ɵɵtemplate(4, MbscCalendarView_ng_template_4_Template, 1, 78, "ng-template", null, 0, ɵɵtemplateRefExtractor);
        ɵɵelementStart(6, "div", 11, 1);
        ɵɵlistener("keydown", function MbscCalendarView_Template_div_keydown_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onKeyDown($event));
        });
        ɵɵtemplate(8, MbscCalendarView_div_8_Template, 5, 6, "div", 9);
        ɵɵelementEnd()();
        ɵɵprojection(9);
        ɵɵtemplate(10, MbscCalendarView_mbsc_popup_10_Template, 11, 29, "mbsc-popup", 12)(11, MbscCalendarView_ng_template_11_Template, 3, 3, "ng-template", null, 2, ɵɵtemplateRefExtractor);
      }
      if (rf & 2) {
        ɵɵclassMap("mbsc-calendar-wrapper mbsc-flex-col" + ctx2._theme + ctx2._hb + (ctx2.s.hasContent || !ctx2.s.showCalendar ? " mbsc-calendar-wrapper-fixed mbsc-flex-none" : " mbsc-flex-1-1"));
        ɵɵadvance();
        ɵɵclassMap("mbsc-calendar-header" + ctx2._theme + ctx2._hb + (ctx2._showDaysTop ? " mbsc-calendar-header-vertical" : ""));
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.showControls);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showDaysTop && ctx2.s.showCalendar);
        ɵɵadvance(3);
        ɵɵclassMap("mbsc-calendar-body mbsc-flex-col mbsc-flex-1-1" + ctx2._theme);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2.s.showCalendar);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._hasPicker);
      }
    },
    dependencies: [MbscCalendarNav, MbscCalendarPrev, MbscCalendarToday, MbscCalendarNext, MbscCalendarWeekDays, MbscMonthView, MbscScrollviewBase, MbscPopup, MbscButton, MbscMultiYearView, MbscYearView, NgIf, NgTemplateOutlet, NgForOf, NgStyle],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscCalendarView2;
}(CalendarViewBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarView, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(click)": "_noop",
        "[class]": "_cssClass",
        "[style.height]": "_dim.height",
        "[style.width]": "_dim.width"
      },
      selector: "mbsc-calendar-view",
      template: ` <div
      [class]="
        'mbsc-calendar-wrapper mbsc-flex-col' +
        _theme +
        _hb +
        (s.hasContent || !s.showCalendar ? ' mbsc-calendar-wrapper-fixed mbsc-flex-none' : ' mbsc-flex-1-1')
      "
    >
      <div [class]="'mbsc-calendar-header' + _theme + _hb + (_showDaysTop ? ' mbsc-calendar-header-vertical' : '')">
        <div *ngIf="s.showControls" [class]="'mbsc-calendar-controls mbsc-flex' + _theme">
          <ng-template [ngTemplateOutlet]="headerTemplate || defaultHeader"></ng-template>
          <ng-template #defaultHeader>
            <mbsc-calendar-nav class="mbsc-flex mbsc-flex-1-1 mbsc-calendar-title-wrapper"> </mbsc-calendar-nav>
            <mbsc-calendar-prev [class]="'mbsc-calendar-button-prev' + (_pageNr > 1 ? ' mbsc-calendar-button-prev-multi' : '')">
            </mbsc-calendar-prev>
            <mbsc-calendar-today class="mbsc-calendar-header-today"></mbsc-calendar-today>
            <mbsc-calendar-next [class]="'mbsc-calendar-button-next' + (_pageNr > 1 ? ' mbsc-calendar-button-next-multi' : '')">
            </mbsc-calendar-next>
          </ng-template>
        </div>
        <mbsc-calendar-weekdays
          *ngIf="_showDaysTop && s.showCalendar"
          [dayNamesShort]="_dayNames"
          [firstDay]="s.firstDay!"
          [hasScroll]="state.hasScrollY"
          [hidden]="_view !== PAGE_VIEW && !_hasPicker"
          [showWeekNumbers]="s.showWeekNumbers"
          [rtl]="_rtl"
          [theme]="_theme"
        >
        </mbsc-calendar-weekdays>
      </div>
      <ng-template #monthView let-timestamp="timestamp" let-drag="drag" let-isActive="isActive">
        <mbsc-month-view
          [activeDate]="_active"
          [amText]="s.amText"
          [calendarType]="s.calendarType"
          [cellTextHeight]="state.cellTextHeight"
          [clickToCreate]="s.clickToCreate"
          [colors]="_colors"
          [dayNames]="s.dayNames"
          [dayNamesShort]="_dayNames"
          [dayTemplate]="dayTemplate"
          [dayContentTemplate]="dayContentTemplate"
          [dataTimezone]="dataTimezone"
          [displayTimezone]="displayTimezone"
          [dragData]="drag && s.dragData"
          [dragToCreate]="drag && s.dragToCreate"
          [dragToResize]="drag && s.dragToResize"
          [dragToMove]="drag && s.dragToMove"
          [eventText]="s.eventText"
          [events]="s.eventMap"
          [eventsText]="s.eventsText"
          [exclusiveEndDates]="exclusiveEndDates"
          [firstDay]="s.firstDay"
          [firstPageDay]="timestamp"
          [getDate]="s.getDate"
          [getDay]="s.getDay"
          [getMonth]="s.getMonth"
          [getYear]="s.getYear"
          [getWeekNumber]="s.getWeekNumber"
          [hasMarks]="!!_marked"
          [hoverEnd]="s.hoverEnd"
          [hoverStart]="s.hoverStart"
          [invalid]="_invalid"
          [isActive]="isActive"
          [isPicker]="s.isPicker"
          [labels]="_labelsLayout"
          [labelHeight]="state.labelHeight"
          [labelTemplate]="labelTemplate"
          [labelContentTemplate]="labelContentTemplate"
          [marked]="_marked"
          [max]="_maxDate"
          [min]="_minDate"
          [monthNames]="s.monthNames"
          [monthNamesShort]="s.monthNamesShort"
          [onDayClick]="_onDayClick"
          [onDayDoubleClick]="s.onDayDoubleClick"
          [onDayRightClick]="s.onDayRightClick"
          [onDayHoverIn]="_onDayHoverIn"
          [onDayHoverOut]="_onDayHoverOut"
          [onLabelClick]="_onLabelClick"
          [onLabelDoubleClick]="s.onLabelDoubleClick"
          [onLabelRightClick]="s.onLabelRightClick"
          [onLabelHoverIn]="s.onLabelHoverIn"
          [onLabelHoverOut]="s.onLabelHoverOut"
          [onLabelDelete]="s.onLabelDelete"
          [onLabelUpdateStart]="drag && s.onLabelUpdateStart"
          [onLabelUpdateMove]="drag && s.onLabelUpdateMove"
          [onLabelUpdateEnd]="drag && s.onLabelUpdateEnd"
          [onLabelUpdateModeOn]="drag && s.onLabelUpdateModeOn"
          [onLabelUpdateModeOff]="drag && s.onLabelUpdateModeOff"
          [pmText]="s.pmText"
          [rangeEnd]="s.rangeEnd"
          [rangeStart]="s.rangeStart"
          [resourcesMap]="s.resourcesMap"
          [rtl]="s.rtl"
          [selectedDates]="s.selectedDates"
          [selectedEventsMap]="s.selectedEventsMap"
          [showEventTooltip]="s.showEventTooltip"
          [showOuter]="_showOuter"
          [showSingleMark]="!!s.marksMap"
          [showWeekDays]="!_showDaysTop"
          [showWeekNumbers]="s.showWeekNumbers"
          [theme]="s.theme"
          [timeFormat]="s.timeFormat"
          [timezonePlugin]="timezonePlugin"
          [todayText]="s.todayText"
          [valid]="_valid"
          [variableRow]="!!_variableRow"
          [weeks]="_weeks"
          [weekText]="s.weekText"
        >
        </mbsc-month-view>
      </ng-template>
      <div [class]="'mbsc-calendar-body mbsc-flex-col mbsc-flex-1-1' + _theme" (keydown)="_onKeyDown($event)" #body>
        <div
          *ngIf="s.showCalendar"
          [class]="'mbsc-calendar-body-inner mbsc-flex-col mbsc-flex-1-1' + (_variableRow ? ' mbsc-calendar-body-inner-variable' : '')"
        >
          <div
            *ngIf="_isGrid"
            [attr.aria-hidden]="_view !== PAGE_VIEW"
            [class]="'mbsc-calendar-grid mbsc-flex-1-1 mbsc-flex-col' + _theme + _hb"
          >
            <div *ngFor="let row of _monthsMulti; trackBy: _getKey" class="mbsc-calendar-grid-row mbsc-flex mbsc-flex-1-1">
              <div *ngFor="let item of row; trackBy: _getKey" [class]="'mbsc-calendar-grid-item mbsc-flex-col mbsc-flex-1-1' + _theme">
                <div [class]="'mbsc-calendar-month-title' + _theme">{{ _getMonthName(item) }}</div>
                <ng-template
                  [ngTemplateOutlet]="monthView"
                  [ngTemplateOutletContext]="{
                    timestamp: item,
                    drag: false,
                    isActive: true
                  }"
                >
                </ng-template>
              </div>
            </div>
          </div>

          <div
            *ngIf="!_isGrid && _variableRow"
            [attr.aria-hidden]="_view !== PAGE_VIEW"
            [class]="'mbsc-calendar-slide mbsc-calendar-slide-active ' + _getPickerClass(PAGE_VIEW)"
          >
            <ng-template
              [ngTemplateOutlet]="monthView"
              [ngTemplateOutletContext]="{
                timestamp: _getFirstDay(),
                isActive: true,
                drag: true
              }"
            >
            </ng-template>
          </div>

          <div
            *ngIf="s.selectView === PAGE_VIEW && !_isGrid && !_variableRow"
            (animationend)="_onViewAnimationEnd()"
            [attr.aria-hidden]="_view !== PAGE_VIEW"
            [class]="_getPickerClass(PAGE_VIEW)"
          >
            <mbsc-scrollview-base
              #scrollview
              [axis]="_axis"
              [batchSize]="1"
              [changeOnEnd]="true"
              class="mbsc-calendar-scroll-wrapper"
              easing="ease-out"
              [items]="_months"
              [itemNr]="_pageNr"
              [itemSize]="state.pageSize / _pageNr"
              [maxIndex]="_maxIndex"
              [minIndex]="_minIndex"
              [mouseSwipe]="s.mouseSwipe"
              [mousewheel]="_mousewheel"
              [onAnimationEnd]="_onAnimationEnd"
              [onGestureStart]="_onGestureStart"
              [onIndexChange]="_onPageChange"
              [onStart]="_onStart"
              [prevAnim]="_prevAnim"
              [rtl]="s.rtl"
              [selectedIndex]="_pageIndex"
              [snap]="true"
              [swipe]="s.swipe"
              [time]="200"
            >
              <div
                *ngFor="let item of scrollview.visibleItems; trackBy: _getKey"
                [class]="
                  'mbsc-calendar-slide' +
                  (item.key >= _pageIndex && item.key < _pageIndex + _pageNr && _view === PAGE_VIEW ? ' mbsc-calendar-slide-active' : '') +
                  _theme +
                  _rtl
                "
                [ngStyle]="_getPageStyle(item.key, scrollview._offset, _pageIndex, _pageNr)"
              >
                <ng-template
                  [ngTemplateOutlet]="monthView"
                  [ngTemplateOutletContext]="{
                    timestamp: _getPageDay(item.key),
                    drag: true,
                    isActive: item.key >= _pageIndex && item.key < _pageIndex + _pageNr && _view === PAGE_VIEW
                  }"
                >
                </ng-template>
              </div>
            </mbsc-scrollview-base>
          </div>
          <div *ngIf="!_hasPicker" #pickerCont>
            <ng-container *ngTemplateOutlet="picker"></ng-container>
          </div>
        </div>
      </div>
    </div>
    <ng-content></ng-content>
    <mbsc-popup
      *ngIf="_hasPicker"
      [anchor]="_pickerBtn"
      class="mbsc-calendar-popup"
      [closeOnScroll]="true"
      [contentPadding]="false"
      [context]="s.context"
      display="anchored"
      [isOpen]="_view !== PAGE_VIEW"
      [locale]="s.locale"
      (onClose)="_onPickerClose()"
      (onOpen)="_onPickerOpen()"
      [rtl]="s.rtl"
      [scrollLock]="false"
      [showOverlay]="false"
      [theme]="s.theme"
      [themeVariant]="s.themeVariant"
    >
      <div (keydown)="_onKeyDown($event)">
        <div [class]="'mbsc-calendar-controls mbsc-flex' + _theme">
          <div
            aria-live="polite"
            [class]="'mbsc-calendar-picker-button-wrapper mbsc-calendar-title-wrapper mbsc-flex mbsc-flex-1-1' + _theme"
          >
            <mbsc-button
              class="mbsc-calendar-button"
              (click)="_onPickerBtnClick($event)"
              [theme]="s.theme"
              [themeVariant]="s.themeVariant"
              variant="flat"
            >
              {{ _viewTitle }}
            </mbsc-button>
          </div>
          <mbsc-button
            [attr.aria-label]="s.prevPageText"
            class="mbsc-calendar-button"
            (click)="prevPage()"
            [disabled]="_isPrevDisabled(true)"
            [iconSvg]="_prevIcon"
            [theme]="s.theme"
            [themeVariant]="s.themeVariant"
            variant="flat"
          ></mbsc-button>
          <mbsc-button
            [attr.aria-label]="s.nextPageText"
            class="mbsc-calendar-button"
            (click)="nextPage()"
            [disabled]="_isNextDisabled(true)"
            [iconSvg]="_nextIcon"
            [theme]="s.theme"
            [themeVariant]="s.themeVariant"
            variant="flat"
          ></mbsc-button>
        </div>
        <div class="mbsc-calendar-picker-wrapper" #pickerCont>
          <ng-container *ngTemplateOutlet="picker"></ng-container>
        </div>
      </div>
    </mbsc-popup>
    <ng-template #picker>
      <div
        *ngIf="state.view === MULTI_YEAR_VIEW || state.viewClosing === MULTI_YEAR_VIEW || selectView === MULTI_YEAR_VIEW"
        (animationend)="_onViewAnimationEnd()"
        [class]="_getPickerClass(MULTI_YEAR_VIEW)"
      >
        <mbsc-scrollview-base
          #multiYearView
          [axis]="_axis"
          [batchSize]="1"
          [changeOnEnd]="true"
          [class]="'mbsc-calendar-scroll-wrapper' + _theme"
          easing="ease-out"
          [items]="_months"
          [itemSize]="state.pickerSize"
          [maxIndex]="_maxYearsIndex"
          [minIndex]="_minYearsIndex"
          [mousewheel]="_mousewheel"
          [onGestureEnd]="_onGestureEnd"
          [onIndexChange]="_onYearsPageChange"
          [prevAnim]="_prevAnim"
          [rtl]="s.rtl"
          [selectedIndex]="_yearsIndex"
          [snap]="true"
          [time]="200"
        >
          <div
            *ngFor="let item of multiYearView.visibleItems; trackBy: _getKey"
            [attr.aria-hidden]="item.key === _yearsIndex ? undefined : 'true'"
            [class]="'mbsc-calendar-picker-slide mbsc-calendar-slide' + _theme + _rtl"
            [ngStyle]="_getPageStyle(item.key, multiYearView._offset, _yearsIndex)"
          >
            <mbsc-multi-year-view
              [active]="_active"
              [activeMonth]="_activeMonth"
              [firstYear]="_getPageYears(item.key)"
              [getDate]="s.getDate!"
              [getYear]="s.getYear!"
              [max]="_maxYears"
              [min]="_minYears"
              [rtl]="s.rtl"
              [theme]="s.theme"
              [yearSuffix]="s.yearSuffix"
              [onYearClick]="_onYearClick"
            ></mbsc-multi-year-view>
          </div>
        </mbsc-scrollview-base>
      </div>
      <div
        *ngIf="state.view === YEAR_VIEW || state.viewClosing === YEAR_VIEW || selectView === YEAR_VIEW"
        (animationend)="_onViewAnimationEnd()"
        [class]="_getPickerClass(YEAR_VIEW)"
      >
        <mbsc-scrollview-base
          #yearView
          [axis]="_axis"
          [batchSize]="1"
          [changeOnEnd]="true"
          [class]="'mbsc-calendar-scroll-wrapper' + _theme"
          easing="ease-out"
          [items]="_months"
          [itemSize]="state.pickerSize"
          [maxIndex]="_maxYearIndex"
          [minIndex]="_minYearIndex"
          [mousewheel]="_mousewheel"
          [onGestureEnd]="_onGestureEnd"
          [onIndexChange]="_onYearPageChange"
          [prevAnim]="_prevAnim"
          [rtl]="s.rtl"
          [selectedIndex]="_yearIndex"
          [snap]="true"
          [time]="200"
        >
          <div
            *ngFor="let item of yearView.visibleItems; trackBy: _getKey"
            [attr.aria-hidden]="item.key === _yearIndex ? undefined : 'true'"
            [class]="'mbsc-calendar-picker-slide mbsc-calendar-slide' + _theme + _rtl"
            [ngStyle]="_getPageStyle(item.key, yearView._offset, _yearIndex)"
          >
            <mbsc-year-view
              [active]="_active"
              [activeMonth]="_activeMonth"
              [getDate]="s.getDate!"
              [getMonth]="s.getMonth!"
              [getYear]="s.getYear!"
              [max]="_maxYear"
              [min]="_minYear"
              [monthNames]="s.monthNames!"
              [monthNamesShort]="s.monthNamesShort!"
              [onMonthClick]="_onMonthClick"
              [rtl]="s.rtl"
              [theme]="s.theme"
              [year]="_getPageYear(item.key)"
            ></mbsc-year-view>
          </div>
        </mbsc-scrollview-base>
      </div>
      <div
        *ngIf="_hasPicker && (state.view === MONTH_VIEW || state.viewClosing === MONTH_VIEW)"
        (animationend)="_onViewAnimationEnd()"
        [class]="_getPickerClass(MONTH_VIEW)"
      >
        <mbsc-scrollview-base
          #montView
          [axis]="_axis"
          [batchSize]="1"
          [changeOnEnd]="true"
          [class]="'mbsc-calendar-scroll-wrapper' + _theme"
          easing="ease-out"
          [items]="_months"
          [itemSize]="state.pickerSize"
          [maxIndex]="_maxMonthIndex"
          [minIndex]="_minMonthIndex"
          [mousewheel]="_mousewheel"
          [onGestureEnd]="_onGestureEnd"
          [onIndexChange]="_onMonthPageChange"
          [prevAnim]="_prevAnim"
          [rtl]="s.rtl"
          [selectedIndex]="_monthIndex"
          [snap]="true"
          [time]="200"
        >
          <div
            *ngFor="let item of montView.visibleItems; trackBy: _getKey"
            [class]="'mbsc-calendar-picker-slide mbsc-calendar-slide' + _theme + _rtl"
            [ngStyle]="_getPageStyle(item.key, montView._offset, 1)"
          >
            <mbsc-month-view
              [activeDate]="_activeMonth"
              [dataTimezone]="dataTimezone"
              [dayNames]="s.dayNames"
              [dayNamesShort]="s.dayNamesMin"
              [displayTimezone]="displayTimezone"
              [firstDay]="s.firstDay"
              [firstPageDay]="_getPageMonth(item.key)"
              [getDate]="s.getDate"
              [getDay]="s.getDay"
              [getMonth]="s.getMonth"
              [getYear]="s.getYear"
              [isActive]="item.key >= _monthIndex && item.key < _monthIndex + 1"
              [max]="_maxDate"
              [min]="_minDate"
              [monthNames]="s.monthNames"
              [monthNamesShort]="s.monthNamesShort"
              [onDayClick]="_onNavDayClick"
              [rtl]="s.rtl"
              [selectedDates]="s.selectedDates"
              [showOuter]="true"
              [showWeekDays]="!_showDaysTop"
              [theme]="s.theme"
              [timezonePlugin]="timezonePlugin"
              [todayText]="s.todayText"
            >
            </mbsc-month-view>
          </div>
        </mbsc-scrollview-base>
      </div>
    </ng-template>`
    }]
  }], null, {
    vBody: [{
      type: ViewChild,
      args: ["body", {
        static: false
      }]
    }],
    vPickerCont: [{
      type: ViewChild,
      args: ["pickerCont", {
        static: false
      }]
    }],
    activeDate: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    clickToCreate: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dayContentTemplate: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    dragToCreate: [{
      type: Input
    }],
    dragToResize: [{
      type: Input
    }],
    dragToMove: [{
      type: Input
    }],
    endDay: [{
      type: Input
    }],
    eventExact: [{
      type: Input
    }],
    eventMap: [{
      type: Input
    }],
    eventOrder: [{
      type: Input
    }],
    eventRange: [{
      type: Input
    }],
    eventRangeSize: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    fromText: [{
      type: Input
    }],
    hasContent: [{
      type: Input
    }],
    hasPicker: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    hoverEnd: [{
      type: Input
    }],
    hoverStart: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    instanceService: [{
      type: Input
    }],
    isPicker: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    labelsMap: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    labelContentTemplate: [{
      type: Input
    }],
    dragData: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    marked: [{
      type: Input
    }],
    marksMap: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    mouseSwipe: [{
      type: Input
    }],
    mousewheel: [{
      type: Input
    }],
    navService: [{
      type: Input
    }],
    navView: [{
      type: Input
    }],
    noOuterChange: [{
      type: Input
    }],
    downIcon: [{
      type: Input
    }],
    nextIconH: [{
      type: Input
    }],
    nextIconV: [{
      type: Input
    }],
    nextPageText: [{
      type: Input
    }],
    prevIconH: [{
      type: Input
    }],
    prevIconV: [{
      type: Input
    }],
    prevPageText: [{
      type: Input
    }],
    upIcon: [{
      type: Input
    }],
    pages: [{
      type: Input
    }],
    pageLoad: [{
      type: Input
    }],
    refDate: [{
      type: Input
    }],
    resourcesMap: [{
      type: Input
    }],
    rangeEnd: [{
      type: Input
    }],
    rangeStart: [{
      type: Input
    }],
    responsiveStyle: [{
      type: Input
    }],
    selectedDates: [{
      type: Input
    }],
    selectedEventsMap: [{
      type: Input
    }],
    selectView: [{
      type: Input
    }],
    showCalendar: [{
      type: Input
    }],
    showControls: [{
      type: Input
    }],
    showEventTooltip: [{
      type: Input
    }],
    showLabelCount: [{
      type: Input
    }],
    showOuterDays: [{
      type: Input
    }],
    showSchedule: [{
      type: Input
    }],
    showToday: [{
      type: Input
    }],
    showWeekNumbers: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    startDay: [{
      type: Input
    }],
    swipe: [{
      type: Input
    }],
    labelList: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    update: [{
      type: Input
    }],
    valid: [{
      type: Input
    }],
    weeks: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    calendarScroll: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    getDate: [{
      type: Input
    }],
    getDay: [{
      type: Input
    }],
    getMaxDayOfMonth: [{
      type: Input
    }],
    getMonth: [{
      type: Input
    }],
    getWeekNumber: [{
      type: Input
    }],
    getYear: [{
      type: Input
    }],
    amText: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    dayNames: [{
      type: Input
    }],
    dayNamesMin: [{
      type: Input
    }],
    dayNamesShort: [{
      type: Input
    }],
    eventText: [{
      type: Input
    }],
    eventsText: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    monthNames: [{
      type: Input
    }],
    monthNamesShort: [{
      type: Input
    }],
    moreEventsPluralText: [{
      type: Input
    }],
    moreEventsText: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    todayText: [{
      type: Input
    }],
    toText: [{
      type: Input
    }],
    weekText: [{
      type: Input
    }],
    yearSuffix: [{
      type: Input
    }],
    onActiveChange: [{
      type: Input
    }],
    onCellHoverIn: [{
      type: Input
    }],
    onCellHoverOut: [{
      type: Input
    }],
    onDayClick: [{
      type: Input
    }],
    onDayDoubleClick: [{
      type: Input
    }],
    onDayRightClick: [{
      type: Input
    }],
    onDayHoverIn: [{
      type: Input
    }],
    onDayHoverOut: [{
      type: Input
    }],
    onGestureStart: [{
      type: Input
    }],
    onLabelClick: [{
      type: Input
    }],
    onLabelDoubleClick: [{
      type: Input
    }],
    onLabelRightClick: [{
      type: Input
    }],
    onLabelHoverIn: [{
      type: Input
    }],
    onLabelHoverOut: [{
      type: Input
    }],
    onLabelDelete: [{
      type: Input
    }],
    onLabelUpdateStart: [{
      type: Input
    }],
    onLabelUpdateMove: [{
      type: Input
    }],
    onLabelUpdateEnd: [{
      type: Input
    }],
    onLabelUpdateModeOn: [{
      type: Input
    }],
    onLabelUpdateModeOff: [{
      type: Input
    }],
    onPageChange: [{
      type: Input
    }],
    onPageLoaded: [{
      type: Input
    }],
    onPageLoading: [{
      type: Input
    }],
    onResize: [{
      type: Input
    }],
    onTodayClick: [{
      type: Input
    }]
  });
})();
var MbscScrollviewBaseModule = function() {
  function MbscScrollviewBaseModule2() {
  }
  MbscScrollviewBaseModule2.ɵfac = function MbscScrollviewBaseModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscScrollviewBaseModule2)();
  };
  MbscScrollviewBaseModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscScrollviewBaseModule2,
    declarations: [MbscScrollviewBase, ScrollviewBase],
    imports: [CommonModule],
    exports: [MbscScrollviewBase]
  });
  MbscScrollviewBaseModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscScrollviewBaseModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscScrollviewBaseModule, [{
    type: NgModule,
    args: [{
      declarations: [MbscScrollviewBase, ScrollviewBase],
      exports: [MbscScrollviewBase],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var MbscCalendarViewModule = function() {
  function MbscCalendarViewModule2() {
  }
  MbscCalendarViewModule2.ɵfac = function MbscCalendarViewModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCalendarViewModule2)();
  };
  MbscCalendarViewModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscCalendarViewModule2,
    declarations: [CalendarDayBase, CalendarLabelBase, CalendarViewBase, MbscCalendarDay, MbscCalendarLabel, MbscCalendarView, MbscCalendarWeekDays, MbscMonthView, MbscMultiYearView, MbscYearView, MonthViewBase],
    imports: [CommonModule, MbscButtonModule, MbscCalendarHeaderModule, MbscIconModule, MbscPopupModule, MbscScrollviewBaseModule],
    exports: [MbscCalendarView, MbscCalendarHeaderModule]
  });
  MbscCalendarViewModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscButtonModule, MbscCalendarHeaderModule, MbscIconModule, MbscPopupModule, MbscScrollviewBaseModule], MbscCalendarHeaderModule]
  });
  return MbscCalendarViewModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarViewModule, [{
    type: NgModule,
    args: [{
      declarations: [CalendarDayBase, CalendarLabelBase, CalendarViewBase, MbscCalendarDay, MbscCalendarLabel, MbscCalendarView, MbscCalendarWeekDays, MbscMonthView, MbscMultiYearView, MbscYearView, MonthViewBase],
      exports: [MbscCalendarView, MbscCalendarHeaderModule],
      imports: [CommonModule, MbscButtonModule, MbscCalendarHeaderModule, MbscIconModule, MbscPopupModule, MbscScrollviewBaseModule]
    }]
  }], null, null);
})();
var MbscCalendar = function(_super) {
  __extends(MbscCalendar2, _super);
  function MbscCalendar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onCancel = new EventEmitter();
    _this.onChange = new EventEmitter();
    _this.onClose = new EventEmitter();
    _this.onOpen = new EventEmitter();
    _this._hours = ARRAY24;
    return _this;
  }
  Object.defineProperty(MbscCalendar2.prototype, "vCal", {
    set: function(cal) {
      this._calendarView = cal;
    },
    enumerable: false,
    configurable: true
  });
  MbscCalendar2.prototype._ctor = function() {
    this._instanceService = this._injector.get(MbscInstanceService);
  };
  MbscCalendar2.prototype._mounted = function() {
    this._instanceService.instance = this;
    _super.prototype._mounted.call(this);
  };
  MbscCalendar2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCalendar_BaseFactory;
    return function MbscCalendar_Factory(__ngFactoryType__) {
      return (ɵMbscCalendar_BaseFactory || (ɵMbscCalendar_BaseFactory = ɵɵgetInheritedFactory(MbscCalendar2)))(__ngFactoryType__ || MbscCalendar2);
    };
  })();
  MbscCalendar2.ɵcmp = ɵɵdefineComponent({
    type: MbscCalendar2,
    selectors: [["mbsc-calendar"]],
    viewQuery: function MbscCalendar_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c28, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vCal = _t.first);
      }
    },
    hostAttrs: [1, "mbsc-flex-1-1"],
    outputs: {
      onCancel: "onCancel",
      onChange: "onChange",
      onClose: "onClose",
      onOpen: "onOpen"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 2,
    vars: 87,
    consts: [["cal", ""], [3, "activeDate", "amText", "cssClass", "calendarScroll", "calendarType", "colors", "context", "dataTimezone", "dayTemplate", "dayContentTemplate", "displayTimezone", "downIcon", "exclusiveEndDates", "fromText", "headerTemplate", "hoverEnd", "hoverStart", "invalid", "instanceService", "isPicker", "labels", "marked", "max", "min", "mousewheel", "navService", "nextIconH", "nextIconV", "nextPageText", "noOuterChange", "onActiveChange", "onCellHoverIn", "onCellHoverOut", "onDayClick", "onDayHoverIn", "onDayHoverOut", "onLabelClick", "onPageChange", "onPageLoaded", "onPageLoading", "onTodayClick", "pmText", "prevIconH", "prevIconV", "prevPageText", "pages", "rangeEnd", "rangeStart", "refDate", "rtl", "selectedDates", "selectView", "showCalendar", "showControls", "showOuterDays", "showToday", "showWeekNumbers", "size", "theme", "themeVariant", "timezonePlugin", "toText", "update", "upIcon", "valid", "weeks", "width", "getDate", "getDay", "getMaxDayOfMonth", "getMonth", "getWeekNumber", "getYear", "dateFormat", "dayNames", "dayNamesMin", "dayNamesShort", "eventText", "eventsText", "firstDay", "monthNames", "monthNamesShort", "moreEventsPluralText", "moreEventsText", "todayText", "weekText", "yearSuffix"]],
    template: function MbscCalendar_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelement(0, "mbsc-calendar-view", 1, 0);
      }
      if (rf & 2) {
        ɵɵproperty("activeDate", ctx2.s.active)("amText", ctx2.s.amText)("cssClass", ctx2._className + " mbsc-flex-1-1 mbsc-calendar-" + ctx2.s.display)("calendarScroll", ctx2.s.calendarScroll)("calendarType", ctx2.s.calendarType)("colors", ctx2.s.colors)("context", ctx2.s.context)("dataTimezone", ctx2.s.dataTimezone)("dayTemplate", ctx2.s.dayTemplate)("dayContentTemplate", ctx2.s.dayContentTemplate)("displayTimezone", ctx2.s.displayTimezone)("downIcon", ctx2.s.downIcon)("exclusiveEndDates", ctx2.s.exclusiveEndDates)("fromText", ctx2.s.fromText)("headerTemplate", ctx2.s.calendarHeaderTemplate)("hoverEnd", ctx2.s.hoverEnd)("hoverStart", ctx2.s.hoverStart)("invalid", ctx2.s.invalid)("instanceService", ctx2._instanceService)("isPicker", true)("labels", ctx2.s.labels)("marked", ctx2.s.marked)("max", ctx2.s.max)("min", ctx2.s.min)("mousewheel", ctx2.s.mousewheel)("navService", ctx2._navService)("nextIconH", ctx2.s.nextIconH)("nextIconV", ctx2.s.nextIconV)("nextPageText", ctx2.s.nextPageText)("noOuterChange", ctx2.s.selectRange)("onActiveChange", ctx2._onActiveChange)("onCellHoverIn", ctx2.s.onCellHoverIn)("onCellHoverOut", ctx2.s.onCellHoverOut)("onDayClick", ctx2._onDayClick)("onDayHoverIn", ctx2.s.onDayHoverIn)("onDayHoverOut", ctx2.s.onDayHoverOut)("onLabelClick", ctx2.s.onLabelClick)("onPageChange", ctx2.s.onPageChange)("onPageLoaded", ctx2.s.onPageLoaded)("onPageLoading", ctx2.s.onPageLoading)("onTodayClick", ctx2._onTodayClick)("pmText", ctx2.s.pmText)("prevIconH", ctx2.s.prevIconH)("prevIconV", ctx2.s.prevIconV)("prevPageText", ctx2.s.prevPageText)("pages", ctx2.s.pages)("rangeEnd", ctx2.s.rangeEnd)("rangeStart", ctx2.s.rangeStart)("refDate", ctx2.s.refDate)("rtl", ctx2.s.rtl)("selectedDates", ctx2._tempValueRep)("selectView", ctx2.s.selectView)("showCalendar", true)("showControls", ctx2.s.showControls)("showOuterDays", ctx2.s.showOuterDays)("showToday", false)("showWeekNumbers", ctx2.s.showWeekNumbers)("size", ctx2.s.size)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant)("timezonePlugin", ctx2.s.timezonePlugin)("toText", ctx2.s.toText)("update", ctx2._update)("upIcon", ctx2.s.upIcon)("valid", ctx2.s.valid)("weeks", ctx2.s.weeks)("width", ctx2.s.width)("getDate", ctx2.s.getDate)("getDay", ctx2.s.getDay)("getMaxDayOfMonth", ctx2.s.getMaxDayOfMonth)("getMonth", ctx2.s.getMonth)("getWeekNumber", ctx2.s.getWeekNumber)("getYear", ctx2.s.getYear)("dateFormat", ctx2.s.dateFormat)("dayNames", ctx2.s.dayNames)("dayNamesMin", ctx2.s.dayNamesMin)("dayNamesShort", ctx2.s.dayNamesShort)("eventText", ctx2.s.eventText)("eventsText", ctx2.s.eventsText)("firstDay", ctx2.s.firstDay)("monthNames", ctx2.s.monthNames)("monthNamesShort", ctx2.s.monthNamesShort)("moreEventsPluralText", ctx2.s.moreEventsPluralText)("moreEventsText", ctx2.s.moreEventsText)("todayText", ctx2.s.todayText)("weekText", ctx2.s.weekText)("yearSuffix", ctx2.s.yearSuffix);
      }
    },
    dependencies: [MbscCalendarView],
    encapsulation: 2,
    changeDetection: 0
  });
  MbscCalendar2 = __decorate([FormControl], MbscCalendar2);
  return MbscCalendar2;
}(CalendarBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendar, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "mbsc-flex-1-1"
      },
      selector: "mbsc-calendar",
      template: `
    <mbsc-calendar-view
      #cal
      [activeDate]="s.active"
      [amText]="s.amText"
      [cssClass]="_className + ' mbsc-flex-1-1 mbsc-calendar-' + s.display"
      [calendarScroll]="s.calendarScroll"
      [calendarType]="s.calendarType"
      [colors]="s.colors"
      [context]="s.context"
      [dataTimezone]="s.dataTimezone"
      [dayTemplate]="s.dayTemplate"
      [dayContentTemplate]="s.dayContentTemplate"
      [displayTimezone]="s.displayTimezone"
      [downIcon]="s.downIcon"
      [exclusiveEndDates]="s.exclusiveEndDates"
      [fromText]="s.fromText"
      [headerTemplate]="s.calendarHeaderTemplate"
      [hoverEnd]="s.hoverEnd"
      [hoverStart]="s.hoverStart"
      [invalid]="s.invalid"
      [instanceService]="_instanceService"
      [isPicker]="true"
      [labels]="s.labels"
      [marked]="s.marked"
      [max]="s.max"
      [min]="s.min"
      [mousewheel]="s.mousewheel"
      [navService]="_navService"
      [nextIconH]="s.nextIconH"
      [nextIconV]="s.nextIconV"
      [nextPageText]="s.nextPageText"
      [noOuterChange]="s.selectRange"
      [onActiveChange]="_onActiveChange"
      [onCellHoverIn]="s.onCellHoverIn"
      [onCellHoverOut]="s.onCellHoverOut"
      [onDayClick]="_onDayClick"
      [onDayHoverIn]="s.onDayHoverIn"
      [onDayHoverOut]="s.onDayHoverOut"
      [onLabelClick]="s.onLabelClick"
      [onPageChange]="s.onPageChange"
      [onPageLoaded]="s.onPageLoaded"
      [onPageLoading]="s.onPageLoading"
      [onTodayClick]="_onTodayClick"
      [pmText]="s.pmText"
      [prevIconH]="s.prevIconH"
      [prevIconV]="s.prevIconV"
      [prevPageText]="s.prevPageText"
      [pages]="s.pages"
      [rangeEnd]="s.rangeEnd"
      [rangeStart]="s.rangeStart"
      [refDate]="s.refDate"
      [rtl]="s.rtl"
      [selectedDates]="_tempValueRep"
      [selectView]="s.selectView"
      [showCalendar]="true"
      [showControls]="s.showControls"
      [showOuterDays]="s.showOuterDays"
      [showToday]="false"
      [showWeekNumbers]="s.showWeekNumbers"
      [size]="s.size"
      [theme]="s.theme"
      [themeVariant]="s.themeVariant"
      [timezonePlugin]="s.timezonePlugin"
      [toText]="s.toText"
      [update]="_update"
      [upIcon]="s.upIcon"
      [valid]="s.valid"
      [weeks]="s.weeks"
      [width]="s.width"
      [getDate]="s.getDate"
      [getDay]="s.getDay"
      [getMaxDayOfMonth]="s.getMaxDayOfMonth"
      [getMonth]="s.getMonth"
      [getWeekNumber]="s.getWeekNumber"
      [getYear]="s.getYear"
      [dateFormat]="s.dateFormat"
      [dayNames]="s.dayNames"
      [dayNamesMin]="s.dayNamesMin"
      [dayNamesShort]="s.dayNamesShort"
      [eventText]="s.eventText"
      [eventsText]="s.eventsText"
      [firstDay]="s.firstDay"
      [monthNames]="s.monthNames"
      [monthNamesShort]="s.monthNamesShort"
      [moreEventsPluralText]="s.moreEventsPluralText"
      [moreEventsText]="s.moreEventsText"
      [todayText]="s.todayText"
      [weekText]="s.weekText"
      [yearSuffix]="s.yearSuffix"
    >
    </mbsc-calendar-view>
  `
    }]
  }], null, {
    onCancel: [{
      type: Output
    }],
    onChange: [{
      type: Output
    }],
    onClose: [{
      type: Output
    }],
    onOpen: [{
      type: Output
    }],
    vCal: [{
      type: ViewChild,
      args: ["cal", {
        static: false
      }]
    }]
  });
})();
var MbscCalendarModule = function() {
  function MbscCalendarModule2() {
  }
  MbscCalendarModule2.ɵfac = function MbscCalendarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCalendarModule2)();
  };
  MbscCalendarModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscCalendarModule2,
    declarations: [CalendarBase, MbscCalendar],
    imports: [CommonModule, MbscCalendarViewModule],
    exports: [MbscCalendar]
  });
  MbscCalendarModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscCalendarViewModule]]
  });
  return MbscCalendarModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCalendarModule, [{
    type: NgModule,
    args: [{
      declarations: [CalendarBase, MbscCalendar],
      exports: [MbscCalendar],
      imports: [CommonModule, MbscCalendarViewModule]
    }]
  }], null, null);
})();
function getPickerTemplate(content) {
  return `
    <mbsc-input *ngIf="_showInput" #input
      [ariaExpanded]="!!_isOpen"
      [ariaHaspopup]="'dialog'"
      [ariaLabel]="ariaLabel"
      [dropdown]="s.dropdown"
      [disabled]="disabled"
      [endIcon]="endIcon"
      [endIconSrc]="endIconSrc"
      [endIconSvg]="endIconSvg"
      [error]="error"
      [errorMessage]="errorMessage"
      [inputStyle]="s.inputStyle"
      [label]="label"
      [labelStyle]="s.labelStyle"
      [name]="name"
      [placeholder]="placeholder"
      [pickerMap]="_valueMap"
      [pickerValue]="_value"
      [role]="'combobox'"
      [rtl]="s.rtl"
      [startIcon]="startIcon"
      [startIconSrc]="startIconSrc"
      [startIconSvg]="startIconSvg"
      [tags]="s.tagInput === undefined ? s.selectMultiple : s.tagInput"
      [theme]="s.theme"
      [themeVariant]="s.themeVariant"
      [value]="(_value != null && _valueText) || ''"
    >
      <ng-content></ng-content>
    </mbsc-input>
    <mbsc-popup #popup
      [activeElm]="s.activeElm"
      [anchor]="_anchor"
      [anchorAlign]="_anchorAlign"
      [animation]="s.animation"
      [ariaLabel]="s.ariaLabel"
      [buttons]="_buttons"
      [cancelText]="s.cancelText"
      [closeOnEsc]="s.closeOnEsc"
      [closeOnOverlayClick]="s.closeOnOverlayClick"
      [closeOnScroll]="s.closeOnScroll"
      [closeText]="s.closeText"
      [contentPadding]="false"
      [context]="s.context"
      [cssClass]="_cssClass"
      [disableLeftRight]="true"
      [display]="s.display"
      [focusElm]="_focusElm"
      [focusOnClose]="s.focusOnClose"
      [focusOnOpen]="!_allowTyping"
      [focusTrap]="s.focusTrap"
      [fullScreen]="s.fullScreen"
      [headerText]="_headerText"
      [height]="s.height"
      [isOpen]="_isOpen"
      [maxHeight]="s.maxHeight"
      [maxWidth]="_maxWidth"
      [setText]="s.setText"
      [showArrow]="s.showArrow"
      [showOverlay]="_allowTyping ? false : s.showOverlay"
      [rtl]="s.rtl"
      [scrollLock]="_scrollLock"
      [theme]="s.theme"
      [themeVariant]="s.themeVariant"
      [touchUi]="_touchUi"
      [windowWidth]="state.width"
      [width]="s.width"
      (onClose)="_onPopupClose($event)"
      (onClosed)="_onPopupClosed($event)"
      (onKeyDown)="_onPopupKey($event)"
      (onOpen)="_onPopupOpen($event)"
      (onResize)="_onResize($event)"
    >
      <ng-container *ngIf="(_popup && _popup._isVisible) || s.display === 'inline'">
        `.concat(content, "\n      </ng-container>\n    </mbsc-popup>");
}
function getValid(wheel, val, disabled, direction) {
  var min = wheel.min === UNDEFINED ? -Infinity : wheel.min;
  var max = wheel.max === UNDEFINED ? Infinity : wheel.max;
  var index = getIndex(wheel, val);
  var value = getValue(wheel, index);
  var value1 = value;
  var value2 = value;
  var dist1 = 0;
  var dist2 = 0;
  if (disabled && disabled.get(value)) {
    while (index - dist1 >= min && disabled.get(value1) && dist1 < 100) {
      dist1++;
      value1 = getValue(wheel, index - dist1);
    }
    while (index + dist2 < max && disabled.get(value2) && dist2 < 100) {
      dist2++;
      value2 = getValue(wheel, index + dist2);
    }
    if (disabled.get(value1) && disabled.get(value2)) {
      return value;
    }
    if ((dist2 < dist1 && dist2 && direction !== -1 || !dist1 || index - dist1 < 0 || direction === 1) && !disabled.get(value2)) {
      value = value2;
    } else {
      value = value1;
    }
  }
  return value;
}
function getItemValue(item) {
  return item !== UNDEFINED ? item.value !== UNDEFINED ? item.value : item.display !== UNDEFINED ? item.display : item : item;
}
function getItem(wheel, index) {
  if (wheel.getItem) {
    return wheel.getItem(index);
  }
  var data = wheel.data || [];
  var len = data.length;
  var i = index % len;
  return wheel._circular ? data[i >= 0 ? i : i + len] : data[constrain(index, 0, len - 1)];
}
function getIndex(wheel, value) {
  var val = wheel.multiple ? value && value.length && value[0] || UNDEFINED : value;
  return (wheel.getIndex ? +wheel.getIndex(value) : wheel._map.get(val)) || 0;
}
function getFirstIndex(wheel, index) {
  if (wheel.getItem && wheel.getIndex) {
    return wheel.getIndex(getItemValue(wheel.getItem(index)));
  }
  var data = wheel.data || [];
  var len = data.length;
  var i = index % len;
  return !len ? 0 : i >= 0 ? i : i + len;
}
function getValue(wheel, index) {
  return getItemValue(getItem(wheel, index));
}
function initWheel(wheel, key, circular, rows) {
  wheel._key = key;
  wheel._map = /* @__PURE__ */ new Map();
  wheel._circular = circular === UNDEFINED ? wheel.circular === UNDEFINED ? wheel.data && wheel.data.length > (rows || 5) : wheel.circular : isArray(circular) ? circular[key] : circular;
  if (wheel.data) {
    wheel.min = wheel._circular ? UNDEFINED : 0;
    wheel.max = wheel._circular ? UNDEFINED : wheel.data.length - 1;
    wheel.data.forEach(function(item, i) {
      wheel._map.set(getItemValue(item), i);
    });
  }
}
var ScrollerBase = function(_super) {
  __extends(ScrollerBase2, _super);
  function ScrollerBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._indexes = [];
    _this._activeIndexes = [];
    _this._wheels = [];
    _this._batches = [];
    _this._lastIndexes = [];
    _this._onSet = function() {
      _this._hook("onChange", {
        value: _this._get(_this._tempValueRep)
      });
    };
    _this._onActiveChange = function(_a) {
      var wheel = _a.wheel, index = _a.index;
      var wheelIndex = wheel._key;
      _this._activeIndexes[wheelIndex] = index;
      var indexes = _this._indexes;
      var currentIndex = indexes[wheelIndex];
      if (_this._scroll3d) {
        currentIndex = index;
      } else if (index - currentIndex >= _this._rows) {
        currentIndex++;
      } else if (index < currentIndex) {
        currentIndex--;
      }
      indexes[wheelIndex] = currentIndex;
      _this.forceUpdate();
    };
    _this._onWheelIndexChange = function(args) {
      var s = _this.s;
      var wheel = args.wheel;
      var key = wheel._key;
      var isMultiple = wheel.multiple;
      var newValue = getValue(wheel, args.index);
      var disabled = _this._disabled && _this._disabled[key] && _this._disabled[key].get(newValue);
      var lengths = [];
      var selectOnScroll = s.selectOnScroll;
      var updateIndex = selectOnScroll || !args.click;
      if (updateIndex) {
        _this._lastIndexes[key] = _this._indexes[key] = args.index;
        _this._indexes.forEach(function(val, i) {
          var w2 = _this._wheelMap[i];
          var len = w2.data ? w2.data.length : 0;
          _this._batches[i] = len ? floor(val / len) : 0;
          lengths[i] = len;
        });
      }
      _this._activeIndexes[key] = args.index;
      var beforeTempValue = _this._get(_this._tempValueRep);
      var itemTap = !!args.click && !disabled;
      var scrollOrTapSelect = selectOnScroll || itemTap;
      if (isMultiple) {
        if (itemTap) {
          var selectionArr = __spreadArray([], _this._tempValueRep[key] || [], true);
          if (args.selected === false) {
            selectionArr.push(newValue);
          } else if (args.selected === true) {
            selectionArr.splice(selectionArr.indexOf(newValue), 1);
          }
          _this._tempValueRep[key] = selectionArr;
        }
      } else if (scrollOrTapSelect) {
        _this._tempValueRep[key] = newValue;
      }
      if (s.onWheelMove && args.index !== UNDEFINED) {
        var wheelRep = s.onWheelMove({
          dataItem: getItem(wheel, args.index),
          selection: scrollOrTapSelect,
          wheelIndex: key
        });
        if (wheelRep) {
          wheelRep.forEach(function(v, i) {
            if (v !== UNDEFINED) {
              _this._tempValueRep[i] = v;
            }
            if (!scrollOrTapSelect) {
              var w2 = _this._wheelMap[i];
              var newIndex = getIndex(w2, v);
              _this._constrainIndex(newIndex, w2);
            }
          });
        }
      }
      if (scrollOrTapSelect) {
        _this._validate(key, args.diff > 0 ? 1 : -1);
      }
      if (selectOnScroll) {
        _this._tempValueRep.forEach(function(val, i) {
          var w2 = _this._wheelMap[i];
          var len = w2.data ? w2.data.length : 0;
          var oldIndex = _this._indexes[i];
          var newIndex = getIndex(w2, val) + _this._batches[i] * len;
          _this._activeIndexes[i] = _this._lastIndexes[i] = _this._indexes[i] = newIndex;
          w2._offset = len !== lengths[i] ? newIndex - oldIndex : 0;
        });
      }
      var currentTempValue = _this._get(_this._tempValueRep);
      var tempValueChanged = !_this._valueEquals(beforeTempValue, currentTempValue);
      if (tempValueChanged || itemTap && isEmpty(s.value)) {
        _this._hook("onChange", {
          value: currentTempValue,
          itemTap,
          closeOnTap: wheel.closeOnTap
        });
      } else {
        _this.forceUpdate();
      }
    };
    return _this;
  }
  ScrollerBase2.prototype._initWheels = function() {
    var _this = this;
    var key = 0;
    var wheels = this.s.wheels || [];
    this._wheelMap = [];
    wheels.forEach(function(wheelGroup) {
      wheelGroup.forEach(function(wheel) {
        initWheel(wheel, key, _this._circular, _this._rows);
        _this._wheelMap[key] = wheel;
        key++;
      });
    });
    this._wheels = wheels;
  };
  ScrollerBase2.prototype._render = function(s, state) {
    var _this = this;
    var props = this.props || {};
    var resp = this._respProps || {};
    var prevS = this._prevS;
    var circular = this._touchUi ? s.circular : false;
    var rows = this._touchUi ? s.rows : resp.rows || props.rows || 7;
    this._displayStyle = s.displayStyle || s.display;
    this._scroll3d = s.scroll3d && this._touchUi && has3d;
    if (s.itemHeight !== prevS.itemHeight || rows !== this._rows) {
      this._rows = rows;
      this._lineStyle = {
        height: s.itemHeight + "px"
      };
      if (this._scroll3d) {
        var translateZ = "translateZ(" + (s.itemHeight * rows / 2 + 3) + "px";
        this._overlayStyle = {};
        this._overlayStyle[cssPrefix + "transform"] = translateZ;
        this._lineStyle[cssPrefix + "transform"] = "translateY(-50%) " + translateZ;
      }
    }
    if (s.wheels !== prevS.wheels || circular !== this._circular) {
      this._batches = [];
      this._shouldSetIndex = true;
      this._circular = circular;
      this._initWheels();
    }
    var valueChange = !this._valueEquals(s.value, prevS.value);
    if (valueChange || this._tempValueRep === UNDEFINED || this._shouldValidate(s, prevS) || s.invalid !== prevS.invalid || s.valid !== prevS.valid) {
      this._tempValueRep = this._parse(s.value);
      this._shouldSetIndex = true;
      this._validate();
      var newValue_1 = this._get(this._tempValueRep);
      var validationChange_1 = !this._valueEquals(s.value, newValue_1);
      var validationChangeOut_1 = validationChange_1 && !isEmpty(s.value);
      setTimeout(function() {
        if (validationChangeOut_1) {
          _this._hook("onChange", {
            value: newValue_1
          });
        } else if (validationChange_1) {
          _this._hook("onTempChange", {
            value: newValue_1
          });
        }
      });
    }
    if (this._shouldSetIndex) {
      this._setIndexes();
      this._shouldSetIndex = this._indexFromValue = false;
    }
    if (s.wheels !== prevS.wheels && prevS.wheels !== UNDEFINED) {
      setTimeout(function() {
        for (var _i = 0, _a = _this._wheelMap; _i < _a.length; _i++) {
          var wheel = _a[_i];
          _this._onWheelIndexChange({
            diff: 0,
            index: _this._indexes[wheel._key],
            wheel
          });
        }
      });
    }
  };
  ScrollerBase2.prototype._validate = function(index, direction) {
    var _this = this;
    if (this.s.validate) {
      var ret = this.s.validate.call(this._el, {
        direction,
        index,
        values: this._tempValueRep.slice(0),
        wheels: this._wheelMap
      });
      this._disabled = ret.disabled;
      if (ret.init) {
        this._initWheels();
      }
      if (ret.indexes) {
        ret.indexes.forEach(function(value, i) {
          if (value !== UNDEFINED) {
            var w2 = _this._wheelMap[i];
            var newIndex = getIndex(w2, value);
            _this._constrainIndex(newIndex, w2);
          }
        });
      }
      if (ret.valid) {
        this._tempValueRep = ret.valid.slice(0);
      } else {
        this._wheelMap.forEach(function(wheel, i) {
          _this._tempValueRep[i] = getValid(wheel, _this._tempValueRep[i], _this._disabled && _this._disabled[i], direction);
        });
      }
    }
  };
  ScrollerBase2.prototype._setIndexes = function() {
    var _this = this;
    var currentIndexes = this._indexes || [];
    this._indexes = [];
    this._activeIndexes = [];
    this._tempValueRep.forEach(function(val, i) {
      var w2 = _this._wheelMap[i];
      var len = w2.data ? w2.data.length : 0;
      var newIndex = getIndex(w2, val);
      if (_this.s.selectOnScroll) {
        _this._activeIndexes[i] = _this._indexes[i] = newIndex + (_this._batches[i] || 0) * len;
      } else {
        var currentIndex = newIndex;
        if (!_this._indexFromValue) {
          currentIndex = _this._prevS.wheels !== _this.s.wheels ? 0 : currentIndexes[i];
          if (currentIndex !== UNDEFINED) {
            currentIndex = getFirstIndex(w2, currentIndex) + (_this._batches[i] || 0) * len;
          }
        }
        _this._constrainIndex(currentIndex, w2);
      }
    });
  };
  ScrollerBase2.prototype._constrainIndex = function(newIndex, wheel) {
    var i = wheel._key;
    if (newIndex !== UNDEFINED && wheel.data) {
      if (!wheel.spaceAround) {
        newIndex = constrain(newIndex, 0, Math.max(wheel.data.length - this._rows, 0));
      }
      this._activeIndexes[i] = this._indexes[i] = newIndex;
    } else {
      this._activeIndexes[i] = this._indexes[i] = this._lastIndexes[i] || 0;
    }
  };
  ScrollerBase2.prototype._shouldValidate = function(s, prevS) {
    return s.shouldValidate ? s.shouldValidate(s, prevS) : false;
  };
  ScrollerBase2.prototype._valueEquals = function(v1, v2) {
    if (this.s.valueEquality) {
      return this.s.valueEquality(v1, v2);
    }
    return v1 === v2;
  };
  ScrollerBase2.prototype._get = function(value) {
    if (this.s.getValue) {
      return this.s.getValue(value);
    }
    return value;
  };
  ScrollerBase2.prototype._parse = function(value) {
    if (this.s.parseValue) {
      return this.s.parseValue(value);
    }
    return value;
  };
  ScrollerBase2.defaults = {
    itemHeight: 40,
    rows: 5,
    selectOnScroll: true
  };
  ScrollerBase2._name = "Scroller";
  ScrollerBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵScrollerBase_BaseFactory;
    return function ScrollerBase_Factory(__ngFactoryType__) {
      return (ɵScrollerBase_BaseFactory || (ɵScrollerBase_BaseFactory = ɵɵgetInheritedFactory(ScrollerBase2)))(__ngFactoryType__ || ScrollerBase2);
    };
  })();
  ScrollerBase2.ɵdir = ɵɵdefineDirective({
    type: ScrollerBase2,
    selectors: [["", "mbsc-sc-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return ScrollerBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollerBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sc-b]"
    }]
  }], null, null);
})();
var WHEEL_WIDTHS = {
  ios: 50,
  material: 46,
  windows: 50
};
var TIME_PARTS = ["a", "h", "i", "s", "tt"];
function validateTimes(s, hasAmPm, i, valid, wheelOrder, getDatePart, maxs, steps, key, disabled, order, validDate, startDate, endDate, isValid, exclusiveEndDates) {
  var start = isSameDay(validDate, startDate) ? startDate : getDayStart(s, startDate);
  var end = isSameDay(validDate, endDate) ? endDate : getDayEnd(s, endDate);
  var startAmPm = getDatePart.a(start);
  var endAmPm = getDatePart.a(end);
  var startProp = true;
  var endProp = true;
  var all = false;
  var add = 0;
  var remove = 0;
  for (var j = 0; j < i; j++) {
    var k = TIME_PARTS[j];
    var validVal = valid[wheelOrder[k]];
    if (validVal !== UNDEFINED) {
      var startVal = startProp ? getDatePart[k](start) : 0;
      var endVal = endProp ? getDatePart[k](end) : maxs[k];
      if (hasAmPm && j === 1) {
        startVal += startAmPm ? 12 : 0;
        endVal += endAmPm ? 12 : 0;
        validVal += valid[wheelOrder.a] ? 12 : 0;
      }
      if ((startProp || endProp) && startVal < validVal && validVal < endVal) {
        all = true;
      }
      if (validVal !== startVal) {
        startProp = false;
      }
      if (validVal !== endVal) {
        endProp = false;
      }
    }
  }
  if (!isValid) {
    for (var j = i + 1; j < 4; j++) {
      var k = TIME_PARTS[j];
      if (wheelOrder[k] !== UNDEFINED) {
        if (getDatePart[k](start) > 0 && startProp) {
          add = steps[key];
        }
        if (getDatePart[k](end) < maxs[k] && endProp) {
          remove = steps[key];
        }
      }
    }
    if (endProp && exclusiveEndDates && !remove) {
      remove = end.getMilliseconds() !== 999 ? steps[key] : 0;
    }
  }
  if (startProp || endProp || all) {
    var startVal = startProp && !all ? getDatePart[key](start) + add : 0;
    var endVal = endProp && !all ? getDatePart[key](end) - remove : maxs[key];
    for (var j = startVal; j <= endVal; j += steps[key]) {
      disabled[order].set(j, !isValid);
    }
  }
}
function getDateIndex(d, hasDay) {
  var dt = new Date(d);
  return hasDay ? floor(+dt / 864e5) : dt.getMonth() + 12 * (dt.getFullYear() - 1970);
}
function getFullDate(d) {
  return d.getFullYear() + "-" + pad(d.getMonth() + 1) + "-" + pad(d.getDate());
}
function getMilliseconds(d) {
  return d.getMilliseconds();
}
function getAmPm(d) {
  return d.getHours() > 11 ? 1 : 0;
}
var DatetimeBase = function(_super) {
  __extends(DatetimeBase2, _super);
  function DatetimeBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._preset = "date";
    _this._innerValues = {};
    _this._parseDate = function(value) {
      var s = _this.s;
      if (!value) {
        _this._innerValues = {};
      }
      return _this._getArray(makeDate(value || s.defaultSelection || /* @__PURE__ */ new Date(), s, _this._format), !!value);
    };
    _this._getDate = function(values) {
      var s = _this.s;
      var getArrayPart = _this._getArrayPart;
      var wheelOrder = _this._wheelOrder;
      var today = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
      var d;
      var t;
      if (values === null || values === UNDEFINED) {
        return null;
      }
      if (wheelOrder.dd !== UNDEFINED) {
        var parts = values[wheelOrder.dd].split("-");
        d = new Date(parts[0], parts[1] - 1, parts[2]);
      }
      if (wheelOrder.tt !== UNDEFINED) {
        t = new Date(+REF_DATE + values[wheelOrder.tt] % 86400 * 1e3);
      }
      var year = getArrayPart(values, "y", d, today);
      var month = getArrayPart(values, "m", d, today);
      var day = Math.min(getArrayPart(values, "d", d, today), s.getMaxDayOfMonth(year, month));
      var hour = getArrayPart(values, "h", t, today);
      return s.getDate(year, month, day, _this._hasAmPm && getArrayPart(values, "a", t, today) ? hour + 12 : hour, getArrayPart(values, "i", t, today), getArrayPart(values, "s", t, today), getArrayPart(values, "u", t, today));
    };
    _this._validate = function(_a) {
      var direction = _a.direction, index = _a.index, values = _a.values, wheels = _a.wheels;
      var disabled = [];
      var s = _this.s;
      var stepHour = s.stepHour;
      var stepMinute = s.stepMinute;
      var stepSecond = s.stepSecond;
      var preset = s.mode || _this._preset;
      var wheelOrder = _this._wheelOrder;
      var getDatePart = _this._getDatePart;
      var maxDate = _this._max;
      var minDate = _this._min;
      var current = addTimezone(s, _this._getDate(values));
      var currYear = s.getYear(current);
      var currMonth = s.getMonth(current);
      var from = s.getDate(currYear, currMonth - 1, 1);
      var until = s.getDate(currYear, currMonth + 2, 1);
      if (index === wheelOrder.y || index === wheelOrder.m || index === wheelOrder.d || index === wheelOrder.dd || index === UNDEFINED) {
        _this._valids = getEventMap(s.valid, from, until, s, true, true);
        _this._invalids = getEventMap(s.invalid, from, until, s, true, true);
      }
      var valids = _this._valids;
      var invalids = _this._invalids;
      var mind = minDate ? +minDate : -Infinity;
      var maxd = maxDate ? +maxDate : Infinity;
      var validated = getClosestValidDate(current, s, mind, maxd, invalids, valids, direction);
      var valid = _this._getArray(validated);
      var dayWheel = _this._wheels && _this._wheels[0][wheelOrder.d];
      var y = getDatePart.y(validated);
      var m = getDatePart.m(validated);
      var maxDays = s.getMaxDayOfMonth(y, m);
      var mins = {
        y: minDate ? minDate.getFullYear() : -Infinity,
        m: 0,
        d: 1,
        h: 0,
        i: 0,
        s: 0,
        a: 0,
        tt: 0
      };
      var maxs = {
        y: maxDate ? maxDate.getFullYear() : Infinity,
        m: 11,
        d: 31,
        h: step(_this._hasAmPm ? 11 : 23, stepHour),
        i: step(59, stepMinute),
        s: step(59, stepSecond),
        a: 1,
        tt: 86400
      };
      var steps = {
        y: 1,
        m: 1,
        d: 1,
        h: stepHour,
        i: stepMinute,
        s: stepSecond,
        a: 1,
        tt: _this._timeStep
      };
      var init = false;
      var minprop = true;
      var maxprop = true;
      ["dd", "y", "m", "d", "tt", "a", "h", "i", "s"].forEach(function(key) {
        var min = mins[key];
        var max = maxs[key];
        var val = getDatePart[key](validated);
        var order = wheelOrder[key];
        if (minprop && minDate) {
          min = getDatePart[key](minDate);
        }
        if (maxprop && maxDate) {
          max = getDatePart[key](maxDate);
        }
        if (val < min) {
          val = min;
        }
        if (val > max) {
          val = max;
        }
        if (key !== "dd" && key !== "tt" && !(key === "a" && order === UNDEFINED)) {
          if (minprop) {
            minprop = val === min;
          }
          if (maxprop) {
            maxprop = val === max;
          }
        }
        if (order !== UNDEFINED) {
          disabled[order] = /* @__PURE__ */ new Map();
          if (key !== "y" && key !== "dd") {
            for (var i = mins[key]; i <= maxs[key]; i += steps[key]) {
              if (i < min || i > max) {
                disabled[order].set(i, true);
              }
            }
          }
          if (key === "d" && invalids) {
            for (var d in invalids) {
              if (!valids || !valids[d]) {
                var dd = makeDate(d, s);
                var yy = s.getYear(dd);
                var mm = s.getMonth(dd);
                if (yy === y && mm === m && isInvalid(s, dd, invalids, valids)) {
                  disabled[order].set(s.getDay(dd), true);
                }
              }
            }
          }
        }
      });
      if (/time/i.test(preset)) {
        var invalidsForDay_1 = invalids && invalids[getDateStr(validated)];
        var validsForDay_1 = valids && valids[getDateStr(validated)];
        TIME_PARTS.forEach(function(key, i) {
          var order = wheelOrder[key];
          if (order !== UNDEFINED) {
            var entries = s.valid ? validsForDay_1 : invalidsForDay_1;
            if (entries) {
              if (s.valid) {
                for (var j2 = 0; j2 <= maxs[key]; j2++) {
                  disabled[order].set(j2, true);
                }
              }
              for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var entry = entries_1[_i];
                var start = entry.start;
                var end = entry.end;
                if (start && end) {
                  validateTimes(s, _this._hasAmPm, i, valid, wheelOrder, getDatePart, maxs, steps, key, disabled, order, validated, start, end, !!s.valid, s.exclusiveEndDates);
                }
              }
            }
            valid[order] = getValid(wheels[order], getDatePart[key](validated), disabled[order], direction);
          }
        });
      }
      var dateDisplay = _this._dateDisplay;
      if (dayWheel && (dayWheel.data.length !== maxDays || /DDD/.test(dateDisplay))) {
        var data = [];
        var dayDisplay = dateDisplay.replace(/[my|]/gi, "").replace(/DDDD/, "{dddd}").replace(/DDD/, "{ddd}").replace(/DD/, "{dd}").replace(/D/, "{d}");
        for (var j = 1; j <= maxDays; j++) {
          var weekDay = s.getDate(y, m, j).getDay();
          var dayStr = dayDisplay.replace(/{dddd}/, s.dayNames[weekDay]).replace(/{ddd}/, s.dayNamesShort[weekDay]).replace(/{dd}/, pad(j) + s.daySuffix).replace(/{d}/, j + s.daySuffix);
          data.push({
            display: dayStr,
            value: j
          });
        }
        dayWheel.data = data;
        init = true;
      }
      return {
        disabled,
        init,
        valid
      };
    };
    _this._shouldValidate = function(s, prevS) {
      return !!(s.min && +s.min !== +prevS.min || s.max && +s.max !== +prevS.max) || s.wheels !== prevS.wheels || s.dataTimezone !== prevS.dataTimezone || s.displayTimezone !== prevS.displayTimezone;
    };
    _this._getYearValue = function(i) {
      return {
        display: (/yy/i.test(_this._dateDisplay) ? i : (i + "").substr(2, 2)) + _this.s.yearSuffix,
        value: i
      };
    };
    _this._getYearIndex = function(i) {
      return +i;
    };
    _this._getDateIndex = function(i) {
      return getDateIndex(i, _this._hasDay);
    };
    _this._getDateItem = function(i) {
      var s = _this.s;
      var hasDay = _this._hasDay;
      var today = new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
      var d = hasDay ? new Date(i * 864e5) : new Date(1970, i, 1);
      if (hasDay) {
        d = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
      }
      return {
        disabled: hasDay && isInvalid(s, d, _this._invalids, _this._valids),
        display: today.getTime() === d.getTime() ? s.todayText : formatDate(_this._dateTemplate, d, s),
        value: getFullDate(d)
      };
    };
    _this._getArrayPart = function(values, part, d, def) {
      var ret;
      if (_this._wheelOrder[part] !== UNDEFINED) {
        ret = +values[_this._wheelOrder[part]];
        if (!isNaN(ret)) {
          return ret;
        }
      }
      if (d) {
        return _this._getDatePart[part](d);
      }
      if (_this._innerValues[part] !== UNDEFINED) {
        return _this._innerValues[part];
      }
      return _this._getDatePart[part](def);
    };
    _this._getHours = function(d) {
      var hour = d.getHours();
      hour = _this._hasAmPm && hour >= 12 ? hour - 12 : hour;
      return step(hour, _this.s.stepHour);
    };
    _this._getMinutes = function(d) {
      return step(d.getMinutes(), _this.s.stepMinute);
    };
    _this._getSeconds = function(d) {
      return step(d.getSeconds(), _this.s.stepSecond);
    };
    _this._getFullTime = function(d) {
      return step(round(getDayMilliseconds(d) / 1e3), _this._timeStep || 1);
    };
    return _this;
  }
  DatetimeBase2.prototype._valueEquals = function(v1, v2) {
    return dateValueEquals(v1, v2, this.s);
  };
  DatetimeBase2.prototype._render = function(s, state) {
    var genWheels = false;
    var prevProps = this._prevS;
    var dateFormat = s.dateFormat;
    var timeFormat = s.timeFormat;
    var preset = s.mode || this._preset;
    var format = preset === "datetime" ? dateFormat + s.separator + timeFormat : preset === "time" ? timeFormat : dateFormat;
    this._minWheelWidth = s.minWheelWidth || (preset === "datetime" ? WHEEL_WIDTHS[s.baseTheme || s.theme] : UNDEFINED);
    this._dateWheels = s.dateWheels || (preset === "datetime" ? s.dateWheelFormat : dateFormat);
    this._dateDisplay = s.dateWheels || s.dateDisplay;
    this._timeWheels = s.timeWheels || timeFormat;
    this._timeDisplay = this._timeWheels;
    this._format = format;
    this._hasAmPm = /h/.test(this._timeDisplay);
    this._getDatePart = {
      y: s.getYear,
      m: s.getMonth,
      d: s.getDay,
      h: this._getHours,
      i: this._getMinutes,
      s: this._getSeconds,
      u: getMilliseconds,
      a: getAmPm,
      dd: getFullDate,
      tt: this._getFullTime
    };
    if (+makeDate(prevProps.min) !== +makeDate(s.min)) {
      genWheels = true;
      this._min = isEmpty(s.min) ? UNDEFINED : makeDate(s.min, s, format);
    }
    if (+makeDate(prevProps.max) !== +makeDate(s.max)) {
      genWheels = true;
      this._max = isEmpty(s.max) ? UNDEFINED : makeDate(s.max, s, format);
    }
    if (s.theme !== prevProps.theme || s.mode !== prevProps.mode || s.locale !== prevProps.locale || s.dateWheels !== prevProps.dateWheels || s.timeWheels !== prevProps.timeWheels || genWheels) {
      this._wheels = this._getWheels();
    }
  };
  DatetimeBase2.prototype._getWheels = function() {
    this._wheelOrder = {};
    var s = this.s;
    var preset = s.mode || this._preset;
    var hasAmPm = this._hasAmPm;
    var dateDisplay = this._dateDisplay;
    var timeDisplay = this._timeDisplay;
    var wheelOrder = this._wheelOrder;
    var wheels = [];
    var dateGroup = [];
    var values;
    var timeGroup = [];
    var nr = 0;
    if (/date/i.test(preset)) {
      var dateParts = this._dateWheels.split(/\|/.test(this._dateWheels) ? "|" : "");
      for (var _i = 0, dateParts_1 = dateParts; _i < dateParts_1.length; _i++) {
        var template2 = dateParts_1[_i];
        var types = 0;
        if (template2.length) {
          if (/y/i.test(template2)) {
            types++;
          }
          if (/m/i.test(template2)) {
            types++;
          }
          if (/d/i.test(template2)) {
            types++;
          }
          if (types > 1 && wheelOrder.dd === UNDEFINED) {
            wheelOrder.dd = nr;
            nr++;
            dateGroup.push(this._getDateWheel(template2));
            timeGroup = dateGroup;
          } else if (/y/i.test(template2) && wheelOrder.y === UNDEFINED) {
            wheelOrder.y = nr;
            nr++;
            dateGroup.push({
              cssClass: "mbsc-datetime-year-wheel",
              getIndex: this._getYearIndex,
              getItem: this._getYearValue,
              label: s.yearText,
              max: this._max ? s.getYear(this._max) : UNDEFINED,
              min: this._min ? s.getYear(this._min) : UNDEFINED,
              spaceAround: true
            });
          } else if (/m/i.test(template2) && wheelOrder.m === UNDEFINED) {
            wheelOrder.m = nr;
            values = [];
            nr++;
            var monthDisplay = dateDisplay.replace(/[dy|]/gi, "").replace(/MMMM/, "{mmmm}").replace(/MMM/, "{mmm}").replace(/MM/, "{mm}").replace(/M/, "{m}");
            for (var j = 0; j < 12; j++) {
              var monthStr = monthDisplay.replace(/{mmmm}/, s.monthNames[j]).replace(/{mmm}/, s.monthNamesShort[j]).replace(/{mm}/, pad(j + 1) + (s.monthSuffix || "")).replace(/{m}/, j + 1 + (s.monthSuffix || ""));
              values.push({
                display: monthStr,
                value: j
              });
            }
            dateGroup.push({
              cssClass: "mbsc-datetime-month-wheel",
              data: values,
              label: s.monthText,
              spaceAround: true
            });
          } else if (/d/i.test(template2) && wheelOrder.d === UNDEFINED) {
            wheelOrder.d = nr;
            values = [];
            nr++;
            for (var j = 1; j < 32; j++) {
              values.push({
                display: (/dd/i.test(dateDisplay) ? pad(j) : j) + s.daySuffix,
                value: j
              });
            }
            dateGroup.push({
              cssClass: "mbsc-datetime-day-wheel",
              data: values,
              label: s.dayText,
              spaceAround: true
            });
          }
        }
      }
      wheels.push(dateGroup);
    }
    if (/time/i.test(preset)) {
      var timeParts = this._timeWheels.split(/\|/.test(this._timeWheels) ? "|" : "");
      for (var _a = 0, timeParts_1 = timeParts; _a < timeParts_1.length; _a++) {
        var template2 = timeParts_1[_a];
        var types = 0;
        if (template2.length) {
          if (/h/i.test(template2)) {
            types++;
          }
          if (/m/i.test(template2)) {
            types++;
          }
          if (/s/i.test(template2)) {
            types++;
          }
          if (/a/i.test(template2)) {
            types++;
          }
        }
        if (types > 1 && wheelOrder.tt === UNDEFINED) {
          wheelOrder.tt = nr;
          nr++;
          timeGroup.push(this._getTimeWheel(template2));
        } else if (/h/i.test(template2) && wheelOrder.h === UNDEFINED) {
          values = [];
          wheelOrder.h = nr;
          nr++;
          for (var j = 0; j < (hasAmPm ? 12 : 24); j += s.stepHour) {
            values.push({
              display: hasAmPm && j === 0 ? 12 : /hh/i.test(timeDisplay) ? pad(j) : j,
              value: j
            });
          }
          timeGroup.push({
            cssClass: "mbsc-datetime-hour-wheel",
            data: values,
            label: s.hourText,
            spaceAround: true
          });
        } else if (/m/i.test(template2) && wheelOrder.i === UNDEFINED) {
          values = [];
          wheelOrder.i = nr;
          nr++;
          for (var j = 0; j < 60; j += s.stepMinute) {
            values.push({
              display: /mm/i.test(timeDisplay) ? pad(j) : j,
              value: j
            });
          }
          timeGroup.push({
            cssClass: "mbsc-datetime-minute-wheel",
            data: values,
            label: s.minuteText,
            spaceAround: true
          });
        } else if (/s/i.test(template2) && wheelOrder.s === UNDEFINED) {
          values = [];
          wheelOrder.s = nr;
          nr++;
          for (var j = 0; j < 60; j += s.stepSecond) {
            values.push({
              display: /ss/i.test(timeDisplay) ? pad(j) : j,
              value: j
            });
          }
          timeGroup.push({
            cssClass: "mbsc-datetime-second-wheel",
            data: values,
            label: s.secondText,
            spaceAround: true
          });
        } else if (/a/i.test(template2) && wheelOrder.a === UNDEFINED) {
          wheelOrder.a = nr;
          nr++;
          timeGroup.push({
            cssClass: "mbsc-dt-whl-a",
            data: /A/.test(template2) ? [{
              display: s.amText.toUpperCase(),
              value: 0
            }, {
              display: s.pmText.toUpperCase(),
              value: 1
            }] : [{
              display: s.amText,
              value: 0
            }, {
              display: s.pmText,
              value: 1
            }],
            spaceAround: true
          });
        }
      }
      if (timeGroup !== dateGroup) {
        wheels.push(timeGroup);
      }
    }
    return wheels;
  };
  DatetimeBase2.prototype._getDateWheel = function(template2) {
    var hasDay = /d/i.test(template2);
    this._hasDay = hasDay;
    this._dateTemplate = template2;
    return {
      cssClass: "mbsc-datetime-date-wheel",
      getIndex: this._getDateIndex,
      getItem: this._getDateItem,
      label: this.s.dateText,
      max: this._max ? getDateIndex(getFullDate(this._max), hasDay) : UNDEFINED,
      min: this._min ? getDateIndex(getFullDate(this._min), hasDay) : UNDEFINED,
      spaceAround: true
    };
  };
  DatetimeBase2.prototype._getTimeWheel = function(template2) {
    var s = this.s;
    var values = [];
    var st = 1;
    if (/s/i.test(template2)) {
      st = s.stepSecond;
    } else if (/m/i.test(template2)) {
      st = s.stepMinute * 60;
    } else if (/h/i.test(template2)) {
      st = s.stepHour * 3600;
    }
    this._timeStep = st;
    for (var i = 0; i < 86400; i += st) {
      var time = new Date(+REF_DATE + i * 1e3);
      values.push({
        display: formatDate(template2, time, s),
        value: i
      });
    }
    return {
      data: values,
      label: s.timeText,
      spaceAround: true
    };
  };
  DatetimeBase2.prototype._getArray = function(d, fillInner) {
    var parts = ["y", "m", "d", "a", "h", "i", "s", "u", "dd", "tt"];
    var ret = [];
    var wheelOrder = this._wheelOrder;
    if (d === null || d === UNDEFINED) {
      return ret;
    }
    for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
      var part = parts_1[_i];
      var v = this._getDatePart[part](d);
      if (wheelOrder[part] !== UNDEFINED) {
        ret[wheelOrder[part]] = v;
      }
      if (fillInner) {
        this._innerValues[part] = v;
      }
    }
    return ret;
  };
  DatetimeBase2.defaults = __assign(__assign({}, dateTimeLocale), {
    dateDisplay: "MMMMDDYYYY",
    dateWheelFormat: "|DDD MMM D|",
    stepHour: 1,
    stepMinute: 1,
    stepSecond: 1
  });
  DatetimeBase2._name = "Datetime";
  DatetimeBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵDatetimeBase_BaseFactory;
    return function DatetimeBase_Factory(__ngFactoryType__) {
      return (ɵDatetimeBase_BaseFactory || (ɵDatetimeBase_BaseFactory = ɵɵgetInheritedFactory(DatetimeBase2)))(__ngFactoryType__ || DatetimeBase2);
    };
  })();
  DatetimeBase2.ɵdir = ɵɵdefineDirective({
    type: DatetimeBase2,
    selectors: [["", "mbsc-dt-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return DatetimeBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatetimeBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-dt-b]"
    }]
  }], null, null);
})();
var WheelBase = function(_super) {
  __extends(WheelBase2, _super);
  function WheelBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onIndexChange = function(args) {
      args.wheel = _this.s.wheel;
      _this._hook("onIndexChange", args);
    };
    _this._onItemClick = function(args) {
      _this._hook("onIndexChange", {
        click: true,
        index: args.index,
        wheel: _this.s.wheel,
        selected: args.selected
      });
    };
    _this._onKeyDown = function(ev) {
      var dir = 0;
      if (ev.keyCode === UP_ARROW) {
        dir = -1;
      } else if (ev.keyCode === DOWN_ARROW) {
        dir = 1;
      }
      var s = _this.s;
      var newIndex = s.activeIndex + dir;
      var change = !(newIndex < s.minIndex) && !(newIndex > s.maxIndex);
      if (dir) {
        ev.preventDefault();
      }
      if (dir && change) {
        var hook = s.selectOnScroll ? "onIndexChange" : "onActiveChange";
        _this._shouldFocus = true;
        _this._hook(hook, {
          diff: dir,
          index: newIndex,
          wheel: s.wheel
        });
      } else if (ev.keyCode === ENTER && s.multiple) {
        _this._hook("onSet", {});
      }
    };
    return _this;
  }
  WheelBase2.prototype._getText = function(data) {
    return data !== UNDEFINED ? data.display !== UNDEFINED ? data.display : data : UNDEFINED;
  };
  WheelBase2.prototype._getValue = function(data) {
    return data ? data.value !== UNDEFINED ? data.value : data.display !== UNDEFINED ? data.display : data : data;
  };
  WheelBase2.prototype._isActive = function(item, text, is3d) {
    var s = this.s;
    var d3 = s.scroll3d && s.multiple ? is3d : !is3d;
    return s.activeIndex === item.key && text && d3;
  };
  WheelBase2.prototype._isSelected = function(item) {
    var s = this.s;
    var selectedValues = s.selectedValues;
    var value = this._getValue(item.data);
    return s.multiple ? !!(selectedValues && selectedValues.indexOf) && selectedValues.indexOf(value) >= 0 : s.selectOnScroll ? item.key === s.selectedIndex : value !== UNDEFINED && value === selectedValues;
  };
  WheelBase2.prototype._isDisabled = function(data) {
    var disabledMap = this.s.disabled;
    var disabledProp = data && data.disabled;
    var value = this._getValue(data);
    return !!(disabledProp || disabledMap && disabledMap.get(value));
  };
  WheelBase2.prototype._render = function(s) {
    var rows = s.rows;
    var itemHeight = s.itemHeight;
    var key = s.wheel._key;
    var itemHeight3d = round((itemHeight - (itemHeight * rows / 2 + 3) * 0.03) / 2) * 2;
    this._items = s.wheel.getItem || s.wheel.data || [];
    this._batchSize3d = round(rows * 1.8);
    this._angle3d = 360 / (this._batchSize3d * 2);
    this._style = {
      height: round(rows * itemHeight * (s.scroll3d ? 1.1 : 1) / 2) * 2 + "px"
    };
    this._itemNr = s.wheel.spaceAround ? 1 : rows;
    this._innerStyle = {
      height: (s.scroll3d ? itemHeight3d : s.wheel.spaceAround ? itemHeight : itemHeight * rows) + "px"
    };
    this._wheelStyle = s.wheelWidth ? {
      width: (isArray(s.wheelWidth) ? s.wheelWidth[key] : s.wheelWidth) + "px"
    } : {
      maxWidth: (isArray(s.maxWheelWidth) ? s.maxWheelWidth[key] : s.maxWheelWidth) + "px",
      minWidth: (isArray(s.minWheelWidth) ? s.minWheelWidth[key] : s.minWheelWidth) + "px"
    };
    if (s.scroll3d) {
      this._innerStyle[cssPrefix + "transform"] = "translateY(-50%) translateZ(" + (itemHeight * rows / 2 + 3) + "px";
    }
  };
  WheelBase2.prototype._updated = function() {
    if (this._shouldFocus) {
      var item_1 = this._el.querySelector('[tabindex="0"]');
      if (item_1) {
        setTimeout(function() {
          item_1.focus();
        });
      }
      this._shouldFocus = false;
    }
  };
  WheelBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵWheelBase_BaseFactory;
    return function WheelBase_Factory(__ngFactoryType__) {
      return (ɵWheelBase_BaseFactory || (ɵWheelBase_BaseFactory = ɵɵgetInheritedFactory(WheelBase2)))(__ngFactoryType__ || WheelBase2);
    };
  })();
  WheelBase2.ɵdir = ɵɵdefineDirective({
    type: WheelBase2,
    selectors: [["", "mbsc-wh-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return WheelBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WheelBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-wh-b]"
    }]
  }], null, null);
})();
var WheelItemBase = function(_super) {
  __extends(WheelItemBase2, _super);
  function WheelItemBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onClick = function() {
      var s = _this.s;
      if (s.text !== UNDEFINED && !s.isGroup) {
        _this._hook("onClick", {
          index: s.index,
          selected: s.selected,
          disabled: s.disabled
        });
      }
    };
    return _this;
  }
  WheelItemBase2.prototype._mounted = function() {
    var _this = this;
    this._unlisten = gestureListener(this._el, {
      click: true,
      keepFocus: false,
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onFocus: function() {
        _this.setState({
          hasFocus: true
        });
      },
      onHoverIn: function() {
        if (_this.s.text !== UNDEFINED) {
          _this.setState({
            hasHover: true
          });
        }
      },
      onHoverOut: function() {
        if (_this.s.text !== UNDEFINED) {
          _this.setState({
            hasHover: false
          });
        }
      },
      onKeyDown: function(ev) {
        if (ev.keyCode === SPACE || !_this.s.multiple && ev.keyCode === ENTER) {
          _this._onClick();
        }
      },
      onPress: function() {
        if (_this.s.text !== UNDEFINED) {
          _this.setState({
            isActive: true
          });
        }
      },
      onRelease: function() {
        if (_this.s.text !== UNDEFINED) {
          _this.setState({
            isActive: false
          });
        }
      }
    });
  };
  WheelItemBase2.prototype._destroy = function() {
    this._unlisten();
  };
  WheelItemBase2.prototype._render = function(s, state) {
    var height = s.height;
    this._cssClass = "mbsc-scroller-wheel-" + (s.isGroup ? "header" : "item") + this._theme + this._rtl + (s.checkmark && !s.isGroup ? " mbsc-wheel-item-checkmark" : "") + (s.is3d ? " mbsc-scroller-wheel-item-3d" : "") + (s.scroll3d && !s.is3d ? " mbsc-scroller-wheel-item-2d" : "") + (s.selected && !s.is3d ? " mbsc-selected" : "") + (s.selected && s.is3d ? " mbsc-selected-3d" : "") + (s.disabled ? " mbsc-disabled" : "") + (s.multiple && !s.isGroup ? " mbsc-wheel-item-multi" : "") + (state.hasHover ? " mbsc-hover" : "") + (state.hasFocus ? " mbsc-focus" : "") + (state.isActive ? " mbsc-active" : "");
    this._style = {
      height: height + "px",
      lineHeight: height + "px"
    };
    this._checkmarkClass = this._theme + this._rtl + " mbsc-wheel-checkmark" + (s.selected ? " mbsc-selected" : "");
    if (s.is3d) {
      this._transform = "rotateX(" + (s.offset - s.index) * s.angle3d % 360 + "deg) translateZ(" + height * s.rows / 2 + "px)";
      this._style[cssPrefix + "transform"] = this._transform;
    }
  };
  WheelItemBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵWheelItemBase_BaseFactory;
    return function WheelItemBase_Factory(__ngFactoryType__) {
      return (ɵWheelItemBase_BaseFactory || (ɵWheelItemBase_BaseFactory = ɵɵgetInheritedFactory(WheelItemBase2)))(__ngFactoryType__ || WheelItemBase2);
    };
  })();
  WheelItemBase2.ɵdir = ɵɵdefineDirective({
    type: WheelItemBase2,
    selectors: [["", "mbsc-whi-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return WheelItemBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WheelItemBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-whi-b]"
    }]
  }], null, null);
})();
var MbscWheelItem = function(_super) {
  __extends(MbscWheelItem2, _super);
  function MbscWheelItem2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscWheelItem2.prototype._render = function(s, state) {
    _super.prototype._render.call(this, s, state);
    this._transform = this._sanitizer.bypassSecurityTrustStyle(this._transform);
  };
  MbscWheelItem2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscWheelItem_BaseFactory;
    return function MbscWheelItem_Factory(__ngFactoryType__) {
      return (ɵMbscWheelItem_BaseFactory || (ɵMbscWheelItem_BaseFactory = ɵɵgetInheritedFactory(MbscWheelItem2)))(__ngFactoryType__ || MbscWheelItem2);
    };
  })();
  MbscWheelItem2.ɵcmp = ɵɵdefineComponent({
    type: MbscWheelItem2,
    selectors: [["mbsc-wheel-item"]],
    hostAttrs: ["role", "option"],
    hostVars: 12,
    hostBindings: function MbscWheelItem_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("click", function MbscWheelItem_click_HostBindingHandler() {
          return ctx2._onClick();
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-disabled", ctx2.disabled ? "true" : void 0)("aria-hidden", ctx2.text === void 0 || ctx2.is3d ? "true" : void 0)("aria-selected", ctx2.selected ? "true" : void 0)("tabindex", ctx2.active ? 0 : ctx2.text === void 0 || ctx2.is3d ? void 0 : -1);
        ɵɵclassMap(ctx2._cssClass);
        ɵɵstyleProp("height", ctx2.height, "px")("line-height", ctx2.height, "px")("transform", ctx2._transform);
      }
    },
    inputs: {
      active: "active",
      angle3d: "angle3d",
      data: "data",
      disabled: "disabled",
      height: "height",
      is3d: "is3d",
      isGroup: "isGroup",
      index: "index",
      itemTemplate: "itemTemplate",
      multiple: "multiple",
      offset: "offset",
      rows: "rows",
      scroll3d: "scroll3d",
      selected: "selected",
      text: "text",
      onClick: "onClick",
      checkmark: "checkmark"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 4,
    consts: [[3, "innerHTML"], [3, "class", 4, "ngIf"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]],
    template: function MbscWheelItem_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelement(0, "div", 0);
        ɵɵtemplate(1, MbscWheelItem_span_1_Template, 1, 2, "span", 1)(2, MbscWheelItem_div_2_Template, 2, 4, "div", 2)(3, MbscWheelItem_ng_container_3_Template, 2, 1, "ng-container", 2);
      }
      if (rf & 2) {
        ɵɵproperty("innerHTML", ctx2.textParam, ɵɵsanitizeHtml);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.checkmark);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.itemTemplate && ctx2.data);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2.itemTemplate || !ctx2.data);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscWheelItem2;
}(WheelItemBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscWheelItem, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(click)": "_onClick()",
        "[attr.aria-disabled]": 'disabled ? "true" : undefined',
        "[attr.aria-hidden]": 'text === undefined || is3d ? "true" : undefined',
        "[attr.aria-selected]": 'selected ? "true" : undefined',
        "[attr.tabindex]": "active ? 0 : text === undefined || is3d ? undefined : -1",
        "[class]": "_cssClass",
        "[style.height.px]": "height",
        "[style.lineHeight.px]": "height",
        "[style.transform]": "_transform",
        role: "option"
      },
      selector: "mbsc-wheel-item",
      template: '<div [innerHTML]="textParam"></div><span *ngIf="checkmark" [class]="_checkmarkClass"></span>\n    <div *ngIf="itemTemplate && data">\n      <ng-template [ngTemplateOutlet]="itemTemplate" [ngTemplateOutletContext]="{ $implicit: data }"></ng-template>\n    </div>\n    <ng-container *ngIf="!itemTemplate || !data">{{ text }}</ng-container>'
    }]
  }], null, {
    active: [{
      type: Input
    }],
    angle3d: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    is3d: [{
      type: Input
    }],
    isGroup: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    offset: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    scroll3d: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    text: [{
      type: Input
    }],
    onClick: [{
      type: Input
    }],
    checkmark: [{
      type: Input
    }]
  });
})();
var MbscWheel = function(_super) {
  __extends(MbscWheel2, _super);
  function MbscWheel2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscWheel2.prototype._getItemKey = function(index, item) {
    return item.key;
  };
  MbscWheel2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscWheel_BaseFactory;
    return function MbscWheel_Factory(__ngFactoryType__) {
      return (ɵMbscWheel_BaseFactory || (ɵMbscWheel_BaseFactory = ɵɵgetInheritedFactory(MbscWheel2)))(__ngFactoryType__ || MbscWheel2);
    };
  })();
  MbscWheel2.ɵcmp = ɵɵdefineComponent({
    type: MbscWheel2,
    selectors: [["mbsc-wheel"]],
    hostAttrs: ["role", "listbox"],
    hostVars: 10,
    hostBindings: function MbscWheel_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("keydown", function MbscWheel_keydown_HostBindingHandler($event) {
          return ctx2._onKeyDown($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("aria-label", ctx2.wheel.label)("aria-multiselectable", ctx2.multiple ? "true" : void 0);
        ɵɵclassMap("mbsc-scroller-wheel-wrapper mbsc-scroller-wheel-wrapper-" + ctx2.wheel._key + " " + (ctx2.wheel.cssClass || "") + (ctx2.scroll3d ? " mbsc-scroller-wheel-wrapper-3d" : "") + ctx2._theme + ctx2._rtl);
        ɵɵstyleProp("max-width", ctx2._wheelStyle.maxWidth)("min-width", ctx2._wheelStyle.minWidth)("width", ctx2._wheelStyle.width);
      }
    },
    inputs: {
      activeIndex: "activeIndex",
      disabled: "disabled",
      display: "display",
      itemHeight: "itemHeight",
      itemTemplate: "itemTemplate",
      maxIndex: "maxIndex",
      maxWheelWidth: "maxWheelWidth",
      minIndex: "minIndex",
      minWheelWidth: "minWheelWidth",
      multiple: "multiple",
      rows: "rows",
      scroll3d: "scroll3d",
      selectedIndex: "selectedIndex",
      selectedValues: "selectedValues",
      selectOnScroll: "selectOnScroll",
      touchUi: "touchUi",
      wheel: "wheel",
      wheelWidth: "wheelWidth",
      onGestureEnd: "onGestureEnd",
      onGestureStart: "onGestureStart",
      onIndexChange: "onIndexChange",
      onActiveChange: "onActiveChange",
      onSet: "onSet"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 26,
    consts: [["scrollview", ""], [3, "batchSize3d", "innerClass", "innerStyles", "items", "itemSize", "itemNr", "margin", "maxIndex", "minIndex", "offset", "onIndexChange", "rtl", "scroll3d", "scrollBar", "selectedIndex", "snap", "spaceAround", "visibleSize"], [3, "active", "angle3d", "data", "disabled", "height", "is3d", "isGroup", "index", "itemTemplate", "multiple", "offset", "checkmark", "rows", "rtl", "scroll3d", "selected", "text", "theme", "onClick", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["content-3d", ""], [3, "active", "angle3d", "data", "disabled", "height", "is3d", "isGroup", "index", "itemTemplate", "multiple", "offset", "checkmark", "rows", "rtl", "scroll3d", "selected", "text", "theme", "onClick"]],
    template: function MbscWheel_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "mbsc-scrollview-base", 1, 0);
        ɵɵtemplate(2, MbscWheel_mbsc_wheel_item_2_Template, 1, 19, "mbsc-wheel-item", 2);
        ɵɵelementContainerStart(3, 3);
        ɵɵtemplate(4, MbscWheel_mbsc_wheel_item_4_Template, 1, 19, "mbsc-wheel-item", 2);
        ɵɵelementContainerEnd();
        ɵɵelementEnd();
      }
      if (rf & 2) {
        const scrollview_r3 = ɵɵreference(1);
        ɵɵclassMap("mbsc-scroller-wheel" + (ctx2.scroll3d ? " mbsc-scroller-wheel-3d" : "") + ctx2._theme);
        ɵɵstyleProp("height", ctx2._style.height);
        ɵɵproperty("batchSize3d", ctx2._batchSize3d)("innerClass", "mbsc-scroller-wheel-cont mbsc-scroller-wheel-cont-" + ctx2.display + (ctx2.scroll3d ? " mbsc-scroller-wheel-cont-3d" : "") + (ctx2.multiple ? " mbsc-scroller-wheel-multi" : "") + ctx2._theme)("innerStyles", ctx2._innerStyle)("items", ctx2._items)("itemSize", ctx2.itemHeight)("itemNr", ctx2._itemNr)("margin", true)("maxIndex", ctx2.maxIndex)("minIndex", ctx2.minIndex)("offset", ctx2.wheel._offset)("onIndexChange", ctx2._onIndexChange)("rtl", ctx2.rtl)("scroll3d", ctx2.scroll3d)("scrollBar", !ctx2._touchUi)("selectedIndex", ctx2.selectedIndex)("snap", true)("spaceAround", ctx2.wheel.spaceAround)("visibleSize", ctx2.rows);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", scrollview_r3.visibleItems)("ngForTrackBy", ctx2._getItemKey);
        ɵɵadvance(2);
        ɵɵproperty("ngForOf", scrollview_r3.visible3dItems)("ngForTrackBy", ctx2._getItemKey);
      }
    },
    dependencies: [MbscScrollviewBase, MbscWheelItem, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscWheel2;
}(WheelBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscWheel, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(keydown)": "_onKeyDown($event)",
        "[attr.aria-label]": "wheel.label",
        "[attr.aria-multiselectable]": 'multiple ? "true" : undefined',
        "[class]": '"mbsc-scroller-wheel-wrapper mbsc-scroller-wheel-wrapper-" + wheel._key + " " +\n        (wheel.cssClass || "") + (scroll3d ? " mbsc-scroller-wheel-wrapper-3d" : "") + _theme + _rtl',
        "[style.maxWidth]": "_wheelStyle.maxWidth",
        "[style.minWidth]": "_wheelStyle.minWidth",
        "[style.width]": "_wheelStyle.width",
        role: "listbox"
      },
      selector: "mbsc-wheel",
      template: `
    <mbsc-scrollview-base
      [class]="'mbsc-scroller-wheel' + (scroll3d ? ' mbsc-scroller-wheel-3d' : '') + _theme"
      #scrollview
      [batchSize3d]="_batchSize3d"
      [innerClass]="
        'mbsc-scroller-wheel-cont mbsc-scroller-wheel-cont-' +
        display +
        (scroll3d ? ' mbsc-scroller-wheel-cont-3d' : '') +
        (multiple ? ' mbsc-scroller-wheel-multi' : '') +
        _theme
      "
      [innerStyles]="_innerStyle"
      [items]="_items"
      [itemSize]="itemHeight"
      [itemNr]="_itemNr"
      [margin]="true"
      [maxIndex]="maxIndex"
      [minIndex]="minIndex"
      [offset]="wheel._offset"
      [onIndexChange]="_onIndexChange"
      [rtl]="rtl"
      [scroll3d]="scroll3d"
      [scrollBar]="!_touchUi"
      [selectedIndex]="selectedIndex"
      [snap]="true"
      [spaceAround]="wheel.spaceAround"
      [style.height]="_style.height"
      [visibleSize]="rows"
    >
      <mbsc-wheel-item
        *ngFor="let item of scrollview.visibleItems; trackBy: _getItemKey"
        [active]="_isActive(item, _getText(item.data), false)"
        [angle3d]="_angle3d"
        [data]="item.data"
        [disabled]="_isDisabled(item.data)"
        [height]="itemHeight"
        [is3d]="false"
        [isGroup]="item.data && item.data.isGroup"
        [index]="item.key"
        [itemTemplate]="itemTemplate"
        [multiple]="multiple"
        [offset]="scrollview._offset"
        [checkmark]="wheel.checkmark"
        [rows]="rows"
        [rtl]="rtl"
        [scroll3d]="scroll3d"
        [selected]="_isSelected(item)"
        [text]="_getText(item.data)"
        [theme]="theme"
        [onClick]="_onItemClick"
      >
      </mbsc-wheel-item>
      <ng-container content-3d>
        <mbsc-wheel-item
          *ngFor="let item of scrollview.visible3dItems; trackBy: _getItemKey"
          [active]="_isActive(item, _getText(item.data), true)"
          [angle3d]="_angle3d"
          [data]="item.data"
          [disabled]="_isDisabled(item.data)"
          [height]="itemHeight"
          [is3d]="true"
          [isGroup]="item.data && item.data.isGroup"
          [index]="item.key"
          [itemTemplate]="itemTemplate"
          [multiple]="multiple"
          [offset]="scrollview._offset"
          [checkmark]="wheel.checkmark"
          [rows]="rows"
          [rtl]="rtl"
          [scroll3d]="scroll3d"
          [selected]="_isSelected(item)"
          [text]="_getText(item.data)"
          [theme]="theme"
          [onClick]="_onItemClick"
        >
        </mbsc-wheel-item>
      </ng-container>
    </mbsc-scrollview-base>
  `
    }]
  }], null, {
    activeIndex: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    display: [{
      type: Input
    }],
    itemHeight: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    maxIndex: [{
      type: Input
    }],
    maxWheelWidth: [{
      type: Input
    }],
    minIndex: [{
      type: Input
    }],
    minWheelWidth: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    scroll3d: [{
      type: Input
    }],
    selectedIndex: [{
      type: Input
    }],
    selectedValues: [{
      type: Input
    }],
    selectOnScroll: [{
      type: Input
    }],
    touchUi: [{
      type: Input
    }],
    wheel: [{
      type: Input
    }],
    wheelWidth: [{
      type: Input
    }],
    onGestureEnd: [{
      type: Input
    }],
    onGestureStart: [{
      type: Input
    }],
    onIndexChange: [{
      type: Input
    }],
    onActiveChange: [{
      type: Input
    }],
    onSet: [{
      type: Input
    }]
  });
})();
var MbscScroller = function(_super) {
  __extends(MbscScroller2, _super);
  function MbscScroller2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onChange = new EventEmitter();
    _this.onTempChange = new EventEmitter();
    return _this;
  }
  MbscScroller2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscScroller_BaseFactory;
    return function MbscScroller_Factory(__ngFactoryType__) {
      return (ɵMbscScroller_BaseFactory || (ɵMbscScroller_BaseFactory = ɵɵgetInheritedFactory(MbscScroller2)))(__ngFactoryType__ || MbscScroller2);
    };
  })();
  MbscScroller2.ɵcmp = ɵɵdefineComponent({
    type: MbscScroller2,
    selectors: [["mbsc-scroller"]],
    inputs: {
      circular: "circular",
      displayStyle: "displayStyle",
      getValue: "getValue",
      maxWheelWidth: "maxWheelWidth",
      minWheelWidth: "minWheelWidth",
      inContentTemplate: "inContentTemplate",
      invalid: "invalid",
      itemHeight: "itemHeight",
      itemTemplate: "itemTemplate",
      onWheelMove: "onWheelMove",
      parseValue: "parseValue",
      preContentTemplate: "preContentTemplate",
      preContentData: "preContentData",
      rows: "rows",
      selectOnScroll: "selectOnScroll",
      shouldValidate: "shouldValidate",
      validate: "validate",
      valueEquality: "valueEquality",
      wheels: "wheels",
      wheelWidth: "wheelWidth",
      display: "display",
      valid: "valid"
    },
    outputs: {
      onChange: "onChange",
      onTempChange: "onTempChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 4,
    vars: 11,
    consts: [[3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", 4, "ngFor", "ngForOf"], [3, "class", "ngStyle", 4, "ngIf"], [3, "ngStyle"], [3, "activeIndex", "disabled", "display", "itemHeight", "onActiveChange", "onIndexChange", "onSet", "maxIndex", "maxWheelWidth", "minIndex", "minWheelWidth", "multiple", "rows", "scroll3d", "selectedIndex", "selectedValues", "selectOnScroll", "itemTemplate", "theme", "rtl", "wheel", "wheelWidth", "touchUi", 4, "ngFor", "ngForOf"], [3, "activeIndex", "disabled", "display", "itemHeight", "onActiveChange", "onIndexChange", "onSet", "maxIndex", "maxWheelWidth", "minIndex", "minWheelWidth", "multiple", "rows", "scroll3d", "selectedIndex", "selectedValues", "selectOnScroll", "itemTemplate", "theme", "rtl", "wheel", "wheelWidth", "touchUi"]],
    template: function MbscScroller_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscScroller_ng_template_0_Template, 0, 0, "ng-template", 0);
        ɵɵelementStart(1, "div");
        ɵɵtemplate(2, MbscScroller_ng_template_2_Template, 0, 0, "ng-template", 0)(3, MbscScroller_div_3_Template, 5, 9, "div", 1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngTemplateOutlet", ctx2.preContentTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c29, ctx2.preContentData));
        ɵɵadvance();
        ɵɵclassMap("mbsc-scroller mbsc-scroller-" + ctx2._displayStyle + ctx2._theme + ctx2._rtl + (ctx2._touchUi ? " mbsc-scroller-touch" : " mbsc-scroller-pointer ") + (ctx2.s.display === "inline" ? " mbsc-font " : " ") + ctx2._className);
        ɵɵadvance();
        ɵɵproperty("ngTemplateOutlet", ctx2.inContentTemplate)("ngTemplateOutletContext", ɵɵpureFunction1(9, _c29, ctx2.preContentData));
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx2._wheels);
      }
    },
    dependencies: [MbscWheel, NgTemplateOutlet, NgForOf, NgIf, NgStyle],
    encapsulation: 2,
    changeDetection: 0
  });
  MbscScroller2 = __decorate([FormControl], MbscScroller2);
  return MbscScroller2;
}(ScrollerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscScroller, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-scroller",
      template: ` <ng-template [ngTemplateOutlet]="preContentTemplate" [ngTemplateOutletContext]="{ data: preContentData }"> </ng-template>

    <div
      [class]="
        'mbsc-scroller mbsc-scroller-' +
        _displayStyle +
        _theme +
        _rtl +
        (_touchUi ? ' mbsc-scroller-touch' : ' mbsc-scroller-pointer ') +
        (s.display === 'inline' ? ' mbsc-font ' : ' ') +
        _className
      "
    >
      <ng-template [ngTemplateOutlet]="inContentTemplate" [ngTemplateOutletContext]="{ data: preContentData }"> </ng-template>
      <div
        *ngFor="let wheelGroup of _wheels"
        [class]="'mbsc-scroller-wheel-group-cont' + (s.scroll3d ? ' mbsc-scroller-wheel-group-cont-3d' : '') + _theme"
      >
        <div *ngIf="s.selectOnScroll" [class]="'mbsc-scroller-wheel-line' + _theme" [ngStyle]="_lineStyle"></div>
        <div [class]="'mbsc-flex mbsc-scroller-wheel-group' + (s.scroll3d ? ' mbsc-scroller-wheel-group-3d' : '') + _theme">
          <div
            [class]="'mbsc-scroller-wheel-overlay mbsc-scroller-wheel-overlay-' + _displayStyle + _theme"
            [ngStyle]="_overlayStyle"
          ></div>
          <mbsc-wheel
            *ngFor="let wheel of wheelGroup"
            [activeIndex]="_activeIndexes[wheel._key!]"
            [disabled]="_disabled && _disabled[wheel._key!]"
            [display]="_displayStyle"
            [itemHeight]="s.itemHeight"
            [onActiveChange]="_onActiveChange"
            [onIndexChange]="_onWheelIndexChange"
            [onSet]="_onSet"
            [maxIndex]="wheel.max"
            [maxWheelWidth]="s.maxWheelWidth"
            [minIndex]="wheel.min"
            [minWheelWidth]="s.minWheelWidth"
            [multiple]="wheel.multiple"
            [rows]="_rows"
            [scroll3d]="_scroll3d"
            [selectedIndex]="_indexes[wheel._key!]"
            [selectedValues]="_tempValueRep[wheel._key!]"
            [selectOnScroll]="s.selectOnScroll"
            [itemTemplate]="s.itemTemplate"
            [theme]="s.theme"
            [rtl]="s.rtl"
            [wheel]="wheel"
            [wheelWidth]="s.wheelWidth"
            [touchUi]="s.touchUi"
          >
          </mbsc-wheel>
        </div>
      </div>
    </div>`
    }]
  }], null, {
    circular: [{
      type: Input
    }],
    displayStyle: [{
      type: Input
    }],
    getValue: [{
      type: Input
    }],
    maxWheelWidth: [{
      type: Input
    }],
    minWheelWidth: [{
      type: Input
    }],
    inContentTemplate: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    itemHeight: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    onWheelMove: [{
      type: Input
    }],
    parseValue: [{
      type: Input
    }],
    preContentTemplate: [{
      type: Input
    }],
    preContentData: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    selectOnScroll: [{
      type: Input
    }],
    shouldValidate: [{
      type: Input
    }],
    validate: [{
      type: Input
    }],
    valueEquality: [{
      type: Input
    }],
    wheels: [{
      type: Input
    }],
    wheelWidth: [{
      type: Input
    }],
    display: [{
      type: Input
    }],
    valid: [{
      type: Input
    }],
    onChange: [{
      type: Output
    }],
    onTempChange: [{
      type: Output
    }]
  });
})();
var TEMPLATE = '\n  <mbsc-scroller\n    [display]="s.display"\n    [circular]="s.circular"\n    [displayStyle]="s.displayStyle"\n    [getValue]="_getDate"\n    [itemHeight]="s.itemHeight"\n    [maxWheelWidth]="s.maxWheelWidth"\n    [minWheelWidth]="_minWheelWidth"\n    [value]="s.value"\n    [parseValue]="_parseDate"\n    [rows]="s.rows"\n    [rtl]="s.rtl"\n    [shouldValidate]="_shouldValidate"\n    [theme]="s.theme"\n    [themeVariant]="s.themeVariant"\n    [touchUi]="_touchUi"\n    [validate]="_validate"\n    [valueEquality]="_valueEquals"\n    [wheels]="_wheels"\n    [wheelWidth]="s.wheelWidth"\n    [invalid]="s.invalid"\n    [valid]="s.valid"\n    (onChange)="_proxyHook($event)"\n    (onTempChange)="_proxyHook($event)"\n  ></mbsc-scroller>\n  ';
var MbscDateBase = function(_super) {
  __extends(MbscDateBase2, _super);
  function MbscDateBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onChange = new EventEmitter();
    _this.onTempChange = new EventEmitter();
    return _this;
  }
  MbscDateBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDateBase_BaseFactory;
    return function MbscDateBase_Factory(__ngFactoryType__) {
      return (ɵMbscDateBase_BaseFactory || (ɵMbscDateBase_BaseFactory = ɵɵgetInheritedFactory(MbscDateBase2)))(__ngFactoryType__ || MbscDateBase2);
    };
  })();
  MbscDateBase2.ɵdir = ɵɵdefineDirective({
    type: MbscDateBase2,
    selectors: [["", "mbsc-dtb-b", ""]],
    outputs: {
      onChange: "onChange",
      onTempChange: "onTempChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  MbscDateBase2 = __decorate([FormControl], MbscDateBase2);
  return MbscDateBase2;
}(DatetimeBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDateBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-dtb-b]"
    }]
  }], null, {
    onChange: [{
      type: Output
    }],
    onTempChange: [{
      type: Output
    }]
  });
})();
var MbscDate = function(_super) {
  __extends(MbscDate2, _super);
  function MbscDate2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscDate2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDate_BaseFactory;
    return function MbscDate_Factory(__ngFactoryType__) {
      return (ɵMbscDate_BaseFactory || (ɵMbscDate_BaseFactory = ɵɵgetInheritedFactory(MbscDate2)))(__ngFactoryType__ || MbscDate2);
    };
  })();
  MbscDate2.ɵcmp = ɵɵdefineComponent({
    type: MbscDate2,
    selectors: [["mbsc-date"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 21,
    consts: [[3, "onChange", "onTempChange", "display", "circular", "displayStyle", "getValue", "itemHeight", "maxWheelWidth", "minWheelWidth", "value", "parseValue", "rows", "rtl", "shouldValidate", "theme", "themeVariant", "touchUi", "validate", "valueEquality", "wheels", "wheelWidth", "invalid", "valid"]],
    template: function MbscDate_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "mbsc-scroller", 0);
        ɵɵlistener("onChange", function MbscDate_Template_mbsc_scroller_onChange_0_listener($event) {
          return ctx2._proxyHook($event);
        })("onTempChange", function MbscDate_Template_mbsc_scroller_onTempChange_0_listener($event) {
          return ctx2._proxyHook($event);
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("display", ctx2.s.display)("circular", ctx2.s.circular)("displayStyle", ctx2.s.displayStyle)("getValue", ctx2._getDate)("itemHeight", ctx2.s.itemHeight)("maxWheelWidth", ctx2.s.maxWheelWidth)("minWheelWidth", ctx2._minWheelWidth)("value", ctx2.s.value)("parseValue", ctx2._parseDate)("rows", ctx2.s.rows)("rtl", ctx2.s.rtl)("shouldValidate", ctx2._shouldValidate)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant)("touchUi", ctx2._touchUi)("validate", ctx2._validate)("valueEquality", ctx2._valueEquals)("wheels", ctx2._wheels)("wheelWidth", ctx2.s.wheelWidth)("invalid", ctx2.s.invalid)("valid", ctx2.s.valid);
      }
    },
    dependencies: [MbscScroller],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscDate2;
}(MbscDateBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDate, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-date",
      template: TEMPLATE
    }]
  }], null, null);
})();
var MbscDatetime = function(_super) {
  __extends(MbscDatetime2, _super);
  function MbscDatetime2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._preset = "datetime";
    return _this;
  }
  MbscDatetime2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDatetime_BaseFactory;
    return function MbscDatetime_Factory(__ngFactoryType__) {
      return (ɵMbscDatetime_BaseFactory || (ɵMbscDatetime_BaseFactory = ɵɵgetInheritedFactory(MbscDatetime2)))(__ngFactoryType__ || MbscDatetime2);
    };
  })();
  MbscDatetime2.ɵcmp = ɵɵdefineComponent({
    type: MbscDatetime2,
    selectors: [["mbsc-datetime"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 21,
    consts: [[3, "onChange", "onTempChange", "display", "circular", "displayStyle", "getValue", "itemHeight", "maxWheelWidth", "minWheelWidth", "value", "parseValue", "rows", "rtl", "shouldValidate", "theme", "themeVariant", "touchUi", "validate", "valueEquality", "wheels", "wheelWidth", "invalid", "valid"]],
    template: function MbscDatetime_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "mbsc-scroller", 0);
        ɵɵlistener("onChange", function MbscDatetime_Template_mbsc_scroller_onChange_0_listener($event) {
          return ctx2._proxyHook($event);
        })("onTempChange", function MbscDatetime_Template_mbsc_scroller_onTempChange_0_listener($event) {
          return ctx2._proxyHook($event);
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("display", ctx2.s.display)("circular", ctx2.s.circular)("displayStyle", ctx2.s.displayStyle)("getValue", ctx2._getDate)("itemHeight", ctx2.s.itemHeight)("maxWheelWidth", ctx2.s.maxWheelWidth)("minWheelWidth", ctx2._minWheelWidth)("value", ctx2.s.value)("parseValue", ctx2._parseDate)("rows", ctx2.s.rows)("rtl", ctx2.s.rtl)("shouldValidate", ctx2._shouldValidate)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant)("touchUi", ctx2._touchUi)("validate", ctx2._validate)("valueEquality", ctx2._valueEquals)("wheels", ctx2._wheels)("wheelWidth", ctx2.s.wheelWidth)("invalid", ctx2.s.invalid)("valid", ctx2.s.valid);
      }
    },
    dependencies: [MbscScroller],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscDatetime2;
}(MbscDateBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDatetime, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-datetime",
      template: TEMPLATE
    }]
  }], null, null);
})();
var MbscTime = function(_super) {
  __extends(MbscTime2, _super);
  function MbscTime2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._preset = "time";
    return _this;
  }
  MbscTime2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscTime_BaseFactory;
    return function MbscTime_Factory(__ngFactoryType__) {
      return (ɵMbscTime_BaseFactory || (ɵMbscTime_BaseFactory = ɵɵgetInheritedFactory(MbscTime2)))(__ngFactoryType__ || MbscTime2);
    };
  })();
  MbscTime2.ɵcmp = ɵɵdefineComponent({
    type: MbscTime2,
    selectors: [["mbsc-time"]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 21,
    consts: [[3, "onChange", "onTempChange", "display", "circular", "displayStyle", "getValue", "itemHeight", "maxWheelWidth", "minWheelWidth", "value", "parseValue", "rows", "rtl", "shouldValidate", "theme", "themeVariant", "touchUi", "validate", "valueEquality", "wheels", "wheelWidth", "invalid", "valid"]],
    template: function MbscTime_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "mbsc-scroller", 0);
        ɵɵlistener("onChange", function MbscTime_Template_mbsc_scroller_onChange_0_listener($event) {
          return ctx2._proxyHook($event);
        })("onTempChange", function MbscTime_Template_mbsc_scroller_onTempChange_0_listener($event) {
          return ctx2._proxyHook($event);
        });
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("display", ctx2.s.display)("circular", ctx2.s.circular)("displayStyle", ctx2.s.displayStyle)("getValue", ctx2._getDate)("itemHeight", ctx2.s.itemHeight)("maxWheelWidth", ctx2.s.maxWheelWidth)("minWheelWidth", ctx2._minWheelWidth)("value", ctx2.s.value)("parseValue", ctx2._parseDate)("rows", ctx2.s.rows)("rtl", ctx2.s.rtl)("shouldValidate", ctx2._shouldValidate)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant)("touchUi", ctx2._touchUi)("validate", ctx2._validate)("valueEquality", ctx2._valueEquals)("wheels", ctx2._wheels)("wheelWidth", ctx2.s.wheelWidth)("invalid", ctx2.s.invalid)("valid", ctx2.s.valid);
      }
    },
    dependencies: [MbscScroller],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscTime2;
}(MbscDateBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscTime, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-time",
      template: TEMPLATE
    }]
  }], null, null);
})();
function getClosestNumber(arr, value) {
  if (isEmpty(value) || !arr.length) {
    return null;
  }
  var i = 0;
  while (i < arr.length && value >= arr[i]) {
    i++;
  }
  if (i === arr.length) {
    return arr[i - 1];
  } else if (i === 0) {
    return arr[0];
  } else {
    var prev = arr[i - 1];
    var next = arr[i];
    return value - prev < next - value ? prev : next;
  }
}
var TimegridBase = function(_super) {
  __extends(TimegridBase2, _super);
  function TimegridBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._setTime = function(timeSlot) {
      _this._hook("onChange", {
        value: createDate$1(_this.s, timeSlot.value)
      });
    };
    _this._isDisabled = function(d) {
      if (d) {
        var key = getDateStr(createDate$1(_this.s, d));
        var invalidsForDay = _this._invalids && _this._invalids[key];
        var validsForDay = _this._valids && _this._valids[key];
        var exclusiveEndDates = _this.s.exclusiveEndDates;
        if (validsForDay) {
          for (var _i = 0, validsForDay_1 = validsForDay; _i < validsForDay_1.length; _i++) {
            var valid = validsForDay_1[_i];
            var lessThanEnd = valid.end && (exclusiveEndDates ? d < +valid.end : d <= +valid.end);
            if (valid.start && d >= +valid.start && lessThanEnd || valid.allDay) {
              return false;
            }
          }
          return true;
        }
        if (invalidsForDay) {
          for (var _a = 0, invalidsForDay_1 = invalidsForDay; _a < invalidsForDay_1.length; _a++) {
            var invalid = invalidsForDay_1[_a];
            var lessThanEnd = invalid.end && (exclusiveEndDates ? d < +invalid.end : d <= +invalid.end);
            if (invalid.start && d >= +invalid.start && lessThanEnd || invalid.allDay) {
              return true;
            }
          }
          return false;
        }
      }
      return false;
    };
    _this._onKeyDown = function(ev) {
      switch (ev.keyCode) {
        case SPACE:
          ev.target.click();
          ev.preventDefault();
          break;
      }
    };
    _this._setCont = function(el2) {
      _this._gridContEl = el2 && el2.parentElement;
    };
    return _this;
  }
  TimegridBase2.prototype._render = function(s, state) {
    var _this = this;
    var prevS = this._prevS;
    this._cssClass = "mbsc-timegrid-container mbsc-font" + this._theme + this._rtl;
    var minChanged = s.min !== prevS.min;
    var maxChanged = s.max !== prevS.max;
    var timeFormat = s.timeFormat;
    var valueChanged = prevS.value && !s.value || s.value && +s.value !== this._value;
    if (minChanged) {
      this._min = isEmpty(s.min) ? UNDEFINED : makeDate(s.min, s, timeFormat);
    }
    if (maxChanged) {
      this._max = isEmpty(s.max) ? UNDEFINED : makeDate(s.max, s, timeFormat);
    }
    var selected = s.value || getClosestValidDate(createDate$1(s), s, -Infinity, Infinity);
    var dayStart = getDateOnly(selected);
    var dayEnd = addDays(dayStart, 1);
    var currentDateChanged = this._selectedDate !== +dayStart;
    var invChanged = s.invalid !== prevS.invalid;
    var validChanged = s.valid !== prevS.valid;
    if (invChanged || currentDateChanged) {
      this._invalids = getEventMap(s.invalid, dayStart, dayEnd, s, true, true);
    }
    if (validChanged || currentDateChanged) {
      this._valids = getEventMap(s.valid, dayStart, dayEnd, s, true, true);
    }
    if (valueChanged) {
      this._value = s.value && +s.value;
    }
    var timeSlotsChange = currentDateChanged || invChanged || minChanged || maxChanged || timeFormat !== prevS.timeFormat;
    if (timeSlotsChange) {
      this._selectedDate = +dayStart;
      var start = Math.max(+dayStart, +(this._min || -Infinity));
      var end = Math.min(+dayEnd, +(this._max || Infinity) + 1);
      var timeInterval = s.stepHour * 36e5 + s.stepMinute * 6e4;
      this._timeSlots = [];
      this._validTimes = [];
      var arr = [];
      var i = 0;
      for (var d = +dayStart; d < +dayEnd; d += timeInterval) {
        if (end >= start ? d >= start && d < end : d >= start || d < end) {
          var timeslot = {
            formattedValue: formatDate(timeFormat, createDate$1(s, d), s),
            value: d
          };
          arr.push(timeslot);
          if (i === 2) {
            this._timeSlots.push(arr);
            arr = [];
            i = -1;
          }
          if (!this._isDisabled(d)) {
            this._validTimes.push(timeslot);
          }
          i++;
        }
      }
      if (arr.length) {
        this._timeSlots.push(arr);
      }
    }
    if (this._isDisabled(this._value) || (valueChanged || timeSlotsChange) && findIndex(this._validTimes, function(ts) {
      return ts.value === _this._value;
    }) === -1) {
      var validated_1 = getClosestNumber(this._validTimes.map(function(slot) {
        return slot.value;
      }), this._value);
      if (validated_1) {
        clearTimeout(this._validationHandle);
        this._validationHandle = setTimeout(function() {
          var validTimeslot = find(_this._validTimes, function(slot) {
            return slot.value === validated_1;
          });
          _this._setTime(validTimeslot);
        });
      }
    } else if (timeSlotsChange) {
      clearTimeout(this._validationHandle);
    }
    this._valueChanged = this._valueChanged || valueChanged;
  };
  TimegridBase2.prototype._updated = function() {
    var isOpen = this.s.isOpen;
    if (isBrowser && this._value !== UNDEFINED && (this._valueChanged || this._isOpen !== isOpen && isOpen)) {
      var animate_1 = this._lastValue !== UNDEFINED;
      var grid_1 = this._gridContEl;
      var timeslot_1 = grid_1.querySelector('[data-timeslot="' + this._value + '"]');
      if (timeslot_1) {
        setTimeout(function() {
          var itemRect = timeslot_1.getBoundingClientRect();
          var itemTop = itemRect.top;
          var itemHeight = itemRect.height;
          var gridRect = grid_1.getBoundingClientRect();
          var gridTop = gridRect.top;
          var gridHeight = gridRect.height;
          var currPos = getScrollTop(grid_1);
          if (itemTop + itemHeight > gridTop + gridHeight || itemTop < gridTop) {
            var scrollPos = itemTop - gridTop + currPos - 5;
            smoothScroll(grid_1, UNDEFINED, scrollPos, animate_1);
          }
        });
      }
      this._valueChanged = false;
      this._lastValue = this._value;
    }
    this._isOpen = isOpen;
  };
  TimegridBase2.defaults = __assign(__assign({}, dateTimeLocale), {
    stepHour: 0,
    stepMinute: 30
  });
  TimegridBase2._name = "Timegrid";
  TimegridBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵTimegridBase_BaseFactory;
    return function TimegridBase_Factory(__ngFactoryType__) {
      return (ɵTimegridBase_BaseFactory || (ɵTimegridBase_BaseFactory = ɵɵgetInheritedFactory(TimegridBase2)))(__ngFactoryType__ || TimegridBase2);
    };
  })();
  TimegridBase2.ɵdir = ɵɵdefineDirective({
    type: TimegridBase2,
    selectors: [["", "mbsc-tg-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return TimegridBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimegridBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-tg-b]"
    }]
  }], null, null);
})();
var MbscTimeBox = function() {
  function MbscTimeBox2() {
  }
  MbscTimeBox2.ɵfac = function MbscTimeBox_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscTimeBox2)();
  };
  MbscTimeBox2.ɵcmp = ɵɵdefineComponent({
    type: MbscTimeBox2,
    selectors: [["mbsc-timebox"]],
    inputs: {
      disabled: "disabled",
      selected: "selected",
      timeSlot: "timeSlot",
      theme: "theme",
      onClick: "onClick",
      onKeyDown: "onKeyDown"
    },
    standalone: false,
    decls: 2,
    vars: 5,
    consts: [[3, "click", "keydown"]],
    template: function MbscTimeBox_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0);
        ɵɵlistener("click", function MbscTimeBox_Template_div_click_0_listener() {
          return ctx2.onClick(ctx2.timeSlot);
        })("keydown", function MbscTimeBox_Template_div_keydown_0_listener($event) {
          return ctx2.onKeyDown($event);
        });
        ɵɵtext(1);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap("mbsc-timegrid-item" + (ctx2.selected ? " mbsc-selected" : "") + (ctx2.disabled ? " mbsc-disabled" : "") + ctx2.theme);
        ɵɵattribute("data-timeslot", ctx2.timeSlot.value)("tabIndex", ctx2.disabled ? null : 0);
        ɵɵadvance();
        ɵɵtextInterpolate1(" ", ctx2.timeSlot.formattedValue, " ");
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscTimeBox2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscTimeBox, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-timebox",
      template: `<div
    [attr.data-timeslot]="timeSlot.value"
    [attr.tabIndex]="disabled ? null : 0"
    [class]="'mbsc-timegrid-item' + (selected ? ' mbsc-selected' : '') + (disabled ? ' mbsc-disabled' : '') + theme"
    (click)="onClick(timeSlot)"
    (keydown)="onKeyDown($event)"
  >
    {{ timeSlot.formattedValue }}
  </div>`
    }]
  }], null, {
    disabled: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    timeSlot: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    onClick: [{
      type: Input
    }],
    onKeyDown: [{
      type: Input
    }]
  });
})();
var MbscTimegrid = function(_super) {
  __extends(MbscTimegrid2, _super);
  function MbscTimegrid2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscTimegrid2.prototype._mounted = function() {
    var el2 = this._elr.nativeElement;
    this._gridContEl = el2 && el2.parentElement;
  };
  MbscTimegrid2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscTimegrid_BaseFactory;
    return function MbscTimegrid_Factory(__ngFactoryType__) {
      return (ɵMbscTimegrid_BaseFactory || (ɵMbscTimegrid_BaseFactory = ɵɵgetInheritedFactory(MbscTimegrid2)))(__ngFactoryType__ || MbscTimegrid2);
    };
  })();
  MbscTimegrid2.ɵcmp = ɵɵdefineComponent({
    type: MbscTimegrid2,
    selectors: [["mbsc-timegrid"]],
    hostVars: 2,
    hostBindings: function MbscTimegrid_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 1,
    vars: 2,
    consts: [["class", "mbsc-timegrid-row", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-timegrid-row"], [3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "innerHTML"], [3, "disabled", "selected", "timeSlot", "theme", "onClick", "onKeyDown"]],
    template: function MbscTimegrid_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscTimegrid_div_0_Template, 2, 2, "div", 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngForOf", ctx2._timeSlots)("ngForTrackBy", ctx2._getKey);
      }
    },
    dependencies: [MbscTimeBox, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscTimegrid2;
}(TimegridBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscTimegrid, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-timegrid",
      template: `
    <div *ngFor="let arr of _timeSlots; let rowIndex = index; trackBy: _getKey" class="mbsc-timegrid-row">
      <div
        *ngFor="let v of arr; let cellIndex = index; trackBy: _getKey"
        [class]="'mbsc-timegrid-cell' + (_isDisabled(v.value) ? ' mbsc-disabled' : '')"
      >
        <div [innerHTML]="textParamMulti(rowIndex*3+cellIndex)"></div>
        <mbsc-timebox
          [disabled]="_isDisabled(v.value)"
          [selected]="_value === v.value"
          [timeSlot]="v"
          [theme]="_theme"
          [onClick]="_setTime"
          [onKeyDown]="_onKeyDown"
        >
        </mbsc-timebox>
      </div>
    </div>
  `
    }]
  }], null, null);
})();
var radios = {};
function subscribeRadio(name, handler) {
  if (!radios[name]) {
    radios[name] = {
      change: new Observable(),
      selectedIndex: -1
    };
  }
  return radios[name].change.subscribe(handler);
}
function unsubscribeRadio(name, key) {
  var data = radios[name];
  if (data) {
    data.change.unsubscribe(key);
    if (!data.change.nr) {
      delete radios[name];
    }
  }
}
function setRadio(name, value, selectedIndex) {
  var data = radios[name];
  if (data) {
    if (selectedIndex !== UNDEFINED) {
      data.selectedIndex = selectedIndex;
    }
    if (value !== UNDEFINED) {
      data.value = value;
    }
    data.change.next(data.value);
  }
}
function getSelectedIndex(name) {
  return radios[name] && radios[name].selectedIndex;
}
function setSelectedIndex(name, selectedIndex) {
  if (radios[name]) {
    radios[name].selectedIndex = selectedIndex;
  }
}
var guid$5 = 1;
var SegmentedGroupBase = function(_super) {
  __extends(SegmentedGroupBase2, _super);
  function SegmentedGroupBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._id = "mbsc-segmented-group" + guid$5++;
    _this._onChange = function(ev, val) {
      var s = _this.s;
      var value = s.modelValue !== UNDEFINED ? s.modelValue : _this.value;
      if (s.select === "multiple") {
        if (value !== UNDEFINED) {
          value = value || [];
          var index = value.indexOf(val);
          if (index !== -1) {
            value.splice(index, 1);
          } else {
            value.push(val);
          }
          _this.value = __spreadArray([], value, true);
        }
      } else {
        _this.value = val;
      }
      _this._change(_this.value);
      if (s.onChange) {
        s.onChange(ev);
      }
    };
    return _this;
  }
  SegmentedGroupBase2.prototype._change = function(value) {
  };
  SegmentedGroupBase2.prototype._render = function(s, state) {
    this._name = s.name === UNDEFINED ? this._id : s.name;
    this._groupClass = "mbsc-segmented mbsc-flex " + this._className + this._theme + this._rtl + (s.color ? " mbsc-segmented-" + s.color : "") + (state.dragging ? " mbsc-segmented-dragging" : "");
    this._groupOpt = {
      color: s.color,
      disabled: s.disabled,
      name: this._name,
      onChange: this._onChange,
      select: s.select,
      value: s.modelValue !== UNDEFINED ? s.modelValue : s.value
    };
  };
  SegmentedGroupBase2.prototype._updated = function() {
    if (this.s.drag && this.s.select !== "multiple") {
      if (!this._unlisten) {
        this._setupDrag();
      }
    } else {
      this._cleanupDrag();
    }
  };
  SegmentedGroupBase2.prototype._destroy = function() {
    this._cleanupDrag();
  };
  SegmentedGroupBase2.prototype._setupDrag = function() {
    var _this = this;
    var disabledArray;
    var itemLefts;
    var isDragging;
    var selectedIndex;
    var oldIndex;
    var name;
    this._unlisten = gestureListener(this._el, {
      onEnd: function() {
        if (isDragging && selectedIndex !== oldIndex && !disabledArray[selectedIndex]) {
          var inputElement = _this._el.querySelectorAll(".mbsc-segmented-input")[selectedIndex];
          inputElement.click();
        }
        isDragging = false;
        _this.setState({
          dragging: false
        });
      },
      onMove: function(ev) {
        if (isDragging) {
          var i = 0;
          var newIndex = 0;
          while (ev.endX > itemLefts[i] && i < itemLefts.length) {
            newIndex = i;
            i++;
          }
          newIndex = _this.s.rtl ? itemLefts.length - newIndex - 1 : newIndex;
          if (newIndex !== selectedIndex && !disabledArray[newIndex]) {
            selectedIndex = newIndex;
            setRadio(name, UNDEFINED, selectedIndex);
          }
        }
      },
      onStart: function(ev) {
        var item = closest(ev.domEvent.target, ".mbsc-segmented-item", _this._el);
        if (!item) {
          return;
        }
        var input = item.querySelector(".mbsc-segmented-input");
        var classList = input.classList;
        if (classList.contains("mbsc-selected")) {
          disabledArray = [];
          forEach(_this._el.querySelectorAll(".mbsc-segmented-button"), function(button) {
            disabledArray.push(button.classList.contains("mbsc-disabled"));
          });
          itemLefts = [];
          forEach(_this._el.querySelectorAll(".mbsc-segmented-item"), function(el2) {
            if (_this.s.rtl) {
              itemLefts.unshift(getOffset(el2).left);
            } else {
              itemLefts.push(getOffset(el2).left);
            }
          });
          name = input.name;
          selectedIndex = getSelectedIndex(name);
          oldIndex = selectedIndex;
          if (itemLefts.length && input.type === "radio") {
            isDragging = true;
            _this.setState({
              dragging: true
            });
          }
        }
      }
    });
  };
  SegmentedGroupBase2.prototype._cleanupDrag = function() {
    if (this._unlisten) {
      this._unlisten();
      this._unlisten = null;
    }
  };
  SegmentedGroupBase2.defaults = {
    select: "single"
  };
  SegmentedGroupBase2._name = "SegmentedGroup";
  SegmentedGroupBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵSegmentedGroupBase_BaseFactory;
    return function SegmentedGroupBase_Factory(__ngFactoryType__) {
      return (ɵSegmentedGroupBase_BaseFactory || (ɵSegmentedGroupBase_BaseFactory = ɵɵgetInheritedFactory(SegmentedGroupBase2)))(__ngFactoryType__ || SegmentedGroupBase2);
    };
  })();
  SegmentedGroupBase2.ɵdir = ɵɵdefineDirective({
    type: SegmentedGroupBase2,
    selectors: [["", "mbsc-sgr-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return SegmentedGroupBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SegmentedGroupBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sgr-b]"
    }]
  }], null, null);
})();
var MbscRadioService = function() {
  function MbscRadioService2() {
  }
  MbscRadioService2.ɵfac = function MbscRadioService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscRadioService2)();
  };
  MbscRadioService2.ɵprov = ɵɵdefineInjectable({
    token: MbscRadioService2,
    factory: MbscRadioService2.ɵfac
  });
  return MbscRadioService2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscRadioService, [{
    type: Injectable
  }], null, null);
})();
var MbscSegmentedGroup = function(_super) {
  __extends(MbscSegmentedGroup2, _super);
  function MbscSegmentedGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscSegmentedGroup2.prototype._onValueChange = function(value) {
    this._radioService.value = value;
    setRadio(this._radioService.name, value);
  };
  MbscSegmentedGroup2.prototype._ctor = function() {
    this._radioService = this._injector.get(MbscRadioService);
  };
  MbscSegmentedGroup2.prototype._render = function(s, state) {
    _super.prototype._render.call(this, s, state);
    var rs = this._radioService;
    rs.color = s.color;
    rs.disabled = s.disabled;
    rs.name = this._name;
    rs.select = s.select;
    rs.value = this.value;
    rs.onChange = this._onChange;
  };
  MbscSegmentedGroup2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSegmentedGroup_BaseFactory;
    return function MbscSegmentedGroup_Factory(__ngFactoryType__) {
      return (ɵMbscSegmentedGroup_BaseFactory || (ɵMbscSegmentedGroup_BaseFactory = ɵɵgetInheritedFactory(MbscSegmentedGroup2)))(__ngFactoryType__ || MbscSegmentedGroup2);
    };
  })();
  MbscSegmentedGroup2.ɵcmp = ɵɵdefineComponent({
    type: MbscSegmentedGroup2,
    selectors: [["mbsc-segmented-group"]],
    hostVars: 2,
    hostBindings: function MbscSegmentedGroup_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._groupClass);
      }
    },
    inputs: {
      color: "color",
      disabled: "disabled",
      name: "name",
      select: "select"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MbscRadioService]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscSegmentedGroup_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  MbscSegmentedGroup2 = __decorate([FormControl], MbscSegmentedGroup2);
  return MbscSegmentedGroup2;
}(SegmentedGroupBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSegmentedGroup, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_groupClass"
      },
      providers: [MbscRadioService],
      selector: "mbsc-segmented-group",
      template: "<ng-content></ng-content>"
    }]
  }], null, {
    color: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    select: [{
      type: Input
    }]
  });
})();
var guid$4 = 1;
var SegmentedBase = function(_super) {
  __extends(SegmentedBase2, _super);
  function SegmentedBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onChange = function(ev) {
      var s = _this.s;
      var checked = ev.target.checked;
      if (checked === _this._checked) {
        return;
      }
      _this._change(checked);
      if (_this._onGroupChange) {
        _this._onGroupChange(ev, _this._value);
      }
      _this._toggle(checked);
      if (s.onChange) {
        s.onChange(ev);
      }
    };
    _this._onValueChange = function(value) {
      var s = _this.s;
      var selected = _this._isMultiple ? isArray(value) && value.indexOf(_this._value) !== -1 : value === _this._value;
      if (s.checked === UNDEFINED && selected !== _this.state.selected) {
        _this.setState({
          selected
        });
      } else {
        _this.forceUpdate();
      }
      _this._change(selected);
    };
    _this._setBox = function(box) {
      _this._box = box;
    };
    return _this;
  }
  SegmentedBase2.prototype._change = function(checked) {
  };
  SegmentedBase2.prototype._groupOptions = function(_a) {
    var _this = this;
    var color = _a.color, disabled = _a.disabled, name = _a.name, onChange = _a.onChange, select = _a.select, value = _a.value;
    var s = this.s;
    var state = this.state;
    var prevChecked = this._checked;
    var modelValue = s.modelValue !== UNDEFINED ? s.modelValue === s.value : s.checked;
    var checked = modelValue !== UNDEFINED ? emptyOrTrue(modelValue) : state.selected === UNDEFINED ? emptyOrTrue(s.defaultChecked) : state.selected;
    this._id = s.id === UNDEFINED ? this._id || "mbsc-segmented-" + guid$4++ : s.id;
    this._value = s.value === UNDEFINED ? this._id : s.value;
    this._onGroupChange = onChange;
    this._isMultiple = (select || s.select) === "multiple";
    this._name = name === UNDEFINED ? s.name : name;
    this._disabled = disabled === UNDEFINED ? s.disabled === UNDEFINED ? state.disabled : emptyOrTrue(s.disabled) : emptyOrTrue(disabled);
    this._color = color === UNDEFINED ? s.color : color;
    this._checked = value === UNDEFINED ? checked : this._isMultiple ? value && value.indexOf(this._value) !== -1 : value === this._value;
    if (!this._isMultiple && !prevChecked && this._checked) {
      setTimeout(function() {
        if (_this._checked) {
          setRadio(_this._name, _this._value, _this._index);
        }
      });
    }
    this._selectedIndex = getSelectedIndex(this._name);
    this._cssClass = "mbsc-segmented-item " + this._className + this._theme + this._rtl + (this._checked ? " mbsc-segmented-item-checked" : "") + (state.hasFocus ? " mbsc-focus" : "") + (this._index === this._selectedIndex || this._index === UNDEFINED && this._checked || this._isMultiple && this._checked ? " mbsc-segmented-item-selected" : "");
  };
  SegmentedBase2.prototype._toggle = function(checked) {
    if (this.s.checked === UNDEFINED) {
      this.setState({
        selected: checked
      });
    }
  };
  SegmentedBase2.prototype._mounted = function() {
    var _this = this;
    listen(this._el, CLICK, this._onChange);
    this._unlisten = gestureListener(this._el, {
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onFocus: function() {
        _this.setState({
          hasFocus: true
        });
      }
    });
  };
  SegmentedBase2.prototype._updated = function() {
    if (this._name && !this._unsubscribe) {
      this._unsubscribe = subscribeRadio(this._name, this._onValueChange);
    }
    if (!this._isMultiple) {
      var cont = closest(this._el, ".mbsc-segmented");
      var index = -1;
      var selectedIndex = -1;
      if (cont) {
        var items = cont.querySelectorAll('.mbsc-segmented-input[name="' + this._name + '"]');
        for (var i = 0; i < items.length; i++) {
          if (items[i] === this._el) {
            index = i;
          }
          if (items[i].checked) {
            selectedIndex = i;
          }
        }
      }
      if (this._index !== index && selectedIndex !== -1) {
        setSelectedIndex(this._name, selectedIndex);
      }
      if (this._selectedIndex !== -1) {
        this._box.style.transform = "translateX(" + (this.s.rtl ? -1 : 1) * (this._selectedIndex - index) * 100 + "%)";
        this._animate = true;
      }
      if (index !== -1) {
        this._index = index;
      }
    }
  };
  SegmentedBase2.prototype._destroy = function() {
    unlisten(this._el, CLICK, this._onChange);
    if (this._unsubscribe) {
      unsubscribeRadio(this._name, this._unsubscribe);
      this._unsubscribe = UNDEFINED;
    }
    if (this._unlisten) {
      this._unlisten();
    }
  };
  SegmentedBase2.defaults = {
    select: "single"
  };
  SegmentedBase2._name = "Segmented";
  SegmentedBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵSegmentedBase_BaseFactory;
    return function SegmentedBase_Factory(__ngFactoryType__) {
      return (ɵSegmentedBase_BaseFactory || (ɵSegmentedBase_BaseFactory = ɵɵgetInheritedFactory(SegmentedBase2)))(__ngFactoryType__ || SegmentedBase2);
    };
  })();
  SegmentedBase2.ɵdir = ɵɵdefineDirective({
    type: SegmentedBase2,
    selectors: [["", "mbsc-seg-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return SegmentedBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SegmentedBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-seg-b]"
    }]
  }], null, null);
})();
var MbscSegmented = function(_super) {
  __extends(MbscSegmented2, _super);
  function MbscSegmented2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.checkedChange = new EventEmitter();
    return _this;
  }
  Object.defineProperty(MbscSegmented2.prototype, "checked", {
    get: function() {
      return this._check;
    },
    set: function(val) {
      var rs = this._radioService;
      if (this._check !== val) {
        if (this._isMultiple) {
          this._onFormChange(val);
        } else if (val) {
          if (rs) {
            rs.value = this.value;
          }
          this._onFormChange(this.value);
        }
        this.props.checked = val;
        this._check = val;
        this.setState({
          selected: val
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  MbscSegmented2.prototype.registerOnChange = function(fn) {
    this._onFormChange = fn;
  };
  MbscSegmented2.prototype.registerOnTouched = function(fn) {
    this._onFormTouch = fn;
  };
  MbscSegmented2.prototype.setDisabledState = function(disabled) {
    this.setState({
      disabled
    });
  };
  MbscSegmented2.prototype.writeValue = function(val) {
    this.checked = this._isMultiple ? val : this.value === val;
  };
  MbscSegmented2.prototype._change = function(checked) {
    this.checked = checked;
  };
  MbscSegmented2.prototype._ctor = function() {
    var rs;
    this._radioService = rs = this._injector.get(MbscRadioService, null);
    var select = rs && rs.select || this.select;
    this._isMultiple = select === "multiple";
  };
  MbscSegmented2.prototype._render = function(s, state) {
    this._groupOptions(this._radioService || {});
    _super.prototype._render.call(this, s, state);
  };
  MbscSegmented2.prototype._mounted = function() {
    this._el = this.vInput.nativeElement;
    this._box = this.vBox.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscSegmented2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSegmented_BaseFactory;
    return function MbscSegmented_Factory(__ngFactoryType__) {
      return (ɵMbscSegmented_BaseFactory || (ɵMbscSegmented_BaseFactory = ɵɵgetInheritedFactory(MbscSegmented2)))(__ngFactoryType__ || MbscSegmented2);
    };
  })();
  MbscSegmented2.ɵcmp = ɵɵdefineComponent({
    type: MbscSegmented2,
    selectors: [["mbsc-segmented"]],
    viewQuery: function MbscSegmented_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
        ɵɵviewQuery(_c30, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vBox = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscSegmented_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      ariaLabel: "ariaLabel",
      color: "color",
      disabled: "disabled",
      endIcon: "endIcon",
      endIconSrc: "endIconSrc",
      endIconSvg: "endIconSvg",
      icon: "icon",
      iconSvg: "iconSvg",
      iconSrc: "iconSrc",
      id: "id",
      name: "name",
      ripple: "ripple",
      startIcon: "startIcon",
      startIconSrc: "startIconSrc",
      startIconSvg: "startIconSvg",
      select: "select",
      checked: "checked"
    },
    outputs: {
      checkedChange: "checkedChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 8,
    vars: 32,
    consts: [["box", ""], ["input", ""], [1, "mbsc-segmented-label"], [3, "checked", "disabled", "name", "type", "value"], ["aria-hidden", "true", "role", "none", 3, "ariaLabel", "color", "disabled", "endIcon", "endIconSrc", "endIconSvg", "hidden", "icon", "iconSrc", "iconSvg", "id", "ripple", "rtl", "startIcon", "startIconSrc", "startIconSvg", "theme", "themeVariant"]],
    template: function MbscSegmented_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelementStart(0, "label", 2)(1, "div", null, 0);
        ɵɵelement(3, "div");
        ɵɵelementEnd();
        ɵɵelement(4, "input", 3, 1);
        ɵɵelementStart(6, "mbsc-button", 4);
        ɵɵprojection(7);
        ɵɵelementEnd()();
      }
      if (rf & 2) {
        ɵɵadvance();
        ɵɵclassMap("mbsc-segmented-selectbox" + ctx2._theme + (ctx2._animate ? " mbsc-segmented-selectbox-animate" : "") + (ctx2._checked ? " mbsc-selected" : ""));
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-segmented-selectbox-inner" + (ctx2._index === ctx2._selectedIndex || ctx2._checked ? " mbsc-segmented-selectbox-inner-visible" : "") + (ctx2._checked ? " mbsc-selected" : "") + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-segmented-input mbsc-reset" + ctx2._theme + (ctx2._checked ? " mbsc-selected" : ""));
        ɵɵproperty("checked", ctx2._checked)("disabled", ctx2._disabled)("name", ctx2._isMultiple ? ctx2.s.name === void 0 ? "" : ctx2.s.name : ctx2._name)("type", ctx2._isMultiple ? "checkbox" : "radio")("value", ctx2._value);
        ɵɵattribute("aria-labelledby", ctx2._id);
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-segmented-button" + (ctx2._checked ? " mbsc-selected" : "") + (ctx2.state.hasFocus ? " mbsc-focus" : ""));
        ɵɵproperty("ariaLabel", ctx2.s.ariaLabel)("color", ctx2._color)("disabled", ctx2._disabled)("endIcon", ctx2.s.endIcon)("endIconSrc", ctx2.s.endIconSrc)("endIconSvg", ctx2.s.endIconSvg)("hidden", true)("icon", ctx2.s.icon)("iconSrc", ctx2.s.iconSrc)("iconSvg", ctx2.s.iconSvg)("id", ctx2._id)("ripple", ctx2.s.ripple)("rtl", ctx2.s.rtl)("startIcon", ctx2.s.startIcon)("startIconSrc", ctx2.s.startIconSrc)("startIconSvg", ctx2.s.startIconSvg)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant);
      }
    },
    dependencies: [MbscButton],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscSegmented2;
}(SegmentedBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSegmented, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-segmented",
      template: `
    <label class="mbsc-segmented-label">
      <div
        #box
        [class]="
          'mbsc-segmented-selectbox' + _theme + (_animate ? ' mbsc-segmented-selectbox-animate' : '') + (_checked ? ' mbsc-selected' : '')
        "
      >
        <div
          [class]="
            'mbsc-segmented-selectbox-inner' +
            (_index === _selectedIndex || _checked ? ' mbsc-segmented-selectbox-inner-visible' : '') +
            (_checked ? ' mbsc-selected' : '') +
            _theme
          "
        ></div>
      </div>
      <input
        #input
        [attr.aria-labelledby]="_id"
        [class]="'mbsc-segmented-input mbsc-reset' + _theme + (_checked ? ' mbsc-selected' : '')"
        [checked]="_checked"
        [disabled]="_disabled"
        [name]="_isMultiple ? (s.name === undefined ? '' : s.name) : _name"
        [type]="_isMultiple ? 'checkbox' : 'radio'"
        [value]="_value"
      />
      <mbsc-button
        aria-hidden="true"
        [ariaLabel]="s.ariaLabel"
        [class]="'mbsc-segmented-button' + (_checked ? ' mbsc-selected' : '') + (state.hasFocus ? ' mbsc-focus' : '')"
        [color]="_color"
        [disabled]="_disabled"
        [endIcon]="s.endIcon"
        [endIconSrc]="s.endIconSrc"
        [endIconSvg]="s.endIconSvg"
        [hidden]="true"
        [icon]="s.icon"
        [iconSrc]="s.iconSrc"
        [iconSvg]="s.iconSvg"
        [id]="_id"
        [ripple]="s.ripple"
        [rtl]="s.rtl"
        role="none"
        [startIcon]="s.startIcon"
        [startIconSrc]="s.startIconSrc"
        [startIconSvg]="s.startIconSvg"
        [theme]="s.theme"
        [themeVariant]="s.themeVariant"
      >
        <ng-content></ng-content>
      </mbsc-button>
    </label>
  `
    }]
  }], null, {
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    vBox: [{
      type: ViewChild,
      args: ["box", {
        static: false
      }]
    }],
    ariaLabel: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    endIcon: [{
      type: Input
    }],
    endIconSrc: [{
      type: Input
    }],
    endIconSvg: [{
      type: Input
    }],
    icon: [{
      type: Input
    }],
    iconSvg: [{
      type: Input
    }],
    iconSrc: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    ripple: [{
      type: Input
    }],
    startIcon: [{
      type: Input
    }],
    startIconSrc: [{
      type: Input
    }],
    startIconSvg: [{
      type: Input
    }],
    select: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    checked: [{
      type: Input
    }]
  });
})();
var template$1 = `
<div [class]="'mbsc-datepicker mbsc-flex-col mbsc-datepicker-' + s.display + _theme +
  (s.display === 'inline' ? ' ' + _className + _hb : '') + _controlsClass"
>
  <div *ngIf="_headerText && s.display === 'inline'" [class]="'mbsc-picker-header' + _theme + _hb">
    {{_headerText}}
  </div>

  <mbsc-segmented-group *ngIf="_renderTabs"
    [rtl]="s.rtl"
    [theme]="s.theme"
    [themeVariant]="s.themeVariant"
    [(ngModel)]="_activeTab"
    (change)="_changeActiveTab($event)"
  >
    <mbsc-segmented *ngFor="let control of _controls"
      [rtl]="s.rtl"
      [theme]="s.theme"
      [themeVariant]="s.themeVariant"
      [value]="control.name"
    >
      {{control.title}}
    </mbsc-segmented>
  </mbsc-segmented-group>
  <div *ngIf="_renderControls" [class]="'mbsc-range-control-wrapper' + _theme">
    <mbsc-segmented-group
      [rtl]="s.rtl"
      [theme]="s.theme"
      [themeVariant]="s.themeVariant"
      [(ngModel)]="_activeSelect"
      (change)="_changeActiveSelect($event)"
    >
      <mbsc-segmented [rtl]="s.rtl" [theme]="s.theme" [themeVariant]="s.themeVariant" value="start" [class]="'mbsc-range-start' +
        (_tempStartText ? ' mbsc-range-value-nonempty' : '')">
        <div [class]="'mbsc-range-control-label' + _theme + _rtl +
        (_activeSelect === 'start'? ' active' : '')">{{s.rangeStartLabel}}</div>
        <div [class]="'mbsc-range-control-value' + _theme + _rtl +
        (_activeSelect === 'start' ? ' active' : '') +
        (!_tempStartText ? ' mbsc-range-control-text-empty' : '')">{{_tempStartText || s.rangeStartHelp}}</div>
        <mbsc-icon *ngIf="_activeSelect === 'start' && _tempStartText" [class]="'mbsc-range-label-clear' + _rtl"
          (click)="_clearStart()" [svg]="s.clearIcon" [theme]="s.theme"></mbsc-icon>
      </mbsc-segmented>
      <mbsc-segmented [rtl]="s.rtl" [theme]="s.theme" [themeVariant]="s.themeVariant" value="end" [class]="'mbsc-range-end' +
        (_tempEndText ? ' mbsc-range-value-nonempty' : '')">
        <div [class]="'mbsc-range-control-label' + _theme + _rtl +
        (_activeSelect === 'end'? ' active' : '')">{{s.rangeEndLabel}}</div>
        <div [class]="'mbsc-range-control-value' + _theme + _rtl +
        (_activeSelect === 'end' ? ' active' : '') +
        (!_tempEndText ? ' mbsc-range-control-text-empty' : '')">{{_tempEndText || s.rangeEndHelp}}</div>
        <mbsc-icon *ngIf="_activeSelect === 'end' && _tempEndText" [class]="'mbsc-range-label-clear' + _rtl"
          (click)="_clearEnd()" [svg]="s.clearIcon" [theme]="s.theme"></mbsc-icon>
      </mbsc-segmented>
    </mbsc-segmented-group>
  </div>
  <div [class]="'mbsc-datepicker-tab-wrapper mbsc-flex mbsc-flex-1-1 ' + _theme" #wrapper>
    <div *ngFor="let control of _controls"
      [class]="'mbsc-flex mbsc-datepicker-tab mbsc-datepicker-tab-' + control.name + _theme +
        ((_renderTabs && control.name === _activeTab) || !_renderTabs ? ' mbsc-datepicker-tab-active' : '') +
        (_renderTabs && control.name === 'time' ? ' mbsc-datepicker-time-modal' : '') +
        (_renderTabs || _controls.length === 1 ? ' mbsc-datepicker-tab-expand mbsc-flex-1-1' : '')"
      >
      <mbsc-calendar *ngIf="control.name === 'calendar'" [options]="control.options" #ctrlVar></mbsc-calendar>
      <mbsc-datetime *ngIf="control.name === 'datetime'" [options]="control.options" #ctrlVar></mbsc-datetime>
      <mbsc-date *ngIf="control.name === 'date'" [options]="control.options" #ctrlVar></mbsc-date>
      <mbsc-time *ngIf="control.name === 'time'" [options]="control.options" #ctrlVar></mbsc-time>
      <mbsc-timegrid *ngIf="control.name === 'timegrid'" [options]="control.options" #ctrlVar></mbsc-timegrid>
      <!--<ng-container mbsc-tpl></ng-container>-->
    </div>
  </div>
</div>
`;
var MbscDatepickerBase = function(_super) {
  __extends(MbscDatepickerBase2, _super);
  function MbscDatepickerBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onCancel = new EventEmitter();
    _this.onCellClick = new EventEmitter();
    _this.onCellHoverIn = new EventEmitter();
    _this.onCellHoverOut = new EventEmitter();
    _this.onChange = new EventEmitter();
    _this.onClose = new EventEmitter();
    _this.onLabelClick = new EventEmitter();
    _this.onPageChange = new EventEmitter(true);
    _this.onPageLoaded = new EventEmitter(true);
    _this.onPageLoading = new EventEmitter(true);
    _this.onOpen = new EventEmitter();
    _this.onPosition = new EventEmitter();
    _this.onTempChange = new EventEmitter();
    _this.onActiveDateChange = new EventEmitter();
    return _this;
  }
  MbscDatepickerBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDatepickerBase_BaseFactory;
    return function MbscDatepickerBase_Factory(__ngFactoryType__) {
      return (ɵMbscDatepickerBase_BaseFactory || (ɵMbscDatepickerBase_BaseFactory = ɵɵgetInheritedFactory(MbscDatepickerBase2)))(__ngFactoryType__ || MbscDatepickerBase2);
    };
  })();
  MbscDatepickerBase2.ɵdir = ɵɵdefineDirective({
    type: MbscDatepickerBase2,
    selectors: [["", "mbsc-dp-b", ""]],
    inputs: {
      ariaLabel: "ariaLabel",
      calendarHeaderTemplate: "calendarHeaderTemplate",
      calendarScroll: "calendarScroll",
      calendarSize: "calendarSize",
      calendarSystem: "calendarSystem",
      calendarType: "calendarType",
      colors: "colors",
      controls: "controls",
      dataTimezone: "dataTimezone",
      defaultSelection: "defaultSelection",
      displayTimezone: "displayTimezone",
      element: "element",
      endInput: "endInput",
      exclusiveEndDates: "exclusiveEndDates",
      firstSelectDay: "firstSelectDay",
      inputTyping: "inputTyping",
      invalid: "invalid",
      inRangeInvalid: "inRangeInvalid",
      labels: "labels",
      marked: "marked",
      max: "max",
      maxRange: "maxRange",
      maxTime: "maxTime",
      min: "min",
      minRange: "minRange",
      minTime: "minTime",
      mode: "mode",
      moment: "moment",
      pages: "pages",
      rangeHighlight: "rangeHighlight",
      rangeEndInvalid: "rangeEndInvalid",
      refDate: "refDate",
      returnFormat: "returnFormat",
      showInput: "showInput",
      startInput: "startInput",
      stepHour: "stepHour",
      stepMinute: "stepMinute",
      stepSecond: "stepSecond",
      select: "select",
      selectCounter: "selectCounter",
      selectSize: "selectSize",
      selectMax: "selectMax",
      selectMin: "selectMin",
      selectMultiple: "selectMultiple",
      showOuterDays: "showOuterDays",
      showRangeLabels: "showRangeLabels",
      showWeekNumbers: "showWeekNumbers",
      tabs: "tabs",
      theme: "theme",
      timezonePlugin: "timezonePlugin",
      valid: "valid",
      weeks: "weeks",
      disabled: "disabled",
      dropdown: "dropdown",
      endIcon: "endIcon",
      endIconSrc: "endIconSrc",
      endIconSvg: "endIconSvg",
      error: "error",
      errorMessage: "errorMessage",
      inputStyle: "inputStyle",
      label: "label",
      labelStyle: "labelStyle",
      name: "name",
      placeholder: "placeholder",
      startIcon: "startIcon",
      startIconSrc: "startIconSrc",
      startIconSvg: "startIconSvg",
      tagInput: "tagInput",
      circular: "circular",
      clearText: "clearText",
      itemHeight: "itemHeight",
      maxWheelWidth: "maxWheelWidth",
      minWheelWidth: "minWheelWidth",
      rows: "rows",
      showOnClick: "showOnClick",
      showOnFocus: "showOnFocus",
      wheelWidth: "wheelWidth",
      anchor: "anchor",
      anchorAlign: "anchorAlign",
      animation: "animation",
      buttons: "buttons",
      cancelText: "cancelText",
      closeOnEsc: "closeOnEsc",
      closeOnOverlayClick: "closeOnOverlayClick",
      closeOnScroll: "closeOnScroll",
      closeText: "closeText",
      context: "context",
      display: "display",
      focusOnClose: "focusOnClose",
      focusTrap: "focusTrap",
      fullScreen: "fullScreen",
      headerText: "headerText",
      height: "height",
      isOpen: "isOpen",
      maxHeight: "maxHeight",
      maxWidth: "maxWidth",
      scrollLock: "scrollLock",
      setText: "setText",
      showArrow: "showArrow",
      showOverlay: "showOverlay",
      width: "width",
      amText: "amText",
      dateFormat: "dateFormat",
      dateWheels: "dateWheels",
      dayNames: "dayNames",
      dayNamesMin: "dayNamesMin",
      dayNamesShort: "dayNamesShort",
      dateText: "dateText",
      daySuffix: "daySuffix",
      dayText: "dayText",
      hourText: "hourText",
      monthText: "monthText",
      minuteText: "minuteText",
      secondText: "secondText",
      separator: "separator",
      timeText: "timeText",
      yearText: "yearText",
      dayTemplate: "dayTemplate",
      dayContentTemplate: "dayContentTemplate",
      firstDay: "firstDay",
      monthNames: "monthNames",
      monthNamesShort: "monthNamesShort",
      monthSuffix: "monthSuffix",
      moreEventsPluralText: "moreEventsPluralText",
      moreEventsText: "moreEventsText",
      nextPageText: "nextPageText",
      nowText: "nowText",
      pmText: "pmText",
      prevPageText: "prevPageText",
      rangeEndHelp: "rangeEndHelp",
      rangeEndLabel: "rangeEndLabel",
      rangeStartHelp: "rangeStartHelp",
      rangeStartLabel: "rangeStartLabel",
      selectedPluralText: "selectedPluralText",
      selectedText: "selectedText",
      timeFormat: "timeFormat",
      timeWheels: "timeWheels",
      yearSuffix: "yearSuffix"
    },
    outputs: {
      onCancel: "onCancel",
      onCellClick: "onCellClick",
      onCellHoverIn: "onCellHoverIn",
      onCellHoverOut: "onCellHoverOut",
      onChange: "onChange",
      onClose: "onClose",
      onLabelClick: "onLabelClick",
      onPageChange: "onPageChange",
      onPageLoaded: "onPageLoaded",
      onPageLoading: "onPageLoading",
      onOpen: "onOpen",
      onPosition: "onPosition",
      onTempChange: "onTempChange",
      onActiveDateChange: "onActiveDateChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  MbscDatepickerBase2 = __decorate([FormControl], MbscDatepickerBase2);
  return MbscDatepickerBase2;
}(DatepickerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDatepickerBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-dp-b]"
    }]
  }], null, {
    ariaLabel: [{
      type: Input
    }],
    calendarHeaderTemplate: [{
      type: Input
    }],
    calendarScroll: [{
      type: Input
    }],
    calendarSize: [{
      type: Input
    }],
    calendarSystem: [{
      type: Input
    }],
    calendarType: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    controls: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    defaultSelection: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    element: [{
      type: Input
    }],
    endInput: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    firstSelectDay: [{
      type: Input
    }],
    inputTyping: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    inRangeInvalid: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    marked: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    maxRange: [{
      type: Input
    }],
    maxTime: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    minRange: [{
      type: Input
    }],
    minTime: [{
      type: Input
    }],
    mode: [{
      type: Input
    }],
    moment: [{
      type: Input
    }],
    pages: [{
      type: Input
    }],
    rangeHighlight: [{
      type: Input
    }],
    rangeEndInvalid: [{
      type: Input
    }],
    refDate: [{
      type: Input
    }],
    returnFormat: [{
      type: Input
    }],
    showInput: [{
      type: Input
    }],
    startInput: [{
      type: Input
    }],
    stepHour: [{
      type: Input
    }],
    stepMinute: [{
      type: Input
    }],
    stepSecond: [{
      type: Input
    }],
    select: [{
      type: Input
    }],
    selectCounter: [{
      type: Input
    }],
    selectSize: [{
      type: Input
    }],
    selectMax: [{
      type: Input
    }],
    selectMin: [{
      type: Input
    }],
    selectMultiple: [{
      type: Input
    }],
    showOuterDays: [{
      type: Input
    }],
    showRangeLabels: [{
      type: Input
    }],
    showWeekNumbers: [{
      type: Input
    }],
    tabs: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    valid: [{
      type: Input
    }],
    weeks: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    dropdown: [{
      type: Input
    }],
    endIcon: [{
      type: Input
    }],
    endIconSrc: [{
      type: Input
    }],
    endIconSvg: [{
      type: Input
    }],
    error: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    inputStyle: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    labelStyle: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    startIcon: [{
      type: Input
    }],
    startIconSrc: [{
      type: Input
    }],
    startIconSvg: [{
      type: Input
    }],
    tagInput: [{
      type: Input
    }],
    circular: [{
      type: Input
    }],
    clearText: [{
      type: Input
    }],
    itemHeight: [{
      type: Input
    }],
    maxWheelWidth: [{
      type: Input
    }],
    minWheelWidth: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    showOnClick: [{
      type: Input
    }],
    showOnFocus: [{
      type: Input
    }],
    wheelWidth: [{
      type: Input
    }],
    anchor: [{
      type: Input
    }],
    anchorAlign: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    buttons: [{
      type: Input
    }],
    cancelText: [{
      type: Input
    }],
    closeOnEsc: [{
      type: Input
    }],
    closeOnOverlayClick: [{
      type: Input
    }],
    closeOnScroll: [{
      type: Input
    }],
    closeText: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    display: [{
      type: Input
    }],
    focusOnClose: [{
      type: Input
    }],
    focusTrap: [{
      type: Input
    }],
    fullScreen: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    isOpen: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    maxWidth: [{
      type: Input
    }],
    scrollLock: [{
      type: Input
    }],
    setText: [{
      type: Input
    }],
    showArrow: [{
      type: Input
    }],
    showOverlay: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    amText: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    dateWheels: [{
      type: Input
    }],
    dayNames: [{
      type: Input
    }],
    dayNamesMin: [{
      type: Input
    }],
    dayNamesShort: [{
      type: Input
    }],
    dateText: [{
      type: Input
    }],
    daySuffix: [{
      type: Input
    }],
    dayText: [{
      type: Input
    }],
    hourText: [{
      type: Input
    }],
    monthText: [{
      type: Input
    }],
    minuteText: [{
      type: Input
    }],
    secondText: [{
      type: Input
    }],
    separator: [{
      type: Input
    }],
    timeText: [{
      type: Input
    }],
    yearText: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dayContentTemplate: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    monthNames: [{
      type: Input
    }],
    monthNamesShort: [{
      type: Input
    }],
    monthSuffix: [{
      type: Input
    }],
    moreEventsPluralText: [{
      type: Input
    }],
    moreEventsText: [{
      type: Input
    }],
    nextPageText: [{
      type: Input
    }],
    nowText: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    prevPageText: [{
      type: Input
    }],
    rangeEndHelp: [{
      type: Input
    }],
    rangeEndLabel: [{
      type: Input
    }],
    rangeStartHelp: [{
      type: Input
    }],
    rangeStartLabel: [{
      type: Input
    }],
    selectedPluralText: [{
      type: Input
    }],
    selectedText: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timeWheels: [{
      type: Input
    }],
    yearSuffix: [{
      type: Input
    }],
    onCancel: [{
      type: Output
    }],
    onCellClick: [{
      type: Output
    }],
    onCellHoverIn: [{
      type: Output
    }],
    onCellHoverOut: [{
      type: Output
    }],
    onChange: [{
      type: Output
    }],
    onClose: [{
      type: Output
    }],
    onLabelClick: [{
      type: Output
    }],
    onPageChange: [{
      type: Output
    }],
    onPageLoaded: [{
      type: Output
    }],
    onPageLoading: [{
      type: Output
    }],
    onOpen: [{
      type: Output
    }],
    onPosition: [{
      type: Output
    }],
    onTempChange: [{
      type: Output
    }],
    onActiveDateChange: [{
      type: Output
    }]
  });
})();
var MbscDatepicker = function(_super) {
  __extends(MbscDatepicker2, _super);
  function MbscDatepicker2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(MbscDatepicker2.prototype, "vInput", {
    set: function(inp) {
      if (inp) {
        this._el = inp.nativeElement;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MbscDatepicker2.prototype, "vPopup", {
    set: function(popup) {
      this._popup = popup;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MbscDatepicker2.prototype, "vWrapper", {
    set: function(wrapper) {
      this._wrapper = wrapper && wrapper.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  MbscDatepicker2.prototype._render = function(s, state) {
    _super.prototype._render.call(this, s, state);
    if (this._controlRefs) {
      this._controlRefs.forEach(function(ctrl) {
        ctrl.props = ctrl.options;
        ctrl.forceUpdate();
      });
    }
  };
  MbscDatepicker2.prototype._destroy = function() {
    _super.prototype._destroy.call(this);
  };
  MbscDatepicker2.prototype._onClosed = function() {
    _super.prototype._onClosed.call(this);
    this._onFormTouch();
  };
  MbscDatepicker2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDatepicker_BaseFactory;
    return function MbscDatepicker_Factory(__ngFactoryType__) {
      return (ɵMbscDatepicker_BaseFactory || (ɵMbscDatepicker_BaseFactory = ɵɵgetInheritedFactory(MbscDatepicker2)))(__ngFactoryType__ || MbscDatepicker2);
    };
  })();
  MbscDatepicker2.ɵcmp = ɵɵdefineComponent({
    type: MbscDatepicker2,
    selectors: [["mbsc-datepicker"]],
    viewQuery: function MbscDatepicker_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
        ɵɵviewQuery(_c13, 5);
        ɵɵviewQuery(_c12, 5);
        ɵɵviewQuery(_c31, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vPopup = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vWrapper = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2._controlRefs = _t);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MbscInstanceService]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 4,
    vars: 38,
    consts: [["popup", ""], ["input", ""], ["wrapper", ""], ["ctrlVar", ""], [3, "ariaExpanded", "ariaHaspopup", "ariaLabel", "dropdown", "disabled", "endIcon", "endIconSrc", "endIconSvg", "error", "errorMessage", "inputStyle", "label", "labelStyle", "name", "placeholder", "pickerMap", "pickerValue", "role", "rtl", "startIcon", "startIconSrc", "startIconSvg", "tags", "theme", "themeVariant", "value", 4, "ngIf"], [3, "onClose", "onClosed", "onKeyDown", "onOpen", "onResize", "activeElm", "anchor", "anchorAlign", "animation", "ariaLabel", "buttons", "cancelText", "closeOnEsc", "closeOnOverlayClick", "closeOnScroll", "closeText", "contentPadding", "context", "cssClass", "disableLeftRight", "display", "focusElm", "focusOnClose", "focusOnOpen", "focusTrap", "fullScreen", "headerText", "height", "isOpen", "maxHeight", "maxWidth", "setText", "showArrow", "showOverlay", "rtl", "scrollLock", "theme", "themeVariant", "touchUi", "windowWidth", "width"], [4, "ngIf"], [3, "ariaExpanded", "ariaHaspopup", "ariaLabel", "dropdown", "disabled", "endIcon", "endIconSrc", "endIconSvg", "error", "errorMessage", "inputStyle", "label", "labelStyle", "name", "placeholder", "pickerMap", "pickerValue", "role", "rtl", "startIcon", "startIconSrc", "startIconSvg", "tags", "theme", "themeVariant", "value"], [3, "class", 4, "ngIf"], [3, "rtl", "theme", "themeVariant", "ngModel", "ngModelChange", "change", 4, "ngIf"], [3, "class", 4, "ngFor", "ngForOf"], [3, "ngModelChange", "change", "rtl", "theme", "themeVariant", "ngModel"], [3, "rtl", "theme", "themeVariant", "value", 4, "ngFor", "ngForOf"], [3, "rtl", "theme", "themeVariant", "value"], ["value", "start", 3, "rtl", "theme", "themeVariant"], [3, "class", "svg", "theme", "click", 4, "ngIf"], ["value", "end", 3, "rtl", "theme", "themeVariant"], [3, "click", "svg", "theme"], [3, "options", 4, "ngIf"], [3, "options"]],
    template: function MbscDatepicker_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵtemplate(0, MbscDatepicker_mbsc_input_0_Template, 3, 26, "mbsc-input", 4);
        ɵɵelementStart(1, "mbsc-popup", 5, 0);
        ɵɵlistener("onClose", function MbscDatepicker_Template_mbsc_popup_onClose_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupClose($event));
        })("onClosed", function MbscDatepicker_Template_mbsc_popup_onClosed_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupClosed($event));
        })("onKeyDown", function MbscDatepicker_Template_mbsc_popup_onKeyDown_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupKey($event));
        })("onOpen", function MbscDatepicker_Template_mbsc_popup_onOpen_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupOpen($event));
        })("onResize", function MbscDatepicker_Template_mbsc_popup_onResize_1_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onResize($event));
        });
        ɵɵtemplate(3, MbscDatepicker_ng_container_3_Template, 8, 8, "ng-container", 6);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2._showInput);
        ɵɵadvance();
        ɵɵproperty("activeElm", ctx2.s.activeElm)("anchor", ctx2._anchor)("anchorAlign", ctx2._anchorAlign)("animation", ctx2.s.animation)("ariaLabel", ctx2.s.ariaLabel)("buttons", ctx2._buttons)("cancelText", ctx2.s.cancelText)("closeOnEsc", ctx2.s.closeOnEsc)("closeOnOverlayClick", ctx2.s.closeOnOverlayClick)("closeOnScroll", ctx2.s.closeOnScroll)("closeText", ctx2.s.closeText)("contentPadding", false)("context", ctx2.s.context)("cssClass", ctx2._cssClass)("disableLeftRight", true)("display", ctx2.s.display)("focusElm", ctx2._focusElm)("focusOnClose", ctx2.s.focusOnClose)("focusOnOpen", !ctx2._allowTyping)("focusTrap", ctx2.s.focusTrap)("fullScreen", ctx2.s.fullScreen)("headerText", ctx2._headerText)("height", ctx2.s.height)("isOpen", ctx2._isOpen)("maxHeight", ctx2.s.maxHeight)("maxWidth", ctx2._maxWidth)("setText", ctx2.s.setText)("showArrow", ctx2.s.showArrow)("showOverlay", ctx2._allowTyping ? false : ctx2.s.showOverlay)("rtl", ctx2.s.rtl)("scrollLock", ctx2._scrollLock)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant)("touchUi", ctx2._touchUi)("windowWidth", ctx2.state.width)("width", ctx2.s.width);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._popup && ctx2._popup._isVisible || ctx2.s.display === "inline");
      }
    },
    dependencies: [MbscInput, MbscPopup, MbscSegmentedGroup, MbscSegmented, MbscIcon, MbscCalendar, MbscDatetime, MbscDate, MbscTime, MbscTimegrid, NgIf, NgControlStatus, NgModel, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  MbscDatepicker2 = __decorate([FormControl], MbscDatepicker2);
  return MbscDatepicker2;
}(MbscDatepickerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDatepicker, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [MbscInstanceService],
      selector: "mbsc-datepicker",
      template: getPickerTemplate(template$1)
    }]
  }], null, {
    _controlRefs: [{
      type: ViewChildren,
      args: ["ctrlVar", {
        static: false
      }]
    }],
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    vPopup: [{
      type: ViewChild,
      args: ["popup", {
        static: false
      }]
    }],
    vWrapper: [{
      type: ViewChild,
      args: ["wrapper", {
        static: false
      }]
    }]
  });
})();
var MbscDatepickerDirective = function(_super) {
  __extends(MbscDatepickerDirective2, _super);
  function MbscDatepickerDirective2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscDatepickerDirective2.prototype._ctor = function() {
    this._cfr = this._injector.get(ComponentFactoryResolver$1);
  };
  MbscDatepickerDirective2.prototype._init = function() {
    var _this = this;
    var componentFactory = this._cfr.resolveComponentFactory(MbscDatepicker);
    this._ref = this._vcf.createComponent(componentFactory);
    this._inst = this._ref.instance;
    var inst = this._inst;
    var _loop_1 = function(prop2) {
      if (prop2 !== "onInit" && prop2 !== "onDestroy" && inst[prop2] instanceof EventEmitter) {
        inst[prop2].subscribe(function(args) {
          if (prop2 === "onClose") {
            _this._onFormTouch();
          }
          if (prop2 === "onChange") {
            _this.value = inst.value;
          }
          _this[prop2].emit(args);
        });
      }
    };
    for (var prop in inst) {
      _loop_1(prop);
    }
    modules[MbscCalendar._name] = MbscCalendar;
    modules[MbscDatetime._name] = MbscDatetime;
    modules[MbscTimegrid._name] = MbscTimegrid;
    _super.prototype._init.call(this);
  };
  MbscDatepickerDirective2.prototype._destroy = function() {
    _super.prototype._destroy.call(this);
    if (this._ref) {
      this._ref.destroy();
    }
  };
  MbscDatepickerDirective2.prototype._render = function(s, state) {
    _super.prototype._render.call(this, s, state);
    var inst = this._inst;
    inst.value = this.value;
    inst.props = s;
    inst.props.element = this._elr.nativeElement;
    inst.forceUpdate();
  };
  MbscDatepickerDirective2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDatepickerDirective_BaseFactory;
    return function MbscDatepickerDirective_Factory(__ngFactoryType__) {
      return (ɵMbscDatepickerDirective_BaseFactory || (ɵMbscDatepickerDirective_BaseFactory = ɵɵgetInheritedFactory(MbscDatepickerDirective2)))(__ngFactoryType__ || MbscDatepickerDirective2);
    };
  })();
  MbscDatepickerDirective2.ɵdir = ɵɵdefineDirective({
    type: MbscDatepickerDirective2,
    selectors: [["", "mbsc-datepicker", ""]],
    inputs: {
      options: [0, "mbscOptions", "options"]
    },
    exportAs: ["mobiscroll"],
    standalone: false,
    features: [ɵɵProvidersFeature([MbscInstanceService]), ɵɵInheritDefinitionFeature]
  });
  return MbscDatepickerDirective2;
}(MbscDatepickerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDatepickerDirective, [{
    type: Directive,
    args: [{
      exportAs: "mobiscroll",
      providers: [MbscInstanceService],
      selector: "[mbsc-datepicker]"
    }]
  }], null, {
    options: [{
      type: Input,
      args: ["mbscOptions"]
    }]
  });
})();
var MbscScrollerModule = function() {
  function MbscScrollerModule2() {
  }
  MbscScrollerModule2.ɵfac = function MbscScrollerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscScrollerModule2)();
  };
  MbscScrollerModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscScrollerModule2,
    declarations: [MbscScroller, MbscWheelItem, MbscWheel, ScrollerBase, WheelBase, WheelItemBase],
    imports: [CommonModule, MbscInputModule, MbscPickerModule, MbscScrollviewBaseModule],
    exports: [MbscScroller]
  });
  MbscScrollerModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscInputModule, MbscPickerModule, MbscScrollviewBaseModule]]
  });
  return MbscScrollerModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscScrollerModule, [{
    type: NgModule,
    args: [{
      declarations: [MbscScroller, MbscWheelItem, MbscWheel, ScrollerBase, WheelBase, WheelItemBase],
      exports: [MbscScroller],
      imports: [CommonModule, MbscInputModule, MbscPickerModule, MbscScrollviewBaseModule]
    }]
  }], null, null);
})();
var MbscDatetimeModule = function() {
  function MbscDatetimeModule2() {
  }
  MbscDatetimeModule2.ɵfac = function MbscDatetimeModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscDatetimeModule2)();
  };
  MbscDatetimeModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscDatetimeModule2,
    declarations: [DatetimeBase, MbscDate, MbscDateBase, MbscDatetime, MbscTime],
    imports: [CommonModule, FormsModule, MbscScrollerModule],
    exports: [MbscDate, MbscDatetime, MbscTime]
  });
  MbscDatetimeModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, FormsModule, MbscScrollerModule]]
  });
  return MbscDatetimeModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDatetimeModule, [{
    type: NgModule,
    args: [{
      declarations: [DatetimeBase, MbscDate, MbscDateBase, MbscDatetime, MbscTime],
      exports: [MbscDate, MbscDatetime, MbscTime],
      imports: [CommonModule, FormsModule, MbscScrollerModule]
    }]
  }], null, null);
})();
var MbscSegmentedModule = function() {
  function MbscSegmentedModule2() {
  }
  MbscSegmentedModule2.ɵfac = function MbscSegmentedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscSegmentedModule2)();
  };
  MbscSegmentedModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscSegmentedModule2,
    declarations: [SegmentedBase, SegmentedGroupBase, MbscSegmented, MbscSegmentedGroup],
    imports: [CommonModule, MbscButtonModule],
    exports: [MbscSegmented, MbscSegmentedGroup]
  });
  MbscSegmentedModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscButtonModule]]
  });
  return MbscSegmentedModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSegmentedModule, [{
    type: NgModule,
    args: [{
      declarations: [SegmentedBase, SegmentedGroupBase, MbscSegmented, MbscSegmentedGroup],
      exports: [MbscSegmented, MbscSegmentedGroup],
      imports: [CommonModule, MbscButtonModule]
    }]
  }], null, null);
})();
var MbscTimegridModule = function() {
  function MbscTimegridModule2() {
  }
  MbscTimegridModule2.ɵfac = function MbscTimegridModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscTimegridModule2)();
  };
  MbscTimegridModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscTimegridModule2,
    declarations: [MbscTimeBox, TimegridBase, MbscTimegrid],
    imports: [CommonModule],
    exports: [MbscTimegrid]
  });
  MbscTimegridModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscTimegridModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscTimegridModule, [{
    type: NgModule,
    args: [{
      declarations: [MbscTimeBox, TimegridBase, MbscTimegrid],
      exports: [MbscTimegrid],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var id = 0;
function jsonp(url, callback) {
  if (win) {
    var script_1 = doc.createElement("script");
    var unique_1 = "mbscjsonp" + ++id;
    win[unique_1] = function(data) {
      script_1.parentNode.removeChild(script_1);
      delete win[unique_1];
      if (!data) {
        return;
      }
      callback(data);
    };
    script_1.src = url + (url.indexOf("?") >= 0 ? "&" : "?") + "callback=" + unique_1;
    doc.body.appendChild(script_1);
  }
}
function ajaxGet(url, callback) {
  var request = new XMLHttpRequest();
  request.open("GET", url, true);
  request.onload = function() {
    if (request.status >= 200 && request.status < 400) {
      callback(JSON.parse(request.response));
    }
  };
  request.onerror = function() {
  };
  request.send();
}
function getJson(url, callback, type) {
  if (type === "jsonp") {
    jsonp(url, callback);
  } else {
    ajaxGet(url, callback);
  }
}
var localTimezone;
function normTimezone$1(timezone) {
  if (!localTimezone) {
    localTimezone = luxonTimezone.luxon.DateTime.local().zoneName;
  }
  return !timezone || timezone === "local" ? localTimezone : timezone;
}
function getVersion(DT) {
  var fn = DT.fromObject.toString().trim();
  return /^(function )?\w*\(\w+\)/.test(fn) ? 1 : 2;
}
var LDate = function() {
  function LDate2(value, timezone) {
    if (timezone === void 0) {
      timezone = "utc";
    }
    this._mbsc = true;
    this._zone = normTimezone$1(timezone);
    this._init(value);
  }
  LDate2.prototype.clone = function() {
    return new LDate2(this, this._zone);
  };
  LDate2.prototype.createDate = function(year, month, date, h, min, sec, ms) {
    return luxonTimezone.createDate({
      displayTimezone: this._zone
    }, year, month, date, h, min, sec, ms);
  };
  LDate2.prototype[Symbol.toPrimitive] = function(hint) {
    return this._dt.toJSDate()[Symbol.toPrimitive](hint);
  };
  LDate2.prototype.toDateString = function() {
    return this._dt.toFormat("ccc MMM dd yyyy");
  };
  LDate2.prototype.toISOString = function() {
    return this._dt.toISO();
  };
  LDate2.prototype.toJSON = function() {
    return this._dt.toISO();
  };
  LDate2.prototype.valueOf = function() {
    return this._dt.valueOf();
  };
  LDate2.prototype.getDate = function() {
    return this._dt.day;
  };
  LDate2.prototype.getDay = function() {
    return this._dt.weekday % 7;
  };
  LDate2.prototype.getFullYear = function() {
    return this._dt.year;
  };
  LDate2.prototype.getHours = function() {
    return this._dt.hour;
  };
  LDate2.prototype.getMilliseconds = function() {
    return this._dt.millisecond;
  };
  LDate2.prototype.getMinutes = function() {
    return this._dt.minute;
  };
  LDate2.prototype.getMonth = function() {
    return this._dt.month - 1;
  };
  LDate2.prototype.getSeconds = function() {
    return this._dt.second;
  };
  LDate2.prototype.getTime = function() {
    return this.valueOf();
  };
  LDate2.prototype.getTimezoneOffset = function() {
    return -this._dt.offset;
  };
  LDate2.prototype.getUTCDate = function() {
    return this._dt.toUTC().day;
  };
  LDate2.prototype.getUTCDay = function() {
    return this._dt.toUTC().weekday % 7;
  };
  LDate2.prototype.getUTCFullYear = function() {
    return this._dt.toUTC().year;
  };
  LDate2.prototype.getUTCHours = function() {
    return this._dt.toUTC().hour;
  };
  LDate2.prototype.getUTCMilliseconds = function() {
    return this._dt.toUTC().millisecond;
  };
  LDate2.prototype.getUTCMinutes = function() {
    return this._dt.toUTC().minute;
  };
  LDate2.prototype.getUTCMonth = function() {
    return this._dt.toUTC().month - 1;
  };
  LDate2.prototype.getUTCSeconds = function() {
    return this._dt.toUTC().second;
  };
  LDate2.prototype.setMilliseconds = function(millisecond) {
    return this._setter({
      millisecond
    });
  };
  LDate2.prototype.setSeconds = function(second, millisecond) {
    return this._setter({
      second,
      millisecond
    });
  };
  LDate2.prototype.setMinutes = function(minute, second, millisecond) {
    return this._setter({
      minute,
      second,
      millisecond
    });
  };
  LDate2.prototype.setHours = function(hour, minute, second, millisecond) {
    return this._setter({
      hour,
      minute,
      second,
      millisecond
    });
  };
  LDate2.prototype.setDate = function(day) {
    return this._setter({
      day
    });
  };
  LDate2.prototype.setMonth = function(month, day) {
    month++;
    return this._setter({
      month,
      day
    });
  };
  LDate2.prototype.setFullYear = function(year, month, day) {
    if (month !== UNDEFINED) {
      month++;
    }
    return this._setter({
      year,
      month,
      day
    });
  };
  LDate2.prototype.setTime = function(time) {
    this._init(time);
    return this._dt.valueOf();
  };
  LDate2.prototype.setTimezone = function(timezone) {
    timezone = normTimezone$1(timezone);
    this._zone = timezone;
    this._dt = this._dt.setZone(timezone);
  };
  LDate2.prototype.setUTCMilliseconds = function(ms) {
    return 0;
  };
  LDate2.prototype.setUTCSeconds = function(sec, ms) {
    return 0;
  };
  LDate2.prototype.setUTCMinutes = function(min, sec, ms) {
    return 0;
  };
  LDate2.prototype.setUTCHours = function(hours, min, sec, ms) {
    return 0;
  };
  LDate2.prototype.setUTCDate = function(date) {
    return 0;
  };
  LDate2.prototype.setUTCMonth = function(month, date) {
    return 0;
  };
  LDate2.prototype.setUTCFullYear = function(year, month, date) {
    return 0;
  };
  LDate2.prototype.toUTCString = function() {
    return "";
  };
  LDate2.prototype.toTimeString = function() {
    return "";
  };
  LDate2.prototype.toLocaleDateString = function() {
    return "";
  };
  LDate2.prototype.toLocaleTimeString = function() {
    return "";
  };
  LDate2.prototype._init = function(value) {
    var timezone = this._zone;
    var DT = luxonTimezone.luxon.DateTime;
    var zoneOpt = {
      zone: timezone
    };
    if (isUndefined(value)) {
      this._dt = DT.utc().setZone(timezone);
    } else if (isDate(value) || isNumber(value)) {
      this._dt = DT.fromMillis(+value, zoneOpt);
    } else if (isString(value)) {
      this._dt = DT.fromISO(value, zoneOpt);
    } else if (isArray(value)) {
      var keys = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
      var valueObj = {};
      for (var i = 0; i < value.length && i < 7; i++) {
        valueObj[keys[i]] = value[i] + (i === 1 ? 1 : 0);
      }
      luxonTimezone.version = luxonTimezone.version || getVersion(DT);
      if (luxonTimezone.version === 1) {
        this._dt = DT.fromObject(__assign(__assign({}, valueObj), zoneOpt));
      } else {
        this._dt = DT.fromObject(valueObj, zoneOpt);
      }
    }
  };
  LDate2.prototype._setter = function(obj) {
    this._dt = this._dt.set(obj);
    return this._dt.valueOf();
  };
  return LDate2;
}();
var luxonTimezone = {
  parse: function(date, s) {
    return new LDate(date, s.dataTimezone || s.displayTimezone);
  },
  createDate: function(s, year, month, day, hour, minute, second, millisecond) {
    var displayTimezone = s.displayTimezone;
    if (isObject(year) || isString(year) || isUndefined(month)) {
      return new LDate(year, displayTimezone);
    }
    return new LDate([year || 1970, month || 0, day || 1, hour || 0, minute || 0, second || 0, millisecond || 0], displayTimezone);
  },
  getLib: function() {
    return luxonTimezone.luxon;
  }
};
var ISO_8601_WITH_TIMEZONE_OFFSET = /^(.*)([+-])([0-2]\d{1}):([0-5]\d{1})|(Z)$/;
function normTimezone(plugin, timezone) {
  return !timezone || timezone === "local" ? plugin.getLib().tz.guess() : timezone;
}
function createDate(plugin, s, year, month, date, h, min, sec, ms) {
  var displayTimezone = s.displayTimezone;
  if (isObject(year) || isString(year) || isUndefined(month)) {
    return new MDate(year, displayTimezone, plugin);
  }
  var d = plugin.getLib().utc();
  d = d.year(year || 1970);
  d = d.month(month || 0);
  d = d.date(date || 1);
  d = d.hour(h || 0);
  d = d.minute(min || 0);
  d = d.second(sec || 0);
  d = d.millisecond(ms || 0);
  return new MDate(d.format("YYYY-MM-DDTHH:mm:ss.SSS"), displayTimezone, plugin);
}
var MDate = function() {
  function MDate2(value, timezone, plugin) {
    this._mbsc = true;
    this._plugin = plugin || momentTimezone;
    this._timezone = normTimezone(this._plugin, timezone);
    this._init(value);
  }
  MDate2.prototype.clone = function() {
    return new MDate2(this, this._timezone, this._plugin);
  };
  MDate2.prototype.createDate = function(year, month, date, h, min, sec, ms) {
    return this._plugin.createDate({
      displayTimezone: this._timezone
    }, year, month, date, h, min, sec, ms);
  };
  MDate2.prototype[Symbol.toPrimitive] = function(hint) {
    return this._m.toDate()[Symbol.toPrimitive](hint);
  };
  MDate2.prototype.toDateString = function() {
    return this._m.format("ddd MMM DD YYYY");
  };
  MDate2.prototype.toISOString = function() {
    return this._plugin.isMoment ? this._m.toISOString(true) : this._m.format("YYYY-MM-DDTHH:mm:ss.SSSZ");
  };
  MDate2.prototype.toJSON = function() {
    return this._m.toISOString();
  };
  MDate2.prototype.valueOf = function() {
    return this._m.valueOf();
  };
  MDate2.prototype.getDate = function() {
    return this._m.date();
  };
  MDate2.prototype.getDay = function() {
    return this._m.day();
  };
  MDate2.prototype.getFullYear = function() {
    return this._m.year();
  };
  MDate2.prototype.getHours = function() {
    return this._m.hour();
  };
  MDate2.prototype.getMilliseconds = function() {
    return this._m.millisecond();
  };
  MDate2.prototype.getMinutes = function() {
    return this._m.minute();
  };
  MDate2.prototype.getMonth = function() {
    return this._m.month();
  };
  MDate2.prototype.getSeconds = function() {
    return this._m.second();
  };
  MDate2.prototype.getTime = function() {
    return this._m.valueOf();
  };
  MDate2.prototype.getTimezoneOffset = function() {
    return -this._m.utcOffset();
  };
  MDate2.prototype.getUTCDate = function() {
    return this._utc().date();
  };
  MDate2.prototype.getUTCDay = function() {
    return this._utc().day();
  };
  MDate2.prototype.getUTCFullYear = function() {
    return this._utc().year();
  };
  MDate2.prototype.getUTCHours = function() {
    return this._utc().hour();
  };
  MDate2.prototype.getUTCMilliseconds = function() {
    return this._utc().millisecond();
  };
  MDate2.prototype.getUTCMinutes = function() {
    return this._utc().minute();
  };
  MDate2.prototype.getUTCMonth = function() {
    return this._utc().month();
  };
  MDate2.prototype.getUTCSeconds = function() {
    return this._utc().second();
  };
  MDate2.prototype.setMilliseconds = function(millisecond) {
    return this._setter({
      millisecond
    });
  };
  MDate2.prototype.setSeconds = function(second, millisecond) {
    return this._setter({
      second,
      millisecond
    });
  };
  MDate2.prototype.setMinutes = function(minute, second, millisecond) {
    return this._setter({
      minute,
      second,
      millisecond
    });
  };
  MDate2.prototype.setHours = function(hour, minute, second, millisecond) {
    return this._setter({
      hour,
      minute,
      second,
      millisecond
    });
  };
  MDate2.prototype.setDate = function(date) {
    return this._setter({
      date
    });
  };
  MDate2.prototype.setMonth = function(month, date) {
    return this._setter({
      month,
      date
    });
  };
  MDate2.prototype.setFullYear = function(year, month, date) {
    return this._setter({
      year,
      month,
      date
    });
  };
  MDate2.prototype.setTime = function(time) {
    this._init(time);
    return this._m.valueOf();
  };
  MDate2.prototype.setTimezone = function(timezone) {
    this._timezone = normTimezone(this._plugin, timezone);
    this._m = this._m.tz(this._timezone);
  };
  MDate2.prototype.setUTCMilliseconds = function(ms) {
    return 0;
  };
  MDate2.prototype.setUTCSeconds = function(sec, ms) {
    return 0;
  };
  MDate2.prototype.setUTCMinutes = function(min, sec, ms) {
    return 0;
  };
  MDate2.prototype.setUTCHours = function(hours, min, sec, ms) {
    return 0;
  };
  MDate2.prototype.setUTCDate = function(date) {
    return 0;
  };
  MDate2.prototype.setUTCMonth = function(month, date) {
    return 0;
  };
  MDate2.prototype.setUTCFullYear = function(year, month, date) {
    return 0;
  };
  MDate2.prototype.toUTCString = function() {
    return "";
  };
  MDate2.prototype.toTimeString = function() {
    return "";
  };
  MDate2.prototype.toLocaleDateString = function() {
    return "";
  };
  MDate2.prototype.toLocaleTimeString = function() {
    return "";
  };
  MDate2.prototype._init = function(input) {
    var lib = this._plugin.getLib();
    var tz = lib.tz;
    var normInput = isUndefined(input) || isString(input) || isNumber(input) || isArray(input) ? input : +input;
    if (isString(input) && ISO_8601_TIME.test(input)) {
      this._m = tz(normInput, "HH:mm:ss", this._timezone);
    } else if (isString(input) && !this._plugin.isMoment && ISO_8601_WITH_TIMEZONE_OFFSET.test(input)) {
      this._m = tz(lib.utc(input), this._timezone);
    } else {
      this._m = tz(normInput, this._timezone);
    }
  };
  MDate2.prototype._setter = function(value) {
    for (var key in value) {
      if (value[key] !== UNDEFINED) {
        this._m = this._m.set(key, value[key]);
      }
    }
    return +this._m;
  };
  MDate2.prototype._utc = function() {
    return this._m.clone().utc();
  };
  return MDate2;
}();
var momentTimezone = {
  isMoment: true,
  parse: function(date, s) {
    return new MDate(date, s.dataTimezone || s.displayTimezone, momentTimezone);
  },
  createDate: function(s, year, month, date, h, min, sec, ms) {
    return createDate(momentTimezone, s, year, month, date, h, min, sec, ms);
  },
  getLib: function() {
    return momentTimezone.moment;
  }
};
var dayjsTimezone = {
  parse: function(date, s) {
    return new MDate(date, s.dataTimezone || s.displayTimezone, dayjsTimezone);
  },
  createDate: function(s, year, month, date, h, min, sec, ms) {
    return createDate(dayjsTimezone, s, year, month, date, h, min, sec, ms);
  },
  getLib: function() {
    return dayjsTimezone.dayjs;
  }
};
var MbscDatepickerModule = function() {
  function MbscDatepickerModule2() {
  }
  MbscDatepickerModule2.ɵfac = function MbscDatepickerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscDatepickerModule2)();
  };
  MbscDatepickerModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscDatepickerModule2,
    declarations: [DatepickerBase, MbscDatepicker, MbscDatepickerBase, MbscDatepickerDirective],
    imports: [CommonModule, FormsModule, MbscCalendarModule, MbscDatetimeModule, MbscIconModule, MbscInputModule, MbscPickerModule, MbscPopupModule, MbscSegmentedModule, MbscTimegridModule],
    exports: [MbscDatepicker, MbscDatepickerDirective, MbscCalendarHeaderModule]
  });
  MbscDatepickerModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, FormsModule, MbscCalendarModule, MbscDatetimeModule, MbscIconModule, MbscInputModule, MbscPickerModule, MbscPopupModule, MbscSegmentedModule, MbscTimegridModule], MbscCalendarHeaderModule]
  });
  return MbscDatepickerModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDatepickerModule, [{
    type: NgModule,
    args: [{
      declarations: [DatepickerBase, MbscDatepicker, MbscDatepickerBase, MbscDatepickerDirective],
      entryComponents: [MbscDatepicker],
      exports: [MbscDatepicker, MbscDatepickerDirective, MbscCalendarHeaderModule],
      imports: [CommonModule, FormsModule, MbscCalendarModule, MbscDatetimeModule, MbscIconModule, MbscInputModule, MbscPickerModule, MbscPopupModule, MbscSegmentedModule, MbscTimegridModule]
    }]
  }], null, null);
})();
var DELIMITER = ", ";
var DEF_GROUP = "mbsc-group-0";
function createDisabledMap(optionList, invalids) {
  var map2 = /* @__PURE__ */ new Map();
  if (optionList) {
    optionList.forEach(function(item) {
      if (item.disabled) {
        map2.set(item.value, true);
      }
    });
  }
  if (invalids) {
    invalids.forEach(function(value) {
      map2.set(value, true);
    });
  }
  return map2;
}
function createDisabledGroupsMap(disabledMap, optionList) {
  var map2 = /* @__PURE__ */ new Map();
  if (optionList) {
    optionList.forEach(function(_a) {
      var group = _a.group, value = _a.value;
      if (group) {
        if (!map2.has(group)) {
          map2.set(group, true);
        }
        if (!disabledMap.get(value)) {
          map2.set(group, false);
        }
      }
    });
  }
  return map2;
}
function filterOptions(optionList, filterText) {
  if (!filterText) {
    return optionList;
  }
  var escapedText = filterText.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
  var filterRegExp = new RegExp(escapedText, "i");
  var filtered = optionList.filter(function(item) {
    return filterRegExp.test(item.text);
  });
  return filtered;
}
var SelectBase = function(_super) {
  __extends(SelectBase2, _super);
  function SelectBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._options = [];
    _this._selectMap = /* @__PURE__ */ new Map();
    _this._onFilterChange = function(e) {
      var filterText = e.target.value;
      clearTimeout(_this._debounce);
      _this._filterInput.value = filterText;
      _this._debounce = setTimeout(function() {
        _this._filter(filterText);
      }, 300);
    };
    _this._onFilterClear = function() {
      var input = _this._filterInput;
      if (input) {
        input.value = "";
      }
      _this._filter("");
    };
    _this._onResize = function(args) {
      _this.setState({
        width: args.windowWidth
      });
    };
    _this._onChange = function(args) {
      var vals = args.value;
      _this._parsedValue = vals;
      _this._saveSelected(vals);
      _this._tempVal = vals;
      _this._tempValueRep = _this._parse(vals);
      _this._setOrUpdate();
      if (_this._live && args.itemTap && args.closeOnTap) {
        _this.close();
      }
    };
    _this._onWheelMove = function(_a) {
      var wheelIndex = _a.wheelIndex, selection = _a.selection, dataItem = _a.dataItem;
      if (!_this._selectOnScroll && !selection && wheelIndex === 1 && dataItem) {
        var opt = find(_this._options, function(o) {
          return o.value === dataItem.value;
        });
        var group = dataItem.isGroup ? dataItem.value : _this._groupReMap[opt.group || ""];
        return [group];
      }
      return UNDEFINED;
    };
    _this._format = function(valueRep) {
      var optionWheelIndex = _this.s.showGroupWheel ? 1 : 0;
      var value = valueRep[optionWheelIndex];
      var values = _this.s.selectMultiple ? value : [value];
      var labels = values.map && values.map(function(v) {
        if (_this._valueMap) {
          return _this._valueMap.get(v);
        }
        return UNDEFINED;
      });
      return (labels || []).join(DELIMITER);
    };
    _this._parse = function(value) {
      var map2 = _this._valueMap;
      var reMap = _this._reMap;
      var isMultiple = _this.s.selectMultiple;
      var defSel = _this.s.defaultSelection;
      var defValue = isMultiple ? defSel ? defSel.length !== UNDEFINED ? defSel : __spreadArray([], defSel, true) : [] : defSel !== UNDEFINED ? defSel : null;
      var parsedValue;
      _this._parsedValue = value;
      if (map2) {
        if (isMultiple && !isEmpty(value)) {
          var representation = [];
          if (value.length === UNDEFINED) {
            representation.push(value);
          } else {
            if (isString(value)) {
              var labels = value.split(DELIMITER);
              for (var _i = 0, labels_1 = labels; _i < labels_1.length; _i++) {
                var label = labels_1[_i];
                var valueFromLabel = reMap.get(label);
                if (valueFromLabel !== UNDEFINED) {
                  representation.push(valueFromLabel);
                }
              }
            } else {
              for (var _a = 0, value_1 = value; _a < value_1.length; _a++) {
                var iValue = value_1[_a];
                if (map2.has(iValue)) {
                  representation.push(iValue);
                }
              }
            }
          }
          parsedValue = representation;
        } else {
          if (map2.has(value)) {
            parsedValue = value;
          } else if (isString(value) && reMap.has(value)) {
            parsedValue = reMap.get(value);
          }
        }
      }
      if (parsedValue === UNDEFINED) {
        parsedValue = defValue;
      }
      if (_this.s.showGroupWheel) {
        var firstValue_1 = isMultiple ? parsedValue[0] : parsedValue;
        var selectedItem = find(_this._options, function(item) {
          return item.value === firstValue_1;
        });
        return [selectedItem && _this._groupReMap[selectedItem.group || ""], parsedValue];
      }
      return [parsedValue];
    };
    _this._get = function(valueRep) {
      var optWheelIndex = _this.s.showGroupWheel ? 1 : 0;
      var values = valueRep[optWheelIndex];
      return _this.s.selectMultiple ? values || [] : values;
    };
    _this._valueEquals = function(v1, v2) {
      if (_this.s.selectMultiple) {
        return arrayContentEquals(v1 || [], v2 || []);
      } else {
        return v1 === v2;
      }
    };
    _this._shouldValidate = function(s, prevS) {
      var res = s.selectMultiple !== prevS.selectMultiple || !s.filter && s.data !== prevS.data || _this._groupChanged;
      _this._groupChanged = false;
      return res;
    };
    _this._validateScroller = function(_a) {
      var values = _a.values, direction = _a.direction, wheels = _a.wheels, index = _a.index;
      var disabledMap = _this._disabled;
      var selectOnScroll = _this._selectOnScroll;
      var isMulti = _this.s.selectMultiple;
      var groupWheels = _this.s.showGroupWheel;
      var disabled = groupWheels ? [_this._disabledGroups, disabledMap] : [disabledMap];
      var optWheelIndex = groupWheels ? 1 : 0;
      var val = _this._get(values);
      var ret = {
        disabled
      };
      if (index === optWheelIndex || index === UNDEFINED) {
        if (isMulti) {
          var valid_1 = [];
          val.forEach(function(selectedValue) {
            if (!disabledMap.get(selectedValue)) {
              valid_1.push(selectedValue);
            }
          });
          ret.valid = _this._parse(valid_1);
          if (index !== UNDEFINED) {
            ret.valid[0] = values[0];
          }
        } else {
          if (isEmpty(val) && !selectOnScroll) {
            ret.valid = groupWheels ? [null, null] : [null];
            return ret;
          }
          var validValue_1 = getValid(wheels[optWheelIndex], values[optWheelIndex], disabledMap, direction);
          if (groupWheels) {
            var item = find(_this._options, function(o) {
              return o.value === validValue_1;
            });
            ret.valid = [_this._groupReMap[item && item.group || ""], validValue_1];
          } else {
            ret.valid = [validValue_1];
          }
        }
      } else {
        var validGroup = getValid(wheels[0], values[0], disabled[0], direction);
        var validGroupName_1 = validGroup === DEF_GROUP ? UNDEFINED : _this._groupMap[validGroup];
        var firstValidItem = find(_this._options, function(o) {
          return o.group === validGroupName_1 && (!selectOnScroll || !disabledMap.get(o.value));
        });
        var itemOrHeaderValue = _this._touchUi || firstValidItem.group === UNDEFINED ? firstValidItem.value : validGroup;
        if (selectOnScroll) {
          ret.valid = [validGroup, itemOrHeaderValue];
        } else {
          ret.valid = [validGroup, values[1]];
          var first = isMulti ? [itemOrHeaderValue] : itemOrHeaderValue;
          var group = _this._touchUi ? validGroup : UNDEFINED;
          ret.indexes = [group, first];
        }
      }
      return ret;
    };
    _this._setScroller = function(scroller) {
      _this._scroller = scroller;
    };
    _this._setFilterInput = function(input) {
      _this._filterInput = input && input.nativeElement;
    };
    _this._saveSelected = function(values) {
      if (_this.s.selectMultiple) {
        var selectMap_1 = /* @__PURE__ */ new Map();
        forEach(values, function(value) {
          var label = _this._valueMap.get(value);
          selectMap_1.set(value, label);
        });
        _this._selectMap = selectMap_1;
      }
    };
    return _this;
  }
  SelectBase2.prototype.reloadOptionElements = function() {
    var _this = this;
    this._optionsReloaded = true;
    this._setOptionsFromElm();
    setTimeout(function() {
      _this.forceUpdate();
    });
  };
  SelectBase2.prototype.setVal = function(value) {
    _super.prototype.setVal.call(this, value);
  };
  SelectBase2.prototype.getVal = function() {
    return isEmpty(this._parsedValue) ? this._parsedValue : _super.prototype.getVal.call(this);
  };
  SelectBase2.prototype.setTempVal = function(value) {
    if (this._inst) {
      this._inst.setTempVal(value);
    } else {
      this._tempVal = value;
      _super.prototype.setTempVal.call(this, value);
    }
  };
  SelectBase2.prototype.getTempVal = function() {
    if (this._inst) {
      return this._inst.getTempVal();
    } else {
      return _super.prototype.getTempVal.call(this);
    }
  };
  SelectBase2.prototype._validate = function() {
    var wheels = this._wheels[0];
    wheels.forEach(function(wheel, i) {
      if (!wheel._map) {
        initWheel(wheel, i);
      }
    });
    var ret = this._validateScroller({
      values: this._tempValueRep,
      wheels
    });
    if (ret.valid) {
      this._tempValueRep = ret.valid;
      this._tempVal = this._get(ret.valid);
    }
  };
  SelectBase2.prototype._onOpen = function() {
    this._tempVal = this._value;
  };
  SelectBase2.prototype._onClosed = function() {
    var _this = this;
    if (this._filterText) {
      setTimeout(function() {
        return _this._onFilterClear();
      }, 100);
    }
  };
  SelectBase2.prototype._onRender = function(s) {
    var prevS = this._prevS;
    var spaceAround = this._touchUi && (!s.selectMultiple || (s.baseTheme || s.theme) === "ios");
    var selectOnScroll = this._touchUi && !s.selectMultiple;
    var elementChanged = s.element !== prevS.element || s.selectElement !== prevS.selectElement;
    var dataChanged = s.data !== prevS.data;
    var dataReloaded = dataChanged || this._optionsReloaded;
    var placeholder = s.placeholder;
    var checkEmptyOption = s.display !== prevS.display || placeholder !== prevS.placeholder || selectOnScroll !== this._selectOnScroll;
    var disabledChanged = dataReloaded || elementChanged || s.invalid !== prevS.invalid || this._selectOnScroll !== selectOnScroll;
    var groupChanged = s.showGroupWheel !== prevS.showGroupWheel;
    this._selectOnScroll = selectOnScroll;
    if (groupChanged) {
      this._groupChanged = true;
    }
    if (elementChanged || checkEmptyOption) {
      this._isSelect = s.selectElement !== UNDEFINED;
      if (this._isSelect) {
        this._setOptionsFromElm();
      } else if (!s.element) {
        this._options = [];
      }
    }
    if ((dataChanged || checkEmptyOption) && s.data) {
      this._createOptionList(s.data);
    }
    if (disabledChanged) {
      this._disabled = createDisabledMap(this._options, s.invalid);
      this._disabledGroups = createDisabledGroupsMap(this._disabled, selectOnScroll ? this._options : UNDEFINED);
    }
    if (disabledChanged || groupChanged || spaceAround !== this._spaceAround || s.filter !== prevS.filter || s.selectMultiple !== prevS.selectMultiple) {
      this._createWheels(this._filterText, spaceAround);
    }
    if (dataReloaded || s.filter !== prevS.filter || s.touchUi !== prevS.touchUi || s.rows !== prevS.rows) {
      var dataLength = s.filter ? Infinity : this._wheels[0][s.showGroupWheel ? 1 : 0].data.length;
      var respRows = (this._respProps || {}).rows;
      var propRows = this.props.rows;
      var defRows = this._touchUi ? s.rows : Math.min(respRows || propRows || 7, dataLength);
      this._rows = propRows || defRows;
    }
    this._wheelWidth = s.wheelWidth || (s.filter ? s.showGroupWheel ? [150, 250] : 400 : UNDEFINED);
    this._spaceAround = spaceAround;
    this._optionsReloaded = false;
  };
  SelectBase2.prototype._writeValue = function(elm, text, value) {
    var oldValue = elm.value;
    elm.value = text;
    if (this._isSelect) {
      if (!isArray(value)) {
        value = [value];
      }
      var select = this.s.selectElement;
      var options2 = select.options;
      var changed = false;
      for (var i = 0; i < options2.length; i++) {
        var opt = options2[i];
        var wasSelected = opt.selected;
        opt.selected = value.indexOf(opt.value) > -1;
        if (wasSelected !== opt.selected) {
          changed = true;
        }
      }
      if (changed) {
        trigger(select, CHANGE);
      }
      return changed;
    } else {
      return oldValue !== text;
    }
  };
  SelectBase2.prototype._createOptionList = function(data) {
    var s = this.s;
    var text = s.placeholder;
    var options2 = [];
    var map2 = /* @__PURE__ */ new Map();
    var reMap = /* @__PURE__ */ new Map();
    this._selectMap.forEach(function(label, value) {
      map2.set(value, label);
    });
    var hasEmpty = false;
    var addOption = function(item, index) {
      if (!item || item.value === UNDEFINED) {
        item = {
          text: item,
          value: item
        };
      }
      if (isEmpty(item.value)) {
        hasEmpty = true;
      }
      map2.set(item.value, item.text);
      reMap.set(item.text, item.value);
      options2.splice(index, 0, item);
    };
    data.forEach(addOption);
    if (s.display === "inline" && this._selectOnScroll && text && !hasEmpty) {
      addOption({
        value: "",
        text
      }, 0);
    }
    this._valueMap = map2;
    this._reMap = reMap;
    this._options = options2;
  };
  SelectBase2.prototype._createWheels = function(filterText, spaceAround) {
    var _this = this;
    var s = this.s;
    var isMultiple = s.selectMultiple;
    var options2 = s.filter && filterText ? filterOptions(this._options, filterText) : this._options;
    var data = [];
    var groupData = [];
    var groups = {};
    this._groupMap = {};
    this._groupReMap = {};
    options2.forEach(function(option) {
      var group = option.group;
      var groupName = group === UNDEFINED ? "" : group;
      var groupOptions = groups[groupName];
      var item = {
        display: option.text,
        value: option.value,
        data: option,
        disabled: _this._disabled.get(option.value)
      };
      if (groupOptions) {
        groupOptions.push(item);
      } else {
        groups[groupName] = [item];
      }
    });
    var groupUnique = 0;
    Object.keys(groups).forEach(function(groupName) {
      var groupValue = groupName === "" ? DEF_GROUP : "mbsc-group-" + ++groupUnique;
      var groupOptions = groups[groupName];
      if (groupName === "") {
        data.unshift.apply(data, groupOptions);
        if (_this._selectOnScroll) {
          groupData.unshift({
            display: "",
            value: groupValue
          });
        }
      } else {
        data.push({
          display: groupName,
          isGroup: true,
          value: groupValue
        });
        data.push.apply(data, groupOptions);
        groupData.push({
          display: groupName,
          value: groupValue
        });
        _this._disabled.set(groupValue, true);
      }
      _this._groupMap[groupValue] = groupName;
      _this._groupReMap[groupName] = groupValue;
    });
    var optWheel = {
      checkmark: true,
      circular: false,
      closeOnTap: !isMultiple,
      data,
      label: s.label,
      multiple: isMultiple,
      spaceAround
    };
    var groupWheel = {
      checkmark: false,
      circular: false,
      cssClass: "mbsc-select-group-wheel" + (isMultiple ? " mbsc-select-group-wheel-multi" : ""),
      data: groupData,
      label: s.groupText,
      multiple: false,
      spaceAround
    };
    this._noResults = s.filter && !options2.length;
    this._wheels = s.showGroupWheel ? [[groupWheel, optWheel]] : [[optWheel]];
  };
  SelectBase2.prototype._setOptionsFromElm = function() {
    var select = this.s.selectElement;
    var doc2 = getDocument(select);
    var options2 = select.options;
    var data = [];
    var hasEmpty = false;
    var hasSelected = false;
    for (var i = 0; i < options2.length; i++) {
      var opt = options2[i];
      var parent_1 = opt.parentElement;
      var group = parent_1.nodeName.toLowerCase() === "optgroup" ? parent_1.label : UNDEFINED;
      if (opt.value !== "") {
        data.push({
          disabled: opt.disabled,
          group,
          text: opt.text,
          value: opt.value
        });
      } else {
        hasEmpty = true;
      }
      if (opt.defaultSelected) {
        hasSelected = true;
      }
    }
    if (!hasEmpty && doc2) {
      select.insertBefore(doc2.createElement("option"), select.childNodes[0] || null);
      if (!hasSelected) {
        select.value = "";
      }
    }
    this._createOptionList(data);
  };
  SelectBase2.prototype._filter = function(filterText) {
    var ret = this._hook("onFilter", {
      filterText
    });
    if (ret !== false) {
      this._filterText = filterText;
      this._createWheels(filterText, this._spaceAround);
    }
    this.forceUpdate();
  };
  SelectBase2.defaults = __assign(__assign({}, PickerBase.defaults), {
    activeElm: ".mbsc-select-filter-input",
    dropdown: true,
    filterEmptyText: "No results",
    filterPlaceholderText: "Search",
    groupText: "Group",
    rows: 5,
    showOnClick: true
  });
  SelectBase2._name = "Select";
  SelectBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵSelectBase_BaseFactory;
    return function SelectBase_Factory(__ngFactoryType__) {
      return (ɵSelectBase_BaseFactory || (ɵSelectBase_BaseFactory = ɵɵgetInheritedFactory(SelectBase2)))(__ngFactoryType__ || SelectBase2);
    };
  })();
  SelectBase2.ɵdir = ɵɵdefineDirective({
    type: SelectBase2,
    selectors: [["", "mbsc-sel-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return SelectBase2;
}(PickerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sel-b]"
    }]
  }], null, null);
})();
var template = `<input [hidden]="element || s.inputElement || !s.selectElement || s.display === 'inline'" #defaultInput type="text" />` + getPickerTemplate(`
<ng-template #filterInputTemplate let-inst="data">
  <div [class]="'mbsc-select-filter-cont' + inst._theme + inst._rtl">
    <mbsc-input
      #filterInput
      autocomplete="off"
      class="mbsc-select-filter"
      (input)="inst._onFilterChange($event)"
      inputClass="mbsc-select-filter-input"
      inputStyle="box"
      [placeholder]="inst.s.filterPlaceholderText"
      [rtl]="inst.s.rtl"
      [theme]="inst.s.theme"
      [themeVariant]="inst.s.themeVariant"
    >
    </mbsc-input>
    <mbsc-icon
      *ngIf="inst._filterText"
      [class]="'mbsc-select-filter-clear' + inst._rtl"
      (click)="inst._onFilterClear()"
      [svg]="inst.s.clearIcon"
      [theme]="inst.s.theme"
    ></mbsc-icon>
  </div>
</ng-template>
<ng-template #filterEmptyTemplate let-inst="data">
  <div *ngIf="inst._noResults" [class]="'mbsc-select-empty-text mbsc-flex' + inst._theme">{{ inst.s.filterEmptyText }}</div>
</ng-template>

<mbsc-scroller
  [circular]="s.circular"
  [class]="
    (s.cssClass || s.class || '') + (_noResults ? ' mbsc-select-empty' : '') + ' mbsc-select-scroller mbsc-select-scroller-' + s.display
  "
  [display]="s.display"
  [getValue]="_get"
  [inContentTemplate]="filterEmptyTemplate"
  [invalid]="s.invalid"
  [itemHeight]="s.itemHeight"
  [itemTemplate]="itemTemplate"
  [maxWheelWidth]="s.maxWheelWidth"
  [minWheelWidth]="s.minWheelWidth"
  [onWheelMove]="_onWheelMove"
  [parseValue]="_parse"
  [preContentData]="this"
  [preContentTemplate]="s.filter && filterInputTemplate"
  [rows]="_rows"
  [rtl]="s.rtl"
  [selectOnScroll]="_selectOnScroll"
  [shouldValidate]="_shouldValidate"
  [theme]="s.theme"
  [themeVariant]="s.themeVariant"
  [touchUi]="_touchUi"
  [validate]="_validateScroller"
  [valueEquality]="_valueEquals"
  [value]="_tempVal"
  [wheelWidth]="_wheelWidth"
  [wheels]="_wheels"
  (onChange)="_onChange($event)"
></mbsc-scroller>`);
var MbscSelectOptionBase = function() {
  function MbscSelectOptionBase2(_host, _changeService) {
    this._host = _host;
    this._changeService = _changeService;
    this._component = false;
  }
  MbscSelectOptionBase2.prototype.ngAfterViewInit = function() {
    this.text = this._host.nativeElement.textContent || "";
  };
  MbscSelectOptionBase2.prototype.ngOnChanges = function(changes) {
    this.text = this._host.nativeElement.textContent || "";
    this._changeService.reloadOptions(this._component);
  };
  MbscSelectOptionBase2.ɵfac = function MbscSelectOptionBase_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscSelectOptionBase2)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MbscSelectOptionChangeService));
  };
  MbscSelectOptionBase2.ɵdir = ɵɵdefineDirective({
    type: MbscSelectOptionBase2,
    selectors: [["", "mbsc-sel-b", ""]],
    inputs: {
      value: "value",
      group: "group",
      disabled: "disabled"
    },
    standalone: false,
    features: [ɵɵNgOnChangesFeature]
  });
  return MbscSelectOptionBase2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSelectOptionBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sel-b]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: MbscSelectOptionChangeService
    }];
  }, {
    value: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var MbscSelectOptionDirective = function(_super) {
  __extends(MbscSelectOptionDirective2, _super);
  function MbscSelectOptionDirective2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscSelectOptionDirective2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSelectOptionDirective_BaseFactory;
    return function MbscSelectOptionDirective_Factory(__ngFactoryType__) {
      return (ɵMbscSelectOptionDirective_BaseFactory || (ɵMbscSelectOptionDirective_BaseFactory = ɵɵgetInheritedFactory(MbscSelectOptionDirective2)))(__ngFactoryType__ || MbscSelectOptionDirective2);
    };
  })();
  MbscSelectOptionDirective2.ɵdir = ɵɵdefineDirective({
    type: MbscSelectOptionDirective2,
    selectors: [["", "mbsc-select-option", ""]],
    inputs: {
      value: "value",
      group: "group",
      disabled: "disabled"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return MbscSelectOptionDirective2;
}(MbscSelectOptionBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSelectOptionDirective, [{
    type: Directive,
    args: [{
      selector: "[mbsc-select-option]"
    }]
  }], null, {
    value: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var MbscSelectOptionComponent = function(_super) {
  __extends(MbscSelectOptionComponent2, _super);
  function MbscSelectOptionComponent2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._component = true;
    return _this;
  }
  MbscSelectOptionComponent2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSelectOptionComponent_BaseFactory;
    return function MbscSelectOptionComponent_Factory(__ngFactoryType__) {
      return (ɵMbscSelectOptionComponent_BaseFactory || (ɵMbscSelectOptionComponent_BaseFactory = ɵɵgetInheritedFactory(MbscSelectOptionComponent2)))(__ngFactoryType__ || MbscSelectOptionComponent2);
    };
  })();
  MbscSelectOptionComponent2.ɵcmp = ɵɵdefineComponent({
    type: MbscSelectOptionComponent2,
    selectors: [["mbsc-select-option"]],
    inputs: {
      value: "value",
      group: "group",
      disabled: "disabled"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscSelectOptionComponent_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2
  });
  return MbscSelectOptionComponent2;
}(MbscSelectOptionBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSelectOptionComponent, [{
    type: Component,
    args: [{
      selector: "mbsc-select-option",
      template: "<ng-content></ng-content>"
    }]
  }], null, {
    value: [{
      type: Input
    }],
    group: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var MbscSelectBase = function(_super) {
  __extends(MbscSelectBase2, _super);
  function MbscSelectBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onCancel = new EventEmitter();
    _this.onChange = new EventEmitter();
    _this.onClose = new EventEmitter();
    _this.onFilter = new EventEmitter();
    _this.onOpen = new EventEmitter();
    _this.onTempChange = new EventEmitter();
    return _this;
  }
  MbscSelectBase2.prototype._onValueChange = function(value) {
    this.setState({
      value
    });
  };
  MbscSelectBase2.prototype._render = function(s, state) {
    var elm = s.element;
    s.element = (elm ? elm._el || elm : UNDEFINED) || (s.selectElement ? this._defaultInput : UNDEFINED);
    _super.prototype._render.call(this, s, state);
  };
  MbscSelectBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSelectBase_BaseFactory;
    return function MbscSelectBase_Factory(__ngFactoryType__) {
      return (ɵMbscSelectBase_BaseFactory || (ɵMbscSelectBase_BaseFactory = ɵɵgetInheritedFactory(MbscSelectBase2)))(__ngFactoryType__ || MbscSelectBase2);
    };
  })();
  MbscSelectBase2.ɵdir = ɵɵdefineDirective({
    type: MbscSelectBase2,
    selectors: [["", "mbsc-sel-b", ""]],
    inputs: {
      ariaLabel: "ariaLabel",
      circular: "circular",
      clearIcon: "clearIcon",
      data: "data",
      element: "element",
      defaultSelection: "defaultSelection",
      filter: "filter",
      formatValue: "formatValue",
      getValue: "getValue",
      invalid: "invalid",
      itemHeight: "itemHeight",
      itemTemplate: "itemTemplate",
      maxHeight: "maxHeight",
      maxWidth: "maxWidth",
      maxWheelWidth: "maxWheelWidth",
      minWheelWidth: "minWheelWidth",
      parseValue: "parseValue",
      rows: "rows",
      rtl: "rtl",
      selectMultiple: "selectMultiple",
      showGroupWheel: "showGroupWheel",
      showOnClick: "showOnClick",
      showOnFocus: "showOnFocus",
      valueEquality: "valueEquality",
      wheels: "wheels",
      wheelWidth: "wheelWidth",
      disabled: "disabled",
      dropdown: "dropdown",
      endIcon: "endIcon",
      endIconSrc: "endIconSrc",
      endIconSvg: "endIconSvg",
      error: "error",
      errorMessage: "errorMessage",
      inputStyle: "inputStyle",
      label: "label",
      labelStyle: "labelStyle",
      name: "name",
      placeholder: "placeholder",
      startIcon: "startIcon",
      startIconSrc: "startIconSrc",
      startIconSvg: "startIconSvg",
      tagInput: "tagInput",
      anchor: "anchor",
      animation: "animation",
      buttons: "buttons",
      cancelText: "cancelText",
      clearText: "clearText",
      closeOnEsc: "closeOnEsc",
      closeOnOverlayClick: "closeOnOverlayClick",
      closeText: "closeText",
      context: "context",
      display: "display",
      focusOnClose: "focusOnClose",
      focusTrap: "focusTrap",
      headerText: "headerText",
      height: "height",
      setText: "setText",
      showArrow: "showArrow",
      showInput: "showInput",
      showOverlay: "showOverlay",
      width: "width",
      filterEmptyText: "filterEmptyText",
      filterPlaceholderText: "filterPlaceholderText",
      groupText: "groupText"
    },
    outputs: {
      onCancel: "onCancel",
      onChange: "onChange",
      onClose: "onClose",
      onFilter: "onFilter",
      onOpen: "onOpen",
      onTempChange: "onTempChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  MbscSelectBase2 = __decorate([FormControl], MbscSelectBase2);
  return MbscSelectBase2;
}(SelectBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSelectBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sel-b]"
    }]
  }], null, {
    ariaLabel: [{
      type: Input
    }],
    circular: [{
      type: Input
    }],
    clearIcon: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    element: [{
      type: Input
    }],
    defaultSelection: [{
      type: Input
    }],
    filter: [{
      type: Input
    }],
    formatValue: [{
      type: Input
    }],
    getValue: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    itemHeight: [{
      type: Input
    }],
    itemTemplate: [{
      type: Input
    }],
    maxHeight: [{
      type: Input
    }],
    maxWidth: [{
      type: Input
    }],
    maxWheelWidth: [{
      type: Input
    }],
    minWheelWidth: [{
      type: Input
    }],
    parseValue: [{
      type: Input
    }],
    rows: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    selectMultiple: [{
      type: Input
    }],
    showGroupWheel: [{
      type: Input
    }],
    showOnClick: [{
      type: Input
    }],
    showOnFocus: [{
      type: Input
    }],
    valueEquality: [{
      type: Input
    }],
    wheels: [{
      type: Input
    }],
    wheelWidth: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    dropdown: [{
      type: Input
    }],
    endIcon: [{
      type: Input
    }],
    endIconSrc: [{
      type: Input
    }],
    endIconSvg: [{
      type: Input
    }],
    error: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    inputStyle: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    labelStyle: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    startIcon: [{
      type: Input
    }],
    startIconSrc: [{
      type: Input
    }],
    startIconSvg: [{
      type: Input
    }],
    tagInput: [{
      type: Input
    }],
    anchor: [{
      type: Input
    }],
    animation: [{
      type: Input
    }],
    buttons: [{
      type: Input
    }],
    cancelText: [{
      type: Input
    }],
    clearText: [{
      type: Input
    }],
    closeOnEsc: [{
      type: Input
    }],
    closeOnOverlayClick: [{
      type: Input
    }],
    closeText: [{
      type: Input
    }],
    context: [{
      type: Input
    }],
    display: [{
      type: Input
    }],
    focusOnClose: [{
      type: Input
    }],
    focusTrap: [{
      type: Input
    }],
    headerText: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    setText: [{
      type: Input
    }],
    showArrow: [{
      type: Input
    }],
    showInput: [{
      type: Input
    }],
    showOverlay: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    filterEmptyText: [{
      type: Input
    }],
    filterPlaceholderText: [{
      type: Input
    }],
    groupText: [{
      type: Input
    }],
    onCancel: [{
      type: Output
    }],
    onChange: [{
      type: Output
    }],
    onClose: [{
      type: Output
    }],
    onFilter: [{
      type: Output
    }],
    onOpen: [{
      type: Output
    }],
    onTempChange: [{
      type: Output
    }]
  });
})();
var MbscSelectOptionChangeService = function() {
  function MbscSelectOptionChangeService2() {
  }
  MbscSelectOptionChangeService2.prototype.reloadOptions = function(component) {
    var _this = this;
    clearTimeout(this._handler);
    this._handler = setTimeout(function() {
      if (_this._inst) {
        if (component) {
          _this._inst.updateOptionlist();
        } else {
          _this._inst.reloadOptionElements();
        }
      }
    });
  };
  MbscSelectOptionChangeService2.prototype.setInst = function(i) {
    this._inst = i;
  };
  return MbscSelectOptionChangeService2;
}();
var MbscSelect = function(_super) {
  __extends(MbscSelect2, _super);
  function MbscSelect2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(MbscSelect2.prototype, "vInput", {
    set: function(inp) {
      if (inp) {
        this._el = inp.nativeElement;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MbscSelect2.prototype, "vDefInput", {
    set: function(inp) {
      if (inp) {
        this._defaultInput = inp.nativeElement;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MbscSelect2.prototype, "vFilter", {
    set: function(input) {
      this._filterInput = input && input.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MbscSelect2.prototype, "vPopup", {
    set: function(popup) {
      this._popup = popup;
    },
    enumerable: false,
    configurable: true
  });
  MbscSelect2.prototype.updateOptionlist = function() {
    var _this = this;
    var data = this.optionComponents.map(function(ch) {
      return {
        disabled: ch.disabled,
        group: ch.group,
        text: ch.text,
        value: ch.value
      };
    });
    this._createOptionList(data);
    this._optionsReloaded = true;
    setTimeout(function() {
      _this.forceUpdate();
    });
  };
  MbscSelect2.prototype.valueSet = function(event) {
    this.value = event.value;
    this._saveSelected(event.value);
    this._hook("onChange", event);
  };
  MbscSelect2.prototype._ctor = function() {
    var s = this._injector.get(MbscSelectOptionChangeService);
    s.setInst(this);
  };
  MbscSelect2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSelect_BaseFactory;
    return function MbscSelect_Factory(__ngFactoryType__) {
      return (ɵMbscSelect_BaseFactory || (ɵMbscSelect_BaseFactory = ɵɵgetInheritedFactory(MbscSelect2)))(__ngFactoryType__ || MbscSelect2);
    };
  })();
  MbscSelect2.ɵcmp = ɵɵdefineComponent({
    type: MbscSelect2,
    selectors: [["mbsc-select"]],
    contentQueries: function MbscSelect_ContentQueries(rf, ctx2, dirIndex) {
      if (rf & 1) {
        ɵɵcontentQuery(dirIndex, MbscSelectOptionComponent, 4);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.optionComponents = _t);
      }
    },
    viewQuery: function MbscSelect_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
        ɵɵviewQuery(_c32, 5);
        ɵɵviewQuery(_c33, 5);
        ɵɵviewQuery(_c13, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vDefInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vFilter = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vPopup = _t.first);
      }
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MbscSelectOptionChangeService]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 6,
    vars: 39,
    consts: [["defaultInput", ""], ["popup", ""], ["input", ""], ["filterInputTemplate", ""], ["filterEmptyTemplate", ""], ["filterInput", ""], ["type", "text", 3, "hidden"], [3, "ariaExpanded", "ariaHaspopup", "ariaLabel", "dropdown", "disabled", "endIcon", "endIconSrc", "endIconSvg", "error", "errorMessage", "inputStyle", "label", "labelStyle", "name", "placeholder", "pickerMap", "pickerValue", "role", "rtl", "startIcon", "startIconSrc", "startIconSvg", "tags", "theme", "themeVariant", "value", 4, "ngIf"], [3, "onClose", "onClosed", "onKeyDown", "onOpen", "onResize", "activeElm", "anchor", "anchorAlign", "animation", "ariaLabel", "buttons", "cancelText", "closeOnEsc", "closeOnOverlayClick", "closeOnScroll", "closeText", "contentPadding", "context", "cssClass", "disableLeftRight", "display", "focusElm", "focusOnClose", "focusOnOpen", "focusTrap", "fullScreen", "headerText", "height", "isOpen", "maxHeight", "maxWidth", "setText", "showArrow", "showOverlay", "rtl", "scrollLock", "theme", "themeVariant", "touchUi", "windowWidth", "width"], [4, "ngIf"], [3, "ariaExpanded", "ariaHaspopup", "ariaLabel", "dropdown", "disabled", "endIcon", "endIconSrc", "endIconSvg", "error", "errorMessage", "inputStyle", "label", "labelStyle", "name", "placeholder", "pickerMap", "pickerValue", "role", "rtl", "startIcon", "startIconSrc", "startIconSvg", "tags", "theme", "themeVariant", "value"], [3, "onChange", "circular", "display", "getValue", "inContentTemplate", "invalid", "itemHeight", "itemTemplate", "maxWheelWidth", "minWheelWidth", "onWheelMove", "parseValue", "preContentData", "preContentTemplate", "rows", "rtl", "selectOnScroll", "shouldValidate", "theme", "themeVariant", "touchUi", "validate", "valueEquality", "value", "wheelWidth", "wheels"], ["autocomplete", "off", "inputClass", "mbsc-select-filter-input", "inputStyle", "box", 1, "mbsc-select-filter", 3, "input", "placeholder", "rtl", "theme", "themeVariant"], [3, "class", "svg", "theme", "click", 4, "ngIf"], [3, "click", "svg", "theme"], [3, "class", 4, "ngIf"]],
    template: function MbscSelect_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵelement(0, "input", 6, 0);
        ɵɵtemplate(2, MbscSelect_mbsc_input_2_Template, 3, 26, "mbsc-input", 7);
        ɵɵelementStart(3, "mbsc-popup", 8, 1);
        ɵɵlistener("onClose", function MbscSelect_Template_mbsc_popup_onClose_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupClose($event));
        })("onClosed", function MbscSelect_Template_mbsc_popup_onClosed_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupClosed($event));
        })("onKeyDown", function MbscSelect_Template_mbsc_popup_onKeyDown_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupKey($event));
        })("onOpen", function MbscSelect_Template_mbsc_popup_onOpen_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopupOpen($event));
        })("onResize", function MbscSelect_Template_mbsc_popup_onResize_3_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onResize($event));
        });
        ɵɵtemplate(5, MbscSelect_ng_container_5_Template, 6, 27, "ng-container", 9);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("hidden", ctx2.element || ctx2.s.inputElement || !ctx2.s.selectElement || ctx2.s.display === "inline");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._showInput);
        ɵɵadvance();
        ɵɵproperty("activeElm", ctx2.s.activeElm)("anchor", ctx2._anchor)("anchorAlign", ctx2._anchorAlign)("animation", ctx2.s.animation)("ariaLabel", ctx2.s.ariaLabel)("buttons", ctx2._buttons)("cancelText", ctx2.s.cancelText)("closeOnEsc", ctx2.s.closeOnEsc)("closeOnOverlayClick", ctx2.s.closeOnOverlayClick)("closeOnScroll", ctx2.s.closeOnScroll)("closeText", ctx2.s.closeText)("contentPadding", false)("context", ctx2.s.context)("cssClass", ctx2._cssClass)("disableLeftRight", true)("display", ctx2.s.display)("focusElm", ctx2._focusElm)("focusOnClose", ctx2.s.focusOnClose)("focusOnOpen", !ctx2._allowTyping)("focusTrap", ctx2.s.focusTrap)("fullScreen", ctx2.s.fullScreen)("headerText", ctx2._headerText)("height", ctx2.s.height)("isOpen", ctx2._isOpen)("maxHeight", ctx2.s.maxHeight)("maxWidth", ctx2._maxWidth)("setText", ctx2.s.setText)("showArrow", ctx2.s.showArrow)("showOverlay", ctx2._allowTyping ? false : ctx2.s.showOverlay)("rtl", ctx2.s.rtl)("scrollLock", ctx2._scrollLock)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant)("touchUi", ctx2._touchUi)("windowWidth", ctx2.state.width)("width", ctx2.s.width);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._popup && ctx2._popup._isVisible || ctx2.s.display === "inline");
      }
    },
    dependencies: [MbscInput, MbscPopup, MbscIcon, MbscScroller, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  MbscSelect2 = __decorate([FormControl], MbscSelect2);
  return MbscSelect2;
}(MbscSelectBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSelect, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [MbscSelectOptionChangeService],
      selector: "mbsc-select",
      template
    }]
  }], null, {
    optionComponents: [{
      type: ContentChildren,
      args: [MbscSelectOptionComponent]
    }],
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    vDefInput: [{
      type: ViewChild,
      args: ["defaultInput", {
        static: false
      }]
    }],
    vFilter: [{
      type: ViewChild,
      args: ["filterInput", {
        static: false
      }]
    }],
    vPopup: [{
      type: ViewChild,
      args: ["popup", {
        static: false
      }]
    }]
  });
})();
var MbscSelectDirective = function(_super) {
  __extends(MbscSelectDirective2, _super);
  function MbscSelectDirective2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscSelectDirective2.prototype.reloadOptionElements = function() {
    if (this._inst) {
      this._inst.reloadOptionElements();
    }
  };
  MbscSelectDirective2.prototype._ctor = function() {
    this._cfr = this._injector.get(ComponentFactoryResolver$1);
    var s = this._injector.get(MbscSelectOptionChangeService);
    s.setInst(this);
  };
  MbscSelectDirective2.prototype._init = function() {
    var _this = this;
    var componentFactory = this._cfr.resolveComponentFactory(MbscSelect);
    this._ref = this._vcf.createComponent(componentFactory);
    this._inst = this._ref.instance;
    var inst = this._inst;
    var _loop_1 = function(prop2) {
      if (prop2 !== "onInit" && prop2 !== "onDestroy" && inst[prop2] instanceof EventEmitter) {
        inst[prop2].subscribe(function(args) {
          if (prop2 === "onClose") {
            _this._onFormTouch();
          }
          if (prop2 === "onChange") {
            _this.value = inst.value;
          }
          _this[prop2].emit(args);
        });
      }
    };
    for (var prop in inst) {
      _loop_1(prop);
    }
    _super.prototype._init.call(this);
  };
  MbscSelectDirective2.prototype._destroy = function() {
    _super.prototype._destroy.call(this);
    if (this._ref) {
      this._ref.destroy();
    }
  };
  MbscSelectDirective2.prototype._render = function(s, state) {
    var inst = this._ref.instance;
    inst.value = this.value;
    inst.props = s;
    inst.props.rows = this.props.rows;
    var el2 = this._elr.nativeElement;
    if (el2.nodeName.toLowerCase() === "select") {
      el2.style.display = "none";
      inst.props.selectElement = el2;
      if (s.inputElement) {
        inst.props.element = s.inputElement;
      }
    } else {
      inst.props.element = el2;
    }
    _super.prototype._render.call(this, s, state);
    inst.forceUpdate();
  };
  MbscSelectDirective2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSelectDirective_BaseFactory;
    return function MbscSelectDirective_Factory(__ngFactoryType__) {
      return (ɵMbscSelectDirective_BaseFactory || (ɵMbscSelectDirective_BaseFactory = ɵɵgetInheritedFactory(MbscSelectDirective2)))(__ngFactoryType__ || MbscSelectDirective2);
    };
  })();
  MbscSelectDirective2.ɵdir = ɵɵdefineDirective({
    type: MbscSelectDirective2,
    selectors: [["", "mbsc-select", ""]],
    inputs: {
      options: [0, "mbscOptions", "options"],
      inputElement: "inputElement"
    },
    exportAs: ["mobiscroll"],
    standalone: false,
    features: [ɵɵProvidersFeature([MbscSelectOptionChangeService]), ɵɵInheritDefinitionFeature]
  });
  return MbscSelectDirective2;
}(MbscSelectBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSelectDirective, [{
    type: Directive,
    args: [{
      exportAs: "mobiscroll",
      providers: [MbscSelectOptionChangeService],
      selector: "[mbsc-select]"
    }]
  }], null, {
    options: [{
      type: Input,
      args: ["mbscOptions"]
    }],
    inputElement: [{
      type: Input
    }]
  });
})();
var MbscSelectModule = function() {
  function MbscSelectModule2() {
  }
  MbscSelectModule2.ɵfac = function MbscSelectModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscSelectModule2)();
  };
  MbscSelectModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscSelectModule2,
    declarations: [SelectBase, MbscSelect, MbscSelectBase, MbscSelectDirective, MbscSelectOptionBase, MbscSelectOptionDirective, MbscSelectOptionComponent],
    imports: [CommonModule, FormsModule, MbscScrollerModule, MbscIconModule, MbscInputModule, MbscPopupModule],
    exports: [MbscSelect, MbscSelectDirective, MbscSelectOptionDirective, MbscSelectOptionComponent]
  });
  MbscSelectModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, FormsModule, MbscScrollerModule, MbscIconModule, MbscInputModule, MbscPopupModule]]
  });
  return MbscSelectModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSelectModule, [{
    type: NgModule,
    args: [{
      declarations: [SelectBase, MbscSelect, MbscSelectBase, MbscSelectDirective, MbscSelectOptionBase, MbscSelectOptionDirective, MbscSelectOptionComponent],
      entryComponents: [MbscSelect],
      exports: [MbscSelect, MbscSelectDirective, MbscSelectOptionDirective, MbscSelectOptionComponent],
      imports: [CommonModule, FormsModule, MbscScrollerModule, MbscIconModule, MbscInputModule, MbscPopupModule]
    }]
  }], null, null);
})();
var dragObservable = new Observable();
function subscribeExternalDrag(handler) {
  return dragObservable.subscribe(handler);
}
function unsubscribeExternalDrag(key) {
  dragObservable.unsubscribe(key);
}
function moveClone(ev, clone) {
  clone.style.left = ev.endX + "px";
  clone.style.top = ev.endY + "px";
}
var DraggableBase = function(_super) {
  __extends(DraggableBase2, _super);
  function DraggableBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DraggableBase2.prototype._render = function(s) {
    if (s.context !== this._prevS.context) {
      this._ctx = UNDEFINED;
    }
    if (s.dragData !== this._prevS.dragData) {
      this._dragData = isString(s.dragData) ? JSON.parse(s.dragData.toString()) : s.dragData;
    }
  };
  DraggableBase2.prototype._updated = function() {
    var _this = this;
    var el2 = this.s.element || this._el;
    var doc2 = getDocument(el2);
    var ctx2 = this._ctx;
    if (doc2 && !ctx2) {
      ctx2 = getContext(this.s.context, doc2);
      this._ctx = ctx2;
    }
    if (this._unlisten === UNDEFINED && el2 && ctx2) {
      el2.classList.add("mbsc-draggable");
      var clone_1;
      var isDrag_1;
      var touchTimer_1;
      this._unlisten = gestureListener(el2, {
        onEnd: function(ev) {
          if (isDrag_1) {
            var args = __assign({}, ev);
            args.domEvent.preventDefault();
            args.action = "externalDrop";
            args.dragData = _this._dragData;
            args.dragDataType = _this.s.type || "event";
            args.clone = clone_1;
            args.create = true;
            args.external = true;
            args.eventName = "onDragEnd";
            dragObservable.next(args);
            isDrag_1 = false;
            ctx2.removeChild(clone_1);
          }
          clearTimeout(touchTimer_1);
        },
        onMove: function(ev) {
          var args = __assign({}, ev);
          args.dragData = _this._dragData;
          args.dragDataType = _this.s.type || "event";
          args.clone = clone_1;
          args.create = true;
          args.external = true;
          if (isDrag_1 || !args.isTouch) {
            args.domEvent.preventDefault();
          }
          if (isDrag_1) {
            moveClone(ev, clone_1);
            args.eventName = "onDragMove";
            dragObservable.next(args);
          } else if (Math.abs(args.deltaX) > 7 || Math.abs(args.deltaY) > 7) {
            clearTimeout(touchTimer_1);
            if (!args.isTouch) {
              moveClone(ev, clone_1);
              ctx2.appendChild(clone_1);
              args.eventName = "onDragStart";
              dragObservable.next(args);
              isDrag_1 = true;
            }
          }
        },
        onStart: function(ev) {
          var args = __assign({}, ev);
          if (!isDrag_1) {
            clone_1 = el2.cloneNode(true);
            clone_1.classList.add("mbsc-drag-clone");
            args.dragData = _this._dragData;
            args.dragDataType = _this.s.type || "event";
            args.create = true;
            args.external = true;
            if (args.isTouch) {
              touchTimer_1 = setTimeout(function() {
                moveClone(ev, clone_1);
                ctx2.appendChild(clone_1);
                args.clone = clone_1;
                args.eventName = "onDragStart";
                dragObservable.next(args);
                args.eventName = "onDragModeOn";
                dragObservable.next(args);
                isDrag_1 = true;
              }, 350);
            }
          }
        }
      });
    }
  };
  DraggableBase2.prototype._destroy = function() {
    if (this._unlisten) {
      this._unlisten();
      this._unlisten = UNDEFINED;
    }
  };
  DraggableBase2._name = "Draggable";
  DraggableBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵDraggableBase_BaseFactory;
    return function DraggableBase_Factory(__ngFactoryType__) {
      return (ɵDraggableBase_BaseFactory || (ɵDraggableBase_BaseFactory = ɵɵgetInheritedFactory(DraggableBase2)))(__ngFactoryType__ || DraggableBase2);
    };
  })();
  DraggableBase2.ɵdir = ɵɵdefineDirective({
    type: DraggableBase2,
    selectors: [["", "mbsc-drag", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return DraggableBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-drag]"
    }]
  }], null, null);
})();
var uid = 1;
function getDataInRange(data, s, firstDay, lastDay, start, end) {
  var startDate = firstDay;
  var endDate = lastDay;
  var map2 = /* @__PURE__ */ new Map();
  var dataInRange = [];
  if (start) {
    startDate = makeDate(start, s);
  }
  if (end) {
    endDate = makeDate(end, s);
  } else if (start) {
    endDate = addDays(startDate, 1);
  }
  var events = getEventMap(data, startDate, endDate, s);
  for (var date in events) {
    if (date) {
      for (var _i = 0, _a = events[date]; _i < _a.length; _i++) {
        var event_1 = _a[_i];
        if (!event_1.start) {
          dataInRange.push(event_1);
        } else if (!map2.has(event_1)) {
          var eventStart = makeDate(event_1.start, s);
          var eventEnd = makeDate(event_1.end, s) || eventStart;
          if (event_1.allDay) {
            eventStart = createDate$1(s, eventStart.getFullYear(), eventStart.getMonth(), eventStart.getDate());
            eventEnd = getEndDate(s, true, eventStart, eventEnd);
            eventEnd = createDate$1(s, eventEnd.getFullYear(), eventEnd.getMonth(), eventEnd.getDate(), 23, 59, 59, 999);
          }
          if (checkDateRangeOverlap(startDate, endDate, eventStart, eventEnd)) {
            var eventCopy = __assign({}, event_1);
            if (s.dataTimezone || s.displayTimezone) {
              eventCopy.start = eventStart.toISOString();
              eventCopy.end = eventEnd.toISOString();
            }
            map2.set(event_1, true);
            dataInRange.push(eventCopy);
          }
        }
      }
    }
  }
  return dataInRange;
}
function getEventId() {
  return "mbsc_".concat(uid++);
}
function getEventData(s, event, eventDay, colorEvent, resource, slot, isList, isMultipart, isDailyResolution, skipLabels, fullDates) {
  var color = event.color || resource && resource.color;
  var st = event.start || event.date;
  var origStart = event.recurring ? event.original.start : event.start;
  var allDay = event.allDay || !origStart;
  var tzOpt = getTzOpt(s, event);
  var start = st ? makeDate(st, tzOpt) : null;
  var end = event.end ? makeDate(event.end, tzOpt) : null;
  var endDate = getEndDate(s, event.allDay, start, end, isList);
  var bufferStart = event.bufferBefore ? makeDate(+start - event.bufferBefore * 6e4, tzOpt) : null;
  var bufferEnd = event.bufferAfter ? makeDate(+endDate + event.bufferAfter * 6e4, tzOpt) : null;
  var isMultiDay = start && endDate && !isSameDay(start, endDate);
  var isFirstDay = isMultiDay ? isSameDay(start, eventDay) : true;
  var isLastDay = isMultiDay ? isSameDay(endDate, eventDay) : true;
  var fillsAllDay = !fullDates && (allDay || isMultipart && isMultiDay && !isFirstDay && !isLastDay);
  var startTime = "";
  var endTime = "";
  if (!skipLabels) {
    if (fullDates) {
      var dateTimeFormat = s.dateFormat + (allDay ? "" : s.separator + s.timeFormat);
      startTime = start ? formatDate(dateTimeFormat, start, s) : "";
      endTime = end ? formatDate(dateTimeFormat, allDay ? endDate : end, s) : "";
    } else if (!isMultipart && !isDailyResolution) {
      startTime = start ? formatDate(s.dateFormat, start, s) : "";
      endTime = end ? formatDate(s.dateFormat, endDate, s) : "";
    } else if (!allDay) {
      startTime = start ? formatDate(s.timeFormat, start, s) : "";
      endTime = end ? formatDate(s.timeFormat, end, s) : "";
    }
  }
  var eventStart = !fillsAllDay && (isFirstDay || !isMultipart || fullDates) ? startTime : "";
  var eventEnd = !fillsAllDay && (isLastDay || !isMultipart || fullDates) ? endTime : "";
  var html = event.title || event.text || "";
  var title = html;
  var tooltip = title + (fillsAllDay ? "" : ", " + eventStart + " - " + eventEnd);
  var format = s.dateFormatFull;
  var startStr = !skipLabels && start ? ", " + s.fromText + ": " + formatDate(format, start, s) + (allDay ? "" : ", " + startTime) : "";
  var endStr = !skipLabels && end ? ", " + s.toText + ": " + formatDate(format, end, s) + (allDay ? "" : ", " + endTime) : "";
  var resourceStr = resource && resource.name ? ", " + resource.name : "";
  return {
    allDay,
    allDayText: fillsAllDay ? s.allDayText : "",
    ariaLabel: title + resourceStr + startStr + endStr,
    bufferEnd,
    bufferStart,
    color,
    currentResource: resource,
    currentSlot: slot,
    date: +eventDay,
    end: eventEnd,
    endDate: end ? end : start ? new Date(start) : null,
    html,
    id: event.id,
    isMultiDay,
    lastDay: !fillsAllDay && isMultiDay && isLastDay ? s.toText : "",
    original: event,
    position: {},
    resource: event.resource,
    slot: event.slot,
    start: eventStart,
    startDate: start,
    style: {
      background: color,
      color: colorEvent && color ? getTextColor(color) : ""
    },
    title,
    tooltip: s.showEventTooltip ? event.tooltip || tooltip : UNDEFINED,
    uid: event.occurrenceId ? event.occurrenceId : event.id
  };
}
function prepareEvents(events) {
  var data = [];
  if (events) {
    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
      var event_2 = events_1[_i];
      if (event_2.id === UNDEFINED) {
        event_2.id = getEventId();
      }
      data.push(event_2);
    }
  }
  return data;
}
function checkInvalidCollision(s, invalids, valids, start, end, min, max, invalidateEvent, exclusiveEndDates) {
  if (invalidateEvent === "start-end") {
    var invalidStart = isInvalid(s, start, invalids, valids, min, max);
    var invalidEnd = isInvalid(s, end, invalids, valids, min, max);
    if (invalidStart) {
      return invalidStart;
    }
    if (invalidEnd) {
      return invalidEnd;
    }
  } else {
    var until = exclusiveEndDates ? end : getDateOnly(addDays(end, 1));
    for (var d = getDateOnly(start); d < until; d.setDate(d.getDate() + 1)) {
      var invalid = isInvalid(s, d, invalids, valids, min, max);
      if (invalid) {
        return invalid;
      }
    }
  }
  return false;
}
function checkOverlap(event, start, end, eventMap, exactDisplay, s) {
  var until = s.exclusiveEndDates ? end : getDateOnly(addDays(end, 1));
  for (var d = getDateOnly(start); d < until; d.setDate(d.getDate() + 1)) {
    var dayEvents = (eventMap[getDateStr(d)] || []).filter(function(e) {
      return e.id !== event.id;
    });
    var shouldCheckOverlap = s.eventOverlap === false || event.overlap === false;
    var allDay = event.allDay || !event.start;
    var isExact = exactDisplay && !allDay;
    if (dayEvents.length) {
      if (shouldCheckOverlap && !isExact) {
        return dayEvents[0];
      }
      for (var _i = 0, dayEvents_1 = dayEvents; _i < dayEvents_1.length; _i++) {
        var item = dayEvents_1[_i];
        if (shouldCheckOverlap || item.overlap === false) {
          if (isExact && item.start && !item.allDay) {
            var itemStart = makeDate(item.start, s);
            var itemEnd = item.end ? makeDate(item.end, s) : itemStart;
            if (itemStart < end && itemEnd > start) {
              return item;
            }
          } else {
            return item;
          }
        }
      }
    }
  }
  return false;
}
var EventcalendarBase = function(_super) {
  __extends(EventcalendarBase2, _super);
  function EventcalendarBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.print = noop;
    _this._checkSize = 0;
    _this._navService = new MbscCalendarNavService();
    _this._pageLoad = 0;
    _this._selectedDates = {};
    _this._shouldScrollSchedule = 0;
    _this._update = 0;
    _this._onScroll = throttle(function() {
      if (!_this._isListScrolling && !_this._viewChanged) {
        for (var timestamp in _this._listDays) {
          if (_this._listDays[timestamp]) {
            var day = _this._listDays[timestamp];
            var bottom = day.offsetTop + day.offsetHeight - _this._list.scrollTop;
            if (bottom > 0) {
              if (+timestamp !== _this._selected) {
                _this._shouldSkipScroll = true;
                _this._selectedChange(+timestamp, true);
              }
              break;
            }
          }
        }
      }
    });
    _this._isListScrolling = 0;
    _this._remote = 0;
    _this._tempViewChanged = false;
    _this._onWeekDayClick = function(d) {
      if (d !== _this._selected) {
        _this._skipScheduleScroll = true;
        _this._selectedChange(d, true);
      }
    };
    _this._onDayClick = function(args) {
      var date = args.date;
      var d = +date;
      var key = getDateStr(date);
      var events = sortEvents(_this._eventMap[key], _this.s);
      var showEventPopover = _this._showEventPopover;
      var computed = showEventPopover === UNDEFINED ? !_this._showEventLabels && !_this._showEventList && !_this._showSchedule : showEventPopover;
      var showMore = showEventPopover !== false && _this._moreLabelClicked;
      var showPopover = (computed || showMore) && events && events.length > 0;
      args.events = events;
      if (!_this._isEventClick) {
        _this._resetSelection();
      }
      _this._hook("onCellClick", args);
      _this._moreLabelClicked = false;
      if (!args.disabled && d !== _this._selected) {
        _this._navService.preventPageChange = !_this._showEventList;
        _this._skipScheduleScroll = true;
        _this._selectedChange(d, true);
      }
      if (showPopover) {
        _this._showPopover(d, d, events.map(function(event) {
          return _this._getEventData(event, date);
        }), args.target);
      }
      _this._isEventClick = false;
    };
    _this._onActiveChange = function(args) {
      if (args.scroll) {
        _this._viewDate = +args.date;
        _this._viewMiddleDate = +args.middleDate;
        return;
      }
      var d = _this._getValidDay(args.date, args.dir);
      var newState = {
        activeDate: d
      };
      _this._active = d;
      _this._viewDate = d;
      _this._update++;
      _this._skipScheduleScroll = args.pageChange && !args.nav;
      if (args.pageChange || args.today) {
        newState.selectedDate = d;
        _this._selectedChange(d, true, true);
        _this._navService.forcePageChange = true;
      }
      if (args.pageChange) {
        _this._shouldAnimateScroll = false;
      }
      _this.setState(newState);
    };
    _this._onGestureStart = function(args) {
      _this._hidePopover();
    };
    _this._onDayDoubleClick = function(args) {
      _this._dayClick("onCellDoubleClick", args);
    };
    _this._onDayRightClick = function(args) {
      _this._dayClick("onCellRightClick", args);
    };
    _this._onCellHoverIn = function(args) {
      args.events = _this._eventMap[getDateStr(args.date)];
      _this._hook("onCellHoverIn", args);
    };
    _this._onCellHoverOut = function(args) {
      args.events = _this._eventMap[getDateStr(args.date)];
      _this._hook("onCellHoverOut", args);
    };
    _this._onEventHoverIn = function(args) {
      _this._hoverTimer = setTimeout(function() {
        _this._isHover = true;
        _this._eventClick("onEventHoverIn", args);
      }, 150);
    };
    _this._onEventHoverOut = function(args) {
      clearTimeout(_this._hoverTimer);
      if (_this._isHover) {
        _this._isHover = false;
        _this._eventClick("onEventHoverOut", args);
      }
    };
    _this._onEventClick = function(args) {
      var s = _this.s;
      _this._handleMultipleSelect(args);
      var close2 = _this._eventClick("onEventClick", args);
      if (close2 !== false && !(s.selectMultipleEvents || s.eventDelete || (s.dragToCreate || s.clickToCreate) && s.eventDelete !== false)) {
        _this._hidePopover();
      }
    };
    _this._onEventDoubleClick = function(args) {
      _this._eventClick("onEventDoubleClick", args);
    };
    _this._onEventRightClick = function(args) {
      _this._eventClick("onEventRightClick", args);
    };
    _this._onEventDragEnd = function(args) {
      _this._hook("onEventDragEnd", args);
    };
    _this._onEventDragStart = function(args) {
      _this._hook("onEventDragStart", args);
    };
    _this._onEventDragEnter = function(args) {
      _this._hook("onEventDragEnter", args);
    };
    _this._onEventDragLeave = function(args) {
      _this._hook("onEventDragLeave", args);
    };
    _this._onLabelHoverIn = function(args) {
      _this._hoverTimer = setTimeout(function() {
        _this._isHover = true;
        _this._labelClick("onEventHoverIn", args);
      }, 150);
    };
    _this._onLabelHoverOut = function(args) {
      clearTimeout(_this._hoverTimer);
      if (_this._isHover) {
        _this._isHover = false;
        _this._labelClick("onEventHoverOut", args);
      }
    };
    _this._onLabelClick = function(args) {
      _this._handleMultipleSelect(args);
      _this._hook("onLabelClick", args);
      _this._labelClick("onEventClick", args);
      _this._isEventClick = true;
      if (!args.label) {
        _this._moreLabelClicked = true;
      }
    };
    _this._onLabelDoubleClick = function(args) {
      _this._labelClick("onEventDoubleClick", args);
    };
    _this._onLabelRightClick = function(args) {
      _this._labelClick("onEventRightClick", args);
    };
    _this._onCellClick = function(args) {
      _this._resetSelection();
      _this._cellClick("onCellClick", args);
    };
    _this._onCellDoubleClick = function(args) {
      _this._cellClick("onCellDoubleClick", args);
    };
    _this._onCellRightClick = function(args) {
      _this._cellClick("onCellRightClick", args);
    };
    _this._proxy = function(args) {
      return _this._hook(args.type, args);
    };
    _this._onPageChange = function(args) {
      setTimeout(function() {
        _this._hidePopover();
      });
      _this._hook("onPageChange", args);
    };
    _this._onPageLoading = function(args) {
      var s = _this.s;
      var isList = _this._showCalendar && !_this._eventExact;
      var eventMap = getEventMap(_this._events, args.viewStart, args.viewEnd, s, false, isList);
      _this._colorsMap = getEventMap(s.colors, args.viewStart, args.viewEnd, s);
      _this._invalidsMap = getEventMap(s.invalid, args.viewStart, args.viewEnd, s, true);
      _this._validsMap = getEventMap(s.valid, args.viewStart, args.viewEnd, s, true);
      _this._eventMap = eventMap;
      _this._firstDay = getFirstDayOfWeek(args.firstDay, s, _this._firstWeekDay);
      _this._lastDay = args.lastDay;
      _this._isListLoaded = false;
      _this._labelsMap = _this._marksMap = UNDEFINED;
      if (!s.labels && (_this._showEventLabels || _this._showEventCount)) {
        _this._labelsMap = eventMap;
      } else if (!s.marked) {
        _this._marksMap = eventMap;
      }
      if (args.viewChanged) {
        _this._hook("onPageLoading", args);
      }
    };
    _this._onPageLoaded = function(args) {
      var viewType = _this._eventListType;
      if (_this._showEventList && !(_this._showCalendar && viewType === "day")) {
        var s = _this.s;
        var month = args.month;
        var isMonthList = _this._showEventList && month && viewType === "month";
        var firstDay = isMonthList ? month : args.firstDay;
        var lastDay = isMonthList ? s.getDate(s.getYear(month), s.getMonth(month) + _this._eventListSize, 1) : args.lastDay;
        _this._setEventList(firstDay, lastDay);
      }
      _this._hook("onPageLoaded", args);
    };
    _this._onMoreClick = function(args) {
      _this._showPopover(args.key, +args.date, args.list.map(function(event) {
        return _this._getEventData(event.original, new Date(args.date), event.currentResource, event.currentSlot, true);
      }), args.target, args.context, args.inst);
    };
    _this._onPopoverClose = function(args) {
      var state = _this.state;
      if (state.popoverHost && args.source === "dragStart") {
        _this.setState({
          popoverDrag: true,
          popoverHidden: true
        });
      } else if (!state.popoverHost || args.source !== "scroll" || !state.popoverDrag) {
        _this._hidePopover();
      }
    };
    _this._onResize = function(ev) {
      var isListScrollable;
      if (_this._showEventList && isBrowser) {
        var cal = ev.target;
        var height = cal.offsetHeight;
        var calTop = cal.getBoundingClientRect().top;
        var listTop = _this._list.getBoundingClientRect().top;
        isListScrollable = height - listTop + calTop > 170;
      }
      _this.setState({
        height: ev.height,
        isListScrollable,
        width: ev.width
      });
    };
    _this._onSelectedEventsChange = function(events) {
      _this._emit("selectedEventsChange", events);
      _this._hook("onSelectedEventsChange", {
        events
      });
    };
    _this._getDragDates = function(start, end, event) {
      var s = _this.s;
      var draggedDates = {};
      var firstWeekDay = _this._firstWeekDay;
      var isExact = _this._eventExact && !event.allDay;
      var endDate = getEndDate(s, event.allDay, start, end, !isExact);
      var until = getDateOnly(addDays(endDate, 1));
      for (var d = getDateOnly(start); d < until; d.setDate(d.getDate() + 1)) {
        var weekDay = d.getDay();
        var offset = firstWeekDay - weekDay > 0 ? 7 : 0;
        if (isSameDay(start, d) || weekDay === firstWeekDay) {
          var daysNr = getDayDiff(d, endDate) + 1;
          var daysUntilRowEnd = 7 + firstWeekDay - weekDay - offset;
          var startOffset = isExact && isSameDay(start, d) ? getDayMilliseconds(start) / ONE_DAY * 100 : 0;
          var endOffset = isExact && daysNr <= daysUntilRowEnd ? 100 - (getDayMilliseconds(endDate) + 1) / ONE_DAY * 100 : 0;
          draggedDates[getDateStr(d)] = {
            event,
            id: 0,
            isExact,
            position: {
              left: (s.rtl ? UNDEFINED : startOffset) + "%",
              right: (s.rtl ? startOffset : UNDEFINED) + "%",
              width: Math.min(daysNr, daysUntilRowEnd) * 100 - startOffset - endOffset + "%"
            }
          };
        } else {
          draggedDates[getDateStr(d)] = {
            id: 0
          };
        }
      }
      return draggedDates;
    };
    _this._onLabelUpdateModeOn = function(args) {
      var event = args.create ? _this._tempEvent : args.event;
      var start = makeDate(event.start);
      var end = makeDate(event.end || start);
      _this.setState({
        isTouchDrag: true,
        labelDragData: {
          draggedEvent: event,
          originDates: args.external ? UNDEFINED : _this._getDragDates(start, end, event)
        }
      });
    };
    _this._onLabelUpdateModeOff = function(args) {
      _this._hook("onEventDragEnd", {
        domEvent: args.domEvent,
        event: args.create ? _this._tempEvent : args.event,
        source: "calendar"
      });
      _this.setState({
        isTouchDrag: false,
        labelDragData: UNDEFINED
      });
    };
    _this._onLabelUpdateStart = function(args) {
      var s = _this.s;
      var el2 = _this._el;
      if (s.externalDrag && args.drag && !args.create) {
        var eventEl = args.target;
        if (eventEl) {
          var clone = eventEl.cloneNode(true);
          var cloneClass = clone.classList;
          clone.style.display = "none";
          cloneClass.add("mbsc-drag-clone", "mbsc-schedule-drag-clone", "mbsc-font");
          cloneClass.remove("mbsc-calendar-label-hover", "mbsc-focus", "mbsc-active");
          _this._clone = clone;
          _this._ctx = getContext(s.context, getDocument(el2));
          _this._ctx.appendChild(clone);
          _this._eventDropped = false;
          dragObservable.next(__assign(__assign({}, args), {
            clone,
            create: true,
            dragData: args.event,
            eventName: "onDragStart",
            external: true,
            from: _this
          }));
        }
      }
      var weekNumWidth = _this._showWeekNumbers ? el2.querySelector(".mbsc-calendar-week-nr").getBoundingClientRect().width : 0;
      var slide = el2.querySelectorAll(".mbsc-calendar-slide-active")[0];
      var slideRect = slide.getBoundingClientRect();
      var weeksCont = el2.querySelector(".mbsc-calendar-week-days");
      var rows = slide.querySelectorAll(".mbsc-calendar-row");
      var isClick = /click/.test(args.domEvent.type);
      _this._areaTop = 0;
      if (weeksCont) {
        var weeksRect = weeksCont.getBoundingClientRect();
        _this._areaTop = weeksRect.top + weeksRect.height;
      }
      _this._areaLeft = slideRect.left + (s.rtl ? 0 : weekNumWidth);
      _this._areaBottom = slideRect.top + slideRect.height;
      _this._areaRight = _this._areaLeft + slideRect.width - (s.rtl ? weekNumWidth : 0);
      _this._calCellWidth = (_this._areaRight - _this._areaLeft) / 7;
      var newWeek = 0;
      _this._rowTops = [];
      rows.forEach(function(r, i) {
        var rowTop = r.getBoundingClientRect().top - _this._areaTop;
        _this._rowTops.push(rowTop);
        if (args.endY - _this._areaTop > rowTop) {
          newWeek = i;
        }
      });
      if (args.create) {
        var newDay = floor((s.rtl ? _this._areaRight - args.endX : args.endX - _this._areaLeft) / _this._calCellWidth);
        var newStartDay = addDays(_this._firstDay, newWeek * 7 + newDay);
        var newStart = new Date(newStartDay.getFullYear(), newStartDay.getMonth(), newStartDay.getDate());
        var nextDay = addDays(newStart, 1);
        var newEnd = s.exclusiveEndDates ? nextDay : new Date(+nextDay - 1);
        var eventData = s.extendDefaultEvent ? s.extendDefaultEvent({
          start: newStart
        }) : UNDEFINED;
        _this._tempEvent = __assign(__assign({
          allDay: !_this._eventExact,
          end: newEnd,
          id: getEventId(),
          start: newStart,
          title: s.newEventText
        }, eventData), args.dragData);
      }
      if (!isClick) {
        _this._hook("onEventDragStart", {
          action: args.create ? "create" : args.resize ? "resize" : "move",
          domEvent: args.domEvent,
          event: args.create ? _this._tempEvent : args.event,
          source: "calendar"
        });
      }
    };
    _this._onLabelUpdateMove = function(args) {
      var s = _this.s;
      var event = args.create ? _this._tempEvent : args.event;
      var draggedEvent = __assign({}, event);
      var labelDragData = _this.state.labelDragData;
      var tzOpt = event.allDay ? UNDEFINED : s;
      if (s.externalDrag && args.drag && !args.create && _this._clone) {
        dragObservable.next(__assign(__assign({}, args), {
          clone: _this._clone,
          create: true,
          dragData: args.event,
          eventName: "onDragMove",
          external: true,
          from: _this
        }));
        if (!_this._onCalendar) {
          moveClone(args, _this._clone);
          if (!labelDragData || !labelDragData.draggedEvent) {
            _this.setState({
              labelDragData: {
                draggedEvent
              },
              popoverHidden: true
            });
          }
          return;
        }
      }
      if (args.endY > _this._areaTop && args.endY < _this._areaBottom && args.endX > _this._areaLeft && args.endX < _this._areaRight) {
        var newDay = floor((s.rtl ? _this._areaRight - args.endX : args.endX - _this._areaLeft) / _this._calCellWidth);
        var oldDay = floor((s.rtl ? _this._areaRight - args.startX : args.startX - _this._areaLeft) / _this._calCellWidth);
        var newWeek_1 = 0;
        var oldWeek_1 = 0;
        _this._rowTops.forEach(function(rowTop, i) {
          if (args.startY - _this._areaTop > rowTop) {
            oldWeek_1 = i;
          }
          if (args.endY - _this._areaTop > rowTop) {
            newWeek_1 = i;
          }
        });
        var dayDelta = (newWeek_1 - oldWeek_1) * 7 + (newDay - oldDay);
        if (newDay !== _this._tempDay || newWeek_1 !== _this._tempWeek) {
          var start = makeDate(event.start, tzOpt);
          var end = makeDate(event.end, tzOpt) || start;
          var isEventDraggableInTime = computeEventDragInTime(event.dragInTime, UNDEFINED, s.dragInTime);
          var newStart = start;
          var newEnd = end;
          if (args.external) {
            var ms = getDayMilliseconds(start);
            var duration = +end - +start;
            if (isEventDraggableInTime) {
              newStart = createDate$1(s, +addDays(_this._firstDay, newWeek_1 * 7 + newDay) + ms);
              newEnd = createDate$1(s, +newStart + duration);
            }
          } else if (args.drag) {
            if (!isEventDraggableInTime) {
              return;
            }
            newStart = addDays(start, dayDelta);
            newEnd = addDays(end, dayDelta);
          } else {
            var rtl = s.rtl ? -1 : 1;
            var endResize = args.create ? newWeek_1 === oldWeek_1 ? args.deltaX * rtl > 0 : dayDelta > 0 : args.direction === "end";
            var days = getDayDiff(start, end);
            if (endResize) {
              newEnd = addDays(end, Math.max(-days, dayDelta));
            } else {
              newStart = addDays(start, Math.min(days, dayDelta));
            }
            if (newEnd <= newStart) {
              var dragEvent = labelDragData ? labelDragData.draggedEvent : draggedEvent;
              if (endResize) {
                newEnd = createDate$1(tzOpt, _this._eventExact ? dragEvent.end : newStart);
              } else {
                newStart = createDate$1(tzOpt, _this._eventExact ? dragEvent.start : newEnd);
              }
            }
          }
          draggedEvent.start = newStart;
          draggedEvent.end = newEnd;
          _this.setState({
            labelDragData: {
              draggedDates: _this._getDragDates(newStart, newEnd, draggedEvent),
              draggedEvent,
              originDates: labelDragData && labelDragData.originDates
            },
            popoverHidden: true
          });
          _this._tempDay = newDay;
          _this._tempWeek = newWeek_1;
        }
      }
    };
    _this._onLabelUpdateEnd = function(args) {
      var s = _this.s;
      var state = _this.state;
      var isCreating = args.create;
      var dragData = state.labelDragData || {};
      var event = isCreating ? _this._tempEvent : args.event;
      var draggedEvent = dragData.draggedEvent || event;
      var origStart = makeDate(event.start);
      var origEnd = makeDate(event.end);
      var newStart = makeDate(draggedEvent.start);
      var newEnd = makeDate(draggedEvent.end);
      var changed = isCreating || +origStart !== +newStart || +origEnd !== +newEnd;
      var draggedEventData = {
        allDay: event.allDay,
        endDate: newEnd,
        original: event,
        startDate: newStart
      };
      var eventLeft = false;
      if (s.externalDrag && args.drag && !args.create && _this._clone) {
        dragObservable.next(__assign(__assign({}, args), {
          action: "externalDrop",
          clone: _this._clone,
          create: true,
          dragData: args.event,
          eventName: "onDragEnd",
          external: true,
          from: _this
        }));
        _this._ctx.removeChild(_this._clone);
        _this._clone = UNDEFINED;
        if (!_this._onCalendar) {
          eventLeft = true;
          if (_this._eventDropped) {
            _this._onEventDelete(args);
          }
        }
      }
      var action = args.action || (dragData.draggedEvent ? "drag" : "click");
      var allowUpdate = !eventLeft && (changed ? _this._onEventDragStop({
        action,
        collision: checkInvalidCollision(s, _this._invalidsMap, _this._validsMap, newStart, newEnd, _this._minDate, _this._maxDate, s.invalidateEvent, s.exclusiveEndDates),
        create: isCreating,
        domEvent: args.domEvent,
        event: draggedEventData,
        external: args.external,
        from: args.from,
        overlap: checkOverlap(event, newStart, newEnd, _this._eventMap, _this._eventExact, s),
        source: "calendar"
      }) : true);
      var keepDragMode = state.isTouchDrag && !eventLeft && (!isCreating || allowUpdate);
      if (!keepDragMode && action !== "click") {
        _this._hook("onEventDragEnd", {
          domEvent: args.domEvent,
          event,
          source: "calendar"
        });
      }
      _this.setState({
        isTouchDrag: keepDragMode,
        labelDragData: keepDragMode ? {
          draggedEvent: allowUpdate ? draggedEvent : __assign({}, event),
          originDates: allowUpdate ? _this._getDragDates(newStart, newEnd, draggedEventData.original) : dragData.originDates
        } : {}
      });
      if (args.drag) {
        _this._hidePopover();
      }
      _this._tempWeek = -1;
      _this._tempDay = -1;
    };
    _this._onEventDragStop = function(args) {
      var s = _this.s;
      var action = args.action;
      var resource = args.resource;
      var slot = args.slot;
      var invalidCollision = args.collision;
      var overlapCollision = args.overlap;
      var isCreating = args.create;
      var source = args.source;
      var draggedEvent = args.event;
      var event = draggedEvent.original;
      var orig = event.recurring ? event.original : event;
      var originalEvent = s.immutableData ? __assign({}, orig) : orig;
      var oldEvent = __assign({}, originalEvent);
      var eventCopy = __assign({}, originalEvent);
      var eventTz = event.timezone;
      var origStart = convertTimezone(event.start, s, eventTz);
      var start = convertTimezone(draggedEvent.startDate, s, eventTz);
      var end = convertTimezone(draggedEvent.endDate, s, eventTz);
      var allDay = draggedEvent.allDay;
      var isRecurring = eventCopy.recurring;
      if (isRecurring) {
        eventCopy.recurringException = __spreadArray(__spreadArray([], getExceptionList(eventCopy.recurringException), true), [origStart], false);
      } else {
        eventCopy.allDay = allDay;
        eventCopy.start = start;
        eventCopy.end = end;
        if (resource !== UNDEFINED) {
          eventCopy.resource = resource;
        }
        if (slot !== UNDEFINED) {
          eventCopy.slot = slot;
        }
      }
      var allowUpdate = false;
      var newEvent = isRecurring ? __assign({}, originalEvent) : originalEvent;
      if (isCreating || isRecurring) {
        if (isRecurring) {
          delete newEvent.recurring;
        }
        if (isRecurring || newEvent.id === UNDEFINED) {
          newEvent.id = getEventId();
        }
        if (resource !== UNDEFINED) {
          newEvent.resource = resource;
        }
        if (slot !== UNDEFINED) {
          newEvent.slot = slot;
        }
        newEvent.start = start;
        newEvent.end = end;
        newEvent.allDay = allDay;
        allowUpdate = _this._hook("onEventCreate", __assign({
          action,
          domEvent: args.domEvent,
          event: newEvent,
          resourceObj: args.resourceObj,
          slotObj: args.slotObj,
          source
        }, isRecurring && {
          originEvent: event
        })) !== false;
        if (invalidCollision !== false || overlapCollision !== false) {
          allowUpdate = false;
          _this._hook("onEventCreateFailed", __assign({
            action,
            event: newEvent,
            invalid: invalidCollision,
            overlap: overlapCollision,
            source
          }, isRecurring && {
            originEvent: event
          }));
        }
      }
      if ((!isCreating || isRecurring) && !args.external) {
        allowUpdate = _this._hook("onEventUpdate", __assign({
          domEvent: args.domEvent,
          event: eventCopy,
          oldEvent,
          oldResource: args.oldResource,
          oldResourceObj: args.oldResourceObj,
          oldSlot: args.oldSlot,
          oldSlotObj: args.oldSlotObj,
          resource: args.newResource,
          resourceObj: args.resourceObj,
          slot: args.newSlot,
          slotObj: args.slotObj,
          source
        }, isRecurring && {
          newEvent,
          oldEventOccurrence: event
        })) !== false;
        if (invalidCollision !== false || overlapCollision !== false) {
          allowUpdate = false;
          _this._hook("onEventUpdateFailed", __assign({
            event: eventCopy,
            invalid: invalidCollision,
            oldEvent,
            overlap: overlapCollision,
            source
          }, isRecurring && {
            newEvent,
            oldEventOccurrence: event
          }));
        }
      }
      if (allowUpdate) {
        if (args.from) {
          args.from._eventDropped = true;
        }
        if (isCreating || isRecurring) {
          _this._events.push(newEvent);
          _this._triggerCreated = {
            action,
            event: newEvent,
            resourceObj: args.resourceObj,
            slotObj: args.slotObj,
            source
          };
        }
        if (!isCreating || isRecurring) {
          if (isRecurring) {
            draggedEvent.id = newEvent.id;
            draggedEvent.original = newEvent;
            originalEvent.recurringException = eventCopy.recurringException;
          } else {
            originalEvent.start = start;
            originalEvent.end = end;
            originalEvent.allDay = allDay;
            if (resource !== UNDEFINED) {
              originalEvent.resource = resource;
            }
            if (slot !== UNDEFINED) {
              originalEvent.slot = slot;
            }
          }
          _this._triggerUpdated = {
            event: originalEvent,
            oldEvent,
            resourceObj: args.resourceObj,
            slotObj: args.slotObj,
            source
          };
        }
        _this._refresh = true;
        if (source !== "calendar") {
          _this.forceUpdate();
        }
      } else {
        _this._hidePopover();
      }
      return allowUpdate;
    };
    _this._onExternalDrag = function(args) {
      var s = _this.s;
      var clone = args.clone;
      var isSelf = args.from === _this;
      var externalDrop = !isSelf && s.externalDrop;
      var instantDrag = isSelf && s.externalDrag && !s.dragToMove;
      var dragData = _this.state.labelDragData;
      if (_this._showCalendar && (externalDrop || s.externalDrag)) {
        var isInArea = !instantDrag && args.endY > _this._areaTop && args.endY < _this._areaBottom && args.endX > _this._areaLeft && args.endX < _this._areaRight;
        switch (args.eventName) {
          case "onDragModeOff":
            if (externalDrop) {
              _this._onLabelUpdateModeOff(args);
            }
            break;
          case "onDragModeOn":
            if (externalDrop) {
              _this._onLabelUpdateModeOn(args);
            }
            break;
          case "onDragStart":
            if (externalDrop) {
              _this._onLabelUpdateStart(args);
            } else if (isSelf) {
              _this._onCalendar = true;
            }
            break;
          case "onDragMove":
            if (!isSelf && !externalDrop) {
              return;
            }
            if (isInArea) {
              if (!_this._onCalendar) {
                _this._hook("onEventDragEnter", {
                  domEvent: args.domEvent,
                  event: args.dragData,
                  source: "calendar"
                });
              }
              if (isSelf || externalDrop) {
                clone.style.display = "none";
              }
              if (externalDrop) {
                _this._onLabelUpdateMove(args);
              }
              _this._onCalendar = true;
            } else if (_this._onCalendar) {
              _this._hook("onEventDragLeave", {
                domEvent: args.domEvent,
                event: args.dragData,
                source: "calendar"
              });
              clone.style.display = "";
              if (!isSelf || dragData && dragData.draggedEvent) {
                _this.setState({
                  labelDragData: {
                    draggedDates: {},
                    draggedEvent: isSelf ? dragData && dragData.draggedEvent : UNDEFINED,
                    originDates: isSelf ? dragData && dragData.originDates : UNDEFINED
                  }
                });
              }
              _this._tempWeek = -1;
              _this._tempDay = -1;
              _this._onCalendar = false;
            }
            break;
          case "onDragEnd":
            if (externalDrop) {
              if (!isInArea) {
                _this.setState({
                  labelDragData: UNDEFINED
                });
                _this._hook("onEventDragEnd", {
                  domEvent: args.domEvent,
                  event: args.dragData,
                  source: "calendar"
                });
              } else {
                _this._onLabelUpdateEnd(args);
              }
            }
            break;
        }
      }
    };
    _this._onEventDelete = function(args) {
      var _a;
      var s = _this.s;
      if (s.eventDelete === UNDEFINED && !s.dragToCreate && !s.clickToCreate || s.eventDelete === false) {
        return;
      }
      var changed = false;
      var hasRecurring = false;
      var hasNonRecurring = false;
      var originalEvent;
      var oldEvent;
      var eventCopy;
      var event = args.event;
      var occurrence = event;
      var isMultiple = s.selectMultipleEvents;
      var selectedEventsMap = isMultiple ? _this._selectedEventsMap : (_a = {}, _a[event.id] = event, _a);
      var selectedEvents = toArray(selectedEventsMap);
      var oldEvents = [];
      var recurringEvents = [];
      var updatedEvents = [];
      var updatedEventsMap = {};
      var events = [];
      for (var _i = 0, selectedEvents_1 = selectedEvents; _i < selectedEvents_1.length; _i++) {
        var selectedEvent = selectedEvents_1[_i];
        if (selectedEvent.recurring) {
          occurrence = selectedEvent;
          originalEvent = selectedEvent.original;
          hasRecurring = true;
          var id2 = originalEvent.id;
          if (updatedEventsMap[id2]) {
            eventCopy = updatedEventsMap[id2];
          } else {
            oldEvent = __assign({}, originalEvent);
            eventCopy = __assign({}, originalEvent);
            recurringEvents.push(originalEvent);
            oldEvents.push(oldEvent);
            updatedEvents.push(eventCopy);
            updatedEventsMap[id2] = eventCopy;
          }
          var origStart = convertTimezone(selectedEvent.start, s);
          eventCopy.recurringException = __spreadArray(__spreadArray([], getExceptionList(eventCopy.recurringException), true), [origStart], false);
        } else {
          hasNonRecurring = true;
          event = selectedEvent;
          events.push(selectedEvent);
        }
      }
      if (hasRecurring) {
        var allowUpdate = _this._hook("onEventUpdate", {
          domEvent: args.domEvent,
          event: eventCopy,
          events: isMultiple ? updatedEvents : UNDEFINED,
          isDelete: true,
          oldEvent: isMultiple ? UNDEFINED : oldEvent,
          oldEventOccurrence: occurrence,
          oldEvents: isMultiple ? oldEvents : UNDEFINED,
          oldResource: args.resource,
          oldResourceObj: args.resourceObj,
          oldSlot: args.slot,
          oldSlotObj: args.oldSlotObj,
          resource: args.resource,
          resourceObj: args.resourceObj,
          slot: args.slot,
          slotObj: args.slotObj,
          source: args.source
        }) !== false;
        if (allowUpdate) {
          changed = true;
          for (var _b = 0, recurringEvents_1 = recurringEvents; _b < recurringEvents_1.length; _b++) {
            var recurringEvent = recurringEvents_1[_b];
            var updatedEvent = updatedEventsMap[recurringEvent.id];
            recurringEvent.recurringException = updatedEvent.recurringException;
          }
          _this._triggerUpdated = {
            event: originalEvent,
            events: isMultiple ? recurringEvents : UNDEFINED,
            oldEvent: isMultiple ? UNDEFINED : oldEvent,
            oldEvents: isMultiple ? oldEvents : UNDEFINED,
            resourceObj: args.resourceObj,
            slotObj: args.slotObj,
            source: args.source
          };
        }
      }
      if (hasNonRecurring) {
        var allowDelete = _this._hook("onEventDelete", {
          domEvent: args.domEvent,
          event,
          events: isMultiple ? events : UNDEFINED,
          source: args.source
        }) !== false;
        if (allowDelete) {
          changed = true;
          _this._events = _this._events.filter(function(e) {
            return !selectedEventsMap[e.id];
          });
          _this._selectedEventsMap = {};
          _this._triggerDeleted = {
            event,
            events: isMultiple ? events : UNDEFINED,
            source: args.source
          };
        }
      }
      if (changed) {
        _this._hidePopover();
        _this.refresh();
      }
    };
    _this._setEl = function(el2) {
      _this._el = el2 ? el2._el || el2 : null;
      _this._calendarView = el2;
    };
    _this._setList = function(el2) {
      _this._list = el2;
    };
    _this._setPopoverList = function(list) {
      _this._popoverList = list && list._el;
    };
    _this._onKeyDown = function(ev) {
      if (ev.keyCode === TAB) {
        _this._resetSelection();
      }
    };
    return _this;
  }
  EventcalendarBase2.prototype.addEvent = function(events) {
    var eventsToAdd = isArray(events) ? events : [events];
    var ids = [];
    var data = prepareEvents(eventsToAdd);
    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
      var event_1 = data_1[_i];
      ids.push("" + event_1.id);
      this._events.push(event_1);
    }
    this.refresh();
    return ids;
  };
  EventcalendarBase2.prototype.getEvents = function(start, end) {
    return getDataInRange(this._events, this.s, this._firstDay, this._lastDay, start, end);
  };
  EventcalendarBase2.prototype.getInvalids = function(start, end) {
    return getDataInRange(this.s.invalid, this.s, this._firstDay, this._lastDay, start, end);
  };
  EventcalendarBase2.prototype.getSelectedEvents = function() {
    return toArray(this._selectedEventsMap);
  };
  EventcalendarBase2.prototype.setEvents = function(events) {
    var ids = [];
    var data = prepareEvents(events);
    for (var _i = 0, data_2 = data; _i < data_2.length; _i++) {
      var event_2 = data_2[_i];
      ids.push("" + event_2.id);
    }
    this._events = data;
    this.refresh();
    return ids;
  };
  EventcalendarBase2.prototype.getViewDate = function() {
    return makeDate(this._viewMiddleDate || this._viewDate);
  };
  EventcalendarBase2.prototype.setSelectedEvents = function(selectedEvents) {
    this._selectedEventsMap = (selectedEvents || []).reduce(function(map2, ev) {
      if (ev.occurrenceId) {
        map2[ev.occurrenceId] = ev;
      } else {
        map2[ev.id] = ev;
      }
      return map2;
    }, {});
    this.forceUpdate();
  };
  EventcalendarBase2.prototype.removeEvent = function(events) {
    var eventsToRemove = isArray(events) ? events : [events];
    var data = this._events;
    var len = data.length;
    for (var _i = 0, eventsToRemove_1 = eventsToRemove; _i < eventsToRemove_1.length; _i++) {
      var eventToRemove = eventsToRemove_1[_i];
      var found = false;
      var i = 0;
      while (!found && i < len) {
        var event_3 = data[i];
        if (event_3.id === eventToRemove || event_3.id === eventToRemove.id) {
          found = true;
          data.splice(i, 1);
        }
        i++;
      }
    }
    this.refresh();
  };
  EventcalendarBase2.prototype.navigateToEvent = function(event) {
    this._navigateToEvent = event;
    this._shouldScrollSchedule++;
    this.navigate(event.start, true);
  };
  EventcalendarBase2.prototype.navigate = function(date, animate) {
    var d = +makeDate(date);
    var isNavigate = this._navigateToEvent !== UNDEFINED;
    var changed = d !== this._selectedDateTime;
    if (changed || isNavigate) {
      this._shouldAnimateScroll = !!animate;
    }
    if (this.s.selectedDate === UNDEFINED) {
      if ((this._showSchedule || this._showTimeline) && !changed) {
        this._shouldScrollSchedule++;
        this.forceUpdate();
      } else {
        this._selectedDateTime = d;
        this.setState({
          selectedDate: d
        });
      }
    } else if (changed || isNavigate) {
      this._selectedChange(d);
    }
  };
  EventcalendarBase2.prototype.updateEvent = function(events) {
    var eventsToUpdate = isArray(events) ? events : [events];
    var data = this._events;
    var len = data.length;
    for (var _i = 0, eventsToUpdate_1 = eventsToUpdate; _i < eventsToUpdate_1.length; _i++) {
      var eventToUpdate = eventsToUpdate_1[_i];
      var found = false;
      var i = 0;
      while (!found && i < len) {
        var event_4 = data[i];
        if (event_4.id === eventToUpdate.id) {
          found = true;
          data.splice(i, 1, __assign({}, eventToUpdate));
        }
        i++;
      }
    }
    this.refresh();
  };
  EventcalendarBase2.prototype.refresh = function() {
    this._refresh = true;
    this.forceUpdate();
  };
  EventcalendarBase2.prototype._render = function(s, state) {
    var _this = this;
    var prevProps = this._prevS;
    var showDate = this._showDate;
    var timezonesChanged = s.displayTimezone !== prevProps.displayTimezone || s.dataTimezone !== prevProps.dataTimezone;
    var renderList = false;
    var selectedChanged = false;
    var selectedDateTime;
    var viewChanged = this._tempViewChanged;
    this._tempViewChanged = false;
    this._colorEventList = s.eventTemplate !== UNDEFINED || s.renderEvent !== UNDEFINED ? false : s.colorEventList;
    if (s.exclusiveEndDates === UNDEFINED) {
      s.exclusiveEndDates = !!s.displayTimezone;
    }
    if (!isEmpty(s.min)) {
      if (prevProps.min !== s.min) {
        this._minDate = +makeDate(s.min);
      }
    } else {
      this._minDate = -Infinity;
    }
    if (!isEmpty(s.max)) {
      if (prevProps.max !== s.max) {
        this._maxDate = +makeDate(s.max);
      }
    } else {
      this._maxDate = Infinity;
    }
    if (s.selectedDate !== UNDEFINED) {
      if (s.selectedDate !== prevProps.selectedDate) {
        selectedDateTime = +makeDate(s.selectedDate);
        this._selectedChanged = selectedDateTime !== this._selectedDateTime;
      } else {
        selectedDateTime = this._selectedDateTime;
      }
    } else {
      if (!this._defaultDate) {
        this._defaultDate = +(s.defaultSelectedDate !== UNDEFINED ? makeDate(s.defaultSelectedDate) : removeTimezone(createDate$1(s)));
        this._selectedChanged = true;
      }
      selectedDateTime = this._selectedDateTime || this._defaultDate;
    }
    if (s.data !== prevProps.data) {
      this._events = s.immutableData ? __spreadArray([], s.data || [], true) : prepareEvents(s.data);
      this._refresh = true;
    }
    if (s.invalid !== prevProps.invalid || s.colors !== prevProps.colors || timezonesChanged) {
      this._refresh = true;
    }
    if (JSON.stringify(s.view) !== JSON.stringify(prevProps.view) || s.firstDay !== prevProps.firstDay || s.dragTimeStep !== prevProps.dragTimeStep || s.zoomLevel !== prevProps.zoomLevel) {
      var config = {
        c: "eventcalendar",
        dragTimeStep: s.dragTimeStep,
        eventExact: this._eventExact,
        eventListSize: this._eventListSize,
        eventListType: this._eventListType,
        firstDay: s.firstDay,
        resourcesLength: s.resources ? s.resources.length : 0,
        scheduleEndDay: this._scheduleEndDay,
        scheduleEndTime: this._scheduleEndTime,
        scheduleMaxEventStack: this._scheduleMaxEventStack,
        scheduleMinEventWidth: this._scheduleMinEventWidth,
        scheduleSize: this._scheduleSize,
        scheduleStartDay: this._scheduleStartDay,
        scheduleStartTime: this._scheduleStartTime,
        scheduleTimeCellStep: this._scheduleTimeCellStep,
        scheduleTimeLabelStep: this._scheduleTimeLabelStep,
        scheduleTimezones: this._scheduleTimezones,
        scheduleType: this._scheduleType,
        showCalendar: this._showCalendar,
        showEmptyDays: this._showEmptyDays,
        showEventCount: this._showEventCount,
        showEventLabels: this._showEventLabels,
        showEventList: this._showEventList,
        showMarked: !!s.marked,
        showSchedule: this._showSchedule,
        showScheduleDays: this._showScheduleDays,
        showTimeline: this._showTimeline,
        slotsLength: s.slots ? s.slots.length : 0,
        timelineColWidth: this._timelineColWidth,
        timelineEndDay: this._timelineEndDay,
        timelineEndTime: this._timelineEndTime,
        timelineListing: this._timelineListing,
        timelineResolution: this._timelineResolution,
        timelineResolutionVertical: this._timelineResolutionVertical,
        timelineResourceOrder: this._timelineResourceOrder,
        timelineSize: this._timelineSize,
        timelineStartDay: this._timelineStartDay,
        timelineStartTime: this._timelineStartTime,
        timelineTimeCellStep: this._timelineTimeCellStep,
        timelineTimeLabelStep: this._timelineTimeLabelStep,
        timelineType: this._timelineType,
        v: version,
        view: s.view,
        zoomLevel: s.zoomLevel
      };
      this._remote++;
      sendLog(this);
      jsonp$1("remote", this, config, function(data) {
        _this._remote--;
        if (!_this._remote) {
          for (var _i = 0, _a = Object.keys(data); _i < _a.length; _i++) {
            var key = _a[_i];
            _this[key] = data[key];
          }
          showMessage(data.notification);
          _this._tempViewChanged = data._viewChanged;
          _this.forceUpdate();
        }
      }, "comp_" + this._uid);
    }
    this._showDate = !this._showScheduleDays && this._showSchedule && this._scheduleType === "day";
    var lastPageLoad = this._pageLoad;
    if (this._refresh || s.locale !== prevProps.locale || s.theme !== prevProps.theme) {
      renderList = true;
      this._pageLoad++;
    }
    if (s.resources !== prevProps.resources) {
      this._resourcesMap = (s.resources || []).reduce(function(map2, res) {
        map2[res.id] = res;
        return map2;
      }, {});
    }
    if (s.selectMultipleEvents) {
      if (s.selectedEvents !== prevProps.selectedEvents) {
        this._selectedEventsMap = (s.selectedEvents || []).reduce(function(map2, ev) {
          if (ev.occurrenceId) {
            map2[ev.occurrenceId] = ev;
          } else {
            map2[ev.id] = ev;
          }
          return map2;
        }, {});
      }
    }
    if (this._selectedEventsMap === UNDEFINED) {
      this._selectedEventsMap = {};
    }
    if (s.refDate !== prevProps.refDate) {
      this._refDate = makeDate(s.refDate);
    }
    if (!this._refDate && !this._showCalendar && (this._showSchedule || this._showTimeline)) {
      this._refDate = getDateOnly(/* @__PURE__ */ new Date());
    }
    if (s.cssClass !== prevProps.cssClass || s.className !== prevProps.className || s.class !== prevProps.class) {
      this._checkSize++;
      this._viewChanged = viewChanged = true;
    }
    if (s.zoomLevel !== prevProps.zoomLevel) {
      this._viewDate = this._viewMiddleDate;
    }
    if (this._selectedChanged) {
      this._viewDate = selectedDateTime;
    }
    if (viewChanged && this._viewDate && this._viewDate !== selectedDateTime) {
      selectedChanged = true;
      selectedDateTime = this._viewDate;
    }
    if (this._selectedChanged || viewChanged) {
      var validated = this._showCalendar && (this._showSchedule || this._showTimeline || this._showEventList) ? +getClosestValidDate(new Date(selectedDateTime), s, this._minDate, this._maxDate, UNDEFINED, UNDEFINED, 1) : constrain(selectedDateTime, this._minDate, this._maxDate);
      validated = this._getValidDay(validated);
      if (selectedDateTime !== validated || selectedChanged) {
        selectedDateTime = validated;
        setTimeout(function() {
          _this._selectedChange(selectedDateTime);
        });
      }
      if (!this._skipScheduleScroll) {
        this._shouldScrollSchedule++;
      }
      this._selectedDateTime = selectedDateTime;
      this._selectedChanged = false;
    }
    var selectedDate = getDateOnly(new Date(selectedDateTime));
    var selected = +selectedDate;
    if (selected !== this._selected || showDate !== this._showDate || s.locale !== prevProps.locale || prevProps.dateFormatLong !== s.dateFormatLong) {
      this._selectedDateHeader = this._showDate ? formatDate(s.dateFormatLong, selectedDate, s) : "";
    }
    if (selected !== this._selected || s.dataTimezone !== prevProps.dataTimezone || s.displayTimezone !== prevProps.displayTimezone) {
      this._shouldAnimateScroll = this._shouldAnimateScroll !== UNDEFINED ? this._shouldAnimateScroll : this._selected !== UNDEFINED;
      this._selected = selected;
      this._selectedDates = {};
      this._selectedDates[+addTimezone(s, new Date(selected))] = true;
      this._active = selected;
      renderList = true;
      selectedChanged = true;
    }
    if (selectedChanged) {
      this._shouldScroll = !this._shouldSkipScroll;
    }
    if (renderList && this._showCalendar && (this._eventListType === "day" || this._scheduleType === "day" || this._timelineType === "day")) {
      this._setEventList(selectedDate, addDays(selectedDate, 1));
    }
    if (this._refresh && state.showPopover) {
      setTimeout(function() {
        _this._hidePopover();
      });
    }
    this._refresh = false;
    this._cssClass = this._className + " mbsc-eventcalendar" + (this._showEventList ? " mbsc-eventcalendar-agenda" : "") + (this._showSchedule ? " mbsc-eventcalendar-schedule" : "") + (this._showTimeline ? " mbsc-eventcalendar-timeline" : "");
    this._navService.options({
      activeDate: this._active,
      calendarType: this._calendarType,
      endDay: this._showSchedule ? this._scheduleEndDay : this._showTimeline ? this._timelineEndDay : this._rangeEndDay,
      eventRange: this._rangeType,
      eventRangeSize: this._showSchedule ? this._scheduleSize : this._showTimeline ? this._timelineSize : this._eventListSize,
      firstDay: s.firstDay,
      getDate: s.getDate,
      getDay: s.getDay,
      getMonth: s.getMonth,
      getYear: s.getYear,
      max: s.max,
      min: s.min,
      onPageChange: this._onPageChange,
      onPageLoading: this._onPageLoading,
      refDate: this._refDate,
      resolution: this._timelineResolution,
      showCalendar: this._showCalendar,
      showOuterDays: this._showOuterDays,
      size: this._calendarSize,
      startDay: this._rangeStartDay,
      weeks: this._calendarSize
    }, this._pageLoad !== lastPageLoad);
  };
  EventcalendarBase2.prototype._mounted = function() {
    this._unsubscribe = subscribeExternalDrag(this._onExternalDrag);
    listen(this._el, KEY_DOWN, this._onKeyDown);
  };
  EventcalendarBase2.prototype._updated = function() {
    var _this = this;
    if (this._shouldScroll && this._isListLoaded && this.state.isListScrollable) {
      ngSetTimeout(this, function() {
        _this._scrollToDay();
        _this._shouldAnimateScroll = UNDEFINED;
      });
      this._shouldScroll = false;
    }
    if (this._shouldLoadDays) {
      this._shouldLoadDays = false;
      forEach(this._list.querySelectorAll("[mbsc-timestamp]"), function(listItem) {
        _this._listDays[listItem.getAttribute("mbsc-timestamp")] = listItem;
      });
    }
    if (this._shouldEnhance) {
      this._shouldEnhance = this._shouldEnhance === "popover" ? this._popoverList : this._list;
    }
    if (this._triggerCreated) {
      var created = this._triggerCreated;
      var target = created.source === "calendar" ? this._calendarView._body.querySelector('.mbsc-calendar-table-active .mbsc-calendar-text[data-id="'.concat(created.event.id, '"]')) : this._el.querySelector('.mbsc-schedule-event[data-id="'.concat(created.event.id, '"]'));
      this._hook("onEventCreated", __assign(__assign({}, this._triggerCreated), {
        target
      }));
      this._triggerCreated = null;
    }
    if (this._triggerUpdated) {
      var updated = this._triggerUpdated;
      var target = updated.source === "calendar" ? this._calendarView._body.querySelector('.mbsc-calendar-table-active .mbsc-calendar-text[data-id="'.concat(updated.event.id, '"]')) : this._el.querySelector('.mbsc-schedule-event[data-id="'.concat(updated.event.id, '"]'));
      this._hook("onEventUpdated", __assign(__assign({}, this._triggerUpdated), {
        target
      }));
      this._triggerUpdated = null;
    }
    if (this._triggerDeleted) {
      this._hook("onEventDeleted", __assign({}, this._triggerDeleted));
      this._triggerDeleted = null;
    }
    if (this._viewChanged) {
      setTimeout(function() {
        _this._viewChanged = false;
      }, 10);
    }
    if (this._shouldSkipScroll) {
      setTimeout(function() {
        _this._shouldSkipScroll = false;
      });
    }
    if (this._navigateToEvent) {
      setTimeout(function() {
        _this._navigateToEvent = UNDEFINED;
      });
    }
    this._skipScheduleScroll = false;
  };
  EventcalendarBase2.prototype._destroy = function() {
    if (this._unsubscribe) {
      unsubscribeExternalDrag(this._unsubscribe);
    }
    unlisten(this._el, KEY_DOWN, this._onKeyDown);
  };
  EventcalendarBase2.prototype._resetSelection = function() {
    if (this.s.selectMultipleEvents && Object.keys(this._selectedEventsMap).length > 0) {
      this._selectedEventsMap = {};
      this._onSelectedEventsChange([]);
      this.forceUpdate();
    }
  };
  EventcalendarBase2.prototype._getAgendaEvents = function(firstDay, lastDay, eventMap) {
    var _this = this;
    var events = [];
    var s = this.s;
    var nr = 0;
    if (eventMap && this._showEventList) {
      var _loop_1 = function(d2) {
        var eventsForDay = eventMap[getDateStr(d2)] || [];
        var sorted = sortEvents(eventsForDay, s);
        nr += eventsForDay.length;
        events.push({
          date: formatDate(s.dateFormatLong, d2, s),
          dateObj: new Date(d2),
          events: sorted.map(function(event) {
            return _this._getEventData(event, d2);
          }),
          timestamp: +d2
        });
      };
      for (var d = getDateOnly(firstDay); d < lastDay; d.setDate(d.getDate() + 1)) {
        _loop_1(d);
      }
    }
    this._eventListNr = nr;
    return events;
  };
  EventcalendarBase2.prototype._getEventData = function(event, d, res, slot, full) {
    var s = this.s;
    var isList = !this._showCalendar || !this._eventExact;
    if (!event.color && event.resource && res === UNDEFINED) {
      res = (this._resourcesMap || {})[isArray(event.resource) ? event.resource[0] : event.resource];
    }
    return getEventData(s, event, d, this._colorEventList, res, slot, isList, true, false, false, full);
  };
  EventcalendarBase2.prototype._getValidDay = function(timestamp, dir) {
    if (dir === void 0) {
      dir = 1;
    }
    var startDay = this._rangeStartDay;
    var endDay = this._rangeEndDay;
    if (!this._showCalendar && this._rangeType === "day" && startDay !== UNDEFINED && endDay !== UNDEFINED) {
      var date = new Date(timestamp);
      var day = date.getDay();
      var diff = 0;
      if (endDay < startDay ? day > endDay && day < startDay : day > endDay || day < startDay) {
        diff = dir < 0 ? endDay - day : startDay - day;
      }
      if (diff) {
        diff += dir < 0 ? diff > 0 ? -7 : 0 : diff < 0 ? 7 : 0;
        return +addDays(date, diff);
      }
    }
    return timestamp;
  };
  EventcalendarBase2.prototype._setEventList = function(firstDay, lastDay) {
    var _this = this;
    setTimeout(function() {
      var eventList = _this._getAgendaEvents(firstDay, lastDay, _this._eventMap);
      _this._eventListHTML = UNDEFINED;
      _this._shouldScroll = _this._viewChanged;
      _this._isListLoaded = !!_this._eventListNr;
      _this._listDays = null;
      _this.setState({
        eventList
      });
    });
  };
  EventcalendarBase2.prototype._showPopover = function(key, date, list, anchor, context, inst) {
    var _this = this;
    if (!this.state.showPopover || key !== this.state.popoverKey) {
      setTimeout(function() {
        _this._anchor = anchor;
        _this.setState({
          popoverContext: context,
          popoverDate: date,
          popoverHidden: false,
          popoverHost: inst,
          popoverKey: key,
          popoverList: list,
          showPopover: true
        });
      });
    }
  };
  EventcalendarBase2.prototype._hidePopover = function() {
    if (this.state.showPopover) {
      this.setState({
        popoverDrag: false,
        showPopover: false
      });
    }
  };
  EventcalendarBase2.prototype._scrollToDay = function() {
    var _this = this;
    if (this._list) {
      var to = void 0;
      if (this._listDays) {
        var day = this._listDays[this._selected];
        var eventId = this._navigateToEvent && this._navigateToEvent.id;
        if (day) {
          to = day.offsetTop;
          if (eventId !== UNDEFINED) {
            var event_5 = day.querySelector('.mbsc-event[data-id="'.concat(eventId, '"]'));
            var dayHeader = day.querySelector(".mbsc-event-day");
            if (event_5) {
              to = event_5.offsetTop - (dayHeader ? dayHeader.offsetHeight : 0) + 1;
            }
          }
        }
      }
      if (to !== UNDEFINED) {
        this._isListScrolling++;
        smoothScroll(this._list, UNDEFINED, to, this._shouldAnimateScroll, false, function() {
          setTimeout(function() {
            _this._isListScrolling--;
          }, 150);
        });
      }
    }
  };
  EventcalendarBase2.prototype._selectedChange = function(d, setChanged, skipState) {
    var date = new Date(d);
    if (this.s.selectedDate === UNDEFINED) {
      this._selectedDateTime = d;
      this._selectedChanged = setChanged;
      if (!skipState) {
        this.setState({
          selectedDate: +d
        });
      }
    }
    this._emit("selectedDateChange", date);
    this._hook("onSelectedDateChange", {
      date
    });
  };
  EventcalendarBase2.prototype._cellClick = function(name, args) {
    this._hook(name, __assign({
      target: args.domEvent.currentTarget
    }, args));
  };
  EventcalendarBase2.prototype._dayClick = function(name, args) {
    var d = getDateStr(args.date);
    var events = sortEvents(this._eventMap[d], this.s);
    args.events = events;
    this._hook(name, args);
  };
  EventcalendarBase2.prototype._labelClick = function(name, args) {
    if (args.label) {
      this._hook(name, {
        date: args.date,
        domEvent: args.domEvent,
        event: args.label,
        source: "calendar",
        target: args.target
      });
    }
  };
  EventcalendarBase2.prototype._eventClick = function(name, args) {
    args.date = new Date(args.date);
    return this._hook(name, args);
  };
  EventcalendarBase2.prototype._handleMultipleSelect = function(args) {
    var event = args.label || args.event;
    if (event && this.s.selectMultipleEvents) {
      var domEvent = args.domEvent;
      var selectedEvents = !domEvent.shiftKey && !domEvent.ctrlKey && !domEvent.metaKey ? {} : this._selectedEventsMap;
      var eventId = event.occurrenceId || event.id;
      if (selectedEvents[eventId]) {
        delete selectedEvents[eventId];
      } else {
        selectedEvents[eventId] = event;
      }
      this._selectedEventsMap = __assign({}, selectedEvents);
      this._onSelectedEventsChange(toArray(selectedEvents));
      if (this.s.selectedEvents === UNDEFINED) {
        this.forceUpdate();
      }
    }
  };
  EventcalendarBase2.defaults = __assign(__assign({}, calendarViewDefaults), {
    actionableEvents: true,
    allDayText: "All-day",
    data: [],
    newEventText: "New event",
    noEventsText: "No events",
    showControls: true,
    showEventTooltip: true,
    view: {
      calendar: {
        type: "month"
      }
    }
  });
  EventcalendarBase2._name = "Eventcalendar";
  EventcalendarBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵEventcalendarBase_BaseFactory;
    return function EventcalendarBase_Factory(__ngFactoryType__) {
      return (ɵEventcalendarBase_BaseFactory || (ɵEventcalendarBase_BaseFactory = ɵɵgetInheritedFactory(EventcalendarBase2)))(__ngFactoryType__ || EventcalendarBase2);
    };
  })();
  EventcalendarBase2.ɵdir = ɵɵdefineDirective({
    type: EventcalendarBase2,
    selectors: [["", "mbsc-ec-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return EventcalendarBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventcalendarBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-ec-b]"
    }]
  }], null, null);
})();
var DEF_ID = "mbsc-def";
function checkCollision(data, start, end, allDay, noAllDayOverlap, invalidateEvent, s) {
  var showBuffer = s.showEventBuffer !== false;
  var onlyStartEnd = invalidateEvent === "start-end";
  var until = s.exclusiveEndDates ? end : getDateOnly(addDays(end, 1));
  for (var _i = 0, _a = Object.keys(data); _i < _a.length; _i++) {
    var r = _a[_i];
    var resourceData = data[r];
    for (var d = getDateOnly(start); d < until; d.setDate(d.getDate() + 1)) {
      var dayData = resourceData[getDateStr(d)];
      if (dayData) {
        if ((allDay || noAllDayOverlap) && dayData.allDay[0] && (!onlyStartEnd || isSameDay(d, start) || isSameDay(d, end))) {
          return dayData.allDay[0].original;
        }
        if (!allDay) {
          for (var _b = 0, _c = dayData.data; _b < _c.length; _b++) {
            var item = _c[_b];
            var original = item.original;
            var startDate = showBuffer && item.bufferStart ? item.bufferStart : item.startDate;
            var endDate = showBuffer && item.bufferEnd ? item.bufferEnd : item.endDate;
            if (onlyStartEnd) {
              if (checkDateRangeOverlap(startDate, endDate, start, start, true)) {
                return original;
              }
              if (checkDateRangeOverlap(startDate, endDate, end, end)) {
                return original;
              }
            } else if (checkDateRangeOverlap(startDate, endDate, start, end)) {
              return original;
            }
          }
        }
      }
    }
  }
  return false;
}
function getEventLayoutStart(event, s, isListing, isTimeline, isDailyResolution, firstDay, cols, colIndexMap, showBuffer) {
  var eventAllDay = event.allDay || isListing;
  var startDate = showBuffer && event.bufferStart ? event.bufferStart : event.startDate;
  if (isTimeline && isListing && !isDailyResolution) {
    var startCol = colIndexMap[getDateStr(startDate)];
    return startDate < firstDay ? firstDay : cols[startCol + (isInWeek(startDate.getDay(), s.startDay, s.endDay) ? 0 : 1)].date;
  }
  return eventAllDay ? createDate$1(s, startDate.getFullYear(), startDate.getMonth(), startDate.getDate()) : startDate;
}
function getEventLayoutEnd(event, s, isListing, isTimeline, isDailyResolution, lastDay, cols, colIndexMap, showBuffer) {
  var eventAllDay = event.allDay || isListing;
  var endDate = showBuffer && event.bufferEnd ? event.bufferEnd : event.endDate;
  if (isTimeline && isListing && !isDailyResolution) {
    var endCol = colIndexMap[getDateStr(getEndDate(s, event.allDay, event.startDate, endDate))];
    var endD = endDate >= lastDay || endCol >= cols.length - 1 ? lastDay : cols[endCol + 1].date;
    return getEndDate(s, false, event.startDate, endD);
  }
  var eEnd = eventAllDay ? getEndDate(s, event.allDay, event.startDate, endDate) : endDate;
  return eventAllDay ? createDate$1(s, eEnd.getFullYear(), eEnd.getMonth(), eEnd.getDate(), 23, 59, 59, 999) : eEnd;
}
function calcLayout(s, groups, event, next, maxEventStack) {
  var pushed = false;
  for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
    var group = groups_1[_i];
    var i = 0;
    var groupOverlap = false;
    var groupLevel = void 0;
    for (var _a = 0, _b = group.stacks; _a < _b.length; _a++) {
      var level = _b[_a];
      var overlap = false;
      for (var _c = 0, level_1 = level; _c < level_1.length; _c++) {
        var item = level_1[_c];
        if (item.layoutStart < event.layoutEnd && item.layoutEnd > event.layoutStart) {
          overlap = true;
          groupOverlap = true;
          if (groupLevel) {
            next[event.uid] = next[event.uid] || i;
          } else {
            next[item.uid] = i + 1;
          }
        }
      }
      if (!overlap && !groupLevel) {
        groupLevel = level;
      }
      i++;
    }
    if (groupOverlap) {
      if (groupLevel) {
        groupLevel.push(event);
      } else {
        if (maxEventStack === "all" || group.stacks.length < +maxEventStack) {
          group.stacks.push([event]);
        } else {
          event.position = UNDEFINED;
          group.more.push(event);
        }
      }
      pushed = true;
    }
  }
  if (!pushed) {
    next[event.uid] = 0;
    groups.push({
      stacks: [[event]],
      more: []
    });
  }
}
function roundStep(v) {
  v = Math.abs(round(v));
  if (v > 60) {
    return round(v / 60) * 60;
  }
  if (60 % v === 0) {
    return v;
  }
  return [6, 10, 12, 15, 20, 30].reduce(function(a, b) {
    return Math.abs(b - v) < Math.abs(a - v) ? b : a;
  });
}
function calcSchedulerTime(startDate, endDate, startTime, endTime) {
  var start = getDayMilliseconds(startDate);
  var end = getDayMilliseconds(endDate);
  if (startTime > start) {
    start = startTime;
  }
  if (endTime < end) {
    end = endTime;
  }
  return end - start;
}
function calcTimelineTime(startDate, endDate, viewStart, viewEnd, startTime, endTime, startDay, endDay, fullDay) {
  var displayedTime = endTime - startTime;
  var startD = startDate;
  var endD = endDate;
  var until = addDays(getDateOnly(endD), 1);
  if (startD < viewStart) {
    startD = viewStart;
  }
  if (endD > viewEnd) {
    endD = until = viewEnd;
  }
  var start = getDayMilliseconds(startD);
  var end = getDayMilliseconds(endD);
  if (startTime > start) {
    start = startTime;
  }
  if (endTime < end) {
    end = endTime;
  }
  if (!isSameDay(startD, endD)) {
    if (start > endTime) {
      start = endTime;
    }
    if (end < startTime) {
      end = startTime;
    }
  }
  var time = 0;
  if (isSameDay(startD, endD)) {
    time = fullDay ? displayedTime : end - start;
  } else {
    for (var d = getDateOnly(startD); d < until; d.setDate(d.getDate() + 1)) {
      if (isInWeek(d.getDay(), startDay, endDay)) {
        if (!fullDay && isSameDay(d, startD)) {
          time += displayedTime - start + startTime;
        } else if (!fullDay && isSameDay(d, endD)) {
          time += end - startTime;
        } else {
          time += displayedTime;
        }
      }
    }
  }
  return time;
}
function getEventStart(startDate, startTime, displayedTime, viewStart, startDay, endDay) {
  if (viewStart && viewStart > startDate) {
    startDate = viewStart;
  }
  var start = getDayMilliseconds(startDate);
  if (startTime > start || startDay !== UNDEFINED && endDay !== UNDEFINED && !isInWeek(startDate.getDay(), startDay, endDay)) {
    start = startTime;
  }
  return (start - startTime) * 100 / displayedTime;
}
function getResourceMap(eventsMap, resources, slots, hasResources, hasSlots) {
  eventsMap = eventsMap || {};
  var eventKeys = Object.keys(eventsMap);
  var resourceMap = {};
  var resourceIds = resources.map(function(resource) {
    return resource.id;
  });
  var slotIds = slots.map(function(s) {
    return s.id;
  });
  resourceIds.forEach(function(rid) {
    resourceMap[rid] = {};
    slotIds.forEach(function(sid) {
      resourceMap[rid][sid] = {};
    });
  });
  var _loop_1 = function(timestamp2) {
    var events = eventsMap[timestamp2];
    var _loop_2 = function(event_12) {
      var eventResource = event_12.resource;
      var eventSlot = event_12.slot;
      var res = eventResource === UNDEFINED || !hasResources ? resourceIds : isArray(eventResource) ? eventResource : [eventResource];
      var slot = eventSlot === UNDEFINED || !hasSlots ? slotIds : [eventSlot];
      res.forEach(function(rid) {
        var map2 = resourceMap[rid];
        if (map2) {
          slot.forEach(function(sid) {
            var slotMap = map2[sid];
            if (slotMap) {
              if (!slotMap[timestamp2]) {
                slotMap[timestamp2] = [];
              }
              slotMap[timestamp2].push(event_12);
            }
          });
        }
      });
    };
    for (var _a = 0, events_1 = events; _a < events_1.length; _a++) {
      var event_1 = events_1[_a];
      _loop_2(event_1);
    }
  };
  for (var _i = 0, eventKeys_1 = eventKeys; _i < eventKeys_1.length; _i++) {
    var timestamp = eventKeys_1[_i];
    _loop_1(timestamp);
  }
  return resourceMap;
}
function getCellDate(timestamp, ms) {
  var d = new Date(timestamp);
  var time = new Date(+REF_DATE + ms);
  return new Date(d.getFullYear(), d.getMonth(), d.getDate(), time.getHours(), time.getMinutes());
}
var stateObservables = {};
var ScheduleEventBase = function(_super) {
  __extends(ScheduleEventBase2, _super);
  function ScheduleEventBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onClick = function(ev) {
      _this._triggerClick("onClick", ev);
      var s = _this.s;
      var observable = stateObservables[s.event.uid];
      if (observable && s.selected) {
        observable.next({
          hasFocus: false
        });
      }
    };
    _this._onRightClick = function(ev) {
      _this._triggerClick("onRightClick", ev);
    };
    _this._onDocTouch = function(ev) {
      unlisten(_this._doc, TOUCH_START, _this._onDocTouch);
      unlisten(_this._doc, MOUSE_DOWN, _this._onDocTouch);
      _this._isDrag = false;
      _this._hook("onDragModeOff", {
        domEvent: ev,
        event: _this.s.event.original
      });
    };
    _this._updateState = function(args) {
      _this.setState(args);
    };
    return _this;
  }
  ScheduleEventBase2.prototype._render = function(s, state) {
    var event = s.event;
    var day = new Date(event.date);
    var pos = event.position;
    var startDate = event.startDate;
    var endDate = getEndDate(s, event.allDay, startDate, event.endDate);
    var isTimeline = s.isTimeline;
    var isTimelineListing = s.isListing;
    var isMore = event.original["more"];
    var isAllDay = isMore && isTimeline || isTimelineListing || event.allDay;
    var isMultiDay = !isSameDay(startDate, endDate);
    var isMultiDayStart = isMultiDay && isSameDay(startDate, day);
    var isMultiDayEnd = isMultiDay && isSameDay(endDate, day);
    var allDayStyle = isAllDay && (!isTimeline || isTimelineListing || isMore);
    var host = isTimeline ? "timeline" : "schedule";
    var gridStartTime = s.gridStartTime;
    var gridEndTime = s.gridEndTime;
    var startTime = getDayMilliseconds(startDate);
    var endTime = getDayMilliseconds(endDate);
    var hasSlots = isTimeline && s.slot !== DEF_ID;
    var isEndInWeek = isInWeek(endDate.getDay(), s.startDay, s.endDay);
    var lastDay = s.singleDay ? addDays(day, 1) : new Date(s.lastDay);
    if (!event.allDay) {
      lastDay = addTimezone(s, lastDay);
    }
    this._isStart = hasSlots || !isMultiDay || isMultiDayStart;
    this._isEnd = hasSlots || !isMultiDay || (isAllDay || isTimeline && !s.hasResY ? endDate < lastDay && isEndInWeek : isMultiDayEnd);
    if (!hasSlots && !isAllDay && (gridStartTime > startTime || gridEndTime < startTime)) {
      this._isStart = false;
    }
    if (!hasSlots && !isAllDay && (gridEndTime < endTime || gridStartTime > endTime)) {
      this._isEnd = false;
    }
    this._isMore = isMore;
    this._isDrag = this._isDrag || s.isDrag;
    this._content = UNDEFINED;
    this._rangeText = event.start + " - " + event.end;
    this._isAllDay = allDayStyle;
    this._host = host;
    if (event.allDay || (!isTimeline || s.hasResY) && isMultiDay && !isMultiDayStart && !isMultiDayEnd) {
      this._rangeText = event.allDayText || " ";
    }
    if (event.bufferBefore) {
      this._bufferStyleStart = isTimeline ? {
        width: event.bufferBefore
      } : {
        height: event.bufferBefore
      };
    }
    if (event.bufferAfter) {
      this._bufferStyleEnd = isTimeline ? {
        width: event.bufferAfter
      } : {
        height: event.bufferAfter
      };
    }
    this._cssClass = "mbsc-schedule-event" + this._theme + this._rtl + (s.render || s.template ? " mbsc-schedule-event-custom" : "") + (isTimeline ? " mbsc-timeline-event" : "") + (isTimelineListing || isMore ? " mbsc-timeline-event-listing" : "") + (this._isStart ? " mbsc-".concat(host, "-event-start") : "") + (this._isEnd ? " mbsc-".concat(host, "-event-end") : "") + (allDayStyle ? " mbsc-schedule-event-all-day" : "") + (hasSlots ? " mbsc-timeline-event-slot" : "") + (state.hasFocus && !s.inactive && !s.selected || s.selected ? " mbsc-schedule-event-active" : "") + (state.hasHover && !s.inactive && !this._isDrag ? " mbsc-schedule-event-hover" : "") + (s.isDrag ? " mbsc-schedule-event-dragging" + (isTimeline ? " mbsc-timeline-event-dragging" : "") : "") + (s.hidden ? " mbsc-schedule-event-hidden" : "") + (s.inactive ? " mbsc-schedule-event-inactive" : "") + (event.original.editable === false ? " mbsc-readonly-event" : "") + (event.original.cssClass ? " " + event.original.cssClass : "");
    this._style = __assign(__assign({}, pos), {
      color: event.color,
      top: s.eventHeight && pos.top !== UNDEFINED ? pos.top * s.eventHeight + "px" : pos.top
    });
    var renderer = s.render || s.renderContent;
    var text;
    if (renderer && !isMore) {
      var content = renderer(event);
      if (isString(content)) {
        text = content;
      } else {
        this._content = content;
      }
    } else if (!s.contentTemplate || isMore) {
      text = event.html;
    }
    if (text !== this._text) {
      this._text = text;
      this._html = text ? this._safeHtml(text) : UNDEFINED;
      this._shouldEnhance = text && !!renderer;
    }
  };
  ScheduleEventBase2.prototype._mounted = function() {
    var _this = this;
    var id2 = this.s.event.uid;
    var el2 = this._el;
    var resizeDir;
    var observable = stateObservables[id2];
    var startDomEvent;
    var touchTimer;
    if (!observable) {
      observable = new Observable();
      stateObservables[id2] = observable;
    }
    this._unsubscribe = observable.subscribe(this._updateState);
    this._doc = getDocument(el2);
    this._unlisten = gestureListener(el2, {
      keepFocus: true,
      onBlur: function() {
        observable.next({
          hasFocus: false
        });
      },
      onDoubleClick: function(ev) {
        ev.domEvent.stopPropagation();
        _this._triggerClick("onDoubleClick", ev.domEvent);
      },
      onEnd: function(ev) {
        if (_this._isDrag) {
          var s = _this.s;
          var args = __assign({}, ev);
          args.domEvent.preventDefault();
          args.eventData = s.event;
          args.resource = s.resource;
          args.slot = s.slot;
          if (s.resize && resizeDir) {
            args.resize = true;
            args.direction = resizeDir;
          } else if (s.drag) {
            args.drag = true;
          }
          _this._hook("onDragEnd", args);
          if (!s.isDrag) {
            _this._isDrag = false;
          }
          if (el2 && args.moved) {
            el2.blur();
          }
        }
        clearTimeout(touchTimer);
        resizeDir = UNDEFINED;
      },
      onFocus: function() {
        observable.next({
          hasFocus: true
        });
      },
      onHoverIn: function(ev) {
        observable.next({
          hasHover: true
        });
        _this._triggerClick("onHoverIn", ev);
      },
      onHoverOut: function(ev) {
        observable.next({
          hasHover: false
        });
        _this._triggerClick("onHoverOut", ev);
      },
      onKeyDown: function(ev) {
        var event = _this.s.event.original;
        switch (ev.keyCode) {
          case ENTER:
          case SPACE:
            ev.target.click();
            ev.preventDefault();
            break;
          case BACKSPACE:
          case DELETE:
            if (event.editable !== false) {
              _this._hook("onDelete", {
                domEvent: ev,
                event,
                resource: _this.s.resource,
                slot: _this.s.slot,
                source: _this._host
              });
            }
            break;
        }
      },
      onMove: function(ev) {
        var s = _this.s;
        var args = __assign({}, ev);
        args.eventData = s.event;
        args.resource = s.resource;
        args.slot = s.slot;
        if (resizeDir) {
          args.resize = true;
          args.direction = resizeDir;
        } else if (s.drag) {
          args.drag = true;
        } else {
          return;
        }
        if (s.event.original.editable === false) {
          return;
        }
        if (_this._isDrag || !args.isTouch) {
          args.domEvent.preventDefault();
        }
        if (_this._isDrag) {
          _this._hook("onDragMove", args);
        } else if (Math.abs(args.deltaX) > 7 || Math.abs(args.deltaY) > 7) {
          clearTimeout(touchTimer);
          if (!args.isTouch) {
            args.domEvent = startDomEvent;
            _this._isDrag = true;
            _this._hook("onDragStart", args);
          }
        }
      },
      onStart: function(ev) {
        startDomEvent = ev.domEvent;
        var s = _this.s;
        var args = __assign({}, ev);
        var target = startDomEvent.target;
        args.eventData = s.event;
        args.resource = s.resource;
        args.slot = s.slot;
        if (s.resize && target.classList.contains("mbsc-schedule-event-resize")) {
          resizeDir = target.classList.contains("mbsc-schedule-event-resize-start") ? "start" : "end";
          args.resize = true;
          args.direction = resizeDir;
        } else if (s.drag) {
          args.drag = true;
        } else {
          return;
        }
        if (s.event.original.editable === false) {
          return;
        }
        if (_this._isDrag) {
          startDomEvent.stopPropagation();
          _this._hook("onDragStart", args);
        } else if (args.isTouch) {
          touchTimer = setTimeout(function() {
            _this._hook("onDragModeOn", args);
            _this._hook("onDragStart", args);
            _this._isDrag = true;
          }, 350);
        }
      }
    });
    if (this._isDrag) {
      listen(this._doc, TOUCH_START, this._onDocTouch);
      listen(this._doc, MOUSE_DOWN, this._onDocTouch);
    }
  };
  ScheduleEventBase2.prototype._destroy = function() {
    if (this._el) {
      this._el.blur();
    }
    if (this._unsubscribe) {
      var id2 = this.s.event.uid;
      var observable = stateObservables[id2];
      if (observable) {
        observable.unsubscribe(this._unsubscribe);
        if (!observable.nr) {
          delete stateObservables[id2];
        }
      }
    }
    if (this._unlisten) {
      this._unlisten();
    }
    unlisten(this._doc, TOUCH_START, this._onDocTouch);
    unlisten(this._doc, MOUSE_DOWN, this._onDocTouch);
  };
  ScheduleEventBase2.prototype._triggerClick = function(name, domEvent) {
    var s = this.s;
    this._hook(name, {
      date: s.event.date,
      domEvent,
      event: s.event.original,
      resource: s.resource,
      resourceObj: s.resourceObj,
      slot: s.slot,
      slotObj: s.slotObj,
      source: this._host,
      target: this._el
    });
  };
  ScheduleEventBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵScheduleEventBase_BaseFactory;
    return function ScheduleEventBase_Factory(__ngFactoryType__) {
      return (ɵScheduleEventBase_BaseFactory || (ɵScheduleEventBase_BaseFactory = ɵɵgetInheritedFactory(ScheduleEventBase2)))(__ngFactoryType__ || ScheduleEventBase2);
    };
  })();
  ScheduleEventBase2.ɵdir = ɵɵdefineDirective({
    type: ScheduleEventBase2,
    selectors: [["", "mbsc-sch-ev-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return ScheduleEventBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScheduleEventBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sch-ev-b]"
    }]
  }], null, null);
})();
var STBase = function(_super) {
  __extends(STBase2, _super);
  function STBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._eventHeights = {};
    _this._resourceTops = {};
    _this._columnLefts = [];
    _this._viewChanged = 0;
    _this._onScroll = function() {
    };
    _this._onCellClick = function(type, timestamp, v, domEvent, resource, slot) {
      _this._hook(type, {
        date: getCellDate(timestamp, v),
        domEvent,
        resource,
        slot,
        source: _this._isTimeline ? "timeline" : "schedule"
      });
    };
    _this._onResourceClick = function(type, domEvent, resource, date) {
      _this._hook(type, {
        date,
        domEvent,
        resource,
        source: _this._isTimeline ? "timeline" : "schedule",
        target: domEvent.currentTarget
      });
    };
    _this._onMouseLeave = function(ev, force) {
      if (_this._cursorTimeCont && (!_this._dragData || force)) {
        _this._cursorTimeCont.style.visibility = "hidden";
        _this._isCursorTimeVisible = false;
      }
    };
    _this._onMouseMove = function(ev) {
      if (_this._showCursorTime) {
        var s = _this.s;
        var rtl = s.rtl;
        var isTimeline = _this._isTimeline;
        var timeCont = _this._cursorTimeCont;
        if (!_this._isTouch || _this._tempStart) {
          if (!_this._isCursorTimeVisible && ev) {
            timeCont.style.visibility = "visible";
            _this._isCursorTimeVisible = true;
          }
        } else {
          timeCont.style.visibility = "hidden";
          _this._isCursorTimeVisible = false;
        }
        if (_this._isCursorTimeVisible && _this._colWidth) {
          var gridCont = _this._gridCont;
          var gridRect = gridCont.getBoundingClientRect();
          var clientX = ev ? ev.clientX : _this._cursorX || 0;
          var clientY = ev ? ev.clientY : _this._cursorY || 0;
          var posX = rtl ? gridRect.right - clientX : clientX - gridRect.left;
          var posY = constrain(clientY - gridRect.top, 8, _this._colHeight);
          var dayIndex = void 0;
          var date = void 0;
          var time = void 0;
          if (_this._dragDelta !== UNDEFINED) {
            date = createDate$1(s, _this._dragDelta < 0 ? _this._tempStart : _this._tempEnd);
            dayIndex = isTimeline && !_this._hasResY ? _this._dayIndexMap[getDateStr(date)] : 0;
            time = getDayMilliseconds(date);
            time = time === 0 ? _this._dragDelta < 0 ? time : ONE_DAY : time;
          } else {
            dayIndex = isTimeline && !_this._hasResY ? constrain(floor(posX / _this._colWidth), 0, _this._daysNr - 1) : 0;
            time = _this._startTime + step(isTimeline ? floor(_this._time * (posX - dayIndex * _this._colWidth) / _this._colWidth) : floor(_this._time * (posY - 8) / (_this._colHeight - 16)), s.dragTimeStep * ONE_MIN);
            var day = _this._days[dayIndex].date;
            var d = new Date(+REF_DATE + time);
            date = createDate$1(s, day.getFullYear(), day.getMonth(), day.getDate(), d.getHours(), d.getMinutes());
          }
          var milliSeconds = _this._time * (isTimeline ? _this._daysNr : 1);
          var pos = isTimeline ? rtl ? "right" : "left" : "top";
          var timeContStyle = timeCont.style;
          timeContStyle[pos] = (dayIndex * _this._time + time - _this._startTime) * 100 / milliSeconds + "%";
          timeContStyle[rtl ? "left" : "right"] = "";
          timeCont.textContent = formatDate(s.timeFormat, date, s);
          _this._cursorX = clientX;
          _this._cursorY = clientY;
        }
      }
    };
    _this._onEventClick = function(args) {
      var more = args.event["more"];
      if (more) {
        _this._hook("onMoreClick", {
          context: _this._scrollCont,
          date: args.date,
          key: args.event.id,
          list: more,
          target: args.domEvent.target
        });
      } else {
        _this._hook("onEventClick", args);
      }
    };
    _this._onResourceDragStart = function(args, target) {
      _this._calcGridSizes();
      var posY = constrain(args.startY - _this._gridTop, 0, _this._colHeight - 1);
      var dragRow = _this._getDragRow(posY, _this._scrollCont.scrollTop);
      var isExternal = args.external;
      var draggedResource = isExternal ? __assign({}, args.dragData) : _this._visibleResources[dragRow.resourceIndex];
      if (args.create && draggedResource.id === UNDEFINED) {
        draggedResource.id = getEventId();
      }
      _this._scrollY = 0;
      _this._startDayIndex = dragRow.dayIndex;
      _this._startResourceIndex = dragRow.resourceIndex;
      _this._startRow = dragRow.rowKey;
      _this._tempResource = _this._visibleResources[dragRow.resourceIndex].id;
      _this._tempResourceData = draggedResource;
      if (_this.s.externalResourceDrag && target && !isExternal) {
        var eventEl = closest(target, ".mbsc-timeline-resource", _this._el);
        var clone = eventEl.cloneNode(true);
        var cloneClass = clone.classList;
        clone.style.display = "none";
        cloneClass.add("mbsc-timeline-resource-drag-clone", "mbsc-font");
        _this._clone = clone;
        _this._ctx = getContext(_this.s.context, getDocument(_this._el));
        _this._ctx.appendChild(clone);
        _this._resourceDropped = false;
        dragObservable.next(__assign(__assign({}, args), {
          clone,
          create: true,
          dragData: draggedResource,
          dragDataType: "resource",
          eventName: "onDragStart",
          external: true,
          from: _this
        }));
      }
      _this._hook("onResourceDragStart", {
        domEvent: args.domEvent,
        resource: draggedResource,
        source: "timeline"
      });
    };
    _this._onResourceDragMove = function(args) {
      clearTimeout(_this._scrollTimer);
      clearTimeout(_this._expandTimer);
      var resources = _this._visibleResources;
      var state = _this.state;
      var headerHeight = state.headerHeight || 0;
      var endY = constrain(args.endY, _this._gridContTop, _this._gridContBottom - 1);
      var posY = constrain(endY - _this._gridTop + _this._scrollY, 0, _this._colHeight - 1);
      var scrollCont = _this._scrollCont;
      var scrollContTop = scrollCont.scrollTop;
      var scrollThreshold = 50;
      var distBottom = _this._gridContBottom - args.endY;
      var distTop = args.endY - _this._gridContTop - headerHeight;
      var dragRow = _this._getDragRow(posY, scrollContTop);
      var resourceIndex = dragRow.resourceIndex;
      var resource = resources[resourceIndex];
      var dragData = _this._dragData;
      var isExternal = args.external;
      var draggedResource = _this._tempResourceData;
      var hasScroll = false;
      var insertAfter = false;
      if (_this.s.externalResourceDrag && !isExternal && dragData) {
        dragObservable.next(__assign(__assign({}, args), {
          clone: _this._clone,
          create: true,
          dragData: draggedResource,
          dragDataType: "resource",
          eventName: "onDragMove",
          external: true,
          from: _this
        }));
        if (!_this._onCalendar) {
          moveClone(args, _this._clone);
          return;
        }
      }
      if (!_this._hasResY || _this._startDayIndex === dragRow.dayIndex) {
        if (distBottom < scrollThreshold && scrollContTop < scrollCont.scrollHeight - scrollCont.clientHeight) {
          var jump = _this._getScrollJump(distBottom);
          scrollCont.scrollTop += jump;
          hasScroll = true;
        }
        if (distTop < scrollThreshold && scrollContTop > 0) {
          var jump = _this._getScrollJump(distTop);
          scrollCont.scrollTop -= jump;
          hasScroll = true;
        }
        if (hasScroll) {
          _this._scrollY += scrollCont.scrollTop - scrollContTop;
          _this._scrollTimer = setTimeout(function() {
            _this._onResourceDragMove(args);
          }, 20);
        } else {
          _this._scrollStartTime = 0;
        }
        if (_this._draggedResourceEl) {
          var style = _this._draggedResourceEl.style;
          style.visibility = "visible";
          style.top = posY + headerHeight - scrollContTop + "px";
        }
        if (_this._draggedResourceLineEl) {
          var style = _this._draggedResourceLineEl.style;
          if (resource.isParent) {
            style.visibility = "hidden";
          } else {
            var resourceTop = _this._resourceTops[dragRow.rowKey];
            var nextResource = resources[resourceIndex + 1];
            var nextRowKey = nextResource ? _this._hasResY ? dragRow.dateKey + "-" + nextResource.id : nextResource.id : "";
            var nextResourceTop = nextResource ? _this._resourceTops[nextRowKey] : scrollCont.scrollHeight - headerHeight;
            insertAfter = posY - resourceTop > nextResourceTop - posY;
            style.visibility = "visible";
            style.top = (insertAfter ? nextResourceTop : resourceTop) + "px";
          }
        }
        var draggedResourceData = _this._resourcesData[draggedResource.id];
        var targetResource = _this._resourcesMap[resource.id];
        var _a = _this._getDragPos(draggedResource, targetResource), oldParent = _a.oldParent, newParent = _a.newParent, oldIndex = _a.oldIndex, newIndex = _a.newIndex;
        var draggedResourceInvalid = targetResource.children && targetResource === draggedResource || draggedResourceData && resourceIndex > _this._startResourceIndex && resourceIndex <= draggedResourceData.lastChildIndex || oldParent === newParent && oldIndex === newIndex;
        var hoverResource = targetResource.children && !draggedResourceInvalid ? targetResource.id : UNDEFINED;
        if (!dragData || dragData.draggedResourceInvalid !== draggedResourceInvalid || dragData.hoverResource !== hoverResource) {
          _this._dragData = {
            draggedResource,
            draggedResourceInvalid,
            draggedResourceVisible: true,
            hoverResource,
            originDate: _this._hasResY ? +new Date(dragRow.dateKey) : _this.s.selected,
            originResource: isExternal ? UNDEFINED : draggedResource.id
          };
          _this.setState({
            dragData: _this._dragData
          });
        }
        _this._tempResource = resource.id;
        _this._tempResourceNext = insertAfter;
      }
      if (resource.collapsed) {
        _this._expandTimer = setTimeout(function() {
          _this._toggleResource(resource, args.domEvent);
        }, 750);
      }
    };
    _this._onResourceDragEnd = function(args) {
      clearTimeout(_this._scrollTimer);
      clearTimeout(_this._expandTimer);
      var dragData = _this._dragData;
      var s = _this.s;
      var isExternal = args.external;
      if (dragData) {
        var draggedResource = dragData.draggedResource;
        var draggedResourceData = _this._resourcesData[draggedResource.id];
        var targetResource = _this._tempResource ? _this._resourcesMap[_this._tempResource] : UNDEFINED;
        var targetResourceData = targetResource && _this._resourcesData[targetResource.id];
        var _a = _this._getDragPos(draggedResource, targetResource), oldParent = _a.oldParent, newParent = _a.newParent, oldIndex = _a.oldIndex, newIndex = _a.newIndex;
        var draggedResourceInvalid = dragData.draggedResourceInvalid;
        if (s.externalResourceDrag && !isExternal) {
          dragObservable.next(__assign(__assign({}, args), {
            action: "externalDrop",
            clone: _this._clone,
            create: true,
            dragData: draggedResource,
            dragDataType: "resource",
            eventName: "onDragEnd",
            external: true,
            from: _this
          }));
          _this._ctx.removeChild(_this._clone);
          if (!_this._onCalendar) {
            draggedResourceInvalid = true;
            if (_this._resourceDropped) {
              var allowDelete = _this._hook("onResourceDelete", {
                domEvent: args.domEvent,
                index: oldIndex,
                parent: oldParent,
                resource: draggedResource
              }) !== false;
              if (allowDelete) {
                draggedResourceInvalid = false;
                _this._triggerDeleted = {
                  domEvent: args.domEvent,
                  index: oldIndex,
                  parent: oldParent,
                  resource: draggedResource
                };
              }
            }
          }
        }
        if (args.create) {
          var allowCreate = _this._hook("onResourceCreate", {
            domEvent: args.domEvent,
            index: newIndex,
            parent: newParent,
            resource: draggedResource
          }) !== false;
          if (allowCreate) {
            if (args.from) {
              args.from._resourceDropped = true;
            }
            _this._triggerCreated = {
              domEvent: args.domEvent,
              index: newIndex,
              parent: newParent,
              resource: draggedResource
            };
          } else {
            draggedResourceInvalid = true;
          }
        }
        _this._hook("onResourceDragEnd", {
          domEvent: args.domEvent,
          resource: draggedResource,
          source: "timeline"
        });
        if (!draggedResourceInvalid) {
          if (draggedResourceData) {
            draggedResourceData.siblings.splice(oldIndex, 1);
          }
          if (targetResource) {
            if (targetResource.children) {
              targetResource.children.push(draggedResource);
            } else if (targetResourceData) {
              targetResourceData.siblings.splice(newIndex, 0, draggedResource);
            }
          }
          var preventDrop = _this._hook("onResourceOrderUpdate", {
            index: newIndex,
            oldIndex,
            oldParent,
            parent: newParent,
            resource: draggedResource,
            resources: _this._resourcesCopy
          }) === false;
          if (preventDrop) {
            if (targetResource) {
              if (targetResource.children) {
                targetResource.children.pop();
              } else if (targetResourceData) {
                targetResourceData.siblings.splice(newIndex, 1);
              }
            }
            draggedResourceData.siblings.splice(oldIndex, 0, draggedResource);
            _this.setState({
              dragData: UNDEFINED
            });
          } else {
            _this._reloadResources = true;
            _this._shouldCheckSize = !_this.state.hasScrollY;
            _this.setState({
              dragData: {
                hoverResource: draggedResource.id
              }
            });
            setTimeout(function() {
              _this.setState({
                dragData: UNDEFINED
              });
            }, 600);
          }
        } else {
          _this.setState({
            dragData: UNDEFINED
          });
        }
        _this._dragData = UNDEFINED;
      }
    };
    _this._onEventDragModeOn = function(args) {
      if (_this.s.externalDrag && args.drag && !args.create) {
        dragObservable.next(__assign(__assign({}, args), {
          create: true,
          eventName: "onDragModeOn",
          external: true,
          from: _this
        }));
      }
      var event = args.create ? _this._tempEvent : args.eventData;
      var resource = args.create ? _this._tempResource : args.resource;
      var slot = args.create ? _this._tempSlot : args.slot;
      _this._dragData = {
        draggedEvent: event,
        originDates: args.external ? UNDEFINED : _this._getDragDates(event, resource, slot),
        resource
      };
      _this.setState({
        dragData: _this._dragData,
        isTouchDrag: true
      });
    };
    _this._onEventDragModeOff = function(args) {
      _this._hook("onEventDragEnd", {
        domEvent: args.domEvent,
        event: args.create ? _this._tempEvent.original : args.event,
        resource: _this._tempResource !== DEF_ID ? _this._tempResource : UNDEFINED,
        resourceObj: _this._tempResource !== DEF_ID ? _this._resourcesMap[_this._tempResource] : UNDEFINED,
        slot: _this._tempSlot !== DEF_ID ? _this._tempSlot : UNDEFINED,
        slotObj: _this._tempSlot !== DEF_ID ? _this._slotsMap[_this._tempSlot] : UNDEFINED,
        source: _this._isTimeline ? "timeline" : "schedule"
      });
      _this._dragData = UNDEFINED;
      _this.setState({
        dragData: UNDEFINED,
        isTouchDrag: false
      });
    };
    _this._onEventDragStart = function(args) {
      var s = _this.s;
      var isClick = args.click;
      var isListing = s.eventList;
      var isTimeline = _this._isTimeline;
      var resources = _this._visibleResources;
      var slots = _this._slots;
      var timeStep = s.dragTimeStep;
      var startX = args.startX;
      var startY = args.startY;
      _this._isTouch = args.isTouch;
      _this._scrollY = 0;
      _this._scrollX = 0;
      _this._calcGridSizes();
      var posX = s.rtl ? _this._gridRight - startX : startX - _this._gridLeft;
      var posY = constrain(startY - _this._gridTop, 8, _this._colHeight - 9);
      var cols = isListing ? _this._cols : _this._days;
      var colsNr = cols.length;
      var colWidth = _this._colWidth;
      var resourceTops = _this._resourceTops;
      var scrollContTop = _this._scrollCont.scrollTop;
      var rowKey;
      var resourceIndex = 0;
      var colIndex = colWidth ? floor(posX / colWidth) : 1;
      var dayIndex = colIndex;
      var slotIndex = 0;
      if (s.externalDrag && args.drag && !args.create) {
        var eventEl = args.target;
        var clone = eventEl.cloneNode(true);
        var cloneClass = clone.classList;
        clone.style.display = "none";
        cloneClass.add("mbsc-drag-clone", "mbsc-schedule-drag-clone", "mbsc-font");
        cloneClass.remove("mbsc-schedule-event-hover", "mbsc-active", "mbsc-focus");
        _this._clone = clone;
        _this._ctx = getContext(s.context, getDocument(_this._el));
        _this._ctx.appendChild(clone);
        _this._eventDropped = false;
        dragObservable.next(__assign(__assign({}, args), {
          clone,
          create: true,
          dragData: args.eventData.original,
          eventName: "onDragStart",
          external: true,
          from: _this
        }));
      }
      if (!isTimeline) {
        var dragCol = _this._getDragCol(posX);
        colIndex = dragCol.colIndex;
        dayIndex = dragCol.dayIndex;
        resourceIndex = dragCol.resourceIndex;
      } else {
        var dragRow = _this._getDragRow(posY, scrollContTop);
        slotIndex = colWidth ? floor(posX / (colWidth / slots.length)) % slots.length : 0;
        dayIndex = _this._hasResY ? dragRow.dayIndex : dayIndex;
        resourceIndex = dragRow.resourceIndex;
        rowKey = dragRow.rowKey;
      }
      dayIndex = constrain(dayIndex, 0, colsNr - 1);
      _this._startColIndex = colIndex;
      _this._startDayIndex = dayIndex;
      _this._startRow = rowKey;
      _this._startSlotIndex = slotIndex;
      var resource = args.external ? UNDEFINED : resources[resourceIndex];
      var resourceId = resource ? resource.id : UNDEFINED;
      var slot = args.external ? UNDEFINED : slots[slotIndex];
      var slotId = slot ? slot.id : UNDEFINED;
      if (args.create && resource && resource.eventCreation === false) {
        return false;
      }
      if (args.create) {
        var allDay = !isTimeline && s.showAllDay && args.endY < _this._gridContTop;
        var eventDay = s.type === "day" && s.size === 1 ? _this._firstDay : cols[dayIndex].date;
        var eventLength = !isListing && (args.external || isClick) ? _this._stepCell : timeStep * ONE_MIN;
        var gridTime = _this._getGridTime(eventDay, posX, posY, dayIndex, isClick ? _this._stepCell / ONE_MIN : timeStep);
        var newStart = !_this._isDailyResolution || allDay || isListing ? allDay ? eventDay : addTimezone(s, eventDay) : gridTime;
        var nextDay = s.resolution === "year" ? addMonths(newStart, 12, s) : s.resolution === "quarter" ? addMonths(newStart, 3, s) : s.resolution === "month" ? addMonths(newStart, 1, s) : s.resolution === "week" ? addDays(newStart, s.endDay - s.startDay + 1 + (s.endDay < s.startDay ? 7 : 0)) : addDays(newStart, 1);
        var allDayEnd = s.exclusiveEndDates ? nextDay : new Date(+nextDay - 1);
        var newEnd = allDay || isListing ? allDayEnd : roundTime(createDate$1(s, +newStart + eventLength), isClick ? 1 : timeStep);
        var eventData = s.extendDefaultEvent ? s.extendDefaultEvent({
          resource: resourceId,
          slot: slotId,
          start: newStart
        }) : UNDEFINED;
        var newEvent = __assign(__assign({
          allDay,
          end: newEnd,
          id: getEventId(),
          resource: resource && resourceId !== DEF_ID ? resourceId : UNDEFINED,
          slot: slot && slotId !== DEF_ID ? slotId : UNDEFINED,
          start: newStart,
          title: s.newEventText
        }, eventData), args.dragData);
        var ev = _this._getEventData(newEvent, eventDay, resource, slot);
        if (isTimeline) {
          ev.track = 0;
        }
        if (isTimeline && resourceId !== UNDEFINED && slotId !== UNDEFINED && _this._setRowHeight) {
          var dateKey = getDateStr(newStart);
          var key = _this._hasResY ? dateKey + "-" + resourceId : resourceId;
          var top_1 = posY - (_this._fixedResourceTops[resourceId] ? scrollContTop : 0) - resourceTops[key];
          if (_this._variableEventHeight) {
            var events = _this._events[resourceId][slotId][_this._hasSlots || _this._hasResY ? dateKey : "all"];
            var tracks = events && events.tracks || [];
            var i = 0;
            var height = 0;
            while (top_1 > height && i < tracks.length) {
              ev.track = i;
              height += tracks[i];
              i++;
            }
          } else {
            ev.position.top = constrain(floor(top_1 / _this._eventHeight), 0, _this._eventRows[resourceId] - 1);
          }
        }
        if (args.dragData) {
          var eventDuration = +ev.endDate - +ev.startDate;
          if (computeEventDragInTime(args.dragData.dragInTime, UNDEFINED, s.dragInTime)) {
            ev.startDate = eventDay;
            ev.endDate = new Date(+eventDay + eventDuration);
          }
        }
        _this._dragTime = floor(getDayMilliseconds(newStart) / _this._stepCell) * _this._stepCell;
        _this._tempEvent = ev;
        _this._tempResource = resourceId;
        _this._tempSlot = slotId;
      }
      _this._hook("onPopoverClose", {
        source: "dragStart"
      });
      if (!isClick) {
        _this._hook("onEventDragStart", {
          action: args.create ? "create" : args.resize ? "resize" : "move",
          domEvent: args.domEvent,
          event: (args.create ? _this._tempEvent : args.eventData).original,
          resource: resourceId !== DEF_ID ? resourceId : UNDEFINED,
          resourceObj: resourceId !== DEF_ID ? resource : UNDEFINED,
          slot: slotId !== DEF_ID ? slotId : UNDEFINED,
          slotObj: slotId !== DEF_ID ? slot : UNDEFINED,
          source: isTimeline ? "timeline" : "schedule"
        });
      }
      return true;
    };
    _this._onEventDragMove = function(args) {
      clearTimeout(_this._scrollTimer);
      clearTimeout(_this._expandTimer);
      var s = _this.s;
      var rtl = s.rtl;
      var rtlNr = rtl ? -1 : 1;
      var isTimeline = _this._isTimeline;
      var isListing = s.eventList;
      var isMonthYearResolution = s.resolution === "month" || s.resolution === "year";
      var cols = isListing ? _this._cols : _this._days;
      var colWidth = _this._colWidth;
      var colsNr = cols.length;
      var slots = _this._slots;
      var groupByResource = _this._groupByResource;
      var resources = _this._visibleResources;
      var dragData = _this._dragData;
      var timeStep = s.dragTimeStep;
      var timeFormat = s.timeFormat;
      var startX = args.startX;
      var endX = constrain(args.endX, _this._gridContLeft, _this._gridContRight - 1);
      var endY = constrain(args.endY, _this._gridContTop, _this._gridContBottom - 1);
      var deltaY = endY - args.startY + _this._scrollY;
      var deltaX = rtl ? startX - endX + _this._scrollX : endX - startX + _this._scrollX;
      var delta = isTimeline ? deltaX : deltaY;
      var daySize = isTimeline ? colWidth : _this._colHeight - 16;
      var gridWidth = _this._gridRight - _this._gridLeft - 1;
      var posX = constrain(rtl ? _this._gridRight + _this._scrollX - endX : endX - _this._gridLeft + _this._scrollX, 0, gridWidth);
      var posY = constrain(endY - _this._gridTop + _this._scrollY, 8, _this._colHeight - 9);
      var oldIndex = _this._startColIndex;
      var oldDayIndex = _this._startDayIndex;
      var inAllDay = s.showAllDay && args.endY < _this._gridContTop;
      var hasResY = _this._hasResY;
      var scrollCont = _this._scrollCont;
      var scrollContTop = scrollCont.scrollTop;
      var scrollContLeft = scrollCont.scrollLeft;
      var scrollThreshold = 50;
      var event = args.create ? _this._tempEvent : args.eventData;
      var origEvent = event.original;
      var draggedEvent = __assign({}, event);
      var newIndex = floor(posX / colWidth);
      var newDayIndex = newIndex;
      var resourceIndex = 0;
      var slotIndex = 0;
      var hasScroll = false;
      var distBottom = _this._gridContBottom - args.endY;
      var distTop = args.endY - _this._gridContTop - (isTimeline ? _this.state.headerHeight || 0 : 0);
      var distLeft = args.endX - _this._gridContLeft;
      var distRight = _this._gridContRight - args.endX;
      var maxScrollH = (scrollCont.scrollWidth - scrollCont.clientWidth) * rtlNr;
      var rightLimit = rtl ? 0 : maxScrollH;
      var leftLimit = rtl ? maxScrollH : 0;
      if (s.externalDrag && args.drag && !args.create) {
        dragObservable.next(__assign(__assign({}, args), {
          clone: _this._clone,
          create: true,
          dragData: origEvent,
          eventName: "onDragMove",
          external: true,
          from: _this
        }));
        if (!_this._onCalendar) {
          moveClone(args, _this._clone);
          if (!dragData) {
            _this._dragData = {
              draggedEvent
            };
            _this.setState({
              dragData: _this._dragData
            });
          }
          return;
        }
      }
      if (distBottom < scrollThreshold && scrollContTop < scrollCont.scrollHeight - scrollCont.clientHeight) {
        var jump = _this._getScrollJump(distBottom);
        scrollCont.scrollTop += jump;
        hasScroll = true;
      }
      if (distTop < scrollThreshold && !inAllDay && scrollContTop > 0) {
        var jump = _this._getScrollJump(distTop);
        scrollCont.scrollTop -= jump;
        hasScroll = true;
      }
      if (distLeft < scrollThreshold && scrollContLeft > leftLimit) {
        var jump = _this._getScrollJump(distLeft);
        scrollCont.scrollLeft -= jump;
        hasScroll = true;
      }
      if (distRight < scrollThreshold && scrollContLeft < rightLimit) {
        var jump = _this._getScrollJump(distRight);
        scrollCont.scrollLeft += jump;
        hasScroll = true;
      }
      if (hasScroll) {
        _this._scrollX += (scrollCont.scrollLeft - scrollContLeft) * rtlNr;
        _this._scrollY += scrollCont.scrollTop - scrollContTop;
        _this._scrollTimer = setTimeout(function() {
          _this._onEventDragMove(args);
        }, 20);
      } else {
        _this._scrollStartTime = 0;
      }
      if (!isTimeline) {
        var dragCol = _this._getDragCol(posX);
        newIndex = dragCol.colIndex;
        newDayIndex = dragCol.dayIndex;
        resourceIndex = dragCol.resourceIndex;
      } else {
        var dragRow = _this._getDragRow(posY, scrollContTop);
        slotIndex = floor(posX / (colWidth / slots.length)) % slots.length;
        resourceIndex = dragRow.resourceIndex;
        newDayIndex = hasResY ? dragRow.dayIndex : newDayIndex;
      }
      newDayIndex = constrain(newDayIndex, 0, colsNr - 1);
      var start = event.startDate;
      var end = event.endDate;
      var duration = +end - +start;
      var ms = _this._time;
      var timeDelta = floor(ms * delta / daySize);
      var resource = resources[resourceIndex];
      var hoverResource = resource.isParent && resource.eventCreation === false ? resource.id : UNDEFINED;
      var startResource = args.create ? _this._tempResource : args.resource;
      var startSlot = args.create ? _this._tempSlot : args.slot;
      if (resource.collapsed && resource.eventCreation === false) {
        _this._expandTimer = setTimeout(function() {
          _this._toggleResource(resource, args.domEvent);
        }, 750);
      }
      if (args.create && resource.eventCreation === false && _this._tempResource === UNDEFINED) {
        return false;
      }
      var slotId = slots[slotIndex].id;
      var resourceId = resource.eventCreation !== false || resource.id === startResource ? resource.id : _this._tempResource;
      var allDay = event.allDay;
      var tzOpt = allDay ? UNDEFINED : s;
      var addDayOnly = allDay || isListing;
      var newStart = start;
      var newEnd = end;
      var newDate;
      var isEventDraggableBetweenResources = true;
      var isEventDraggableBetweenSlots = true;
      var isEventDraggableInTime = true;
      var oldDay = cols[oldDayIndex].date;
      var newDay = cols[newDayIndex].date;
      var dayDelta = s.type === "day" && s.size === 1 ? 0 : getDayDiff(oldDay, newDay);
      var colDelta = newDayIndex - oldDayIndex;
      var months = s.resolution === "year" ? 12 : 1;
      var deltaDiff = dayDelta - colDelta;
      if (args.drag && !args.create || args.external) {
        if (!args.external) {
          isEventDraggableBetweenResources = computeEventDragBetweenResources(origEvent.dragBetweenResources, _this._resourcesMap[startResource].eventDragBetweenResources, s.dragBetweenResources);
          isEventDraggableBetweenSlots = computeEventDragBetweenSlots(origEvent.dragBetweenSlots, _this._resourcesMap[startResource].eventDragBetweenSlots, slots[_this._startSlotIndex || 0].eventDragBetweenSlots, s.dragBetweenSlots);
        }
        isEventDraggableInTime = computeEventDragInTime(origEvent.dragInTime, args.external || _this._resourcesMap[startResource].eventDragInTime, s.dragInTime);
      }
      if (args.drag || args.external) {
        if (!isTimeline && !isEventDraggableBetweenResources && startResource !== resourceId) {
          dayDelta = _this._dragDayDelta;
        }
        if (isTimeline && isListing && isMonthYearResolution) {
          newStart = addMonths(start, colDelta * months, s);
          newEnd = addMonths(end, colDelta * months, s);
        } else {
          allDay = inAllDay || isTimeline && event.allDay;
          addDayOnly = allDay || isListing;
          tzOpt = allDay ? UNDEFINED : s;
          if (!isTimeline && !inAllDay && (event.allDay || args.external) || isTimeline && args.external && !event.allDay && !isListing) {
            var day = getDateOnly(addDays(start, dayDelta));
            newStart = _this._getGridTime(day, posX, posY, newDayIndex, timeStep);
          } else {
            if (isTimeline && !addDayOnly && !hasResY) {
              newStart = roundTime(createDate$1(s, +start + timeDelta + (ONE_DAY - ms) * dayDelta + ms * deltaDiff), timeStep);
            } else {
              newDate = addDays(start, dayDelta);
              newStart = addDayOnly ? newDate : roundTime(createDate$1(tzOpt, +newDate + timeDelta), timeStep);
            }
          }
          if (resource.eventCreation === false && !isTimeline) {
            newStart = createDate$1(s, _this._tempStart);
          }
          newEnd = createDate$1(tzOpt, +newStart + duration);
        }
      } else {
        var gridDelta = isTimeline ? colDelta : newIndex - oldIndex;
        var endResize = args.create ? gridDelta ? gridDelta > 0 : delta > 0 : args.direction === "end";
        var days = getDayDiff(start, end);
        if (!isTimeline && groupByResource && startResource !== resourceId) {
          dayDelta = _this._dragDayDelta;
        }
        if (endResize) {
          if (isTimeline && isListing && isMonthYearResolution) {
            newEnd = addMonths(end, colDelta * months, s);
          } else if (isTimeline && !addDayOnly && !hasResY) {
            newEnd = roundTime(createDate$1(s, +end + timeDelta + dayDelta * (ONE_DAY - ms) + ms * deltaDiff), timeStep);
          } else {
            newDate = addDays(end, Math.max(-days, dayDelta));
            newEnd = addDayOnly ? newDate : roundTime(createDate$1(tzOpt, +newDate + timeDelta), timeStep);
            if (!addDayOnly && (getDayMilliseconds(newEnd) > _this._endTime + 1 || newEnd >= addDays(getDateOnly(newDate), 1))) {
              newEnd = createDate$1(s, +getDateOnly(newDate) + _this._endTime + 1);
            }
          }
        } else {
          if (isTimeline && isListing && isMonthYearResolution) {
            newStart = addMonths(start, colDelta * months, s);
          } else if (isTimeline && !addDayOnly && !hasResY) {
            newStart = roundTime(createDate$1(s, +start + timeDelta + dayDelta * (ONE_DAY - ms) + ms * deltaDiff), timeStep);
          } else {
            newDate = addDays(start, Math.min(days, dayDelta));
            newStart = addDayOnly ? newDate : roundTime(createDate$1(tzOpt, +newDate + timeDelta), timeStep);
            if (!addDayOnly && (getDayMilliseconds(newStart) < _this._startTime || newStart < getDateOnly(newDate))) {
              newStart = createDate$1(s, +getDateOnly(newDate) + _this._startTime);
            }
          }
        }
        resourceId = startResource;
        if (addDayOnly && newEnd < newStart) {
          if (endResize) {
            newEnd = createDate$1(s, newStart);
          } else {
            newStart = createDate$1(s, newEnd);
          }
        }
        if (!addDayOnly && (newEnd < newStart || Math.abs(+newEnd - +newStart) < timeStep * ONE_MIN)) {
          if (endResize) {
            newEnd = createDate$1(s, +newStart + timeStep * ONE_MIN);
          } else {
            newStart = createDate$1(s, +newEnd - timeStep * ONE_MIN);
          }
        }
      }
      if (args.drag || args.external) {
        if (!isEventDraggableInTime) {
          newStart = start;
          newEnd = end;
          allDay = _this._tempAllDay;
        }
        if (!isEventDraggableBetweenResources) {
          resourceId = startResource;
        }
        if (!isEventDraggableBetweenSlots) {
          slotId = startSlot;
        }
      }
      if (_this._tempStart !== +newStart || _this._tempEnd !== +newEnd || _this._tempAllDay !== allDay || _this._tempResource !== resourceId || _this._tempSlot !== slotId || dragData && hoverResource !== dragData.hoverResource) {
        var startStr = void 0;
        var endStr = void 0;
        if (!_this._isDailyResolution) {
          startStr = formatDate(s.dateFormat, newStart, s);
          endStr = formatDate(s.dateFormat, getEndDate(s, allDay, newStart, newEnd), s);
        } else {
          startStr = formatDate(timeFormat, newStart, s);
          endStr = formatDate(timeFormat, newEnd, s);
        }
        draggedEvent.startDate = newStart;
        draggedEvent.endDate = newEnd;
        draggedEvent.start = startStr;
        draggedEvent.end = endStr;
        draggedEvent.allDay = allDay;
        draggedEvent.date = +newDay;
        if (origEvent.bufferAfter) {
          draggedEvent.bufferEnd = makeDate(+newEnd + origEvent.bufferAfter * 6e4, tzOpt);
        }
        if (origEvent.bufferBefore) {
          draggedEvent.bufferStart = makeDate(+newStart - origEvent.bufferBefore * 6e4, tzOpt);
        }
        _this._tempStart = +newStart;
        _this._tempEnd = +newEnd;
        _this._tempAllDay = allDay;
        _this._tempResource = resourceId;
        _this._tempSlot = slotId;
        _this._dragDelta = args.drag || args.external ? -1 : args.direction ? args.direction === "end" ? 1 : -1 : delta;
        _this._dragDayDelta = dayDelta;
        _this._dragData = {
          draggedDates: _this._getDragDates(draggedEvent, resourceId, slotId),
          draggedEvent,
          hoverResource,
          originDate: event.date,
          originDates: dragData && dragData.originDates,
          originResource: args.external ? UNDEFINED : startResource,
          resource: resourceId,
          slot: slotId
        };
        if (!allDay) {
          _this._onMouseMove(args.domEvent);
        }
        _this.setState({
          dragData: _this._dragData
        });
      }
      return true;
    };
    _this._onEventDragEnd = function(args) {
      clearTimeout(_this._scrollTimer);
      clearTimeout(_this._expandTimer);
      var s = _this.s;
      var isCreating = args.create;
      var state = _this.state;
      var dragData = _this._dragData;
      var eventLeft = false;
      if (s.externalDrag && args.drag && !args.create) {
        dragObservable.next(__assign(__assign({}, args), {
          action: "externalDrop",
          clone: _this._clone,
          create: true,
          dragData: args.eventData.original,
          eventName: "onDragEnd",
          external: true,
          from: _this
        }));
        _this._ctx.removeChild(_this._clone);
        if (!_this._onCalendar) {
          eventLeft = true;
          if (_this._eventDropped) {
            args.event = args.eventData.original;
            s.onEventDelete(args);
          }
        }
      }
      if (isCreating && !dragData) {
        dragData = {};
        dragData.draggedEvent = _this._tempEvent;
      }
      if (dragData && dragData.draggedEvent) {
        var showBuffer = s.showEventBuffer !== false;
        var event_1 = args.eventData;
        var draggedEvent_1 = dragData.draggedEvent;
        var origEvent = draggedEvent_1.original;
        var newStart = draggedEvent_1.startDate;
        var newEnd = draggedEvent_1.endDate;
        var newBufferStart = showBuffer && draggedEvent_1.bufferStart || newStart;
        var newBufferEnd = showBuffer && draggedEvent_1.bufferEnd || newEnd;
        var allDay = draggedEvent_1.allDay;
        var oldResource = isCreating && !args.external ? _this._tempResource : args.resource;
        var newResource = dragData.resource === UNDEFINED ? oldResource : dragData.resource;
        var eventResource = origEvent.resource === UNDEFINED ? newResource : origEvent.resource;
        var oldSlot = isCreating ? _this._tempSlot : args.slot;
        var newSlot = dragData.slot === UNDEFINED ? oldSlot : dragData.slot;
        var invalids = {};
        var events = {};
        var isTimeline = _this._isTimeline;
        var source = isTimeline ? "timeline" : "schedule";
        var changed = isCreating || +newStart !== +event_1.startDate || +newEnd !== +event_1.endDate || allDay !== event_1.allDay || oldResource !== newResource || oldSlot !== newSlot;
        var updatedResource = eventResource;
        var collisionResources = void 0;
        if (oldResource !== newResource && (!isCreating && !_this._isSingleResource || args.external)) {
          if (isArray(eventResource) && eventResource.length && newResource !== UNDEFINED) {
            var indx = eventResource.indexOf(oldResource);
            if (eventResource.indexOf(newResource) === -1) {
              updatedResource = __spreadArray([], eventResource, true);
              updatedResource.splice(indx, 1, newResource);
            }
          } else {
            updatedResource = newResource;
          }
        }
        if (!updatedResource || !s.resources) {
          collisionResources = _this._resources.map(function(r2) {
            return r2.id;
          });
        } else {
          collisionResources = isArray(updatedResource) ? updatedResource : [updatedResource];
        }
        var newRes = _this._resourcesMap[newResource];
        var allowOverlap_1 = origEvent.overlap !== false && newRes.eventOverlap !== false && s.eventOverlap !== false;
        for (var _i = 0, collisionResources_1 = collisionResources; _i < collisionResources_1.length; _i++) {
          var r = collisionResources_1[_i];
          if (_this._invalids[r]) {
            invalids[r] = _this._invalids[r][newSlot];
          }
          if (_this._events[r]) {
            var possibleOverlaps = {};
            var eventsForResource = _this._events[r][newSlot];
            for (var _a = 0, _b = Object.keys(eventsForResource); _a < _b.length; _a++) {
              var dateKey = _b[_a];
              var eventsForDay = eventsForResource[dateKey];
              possibleOverlaps[dateKey] = {
                allDay: eventsForDay.allDay.filter(function(e) {
                  return e.id !== draggedEvent_1.id && (!allowOverlap_1 || e.original.overlap === false);
                }),
                data: eventsForDay.data.filter(function(e) {
                  return e.id !== draggedEvent_1.id && (!allowOverlap_1 || e.original.overlap === false);
                })
              };
            }
            events[r] = possibleOverlaps;
          }
        }
        var action = args.action || (state.dragData ? "drag" : "click");
        var allowUpdate = !eventLeft && (changed ? s.eventDragEnd({
          action,
          collision: checkCollision(invalids, newBufferStart, newBufferEnd, allDay, true, s.invalidateEvent, s),
          create: isCreating,
          domEvent: args.domEvent,
          event: draggedEvent_1,
          external: args.external,
          from: args.from,
          newResource,
          newSlot,
          oldResource,
          oldResourceObj: _this._resourcesMap[oldResource],
          oldSlot,
          oldSlotObj: _this._slotsMap[oldSlot],
          overlap: checkCollision(events, newBufferStart, newBufferEnd, allDay, isTimeline, "strict", s),
          resource: updatedResource !== DEF_ID ? updatedResource : UNDEFINED,
          resourceObj: newResource !== DEF_ID ? _this._resourcesMap[newResource] : UNDEFINED,
          slot: newSlot !== DEF_ID ? newSlot : UNDEFINED,
          slotObj: _this._slotsMap[newSlot],
          source
        }) : true);
        var keepDragMode = state.isTouchDrag && !eventLeft && (!isCreating || allowUpdate);
        if (allowUpdate && keepDragMode && oldResource !== newResource && !origEvent.color) {
          var resColor = newRes && newRes.color;
          if (resColor) {
            draggedEvent_1.color = resColor;
            draggedEvent_1.style.background = resColor;
            draggedEvent_1.style.color = getTextColor(resColor);
          } else {
            draggedEvent_1.color = UNDEFINED;
            draggedEvent_1.style = {};
          }
        }
        if (!keepDragMode && action !== "click") {
          _this._hook("onEventDragEnd", {
            domEvent: args.domEvent,
            event: (isCreating ? _this._tempEvent : event_1).original,
            resource: newResource !== DEF_ID ? newResource : UNDEFINED,
            resourceObj: newResource !== DEF_ID ? _this._resourcesMap[newResource] : UNDEFINED,
            slot: newSlot !== DEF_ID ? newSlot : UNDEFINED,
            slotObj: newSlot !== DEF_ID ? _this._slotsMap[newSlot] : UNDEFINED,
            source
          });
        }
        _this._dragData = keepDragMode ? {
          draggedEvent: allowUpdate ? draggedEvent_1 : __assign({}, event_1),
          originDate: allowUpdate ? draggedEvent_1.date : event_1.date,
          originDates: allowUpdate ? _this._getDragDates(draggedEvent_1, newResource, newSlot) : dragData.originDates,
          originResource: allowUpdate ? newResource : dragData.originResource
        } : UNDEFINED;
        _this.setState({
          dragData: _this._dragData,
          isTouchDrag: keepDragMode
        });
        _this._tempStart = 0;
        _this._tempEnd = 0;
        _this._tempAllDay = UNDEFINED;
        _this._dragDelta = UNDEFINED;
        _this._dragTime = UNDEFINED;
        _this._onMouseMove(args.domEvent);
        _this._isTouch = false;
      }
    };
    _this._onExternalDrag = function(args) {
      var s = _this.s;
      var clone = args.clone;
      var isSelf = args.from === _this;
      var isResourceDrag = args.dragData && args.dragDataType === "resource";
      var externalResourceDrop = isResourceDrag && !isSelf && s.externalResourceDrop;
      var externalDrop = !isResourceDrag && !isSelf && s.externalDrop;
      var instantDrag = !isResourceDrag && isSelf && s.externalDrag && !s.dragToMove;
      var dragData = _this._dragData;
      var resourceArgs = args;
      if (externalDrop || externalResourceDrop || s.externalDrag || s.externalResourceDrag) {
        var isInArea = !instantDrag && args.endY < _this._gridContBottom && args.endY > _this._allDayTop && args.endX > _this._gridContLeft - (isResourceDrag ? s.rtl ? 0 : _this._resourceWidth : 0) && args.endX < _this._gridContRight + (isResourceDrag ? s.rtl ? _this._resourceWidth : 0 : 0);
        switch (args.eventName) {
          case "onDragModeOff":
            if (externalDrop) {
              _this._onEventDragModeOff(args);
            }
            break;
          case "onDragModeOn":
            if (externalDrop) {
              _this._onEventDragModeOn(args);
            }
            break;
          case "onDragStart":
            if (externalResourceDrop) {
              _this._onResourceDragStart(resourceArgs);
            } else if (externalDrop) {
              _this._onEventDragStart(args);
            } else if (isSelf) {
              _this._onCalendar = true;
            }
            break;
          case "onDragMove":
            if (!isSelf && !externalDrop && !externalResourceDrop) {
              return;
            }
            if (isInArea) {
              if (!_this._onCalendar) {
                if (isResourceDrag && (s.externalResourceDrag || s.externalResourceDrop)) {
                  _this._hook("onResourceDragEnter", {
                    domEvent: resourceArgs.domEvent,
                    resource: resourceArgs.dragData,
                    source: "timeline"
                  });
                } else if (s.externalDrag || s.externalDrop) {
                  _this._hook("onEventDragEnter", {
                    domEvent: args.domEvent,
                    event: args.dragData,
                    source: _this._isTimeline ? "timeline" : "schedule"
                  });
                }
              }
              if (isSelf || externalDrop && _this._onEventDragMove(args) !== false || externalResourceDrop && _this._onResourceDragMove(resourceArgs) === UNDEFINED) {
                clone.style.display = "none";
              }
              _this._onCalendar = true;
            } else {
              if (_this._onCalendar) {
                if (isResourceDrag && (s.externalResourceDrag || s.externalResourceDrop)) {
                  _this._hook("onResourceDragLeave", {
                    domEvent: resourceArgs.domEvent,
                    resource: resourceArgs.dragData,
                    source: "timeline"
                  });
                  clearTimeout(_this._scrollTimer);
                  clone.style.display = "";
                } else if (s.externalDrag || s.externalDrop) {
                  _this._hook("onEventDragLeave", {
                    domEvent: args.domEvent,
                    event: args.dragData,
                    source: _this._isTimeline ? "timeline" : "schedule"
                  });
                  clearTimeout(_this._scrollTimer);
                  clone.style.display = "table";
                }
                if (!isSelf || dragData) {
                  _this._dragData = {
                    draggedDates: {},
                    draggedEvent: isSelf ? dragData && dragData.draggedEvent : UNDEFINED,
                    draggedResource: isSelf ? dragData && dragData.draggedResource : UNDEFINED,
                    draggedResourceVisible: false,
                    originDate: isSelf ? dragData && dragData.originDate : UNDEFINED,
                    originDates: isSelf ? dragData && dragData.originDates : UNDEFINED,
                    originResource: isSelf ? dragData && dragData.originResource : UNDEFINED
                  };
                  _this.setState({
                    dragData: _this._dragData
                  });
                }
                _this._tempStart = 0;
                _this._tempEnd = 0;
                _this._tempAllDay = UNDEFINED;
                _this._tempResource = UNDEFINED;
                _this._dragDelta = UNDEFINED;
                _this._onCalendar = false;
                _this._onMouseLeave(UNDEFINED, true);
              }
            }
            break;
          case "onDragEnd":
            if (externalDrop || externalResourceDrop) {
              if (isInArea && _this._tempResource !== UNDEFINED) {
                if (externalResourceDrop) {
                  _this._onResourceDragEnd(resourceArgs);
                } else if (externalDrop) {
                  _this._onEventDragEnd(args);
                }
              } else {
                _this._dragData = UNDEFINED;
                _this.setState({
                  dragData: UNDEFINED,
                  isTouchDrag: false
                });
                _this._hook("onEventDragEnd", {
                  domEvent: args.domEvent,
                  event: args.dragData,
                  resource: args.resource,
                  resourceObj: args.resource !== DEF_ID ? _this._resourcesMap[args.resource] : UNDEFINED,
                  slot: args.slot,
                  slotObj: args.slot !== DEF_ID ? _this._slotsMap[args.slot] : UNDEFINED,
                  source: args.source
                });
              }
            }
            break;
        }
      }
    };
    return _this;
  }
  STBase2.prototype._isToday = function(d) {
    return isSameDay(new Date(d), createDate$1(this.s));
  };
  STBase2.prototype._toggleResource = function(resource, domEvent) {
    resource.collapsed = !resource.collapsed;
    this._hook(resource.collapsed ? "onResourceCollapse" : "onResourceExpand", {
      domEvent,
      resource: resource.id,
      resourceObj: resource
    });
    this._visibleResources = this._flattenResources(this._resourcesCopy, [], 0);
    this._shouldCheckSize = true;
    this._isParentClick = true;
    this._calcRowHeights = true;
    this.forceUpdate();
  };
  STBase2.prototype._getEventPos = function(event, day, dateKey, displayedMap) {
    var s = this.s;
    var tzOpt = event.allDay ? UNDEFINED : s;
    var d = createDate$1(tzOpt, day.getFullYear(), day.getMonth(), day.getDate());
    var nextDay = getDateOnly(addDays(d, 1));
    var firstDay = tzOpt ? this._firstDayTz : this._firstDay;
    var lastDay = tzOpt ? this._lastDayTz : this._lastDay;
    var isTimeline = this._isTimeline;
    var groupByDate = !isTimeline && !this._groupByResource;
    var isAllDay = event.allDay;
    var origEvent = event.original;
    var startTime = this._startTime;
    var endTime = this._endTime + 1;
    var displayedTime = this._time;
    var hasSlots = this._hasSlots;
    var hasResY = this._hasResY;
    var isDailyResolution = this._isDailyResolution;
    var isListing = s.eventList;
    var bufferAfter = "";
    var bufferBefore = "";
    var bufferStart = event.bufferStart;
    var bufferEnd = event.bufferEnd;
    var dayIndex = hasResY ? 0 : this._dayIndexMap[dateKey];
    var start = event.start;
    var end = event.end;
    var startDate = getEventLayoutStart(event, s, isListing, isTimeline, isDailyResolution, firstDay, this._cols, this._colIndexMap);
    var endDate = getEventLayoutEnd(event, s, isListing, isTimeline, isDailyResolution, lastDay, this._cols, this._colIndexMap);
    var adjust = +startDate === +endDate ? 1 : 0;
    var showBuffer = s.showEventBuffer !== false && !isListing && !isAllDay;
    if (!(isAllDay || isTimeline) || hasResY && !hasSlots) {
      if (startDate < d) {
        start = "";
        startDate = createDate$1(s, d);
      }
      if (endDate >= nextDay) {
        end = "";
        endDate = createDate$1(s, +nextDay - 1);
      }
      if (endDate >= nextDay) {
        endDate = createDate$1(s, +nextDay - 1);
      }
    }
    if (isAllDay || isTimeline) {
      if (!displayedMap.get(origEvent) || hasSlots || hasResY || groupByDate) {
        var startDay = s.startDay;
        var endDay = s.endDay;
        var isFullDay = isAllDay || isListing;
        var isMultiDay = !isSameDay(startDate, endDate);
        var daysNr = this._daysNr;
        if (isTimeline && isMultiDay && getDayMilliseconds(startDate) >= endTime) {
          startDate = createDate$1(s, +getDateOnly(startDate) + endTime);
        }
        var eventTime = calcTimelineTime(startDate, endDate, firstDay, lastDay, startTime, endTime, startDay, endDay, isFullDay);
        var offset = getEventStart(startDate, startTime, displayedTime, firstDay, startDay, endDay);
        var width = eventTime * 100 / displayedTime;
        if (showBuffer && bufferStart) {
          var t = calcTimelineTime(bufferStart, startDate, firstDay, lastDay, startTime, endTime, startDay, endDay, isFullDay);
          bufferBefore = Math.max(0, t * 100 / eventTime) + "%";
        }
        if (showBuffer && bufferEnd) {
          var t = calcTimelineTime(endDate, bufferEnd, firstDay, lastDay, startTime, endTime, startDay, endDay, isFullDay);
          bufferAfter = Math.max(0, t * 100 / eventTime) + "%";
        }
        if (isTimeline) {
          var diff = 0;
          if (isListing && !isDailyResolution) {
            dayIndex = this._dayIndexMap[getDateStr(startDate)];
          }
          if (s.resolution === "month" || s.resolution === "quarter") {
            var startDayDiff = this._days[dayIndex].dayDiff;
            var endKey = getDateStr(endDate >= lastDay ? addDays(lastDay, -1) : endDate);
            var endIndex = this._dayIndexMap[endKey];
            var endDayDiff = this._days[endIndex].dayDiff;
            diff = endDayDiff - startDayDiff;
          }
          width = (width + diff * 100) / daysNr;
          offset = ((isFullDay ? 0 : offset) + dayIndex * 100) / daysNr;
        }
        var position = isTimeline ? {
          height: this._setRowHeight ? "" : "100%",
          left: s.rtl || hasSlots ? "" : offset + "%",
          right: s.rtl && !hasSlots ? offset + "%" : "",
          width: hasSlots ? "" : width + "%"
        } : {
          width: (isMultiDay && !groupByDate ? width : 100) + "%"
        };
        var isStartInView = getDayMilliseconds(startDate) < endTime && endDate > firstDay;
        var isEndInView = getDayMilliseconds(endDate) + adjust > startTime;
        if ((isFullDay || isMultiDay) && (width > 0 || hasSlots) || isStartInView && isEndInView) {
          displayedMap.set(origEvent, true);
          return {
            bufferAfter,
            bufferBefore,
            end,
            endDate,
            offset,
            position,
            start,
            startDate
          };
        }
      }
    } else {
      if (getDayMilliseconds(startDate) < endTime && getDayMilliseconds(endDate) + adjust > startTime && endDate >= startDate) {
        var eventTime = calcSchedulerTime(startDate, endDate, startTime, endTime);
        var eventHeight = eventTime * 100 / displayedTime;
        if (showBuffer && bufferStart) {
          if (!isSameDay(bufferStart, startDate)) {
            bufferStart = createDate$1(s, +getDateOnly(startDate) + startTime);
          }
          var bufferTime = calcSchedulerTime(bufferStart, startDate, startTime, endTime);
          bufferBefore = bufferTime * 100 / eventTime + "%";
        }
        if (showBuffer && bufferEnd) {
          if (!isSameDay(bufferEnd, startDate)) {
            bufferEnd = createDate$1(s, +getDateOnly(startDate) + endTime - 1);
          }
          var bufferTime = calcSchedulerTime(endDate, bufferEnd, startTime, endTime);
          bufferAfter = bufferTime * 100 / eventTime + "%";
        }
        return {
          bufferAfter,
          bufferBefore,
          cssClass: eventHeight < 2 ? " mbsc-schedule-event-small-height" : "",
          end,
          endDate,
          position: {
            height: eventHeight + "%",
            top: getEventStart(startDate, startTime, displayedTime) + "%",
            width: "100%"
          },
          start,
          startDate
        };
      }
    }
    return UNDEFINED;
  };
  STBase2.prototype._getEventData = function(event, d, resource, slot, skipLabels) {
    var s = this.s;
    var isListing = s.eventList;
    var showBuffer = s.showEventBuffer !== false;
    var cols = this._cols;
    var colIndexMap = this._colIndexMap;
    var isTimeline = this._isTimeline;
    var isDailyResolution = this._isDailyResolution;
    var resId = resource ? resource.id : DEF_ID;
    var slotId = slot ? slot.id : DEF_ID;
    var first = event.allDay ? this._firstDay : this._firstDayTz;
    var last = event.allDay ? this._lastDay : this._lastDayTz;
    var ev = getEventData(s, event, d, true, resource, slot, false, !isTimeline || this._hasResY, this._isDailyResolution, skipLabels);
    ev.key = resId + "_" + slotId + "_" + (this._hasSlots || this._hasResY || !isTimeline ? getDateStr(d) : "all") + "_" + ev.uid;
    ev.layoutStart = +getEventLayoutStart(ev, s, isListing, isTimeline, isDailyResolution, first, cols, colIndexMap, showBuffer);
    ev.layoutEnd = +getEventLayoutEnd(ev, s, isListing, isTimeline, isDailyResolution, last, cols, colIndexMap, showBuffer);
    if (ev.layoutStart === ev.layoutEnd) {
      ev.layoutEnd += 1;
    }
    if (event.allDay && s.exclusiveEndDates && +ev.endDate === +ev.startDate) {
      ev.endDate = getDateOnly(addDays(ev.startDate, 1));
    }
    return ev;
  };
  STBase2.prototype._getEvents = function(eventMap) {
    var _this = this;
    var s = this.s;
    var resources = this._resources;
    var slots = this._slots;
    var hasSlots = this._hasSlots;
    var hasResY = this._hasResY;
    var isTimeline = this._isTimeline;
    var isSchedule = !isTimeline;
    var events = {};
    var eventMaps = getResourceMap(eventMap, resources, slots, !!s.resources, !!s.slots);
    var eventLabels = {};
    var firstDay = this._firstDay;
    var lastDay = this._lastDay;
    var variableEvent = this._variableEventHeight;
    var variableRow = this._setRowHeight;
    var connectionMap = {};
    var cols = this._cols;
    var allKey = "all";
    var createEventMaps = this._createEventMaps || s.renderHour || s.renderHourFooter || s.renderDay || s.renderDayFooter || s.renderWeek || s.renderWeekFooter || s.renderMonth || s.renderMonthFooter || s.renderQuarter || s.renderQuarterFooter || s.renderYear || s.renderYearFooter;
    if (createEventMaps) {
      cols.forEach(function(c2) {
        return c2.eventMap = {
          all: []
        };
      });
    }
    if (s.connections) {
      for (var _i = 0, _a = s.connections; _i < _a.length; _i++) {
        var c = _a[_i];
        connectionMap[c.from] = true;
        connectionMap[c.to] = true;
      }
    }
    var _loop_1 = function(resource2) {
      var resourceId = resource2.id;
      var eventDisplayMap = /* @__PURE__ */ new Map();
      var eventRows = 0;
      var groups = [];
      var next = {};
      var processGroups = function(dateKey, date, slot2) {
        var slotId = slot2 ? slot2.id : DEF_ID;
        var tracks = [];
        for (var n = 0; n < groups.length; n++) {
          var group = groups[n];
          var nr = group.stacks.length;
          var moreNr = group.more.length;
          if (variableRow && nr > eventRows) {
            eventRows = nr;
          }
          for (var i = 0; i < nr; i++) {
            if (tracks[i] === UNDEFINED) {
              tracks[i] = 0;
            }
            for (var _i2 = 0, _a2 = group.stacks[i]; _i2 < _a2.length; _i2++) {
              var event_2 = _a2[_i2];
              event_2.track = variableEvent ? i : 0;
              if (!hasSlots) {
                var add = isTimeline && moreNr && !variableRow ? 1 : 0;
                var dimension = ((next[event_2.uid] || nr + add) - i) / (nr + add) * 100;
                if (isSchedule) {
                  event_2.position.width = dimension + "%";
                  event_2.position[s.rtl ? "right" : "left"] = i * 100 / nr + "%";
                  event_2.position[s.rtl ? "left" : "right"] = "auto";
                } else {
                  event_2.position.height = variableRow ? "" : dimension + "%";
                  event_2.position.top = variableEvent ? 0 : variableRow ? i : i * 100 / (nr + add) + "%";
                }
              }
            }
          }
          if (moreNr) {
            var moreStart = void 0;
            var moreEnd = void 0;
            for (var _b2 = 0, _c78 = group.more; _b2 < _c78.length; _b2++) {
              var event_3 = _c78[_b2];
              if (!moreStart || event_3.startDate < moreStart) {
                moreStart = event_3.startDate;
              }
              if (!moreEnd || event_3.endDate > moreEnd) {
                moreEnd = event_3.endDate;
              }
            }
            var moreDate = date || new Date(group.more[0].date);
            var moreDateKey = getDateStr(moreDate);
            var key = "more-" + (isSchedule || hasResY ? moreDateKey + "-" : "") + resourceId;
            var mText = s.moreEventsText || "";
            var moreText = (moreNr > 1 ? s.moreEventsPluralText || mText : mText).replace(/{count}/, moreNr);
            var moreData = _this._getEventData({
              color: "#ddd",
              cssClass: "mbsc-schedule-event-more",
              editable: false,
              end: moreEnd,
              id: key + (hasSlots ? (hasResY ? "" : "-" + moreDateKey) + "-" + slotId : "") + "-" + n,
              more: group.more,
              start: moreStart,
              text: (isSchedule ? "+" : "") + (isTimeline ? moreText : moreNr)
            }, moreDate, resource2, slot2);
            var morePos = _this._getEventPos(moreData, moreDate, moreDateKey, eventDisplayMap);
            if (morePos) {
              moreData.position = morePos.position;
              if (isTimeline) {
                moreData.offset = morePos.offset;
                moreData.position.height = variableRow ? "" : 100 / (nr + 1) + "%";
                moreData.position.top = hasSlots ? "" : variableRow ? nr : nr * 100 / (nr + 1) + "%";
                moreData.track = variableEvent ? nr : 0;
                tracks[nr] = 0;
                events[resourceId][slotId][hasResY || hasSlots ? moreDateKey : allKey].data.push(moreData);
              } else {
                moreData.showText = true;
                moreData.position.width = "24px";
                moreData.position[s.rtl ? "right" : "left"] = "auto";
                moreData.position[s.rtl ? "left" : "right"] = "-24px";
                events[resourceId][slotId][moreDateKey].hasMore = true;
                events[resourceId][slotId][moreDateKey].data.push(moreData);
              }
            }
            _this._eventRows[key] = 1;
          }
        }
        events[resourceId][slotId][dateKey].tracks = tracks;
      };
      events[resourceId] = {};
      var _loop_2 = function(slot2) {
        var slotId = slot2.id;
        var eventsForSlot = eventMaps[resourceId][slotId];
        var eventKeys = Object.keys(eventsForSlot).sort();
        events[resourceId][slotId] = {
          all: {
            allDay: [],
            data: []
          }
        };
        if (isSchedule) {
          eventLabels[slotId] = getLabels(s, eventsForSlot, firstDay, lastDay, -1, this_1._daysNr, true, s.startDay, false);
        }
        var _loop_3 = function(dateKey2) {
          var d = eventMap[dateKey2].date;
          if (this_1._dayIndexMap[dateKey2] !== UNDEFINED && isInWeek(d.getDay(), s.startDay, s.endDay)) {
            var eventsForDay = sortEvents(eventsForSlot[dateKey2], s) || [];
            if (isSchedule || hasResY || hasSlots) {
              groups = [];
              next = {};
            }
            events[resourceId][slotId][dateKey2] = {
              allDay: [],
              data: []
            };
            if (hasResY) {
              eventRows = this_1._eventRows[dateKey2 + "-" + resourceId] || 0;
            }
            for (var _e = 0, eventsForDay_1 = eventsForDay; _e < eventsForDay_1.length; _e++) {
              var ev = eventsForDay_1[_e];
              if (!ev.allDay || isTimeline) {
                var event_4 = this_1._getEventData(ev, d, resource2, slot2);
                var pos = this_1._getEventPos(event_4, d, dateKey2, eventDisplayMap);
                event_4.position = UNDEFINED;
                if (pos) {
                  event_4.cssClass = pos.cssClass;
                  event_4.offset = pos.offset;
                  event_4.position = pos.position;
                  event_4.bufferAfter = pos.bufferAfter;
                  event_4.bufferBefore = pos.bufferBefore;
                  if (isSchedule || hasResY) {
                    event_4.showText = true;
                  }
                  calcLayout(s, groups, event_4, next, this_1._maxEventStack || 1);
                  events[resourceId][slotId][allKey].data.push(event_4);
                  this_1._eventMap[event_4.id] = event_4;
                  if (createEventMaps) {
                    var timeStep = this_1._stepCell;
                    var isHoursResolution = this_1._isDailyResolution && timeStep < 1440 * ONE_MIN;
                    var firstDayTz = ev.allDay ? firstDay : addTimezone(s, firstDay);
                    var first = event_4.startDate > firstDayTz ? event_4.startDate : firstDayTz;
                    var colIndex = this_1._colIndexMap[getDateStr(first)];
                    var overlap = true;
                    while (overlap && colIndex < cols.length) {
                      var col = cols[colIndex];
                      var dtStart = col.date;
                      var dtEnd = colIndex < cols.length - 1 ? cols[colIndex + 1].date : lastDay;
                      var start = dtStart;
                      var addedToAll = false;
                      while (start < dtEnd) {
                        var ts = +start;
                        var end = isHoursResolution ? new Date(ts + timeStep) : dtEnd;
                        var colStart = ev.allDay ? dtStart : addTimezone(s, start);
                        var colEnd = ev.allDay ? dtEnd : addTimezone(s, end);
                        if (checkDateRangeOverlap(event_4.startDate, event_4.endDate, colStart, colEnd, true)) {
                          if (!col.eventMap[ts]) {
                            col.eventMap[ts] = [];
                          }
                          if (!addedToAll) {
                            col.eventMap.all.push(event_4.original);
                            addedToAll = true;
                          }
                          col.eventMap[ts].push(event_4.original);
                          overlap = true;
                        } else {
                          overlap = false;
                        }
                        start = end;
                      }
                      colIndex++;
                    }
                  }
                }
                events[resourceId][slotId][dateKey2].data.push(event_4);
                if (isTimeline && ev.allDay) {
                  events[resourceId][slotId][dateKey2].allDay.push(event_4);
                }
              }
            }
            if (isSchedule && eventLabels[slotId][dateKey2]) {
              eventLabels[slotId][dateKey2].data.forEach(function(labels) {
                return labels.forEach(function(_a2) {
                  var event = _a2.event, position = _a2.position;
                  if (event) {
                    var ev2 = _this._getEventData(event, d, resource2, slot2);
                    var pos2 = _this._getEventPos(ev2, d, dateKey2, eventDisplayMap);
                    if (pos2) {
                      ev2.bufferAfter = pos2.bufferAfter;
                      ev2.bufferBefore = pos2.bufferBefore;
                    }
                    ev2.position = {
                      width: pos2 ? pos2.position.width : position.width
                    };
                    ev2.showText = !!pos2;
                    events[resourceId][slotId][dateKey2].allDay.push(ev2);
                  }
                });
              });
            }
            if (isSchedule || hasResY || hasSlots) {
              processGroups(dateKey2, d, slot2);
            }
            if (hasResY) {
              this_1._eventRows[dateKey2 + "-" + resourceId] = eventRows;
            }
          } else if (s.connections) {
            var eventsForDay = eventsForSlot[dateKey2] || [];
            for (var _f = 0, eventsForDay_2 = eventsForDay; _f < eventsForDay_2.length; _f++) {
              var event_5 = eventsForDay_2[_f];
              var id2 = event_5.id;
              if (!this_1._eventMap[id2] && connectionMap[id2]) {
                this_1._eventMap[id2] = this_1._getEventData(event_5, d, resource2, slot2);
              }
            }
          }
        };
        for (var _d = 0, eventKeys_1 = eventKeys; _d < eventKeys_1.length; _d++) {
          var dateKey = eventKeys_1[_d];
          _loop_3(dateKey);
        }
      };
      for (var _c = 0, slots_1 = slots; _c < slots_1.length; _c++) {
        var slot = slots_1[_c];
        _loop_2(slot);
      }
      if (isTimeline && !hasSlots && !hasResY) {
        processGroups(allKey);
      }
      if (!hasResY) {
        this_1._eventRows[resourceId] = eventRows;
      }
    };
    var this_1 = this;
    for (var _b = 0, resources_1 = resources; _b < resources_1.length; _b++) {
      var resource = resources_1[_b];
      _loop_1(resource);
    }
    return events;
  };
  STBase2.prototype._getInvalids = function(invalidMap) {
    var _a;
    var s = this.s;
    var isListing = s.eventList;
    var map2 = invalidMap || {};
    var invalids = {};
    var minD = makeDate(s.minDate, s);
    var maxD = makeDate(s.maxDate, s);
    var minDate = isListing && minD ? getDateOnly(minD) : minD;
    var maxDate = isListing && maxD ? getDateOnly(addDays(maxD, 1)) : maxD;
    var isTimeline = this._isTimeline;
    if (minDate) {
      for (var d = getDateOnly(this._firstDayTz); d < minDate; d.setDate(d.getDate() + 1)) {
        var dateKey = getDateStr(d);
        var invalidsForDay = map2[dateKey] || [];
        invalidsForDay.push({
          end: isSameDay(d, minDate) ? minDate : addDays(d, 1),
          start: cloneDate(d)
        });
        map2[dateKey] = invalidsForDay;
      }
    }
    if (maxDate) {
      for (var d = getDateOnly(maxDate); d < this._lastDayTz; d.setDate(d.getDate() + 1)) {
        var dateKey = getDateStr(d);
        var invalidsForDay = map2[dateKey] || [];
        invalidsForDay.push({
          end: addDays(d, 1),
          start: isSameDay(d, maxDate) ? maxDate : cloneDate(d)
        });
        map2[dateKey] = invalidsForDay;
      }
    }
    var invalidMaps = getResourceMap(map2, this._resources, this._slots, !!s.resources, !!s.slots);
    var invalidKeys = Object.keys(map2).sort();
    for (var _i = 0, _b = this._resources; _i < _b.length; _i++) {
      var resource = _b[_i];
      var resourceId = resource.id;
      var invalidDisplayedMap = /* @__PURE__ */ new Map();
      invalids[resourceId] = {};
      for (var _c = 0, _d = this._slots; _c < _d.length; _c++) {
        var slot = _d[_c];
        var slotId = slot.id;
        var allInvalids = {
          allDay: [],
          data: []
        };
        invalids[resourceId][slotId] = {
          all: allInvalids
        };
        for (var _e = 0, invalidKeys_1 = invalidKeys; _e < invalidKeys_1.length; _e++) {
          var dateKey = invalidKeys_1[_e];
          var d = makeDate(dateKey);
          if (this._dayIndexMap[dateKey] !== UNDEFINED && isInWeek(d.getDay(), s.startDay, s.endDay)) {
            var invalidsForDay = invalidMaps[resourceId][slotId][dateKey] || [];
            var allDailyInvalids = {
              allDay: [],
              data: []
            };
            var dailyInvalids = [];
            invalids[resourceId][slotId][dateKey] = allDailyInvalids;
            for (var _f = 0, invalidsForDay_1 = invalidsForDay; _f < invalidsForDay_1.length; _f++) {
              var invalid = invalidsForDay_1[_f];
              if (isString(invalid) || isDate(invalid)) {
                var start = makeDate(invalid);
                var end = new Date(start);
                invalid = {
                  allDay: true,
                  end,
                  start
                };
              }
              var invalidData = this._getEventData(invalid, d, resource, slot, true);
              invalidData.cssClass = invalid.cssClass ? " " + invalid.cssClass : "";
              invalidData.position = UNDEFINED;
              var pos = this._getEventPos(invalidData, d, dateKey, invalidDisplayedMap);
              if (pos) {
                if (!isTimeline && getDayMilliseconds(pos.startDate) === 0 && +pos.endDate + 1 >= +addDays(addTimezone(s, d), 1)) {
                  invalidData.allDay = true;
                } else {
                  invalidData.position = pos.position;
                  if (getDayMilliseconds(pos.startDate) <= this._startTime) {
                    invalidData.cssClass += " mbsc-schedule-invalid-start";
                  }
                  if (getDayMilliseconds(pos.endDate) >= this._endTime) {
                    invalidData.cssClass += " mbsc-schedule-invalid-end";
                  }
                }
                dailyInvalids.push(invalidData);
              }
              allDailyInvalids.data.push(invalidData);
              if (invalidData.allDay) {
                if (!isTimeline) {
                  invalidData.position = {};
                  if (pos && +invalidData.startDate === +invalidData.endDate) {
                    invalidData.endDate = pos.endDate;
                  }
                }
                allDailyInvalids.allDay = [invalidData];
                allDailyInvalids.data = [invalidData];
                dailyInvalids = [invalidData];
                break;
              }
            }
            (_a = allInvalids.data).push.apply(_a, dailyInvalids);
          }
        }
      }
    }
    return invalids;
  };
  STBase2.prototype._getColors = function(colorMap) {
    var s = this.s;
    var colors = {};
    var colorMaps = getResourceMap(colorMap, this._resources, this._slots, !!s.resources, !!s.slots);
    var colorKeys = Object.keys(colorMap || {}).sort();
    var hasSlots = this._hasSlots;
    var isTimeline = this._isTimeline;
    var hasResY = this._hasResY;
    for (var _i = 0, _a = this._resources; _i < _a.length; _i++) {
      var resource = _a[_i];
      var resourceId = resource.id;
      var colorDisplayedMap = /* @__PURE__ */ new Map();
      colors[resourceId] = {};
      for (var _b = 0, _c = this._slots; _b < _c.length; _b++) {
        var slot = _c[_b];
        var slotId = slot.id;
        colors[resourceId][slotId] = {
          all: {
            allDay: [],
            data: []
          }
        };
        for (var _d = 0, colorKeys_1 = colorKeys; _d < colorKeys_1.length; _d++) {
          var dateKey = colorKeys_1[_d];
          var d = makeDate(dateKey);
          if (this._dayIndexMap[dateKey] !== UNDEFINED && isInWeek(d.getDay(), s.startDay, s.endDay)) {
            var colorsForDay = colorMaps[resourceId][slotId][dateKey] || [];
            var key = !hasResY && !hasSlots && isTimeline ? "all" : dateKey;
            if (!isTimeline || hasSlots || hasResY) {
              colors[resourceId][slotId][key] = {
                allDay: [],
                data: []
              };
            }
            var dailyColors = colors[resourceId][slotId][key];
            for (var _e = 0, colorsForDay_1 = colorsForDay; _e < colorsForDay_1.length; _e++) {
              var color = colorsForDay_1[_e];
              var colorData = this._getEventData(color, d, resource, slot, true);
              colorData.cssClass = color.cssClass ? " " + color.cssClass : "";
              if (colorData.allDay && !isTimeline) {
                dailyColors.allDay = [colorData];
              } else {
                var pos = this._getEventPos(colorData, d, dateKey, colorDisplayedMap);
                if (pos) {
                  colorData.position = pos.position;
                  if (getDayMilliseconds(pos.startDate) <= this._startTime) {
                    colorData.cssClass += " mbsc-schedule-color-start";
                  }
                  if (getDayMilliseconds(pos.endDate) >= this._endTime) {
                    colorData.cssClass += " mbsc-schedule-color-end";
                  }
                  dailyColors.data.push(colorData);
                }
              }
              colorData.position.background = color.background;
              colorData.position.color = color.textColor ? color.textColor : getTextColor(color.background);
            }
          }
        }
      }
    }
    return colors;
  };
  STBase2.prototype._flattenResources = function(resources, flat, depth, all, copy, fixed, parentId) {
    var res = resources && resources.length ? resources : [{
      id: DEF_ID
    }];
    var immutable = this.s.immutableData;
    if (depth === 0) {
      this._resourceDepth = 0;
    } else if (depth > this._resourceDepth) {
      this._resourceDepth = depth;
    }
    for (var i = 0; i < res.length; i++) {
      var resource = res[i];
      var r = copy && immutable ? __assign({}, resource) : resource;
      var children = r.children;
      if (immutable) {
        r.original = resource;
      }
      r.depth = depth;
      r.isParent = !!(children && children.length);
      r.fixed = r.fixed || fixed;
      flat.push(r);
      this._resourcesMap[r.id] = r;
      this._resourcesData[r.id] = {
        index: i,
        lastChildIndex: i,
        parentId,
        siblings: res
      };
      if (copy && (immutable || !depth)) {
        copy.push(r);
      }
      if (r.isParent) {
        this._hasHierarchy = true;
        if (!r.collapsed || all) {
          if (copy && immutable) {
            r.children = [];
          }
          this._flattenResources(children, flat, depth + 1, all, copy && r.children, r.fixed, r.id);
          this._resourcesData[r.id].lastChildIndex = flat.length - 1;
        }
      }
    }
    return flat;
  };
  STBase2.prototype._render = function(s, state) {
    var _this = this;
    var prevS = this._prevS;
    var isTimeline = this._isTimeline;
    var selected = new Date(s.selected);
    var size = +s.size;
    var firstDay = s.firstDay;
    var startDay = s.startDay;
    var endDay = s.endDay;
    var resources = s.resources;
    var slots = s.slots;
    var resolution = s.resolution;
    var isDailyResolution = resolution === "day" || resolution === "hour" || !isTimeline;
    var hasResY = s.resolutionVertical === "day";
    var stepLabel = isDailyResolution ? roundStep(s.timeLabelStep) : 1440;
    var stepCell = isDailyResolution ? roundStep(s.timeCellStep) : 1440;
    var calcDays = false;
    var reloadData = false;
    var resetRowHeights = false;
    var timesChanged = false;
    var viewChanged = false;
    var selectedChanged = false;
    var startTime = this._startTime;
    var endTime = this._endTime;
    if (s.selected !== prevS.selected) {
      selectedChanged = true;
    }
    if (s.zoomLevel !== prevS.zoomLevel && prevS.zoomLevel !== UNDEFINED) {
      this._scrollToMiddle = true;
    }
    if (s.columnWidth !== prevS.columnWidth) {
      viewChanged = true;
    }
    if (startDay !== prevS.startDay || endDay !== prevS.endDay || s.checkSize !== prevS.checkSize || s.eventList !== prevS.eventList || s.refDate !== prevS.refDate || s.size !== prevS.size || s.type !== prevS.type || s.resolution !== prevS.resolution || s.resolutionVertical !== prevS.resolutionVertical || s.displayTimezone !== prevS.displayTimezone || s.weekNumbers !== prevS.weekNumbers) {
      calcDays = true;
      viewChanged = true;
    }
    if (s.eventHeight !== prevS.eventHeight || s.eventList !== prevS.eventList || s.rowHeight !== prevS.rowHeight || s.maxEventStack !== prevS.maxEventStack) {
      resetRowHeights = true;
    }
    if (calcDays || resetRowHeights || s.rtl !== prevS.rtl || s.dateFormat !== prevS.dateFormat || s.getDay !== prevS.getDay) {
      reloadData = true;
    }
    if (s.slots !== prevS.slots || this._slots === UNDEFINED) {
      this._hasSlots = isTimeline && !!slots && slots.length > 0;
      this._slots = slots && slots.length ? slots : [{
        id: DEF_ID
      }];
      this._slotsMap = (slots || []).reduce(function(map2, res) {
        map2[res.id] = res;
        return map2;
      }, {});
      reloadData = true;
    }
    if (resources !== prevS.resources || this._resources === UNDEFINED || this._reloadResources) {
      this._resourcesData = {};
      this._resourcesMap = {};
      if (resources !== prevS.resources || this._resources === UNDEFINED) {
        this._hasResources = !!resources;
        this._hasHierarchy = false;
        this._resourcesCopy = [];
        this._resources = this._flattenResources(resources, [], 0, true, this._resourcesCopy);
      } else {
        this._resources = this._flattenResources(this._resourcesCopy, [], 0, true);
      }
      this._visibleResources = this._flattenResources(this._resourcesCopy, [], 0);
      this._isSingleResource = this._resources.length === 1;
      this._reloadResources = false;
      reloadData = true;
    }
    if (calcDays || selectedChanged || s.getDay !== prevS.getDay || s.monthNames !== prevS.monthNames || s.dateFormat !== prevS.dateFormat || s.currentTimeIndicator !== prevS.currentTimeIndicator) {
      var now = removeTimezone(createDate$1(s));
      var isDaily = s.type === "day";
      var isMonthly = s.type === "month";
      var isYearly = s.type === "year";
      var isDayViewOnly = isDaily && size < 2;
      var navService = s.navService;
      var monthPos = s.dateFormat.search(/m/i);
      var yearPos = s.dateFormat.search(/y/i);
      var datePos = s.dateFormat.search(/d/i);
      var yearFirst = yearPos < monthPos;
      var dayFirst = datePos < monthPos;
      var firstGridDay = void 0;
      var lastGridDay = void 0;
      var firstHeaderDay = void 0;
      var lastHeaderDay = void 0;
      if (size > 1 || isYearly || isMonthly) {
        firstHeaderDay = firstGridDay = navService.firstDay;
        lastHeaderDay = lastGridDay = navService.lastDay;
      } else {
        var firstWeekDay = getFirstDayOfWeek(selected, s);
        firstHeaderDay = addDays(firstWeekDay, startDay - firstDay + (startDay < firstDay ? 7 : 0));
        if (isDaily) {
          if (selected < firstHeaderDay) {
            firstHeaderDay = addDays(firstHeaderDay, -7);
          }
          if (selected >= addDays(firstHeaderDay, 7)) {
            firstHeaderDay = addDays(firstHeaderDay, 7);
          }
        }
        lastHeaderDay = addDays(firstHeaderDay, endDay - startDay + 1 + (endDay < startDay ? 7 : 0));
        firstGridDay = isDaily ? getDateOnly(selected) : firstHeaderDay;
        lastGridDay = isDaily ? addDays(firstGridDay, 1) : lastHeaderDay;
      }
      if (isTimeline && resolution === "week" && (isYearly || isMonthly)) {
        firstGridDay = navService.viewStart;
        lastGridDay = navService.viewEnd;
      }
      if (selectedChanged && isDaily && size < 2) {
        reloadData = true;
      }
      this._isMulti = size > 1 || isYearly;
      this._isDailyResolution = isDailyResolution;
      this._hasResY = hasResY;
      this._firstDayTz = createDate$1(s, firstGridDay.getFullYear(), firstGridDay.getMonth(), firstGridDay.getDate());
      this._lastDayTz = createDate$1(s, lastGridDay.getFullYear(), lastGridDay.getMonth(), lastGridDay.getDate());
      this._selectedDay = +getDateOnly(selected);
      this._showTimeIndicator = !s.eventList && (s.currentTimeIndicator === UNDEFINED ? !isTimeline || isDailyResolution && stepCell < 1440 : s.currentTimeIndicator) && (isDaily && size < 2 ? isSameDay(now, selected) : firstGridDay <= now && lastGridDay >= now);
      if (reloadData || +firstGridDay !== +this._firstDay || +lastGridDay !== +this._lastDay) {
        if (!reloadData) {
          resetRowHeights = true;
        }
        this._firstDay = firstGridDay;
        this._lastDay = lastGridDay;
        this._colIndexMap = {};
        this._cols = [];
        this._dayIndexMap = {};
        this._days = [];
        this._headerDays = [];
        var i = 0;
        var j = -1;
        var dayDiff = 0;
        var daysInMonth = 0;
        var year = -1;
        var columnTitle = "";
        var month = -1;
        var monthIndex = -1;
        var monthText = "";
        var week = -1;
        var weekIndex = -1;
        var weekText = "";
        var first = firstGridDay;
        var last = lastGridDay;
        var lastColStart = 0;
        var weekEndDay = UNDEFINED;
        var newWeek = 0;
        if (!isTimeline && isDayViewOnly) {
          first = firstHeaderDay;
          last = lastHeaderDay;
        }
        for (var d = getDateOnly(first); d < getDateOnly(last); d.setDate(d.getDate() + 1)) {
          var dateKey = getDateStr(d);
          var weekDay = d.getDay();
          this._dayIndexMap[dateKey] = i;
          if (isInWeek(weekDay, startDay, endDay)) {
            var lastOfMonth = void 0;
            var monthTitle = "";
            var weekTitle = "";
            var columnChange = isDailyResolution;
            if (isTimeline && !hasResY) {
              newWeek = s.getWeekNumber(addDays(d, (7 - firstDay + 1) % 7));
              var newDay = s.getDay(d);
              var newMonth = s.getMonth(d);
              var newYear = s.getYear(d);
              var monthName = s.monthNames[newMonth];
              if (year !== newYear) {
                year = newYear;
                if (resolution === "year") {
                  columnChange = true;
                  columnTitle = "" + year;
                }
              }
              if (month !== newMonth) {
                if (resolution === "month") {
                  columnTitle = isYearly && size < 2 ? monthName : yearFirst ? newYear + " " + monthName : monthName + " " + newYear;
                  columnChange = true;
                } else if (resolution === "quarter" && newMonth % 3 === 0) {
                  var quarterNumber = newMonth / 3 + 1;
                  var quarterText = s.quarterText.replace("{count}", "" + quarterNumber);
                  columnTitle = isYearly && size < 2 ? quarterText : yearFirst ? newYear + " " + quarterText : quarterText + " " + newYear;
                  columnChange = true;
                } else if (isDailyResolution) {
                  monthText = yearFirst ? newYear + " " + monthName : monthName + " " + newYear;
                  monthTitle = monthText;
                }
                monthIndex = i;
                month = newMonth;
                daysInMonth = s.getMaxDayOfMonth(year, month);
              }
              if (week !== newWeek) {
                weekIndex = i;
                week = newWeek;
                weekText = s.weekText.replace(/{count}/, week);
                weekTitle = weekText;
                if (i > 0) {
                  this._days[i - 1].lastOfWeek = true;
                }
              }
              if ((weekDay === startDay || !i) && resolution === "week") {
                var dateFormat = dayFirst ? "D MMM" : "MMM D";
                weekEndDay = addDays(d, endDay - startDay + (endDay < startDay ? 7 : 0));
                columnTitle = formatDate(dateFormat, d, s) + " - " + formatDate(dateFormat, weekEndDay, s);
                columnChange = true;
              }
              var hiddenWeekDays = (startDay - endDay - 1 + 7) % 7;
              lastOfMonth = newDay === daysInMonth || weekDay === endDay && hiddenWeekDays >= daysInMonth - newDay;
              if (lastOfMonth && (resolution === "month" || resolution === "quarter")) {
                dayDiff += 31 - daysInMonth;
              }
            }
            var dayData = {
              columnTitle,
              date: new Date(d),
              dateIndex: i,
              dateKey,
              dateText: formatDate(hasResY ? isMonthly && !this._isMulti ? "D DDD" : resources ? s.dateFormatLong : s.dateFormat : isMonthly || this._isMulti ? "D DDD" : s.dateFormatLong, d, s),
              day: s.getDay(d),
              dayDiff,
              dayName: dateTimeLocale.dayNamesShort[i % 7].toLowerCase(),
              endDate: weekEndDay,
              eventMap: {
                all: []
              },
              label: formatDate("DDDD, MMMM D, YYYY", d, s),
              lastOfMonth,
              monthIndex,
              monthText,
              monthTitle,
              times: [],
              timestamp: +getDateOnly(d),
              weekIndex,
              weekNr: newWeek,
              weekText,
              weekTitle
            };
            if (columnChange) {
              dayData.isActive = d <= now && now < last;
              if (lastColStart) {
                this._cols[j].isActive = lastColStart <= +now && now < d;
              }
              lastColStart = +d;
              this._cols.push(dayData);
              j++;
            }
            if (isDayViewOnly) {
              this._headerDays.push(dayData);
            }
            if (!isDayViewOnly || this._selectedDay === +d) {
              this._days.push(dayData);
            }
            if (lastOfMonth && (resolution === "month" || resolution === "quarter")) {
              for (var k = daysInMonth; k < 31; k++) {
                this._days.push(dayData);
                i++;
              }
            }
            i++;
          }
          this._colIndexMap[dateKey] = j < 0 ? 0 : j;
        }
        this._colsNr = hasResY ? 1 : j + 1;
        this._daysNr = hasResY || isDayViewOnly ? 1 : i;
      }
    }
    if (s.startTime !== prevS.startTime || s.endTime !== prevS.endTime || s.timeLabelStep !== prevS.timeLabelStep || s.timeCellStep !== prevS.timeCellStep || s.timeFormat !== prevS.timeFormat || this._startTime === UNDEFINED || this._endTime === UNDEFINED) {
      timesChanged = true;
      viewChanged = true;
    }
    if (timesChanged || !isTimeline && selectedChanged || !isTimeline && s.timezones !== prevS.timezones) {
      var start = makeDate(s.startTime || "00:00");
      var end = new Date(+makeDate(s.endTime || "00:00") - 1);
      var timezones = this._timezones || [{
        label: "",
        timezone: ""
      }];
      this._startTime = startTime = getDayMilliseconds(start);
      this._endTime = endTime = getDayMilliseconds(end);
      this._time = endTime - startTime + 1;
      this._timesBetween = getArray(floor(stepCell / stepLabel) - 1);
      this._times = [];
      var timeLabels_1 = [];
      var timeStep = stepCell * ONE_MIN;
      var timesFrom = floor(startTime / timeStep) * timeStep;
      var labelStep_1 = stepLabel * ONE_MIN;
      var formatTime_1 = function(v, timezone, log) {
        var format = s.timeFormat;
        var timeFormat = /a/i.test(format) && labelStep_1 === ONE_HOUR && v % ONE_HOUR === 0 ? format.replace(/.[m]+/i, "") : format;
        var d2 = new Date(+REF_DATE + v);
        var firstDate = d2;
        if (timezone) {
          firstDate = _this._firstDayTz;
          var nextDay = addDays(firstDate, 1);
          var firstDateEnd = createDate$1(s, +nextDay - 1);
          var isDSTDay = firstDate.getTimezoneOffset() !== firstDateEnd.getTimezoneOffset();
          if ((s.type !== "day" || size > 1 || v === endTime + 1 && getDayMilliseconds(d2) === 0) && isDSTDay) {
            firstDate = nextDay;
          }
        }
        var dd = createDate$1(s, firstDate.getFullYear(), firstDate.getMonth(), firstDate.getDate(), d2.getHours(), d2.getMinutes());
        if (isMBSCDate(dd) && timezone) {
          dd.setTimezone(timezone);
        }
        return formatDate(timeFormat, dd, s);
      };
      var _loop_4 = function(d2) {
        this_2._times.push(d2);
        var first2 = d2 === timesFrom;
        timezones.forEach(function(tz, i2) {
          if (!timeLabels_1[i2]) {
            timeLabels_1[i2] = {};
          }
          if (!timeLabels_1[i2][endTime + 1] && !isTimeline) {
            timeLabels_1[i2][endTime + 1] = formatTime_1(endTime + 1, tz.timezone, true);
          }
          timeLabels_1[i2][d2] = first2 || d2 % labelStep_1 === 0 ? formatTime_1(first2 ? startTime : d2, tz.timezone) : "";
          _this._timesBetween.forEach(function(tb, j2) {
            var ms = d2 + (j2 + 1) * labelStep_1;
            timeLabels_1[i2][ms] = formatTime_1(ms, tz.timezone);
          });
        });
        this_2._timeLabels = timeLabels_1;
      };
      var this_2 = this;
      for (var d = timesFrom; d <= endTime; d += timeStep) {
        _loop_4(d);
      }
      reloadData = true;
    }
    this._groupByResource = s.groupBy !== "date" && !(s.type === "day" && size < 2) || this._isSingleResource;
    this._stepCell = stepCell * ONE_MIN;
    this._stepLabel = stepLabel * ONE_MIN;
    this._dayNames = state.dayNameWidth > 49 ? s.dayNamesShort : s.dayNamesMin;
    this._displayTime = stepLabel < 1440 && isDailyResolution;
    this._eventHeight = state.eventHeight || (s.eventList ? 24 : 46);
    this._showCursorTime = this._displayTime && !!(s.dragToCreate || s.dragToMove || s.dragToResize);
    this._setRowHeight = s.eventList || s.rowHeight !== "equal";
    this._variableEventHeight = s.eventHeight === "variable";
    if (s.maxEventStack !== "auto") {
      this._maxEventStack = s.maxEventStack || "all";
    }
    if (s.colorsMap !== prevS.colorsMap || reloadData) {
      this._colors = this._getColors(s.colorsMap);
    }
    if (s.eventMap !== prevS.eventMap || s.showEventBuffer !== prevS.showEventBuffer || reloadData || !this._events || this._reloadEvents) {
      this._eventMap = {};
      this._eventRows = {};
      this._events = this._getEvents(s.eventMap);
      this._reloadEvents = false;
      this._calcRowHeights = true;
    }
    if (s.invalidsMap !== prevS.invalidsMap || reloadData) {
      this._invalids = this._getInvalids(s.invalidsMap);
    }
    var checkEventHeight = isTimeline && s.eventMap !== prevS.eventMap;
    if (s.height !== prevS.height || s.width !== prevS.width || s.groupBy !== prevS.groupBy || checkEventHeight || reloadData) {
      this._shouldCheckSize = isBrowser && !!s.height && !!s.width;
      this._calcRowHeights = true;
    }
    if (s.scroll !== prevS.scroll) {
      this._shouldScroll = true;
      this._shouldAnimateScroll = prevS.selected !== UNDEFINED && selectedChanged && !viewChanged;
    }
    if (s.height !== UNDEFINED) {
      this._hasSideSticky = hasSticky && !s.rtl;
      this._hasSticky = hasSticky;
    }
    if (resetRowHeights) {
      this._rowHeightsReal = {};
      this._eventHeights = {};
    }
    if (selectedChanged) {
      this._selectedChanged = true;
    }
    if (viewChanged) {
      this._viewChanged++;
      setTimeout(function() {
        _this._viewChanged--;
      }, 50);
    }
  };
  STBase2.prototype._mounted = function() {
    var _this = this;
    var allowCreate;
    var allowStart;
    var allowResourceSort;
    var isResourceSort;
    var startTarget;
    var validTarget;
    this._unlisten = gestureListener(this._el, {
      onDoubleClick: function(args) {
        var s = _this.s;
        if (validTarget && s.clickToCreate && s.clickToCreate !== "single") {
          args.click = true;
          if (_this._onEventDragStart(args)) {
            _this._onEventDragEnd(args);
          }
        }
      },
      onEnd: function(args) {
        if (isResourceSort && allowResourceSort) {
          _this._onResourceDragEnd(args);
        } else if (!allowCreate && allowStart && _this.s.clickToCreate === "single") {
          args.click = true;
          if (_this._onEventDragStart(args)) {
            allowCreate = true;
          }
        }
        if (!isResourceSort && allowCreate) {
          args.domEvent.preventDefault();
          _this._onEventDragEnd(args);
        }
        clearTimeout(_this._touchTimer);
        allowCreate = false;
        allowStart = false;
        allowResourceSort = false;
        isResourceSort = false;
      },
      onMove: function(args) {
        var s = _this.s;
        var resourceArgs = args;
        var hasMoved = Math.abs(args.deltaX) > 7 || Math.abs(args.deltaY) > 7;
        if (allowResourceSort) {
          args.domEvent.preventDefault();
          _this._onResourceDragMove(resourceArgs);
        } else if (allowStart && isResourceSort && hasMoved) {
          _this._onResourceDragStart(resourceArgs, startTarget);
          allowResourceSort = true;
        } else if (allowCreate && s.dragToCreate) {
          args.domEvent.preventDefault();
          _this._onEventDragMove(args);
        } else if (allowStart && s.dragToCreate && hasMoved) {
          if (_this._onEventDragStart(args)) {
            allowCreate = true;
          } else {
            allowStart = false;
          }
        } else {
          clearTimeout(_this._touchTimer);
        }
      },
      onStart: function(args) {
        startTarget = args.domEvent.target;
        var s = _this.s;
        var resourceArgs = args;
        var targetClasses = startTarget && startTarget.classList;
        args.create = true;
        args.click = false;
        _this._isTouch = args.isTouch;
        if (!allowResourceSort && s.resourceReorder && targetClasses && targetClasses.contains("mbsc-timeline-resource-sort")) {
          isResourceSort = true;
          args.create = false;
          if (args.isTouch) {
            _this._touchTimer = setTimeout(function() {
              _this._onResourceDragStart(resourceArgs, startTarget);
              _this._onResourceDragMove(resourceArgs);
              setTimeout(function() {
                _this._onResourceDragMove(resourceArgs);
              });
              allowResourceSort = true;
            }, 350);
          } else {
            allowStart = true;
          }
        }
        if (!allowCreate && (s.dragToCreate || s.clickToCreate)) {
          validTarget = targetClasses && (targetClasses.contains("mbsc-schedule-item") || targetClasses.contains("mbsc-schedule-all-day-item") || targetClasses.contains("mbsc-timeline-column"));
          if (validTarget) {
            if (args.isTouch && s.dragToCreate) {
              _this._touchTimer = setTimeout(function() {
                if (_this._onEventDragStart(args)) {
                  _this._onEventDragModeOn(args);
                  allowCreate = true;
                }
              }, 350);
            } else {
              allowStart = !args.isTouch;
            }
          }
        }
      }
    });
    this._unsubscribe = subscribeExternalDrag(this._onExternalDrag);
  };
  STBase2.prototype._updated = function() {
    var _this = this;
    var s = this.s;
    var state = this.state;
    var grid = this._gridCont;
    var scrollCont = this._scrollCont;
    var shouldCheckSize = this._shouldCheckSize;
    var calcRowHeights = this._calcRowHeights && this._setRowHeight && this._variableEventHeight;
    if (this._scrollAfterResize) {
      ngSetTimeout(this, function() {
        _this._onScroll();
        _this._scrollAfterResize = false;
      });
    }
    if (this._selectedChanged) {
      if (!this._shouldScroll) {
        this._setViewDates();
      }
      this._selectedChanged = false;
    }
    if (shouldCheckSize || calcRowHeights) {
      ngSetTimeout(this, function() {
        var resCont = _this._resCont;
        var headerCont = _this._headerCont;
        var footerCont = _this._footerCont;
        var sidebarCont = _this._sidebarCont;
        var stickyFooter = _this._stickyFooter;
        var headerHeight = headerCont.offsetHeight;
        var resContWidth = resCont ? resCont.offsetWidth : 0;
        var sidebarWidth = sidebarCont ? sidebarCont.offsetWidth : 0;
        var footerHeight = footerCont ? footerCont.offsetHeight : 0;
        var scrollContWidth = scrollCont.offsetWidth;
        var scrollContHeight = scrollCont.offsetHeight;
        var scrollClientWidth = scrollCont.clientWidth;
        var scrollClientHeight = scrollCont.clientHeight;
        var gridContWidth = scrollClientWidth - resContWidth - sidebarWidth;
        var gridContHeight = scrollClientHeight - headerHeight - footerHeight;
        var gridHeight = _this._gridHeight;
        var scrollBarSizeY = scrollContWidth - scrollClientWidth;
        var scrollBarSizeX = scrollContHeight - scrollClientHeight;
        var hasScrollY = scrollCont.scrollHeight > scrollClientHeight;
        var hasScrollX = scrollCont.scrollWidth > scrollClientWidth;
        var cellHeight;
        var cellWidth;
        var dayWidth;
        var dayNameWidth;
        var gridWidth;
        var rowHeight;
        var parentRowHeight;
        var gutterHeight;
        var resourceColWidth = 0;
        var resourceDepthStep = 0;
        var eventHeight = state.eventHeight;
        if (shouldCheckSize) {
          if (_this._isTimeline) {
            var col = scrollCont.querySelector(".mbsc-timeline-empty-column");
            var day = scrollCont.querySelector(".mbsc-timeline-empty-day");
            var gridRow = scrollCont.querySelector(".mbsc-timeline-empty-row");
            var parentRow = scrollCont.querySelector(".mbsc-timeline-empty-parent");
            var gutter = scrollCont.querySelector(".mbsc-timeline-row-gutter");
            var resourceCol = scrollCont.querySelector(".mbsc-timeline-empty-resource");
            var resourceStep = scrollCont.querySelector(".mbsc-timeline-resource-depth-step");
            var colsNr = _this._colsNr;
            var slotsNr = _this._slots.length;
            var isDailyResolution = _this._isDailyResolution;
            cellWidth = col ? col.offsetWidth : 74;
            dayWidth = day ? day.offsetWidth : 0;
            dayWidth = isDailyResolution ? Math.max(_this._time * cellWidth / _this._stepCell, dayWidth, cellWidth * slotsNr) : dayWidth;
            cellWidth = isDailyResolution ? _this._hasSlots ? dayWidth / slotsNr : _this._stepCell * dayWidth / _this._time : dayWidth;
            rowHeight = gridRow ? gridRow.offsetHeight : 52;
            parentRowHeight = parentRow ? parentRow.offsetHeight : 52;
            gutterHeight = gutter ? gutter.offsetHeight : 16;
            resourceColWidth = resourceCol ? resourceCol.offsetWidth : 0;
            resourceDepthStep = resourceStep ? resourceStep.offsetWidth : 28;
            if (dayWidth * colsNr <= gridContWidth) {
              hasScrollX = false;
              scrollBarSizeX = 0;
            } else {
              hasScrollX = true;
              scrollBarSizeX = scrollBarSizeX || scrollBarSizeY;
            }
            if (gridHeight && gridHeight <= gridContHeight) {
              hasScrollY = false;
              scrollBarSizeY = 0;
            }
            dayWidth = hasScrollX ? dayWidth : round(gridContWidth / colsNr);
            gridWidth = hasScrollX ? dayWidth * colsNr : gridContWidth;
            cellWidth = hasScrollX ? cellWidth : _this._stepCell * dayWidth / _this._time;
            _this._gridWidth = gridWidth;
            if (!_this._hasSticky) {
              headerCont.style[s.rtl ? "left" : "right"] = scrollBarSizeY + "px";
              if (footerCont) {
                footerCont.style[s.rtl ? "left" : "right"] = scrollBarSizeY + "px";
                footerCont.style.bottom = scrollBarSizeX + "px";
              }
            }
            if (!_this._hasSideSticky) {
              if (resCont) {
                resCont.style.bottom = scrollBarSizeX + "px";
              }
              if (sidebarCont) {
                sidebarCont.style[s.rtl ? "left" : "right"] = scrollBarSizeY + "px";
                sidebarCont.style.bottom = scrollBarSizeX + "px";
              }
            }
            if (stickyFooter) {
              stickyFooter.style.bottom = scrollBarSizeX + "px";
            }
            if (_this._setRowHeight && !_this._variableEventHeight) {
              var event_6 = scrollCont.querySelector(".mbsc-schedule-event");
              eventHeight = event_6 ? event_6.clientHeight : eventHeight || (s.eventList ? 24 : 46);
            }
          } else {
            var gridCol = _this._el.querySelector(".mbsc-schedule-column-inner");
            var dayName = _this._el.querySelector(".mbsc-schedule-header-item");
            cellHeight = gridCol ? _this._stepCell * gridCol.offsetHeight / _this._time : 0;
            dayNameWidth = dayName ? dayName.offsetWidth : 0;
            if (s.maxEventStack === "auto") {
              var maxEventStack = floor(gridCol.offsetWidth / (s.minEventWidth || 50));
              _this._reloadEvents = _this._maxEventStack !== maxEventStack;
              _this._maxEventStack = maxEventStack;
            }
          }
          if (scrollCont.scrollTop > gridHeight - gridContHeight) {
            scrollCont.scrollTop = gridHeight - gridContHeight;
          } else {
            _this._onScroll();
          }
          _this._calcConnections = !!s.connections && (_this._isParentClick || _this._calcConnections || !hasScrollY);
          _this._shouldCheckSize = rowHeight !== state.rowHeight || eventHeight !== state.eventHeight || hasScrollY !== state.hasScrollY;
          _this._scrollAfterResize = s.virtualScroll && !_this._shouldCheckSize;
          _this._isCursorTimeVisible = false;
          _this._calcGridSizes();
        }
        if (calcRowHeights) {
          var i_1 = 0;
          var totalDiff_1 = 0;
          var totalHeight_1 = 0;
          var scrollTop_1 = scrollCont.scrollTop;
          var rows_1 = grid.querySelectorAll(".mbsc-timeline-row-outer");
          var events = grid.querySelectorAll(".mbsc-timeline-event");
          events.forEach(function(ev) {
            _this._eventHeights[ev.getAttribute("data-key")] = ev.getBoundingClientRect().height;
          });
          _this._virtualRows.forEach(function(rowGroup) {
            var dKey = rowGroup.day ? rowGroup.day.dateKey : "";
            rowGroup.rows.forEach(function(row) {
              var key = (dKey ? dKey + "-" : "") + row.id;
              var eventCont = rows_1[i_1].querySelector(".mbsc-timeline-events");
              var rowSize = rows_1[i_1].querySelector(".mbsc-timeline-row-size");
              var baseHeight = rowSize.getBoundingClientRect().height;
              var height = Math.max(baseHeight, eventCont.getBoundingClientRect().height);
              var diff = height - _this._rowHeightsReal[key];
              if (_this._isScrolling && !_this._shouldScroll && height !== _this._rowHeightsReal[key]) {
                _this._shouldScroll = true;
              }
              if (diff && _this._resourceTops[key] < scrollTop_1) {
                totalDiff_1 += diff;
              }
              _this._rowHeightsReal[key] = height;
              totalHeight_1 += height;
              i_1++;
            });
          });
          if (totalDiff_1) {
            scrollCont.scrollTop = scrollTop_1 + totalDiff_1;
          }
          if (totalHeight_1 > gridContHeight) {
            hasScrollY = true;
          }
          _this._calcRowHeights = false;
        }
        if (shouldCheckSize) {
          _this.setState({
            cellHeight,
            cellWidth,
            dayNameWidth,
            dayWidth,
            eventHeight,
            footerHeight,
            gridContWidth,
            gridWidth,
            gutterHeight,
            hasScrollX,
            hasScrollY,
            headerHeight,
            parentRowHeight,
            resourceColWidth,
            resourceDepthStep,
            rowHeight,
            scrollContHeight: scrollContHeight - scrollBarSizeX,
            scrollContWidth,
            update: _this._calcConnections || _this._reloadEvents || calcRowHeights ? (state.update || 0) + 1 : state.update
          });
        } else {
          _this.forceUpdate();
        }
      });
    }
    if (this._triggerCreated) {
      this._hook("onResourceCreated", this._triggerCreated);
      this._triggerCreated = UNDEFINED;
    }
    if (this._triggerDeleted) {
      this._hook("onResourceDeleted", this._triggerDeleted);
      this._triggerDeleted = UNDEFINED;
    }
    if (this._shouldScroll && (state.dayWidth || state.cellHeight)) {
      clearTimeout(this._scrollTimer);
      this._scrollTimer = setTimeout(function() {
        _this._scrollToTime(_this._shouldAnimateScroll, _this._scrollToMiddle);
        _this._scrollToMiddle = false;
        _this._shouldAnimateScroll = true;
      });
      this._shouldScroll = false;
    }
  };
  STBase2.prototype._destroy = function() {
    if (this._unlisten) {
      this._unlisten();
    }
    if (this._unsubscribe) {
      unsubscribeExternalDrag(this._unsubscribe);
    }
  };
  STBase2.prototype._setViewDates = function(scrollPos, scrollTop) {
    if ((!this._viewChanged || !this._viewDate) && !this._hasResY) {
      var s = this.s;
      var rtl = s.rtl ? -1 : 1;
      var days = this._days;
      var daysNr = this._daysNr;
      var dayWidth = this._gridWidth / daysNr;
      var scrollLeft = scrollPos !== UNDEFINED ? scrollPos : this._scrollCont.scrollLeft;
      if (scrollTop !== UNDEFINED) {
        var dayIndex = this._getDragCol(scrollLeft).dayIndex;
        var day = days[dayIndex].date;
        var ms = this._stepCell * scrollTop / (this.state.cellHeight || 50);
        var date = new Date(+day + this._startTime + ms);
        this._hook("onActiveChange", {
          date,
          scroll: true
        });
      } else {
        var dayIndex = dayWidth ? constrain(floor(scrollLeft * rtl / dayWidth), 0, daysNr - 1) : 0;
        var day = days[dayIndex].date;
        var ms = this._time * (scrollLeft * rtl - dayIndex * dayWidth) / dayWidth;
        var nav = s.navService;
        var date = new Date(+day + this._startTime + ms);
        if (s.resolution === "week" && (s.type === "year" || s.type === "month") && date < nav.firstDay) {
          date = nav.firstDay;
        }
        var halfGridWith = this.state.gridContWidth / 2;
        var middleDayIndex = dayWidth ? constrain(floor((scrollLeft + halfGridWith * rtl) / dayWidth), 0, daysNr - 1) : 0;
        var middleDay = days[middleDayIndex].date;
        var middleMs = this._time * ((scrollLeft + halfGridWith) * rtl - middleDayIndex * dayWidth) / dayWidth;
        var middleDate = new Date(+middleDay + this._startTime + middleMs);
        this._viewDate = middleDate;
        this._hook("onActiveChange", {
          date,
          middleDate,
          scroll: true
        });
      }
    }
  };
  STBase2.prototype._calcGridSizes = function() {
    var _this = this;
    var s = this.s;
    var resources = this._resources;
    var isTimeline = this._isTimeline;
    var daysNr = this._daysNr * (isTimeline ? 1 : resources.length);
    var grid = this._gridCont;
    var scrollCont = this._scrollCont;
    var allDayCont = !isTimeline && this._el.querySelector(".mbsc-schedule-all-day-wrapper");
    var allDayRect = allDayCont && allDayCont.getBoundingClientRect();
    var rect = grid.getBoundingClientRect();
    var gridRect = scrollCont.getBoundingClientRect();
    var gridWidth = isTimeline ? this._gridWidth : grid.scrollWidth;
    var resWidth = this._resCont ? this._resCont.offsetWidth : 0;
    this._gridLeft = s.rtl ? rect.right - gridWidth : rect.left;
    this._gridRight = s.rtl ? rect.right : rect.left + gridWidth;
    this._gridTop = rect.top;
    this._gridContTop = gridRect.top;
    this._gridContBottom = gridRect.bottom;
    this._gridContLeft = gridRect.left + (s.rtl ? 0 : resWidth);
    this._gridContRight = gridRect.right - (s.rtl ? resWidth : 0);
    this._allDayTop = allDayRect ? allDayRect.top : this._gridContTop;
    this._colWidth = gridWidth / (s.eventList ? this._colsNr : daysNr);
    this._colHeight = rect.height;
    if (isTimeline && !this.state.hasScrollY && this.state.rowHeight) {
      this._resourceTops = {};
      var rows = grid.querySelectorAll(".mbsc-timeline-row-outer");
      rows.forEach(function(r, i) {
        _this._rows[i].top = r.getBoundingClientRect().top - rect.top;
        _this._resourceTops[_this._rows[i].key] = _this._rows[i].top;
      });
    } else {
      this._columnLefts = [];
      var columns = grid.querySelectorAll(".mbsc-schedule-column");
      columns.forEach(function(col) {
        var colRect = col.getBoundingClientRect();
        _this._columnLefts.push(s.rtl ? rect.right - colRect.right : colRect.left - rect.left);
      });
    }
  };
  STBase2.prototype._getScrollJump = function(dist) {
    var minJump = 1;
    var maxJump = 20;
    var steepFactor = 20;
    var baseJump = round(maxJump - constrain(minJump + (maxJump - minJump) * (1 - Math.exp(-dist / steepFactor)), minJump, maxJump));
    if (!this._scrollStartTime) {
      this._scrollStartTime = Date.now();
    }
    if (baseJump >= maxJump - 1) {
      var growthRate = 0.1;
      var accelerationFactor = 2.2;
      var maxSpeed = 300;
      var elapsedTime = (Date.now() - this._scrollStartTime) / 1e3;
      var speedMultiplier = 1 + Math.exp(elapsedTime * accelerationFactor) * growthRate;
      return Math.min(Math.round(baseJump * speedMultiplier), maxSpeed);
    }
    this._scrollStartTime = 0;
    return baseJump;
  };
  STBase2.prototype._getDragCol = function(posX) {
    var colIndex = 0;
    this._columnLefts.some(function(left, i) {
      if (posX >= left) {
        colIndex = i;
        return false;
      }
      return true;
    });
    var groupByResource = this._groupByResource;
    var groupCount = groupByResource ? this._days.length : this._visibleResources.length;
    var resourceIndex = groupByResource ? floor(colIndex / groupCount) : colIndex % groupCount;
    var dayIndex = groupByResource ? colIndex % groupCount : floor(colIndex / groupCount);
    return {
      colIndex,
      dayIndex,
      resourceIndex
    };
  };
  STBase2.prototype._getDragRow = function(posY, scrollContTop) {
    var isListing = this.s.eventList;
    var cols = isListing ? this._cols : this._days;
    var hasResY = this._hasResY;
    var resources = this._visibleResources;
    var resourceTops = this._resourceTops;
    var dayIndex = 0;
    var dateKey = "";
    var resourceIndex = 0;
    var rowKey = "";
    if (hasResY) {
      cols.forEach(function(d, i) {
        resources.forEach(function(r2, j) {
          if (posY > resourceTops[d.dateKey + "-" + r2.id]) {
            dayIndex = i;
            dateKey = d.dateKey;
            resourceIndex = j;
            rowKey = dateKey + "-" + r2.id;
          }
        });
      });
    } else {
      resources.forEach(function(r2, i) {
        if (posY > resourceTops[r2.id]) {
          rowKey = "" + r2.id;
          resourceIndex = i;
        }
      });
      var fixedY = posY - scrollContTop + this.state.headerHeight;
      if (scrollContTop && fixedY < this._fixedHeight && posY - scrollContTop > 0) {
        for (var _i = 0, _a = this._fixedResources; _i < _a.length; _i++) {
          var r = _a[_i];
          if (fixedY > this._fixedResourceTops[r.key]) {
            rowKey = r.key;
            resourceIndex = r.index;
          }
        }
      }
    }
    return {
      dateKey,
      dayIndex,
      resourceIndex,
      rowKey
    };
  };
  STBase2.prototype._getDragPos = function(draggedResource, targetResource) {
    var resourcesMap = this._resourcesMap;
    var resourcesData = this._resourcesData;
    var draggedResourceData = resourcesData[draggedResource.id];
    var targetResourceData = targetResource && resourcesData[targetResource.id];
    var oldParent = draggedResourceData && resourcesMap[draggedResourceData.parentId];
    var newParent = targetResourceData && resourcesMap[targetResource.children ? targetResource.id : targetResourceData.parentId];
    var oldIndex = draggedResourceData && draggedResourceData.index;
    var targetIndex = targetResourceData && (targetResource.children ? targetResource.children.length : targetResourceData.index);
    var inc = draggedResource !== targetResource && this._tempResourceNext ? 1 : 0;
    var dec = targetIndex !== UNDEFINED && oldParent === newParent && oldIndex < targetIndex ? -1 : 0;
    var newIndex = targetIndex !== UNDEFINED ? targetIndex + inc + dec : UNDEFINED;
    return {
      oldParent,
      newParent,
      oldIndex,
      newIndex
    };
  };
  STBase2.prototype._getDragDates = function(event, resourceId, slotId) {
    var s = this.s;
    var dates = {};
    var dragDisplayedMap = /* @__PURE__ */ new Map();
    var first = event.allDay ? this._firstDay : this._firstDayTz;
    var start = event.startDate;
    var end = event.endDate;
    start = getDateOnly(start);
    start = start < first ? first : start;
    end = getEndDate(s, event.allDay || s.eventList, start, end);
    while (start <= end) {
      var eventForDay = __assign({}, event);
      var dateKey = getDateStr(start);
      var pos = isInWeek(start.getDay(), s.startDay, s.endDay) && this._getEventPos(event, start, dateKey, dragDisplayedMap);
      var eventTrack = 0;
      if (pos) {
        if (!this._hasSlots && this._isTimeline && this._setRowHeight && this._startRow === (this._hasResY ? dateKey + "-" : "") + this._tempResource) {
          pos.position.top = eventForDay.position.top;
          eventTrack = eventForDay.track || 0;
        }
        var key = this._isTimeline && !this._hasSlots && !this._hasResY ? "all" : dateKey;
        eventForDay.date = +getDateOnly(start, true);
        eventForDay.cssClass = pos.cssClass;
        eventForDay.start = pos.start;
        eventForDay.end = pos.end;
        eventForDay.offset = pos.offset;
        eventForDay.position = pos.position;
        eventForDay.bufferAfter = pos.bufferAfter;
        eventForDay.bufferBefore = pos.bufferBefore;
        eventForDay.track = eventTrack;
        dates[resourceId + "__" + (this._isTimeline ? slotId + "__" : "") + key] = eventForDay;
      }
      start = addDays(start, 1);
    }
    return dates;
  };
  STBase2.prototype._getGridTime = function(day, posX, posY, dayIndex, timeStep) {
    var dayIdx = this._hasResY ? 0 : dayIndex;
    var ms = step(this._isTimeline ? floor(this._time * (posX - dayIdx * this._colWidth) / this._colWidth) : floor(this._time * (posY - 8) / (this._colHeight - 16)), timeStep * ONE_MIN);
    var time = new Date(+REF_DATE + this._startTime + ms);
    return createDate$1(this.s, day.getFullYear(), day.getMonth(), day.getDate(), time.getHours(), time.getMinutes());
  };
  STBase2.prototype._scrollToTime = function(animate, scrollToMiddle) {
    var _this = this;
    var el2 = this._scrollCont;
    var gridCont = this._gridCont;
    var isTimeline = this._isTimeline;
    if (el2) {
      var s = this.s;
      var resources = this._visibleResources;
      var hasResY = this._hasResY;
      var targetEvent = s.navigateToEvent;
      var targetDate = targetEvent && targetEvent.start ? /* @__PURE__ */ new Date(+makeDate(targetEvent.start, s)) : new Date(s.selected);
      var colIndex = this._colIndexMap[getDateStr(targetDate)];
      var colDate = this._cols[colIndex] && this._cols[colIndex].date;
      var useColIndex = isTimeline && !hasResY && colDate && (s.resolution === "month" || s.resolution === "quarter");
      if (!scrollToMiddle) {
        if (isTimeline && !hasResY && colDate && (s.resolution !== "hour" || this._stepCell === ONE_DAY || s.eventList)) {
          targetDate = colDate;
        } else {
          targetDate.setHours(s.eventList ? 0 : targetDate.getHours(), 0, 0, 0);
        }
      }
      var timeStart = getEventStart(targetDate, this._startTime, this._time * (isTimeline ? this._daysNr : 1));
      var colDiff = useColIndex ? colIndex : hasResY ? 0 : getGridDayDiff(this._firstDay, targetDate, s.startDay, s.endDay);
      var colsNr = useColIndex ? this._colsNr : this._daysNr;
      var width = isTimeline ? gridCont.offsetWidth : gridCont.scrollWidth;
      var dateKey = getDateStr(targetDate);
      var resource = targetEvent ? targetEvent.resource : resources[0].id;
      var targetResource_1 = isArray(resource) ? resource[0] : resource;
      var newScrollPosX = void 0;
      var newScrollPosY = void 0;
      if (isTimeline) {
        var key = (hasResY ? dateKey + "-" : "") + targetResource_1;
        newScrollPosX = width * (colDiff * 100 / colsNr + timeStart) / 100 - (scrollToMiddle ? this.state.gridContWidth / 2 : 0) + 1;
        newScrollPosY = this._resourceTops[key];
      } else {
        var dayIndex = this._dayIndexMap[dateKey];
        var resourceIndex = findIndex(resources, function(r) {
          return r.id === targetResource_1;
        }) || 0;
        var columnIndex = this._groupByResource ? resourceIndex * this._daysNr + dayIndex : dayIndex * resources.length + resourceIndex;
        newScrollPosX = this._columnLefts[columnIndex];
        newScrollPosY = this._colHeight ? (this._colHeight - 16) * timeStart / 100 : 0;
      }
      this._setViewDates(newScrollPosX);
      if (this._isScrolling) {
        this._isScrolling(newScrollPosX, newScrollPosY);
      } else {
        this._isScrolling = smoothScroll(el2, newScrollPosX, newScrollPosY, animate, s.rtl, function() {
          setTimeout(function() {
            _this._isScrolling = UNDEFINED;
          }, 150);
        });
      }
    }
  };
  STBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵSTBase_BaseFactory;
    return function STBase_Factory(__ngFactoryType__) {
      return (ɵSTBase_BaseFactory || (ɵSTBase_BaseFactory = ɵɵgetInheritedFactory(STBase2)))(__ngFactoryType__ || STBase2);
    };
  })();
  STBase2.ɵdir = ɵɵdefineDirective({
    type: STBase2,
    selectors: [["", "mbsc-st-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return STBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(STBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-st-b]"
    }]
  }], null, null);
})();
var SchedulerBase = function(_super) {
  __extends(SchedulerBase2, _super);
  function SchedulerBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onScroll = function(ev) {
      var scrollCont = _this._scrollCont;
      if (scrollCont) {
        var scrollTop = scrollCont.scrollTop;
        var scrollLeft = scrollCont.scrollLeft;
        var scrollLeftStyle = "translateX(" + -scrollLeft + "px)";
        var timeCont = _this._timeCont;
        var allDay = _this._allDayCont;
        var header = _this._headerCont;
        var transform = (jsPrefix ? jsPrefix + "T" : "t") + "ransform";
        if (allDay) {
          allDay.style[transform] = scrollLeftStyle;
        }
        if (timeCont) {
          timeCont.style.marginTop = -scrollTop + "px";
        }
        if (header) {
          header.style[transform] = scrollLeftStyle;
        }
        if (scrollTop === 0) {
          _this.setState({
            showShadow: false
          });
        } else if (!_this.state.showShadow) {
          _this.setState({
            showShadow: true
          });
        }
        if (!_this._isScrolling && ev) {
          _this._setViewDates(scrollLeft, scrollTop);
        }
        _this._onMouseMove();
      }
    };
    _this._setCont = function(el2) {
      _this._scrollCont = el2;
    };
    _this._setTimeCont = function(el2) {
      _this._timeCont = el2;
    };
    _this._setAllDayCont = function(el2) {
      _this._allDayCont = el2;
    };
    _this._setGridCont = function(el2) {
      _this._gridCont = el2;
    };
    _this._setHeaderCont = function(el2) {
      _this._headerCont = el2;
    };
    _this._setCursorTimeCont = function(el2) {
      _this._cursorTimeCont = el2;
    };
    return _this;
  }
  SchedulerBase2.prototype._render = function(s, state) {
    var prevS = this._prevS;
    var timezones = s.timezones;
    var stepCell = this._stepCell / ONE_MIN;
    var startMinutes = floor(this._startTime / ONE_MIN) % stepCell;
    var endMinutes = floor(this._endTime / ONE_MIN) % stepCell + 1;
    if (timezones !== prevS.timezones) {
      this._timeWidth = timezones ? {
        width: timezones.length * 4.25 + "em"
      } : UNDEFINED;
      this._timezones = UNDEFINED;
      if (timezones) {
        var tz = [];
        for (var _i = 0, timezones_1 = timezones; _i < timezones_1.length; _i++) {
          var t = timezones_1[_i];
          var tzProps = void 0;
          if (isString(t)) {
            var d = createDate$1(s, 1970, 0, 1);
            if (isMBSCDate(d)) {
              d.setTimezone(t);
            }
            var offset = d.getTimezoneOffset() / 60 * -1;
            tzProps = {
              label: "UTC" + (offset > 0 ? "+" : "") + offset,
              timezone: t
            };
          } else {
            tzProps = t;
          }
          tz.push(tzProps);
        }
        this._timezones = tz;
      }
    }
    _super.prototype._render.call(this, s, state);
    this._colClass = " mbsc-schedule-col-width" + (this._daysNr > 7 ? " mbsc-schedule-col-width-multi" : "");
    this._largeDayNames = state.dayNameWidth > 99;
    this._startCellStyle = startMinutes % stepCell !== 0 ? {
      height: (state.cellHeight || 50) * ((stepCell - startMinutes) % stepCell / stepCell) + "px"
    } : UNDEFINED;
    this._endCellStyle = endMinutes % stepCell !== 0 ? {
      height: (state.cellHeight || 50) * (endMinutes % stepCell) / stepCell + "px"
    } : UNDEFINED;
  };
  SchedulerBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵSchedulerBase_BaseFactory;
    return function SchedulerBase_Factory(__ngFactoryType__) {
      return (ɵSchedulerBase_BaseFactory || (ɵSchedulerBase_BaseFactory = ɵɵgetInheritedFactory(SchedulerBase2)))(__ngFactoryType__ || SchedulerBase2);
    };
  })();
  SchedulerBase2.ɵdir = ɵɵdefineDirective({
    type: SchedulerBase2,
    selectors: [["", "mbsc-sch-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return SchedulerBase2;
}(STBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SchedulerBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sch-b]"
    }]
  }], null, null);
})();
var TimeIndicatorBase = function(_super) {
  __extends(TimeIndicatorBase2, _super);
  function TimeIndicatorBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  TimeIndicatorBase2.prototype._start = function() {
    var _this = this;
    this._timer = setInterval(function() {
      _this.forceUpdate();
    }, 1e4);
  };
  TimeIndicatorBase2.prototype._mounted = function() {
    var _this = this;
    clearInterval(this._timer);
    if (this._zone) {
      this._zone.runOutsideAngular(function() {
        _this._start();
      });
    } else {
      this._start();
    }
  };
  TimeIndicatorBase2.prototype._destroy = function() {
    clearInterval(this._timer);
  };
  TimeIndicatorBase2.prototype._render = function(s) {
    var now = createDate$1(s);
    var rtl = s.rtl;
    var displayedDays = s.displayedDays;
    var displayedTime = s.displayedTime;
    var startTime = s.startTime;
    var time = floor(getDayMilliseconds(now) / ONE_MIN) * ONE_MIN;
    var timezones = s.timezones;
    var formatOpt = {
      amText: s.amText,
      pmText: s.pmText
    };
    if (timezones && isMBSCDate(now)) {
      this._times = [];
      for (var _i = 0, timezones_1 = timezones; _i < timezones_1.length; _i++) {
        var t = timezones_1[_i];
        var tzNow = now.clone();
        tzNow.setTimezone(t.timezone);
        this._times.push(formatDate(s.timeFormat, tzNow, formatOpt));
      }
    } else {
      this._time = formatDate(s.timeFormat, now, formatOpt);
    }
    this._cssClass = "mbsc-schedule-time-indicator mbsc-schedule-time-indicator-" + s.orientation + this._theme + this._rtl + " " + (time < startTime || time > startTime + displayedTime || !isInWeek(now.getDay(), s.startDay, s.endDay) ? " mbsc-hidden" : "");
    var dayIndex = s.hasResY ? 0 : getGridDayDiff(s.firstDay, now, s.startDay, s.endDay);
    if (s.orientation === "x") {
      var horiz = dayIndex * 100 / displayedDays + "%";
      var multiPos = timezones && 4.25 * timezones.length + "em";
      this._pos = {
        left: timezones && !rtl ? multiPos : UNDEFINED,
        right: timezones && rtl ? multiPos : UNDEFINED,
        top: (time - startTime) * 100 / displayedTime + "%"
      };
      this._dayPos = {
        left: rtl ? "" : horiz,
        right: rtl ? horiz : "",
        width: 100 / displayedDays + "%"
      };
    } else {
      var pos = (dayIndex * displayedTime + time - startTime) * 100 / (displayedDays * displayedTime) + "%";
      this._pos = {
        left: rtl ? "" : pos,
        right: rtl ? pos : ""
      };
    }
  };
  TimeIndicatorBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵTimeIndicatorBase_BaseFactory;
    return function TimeIndicatorBase_Factory(__ngFactoryType__) {
      return (ɵTimeIndicatorBase_BaseFactory || (ɵTimeIndicatorBase_BaseFactory = ɵɵgetInheritedFactory(TimeIndicatorBase2)))(__ngFactoryType__ || TimeIndicatorBase2);
    };
  })();
  TimeIndicatorBase2.ɵdir = ɵɵdefineDirective({
    type: TimeIndicatorBase2,
    selectors: [["", "mbsc-ti-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return TimeIndicatorBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeIndicatorBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-ti-b]"
    }]
  }], null, null);
})();
var WeekDayBase = function(_super) {
  __extends(WeekDayBase2, _super);
  function WeekDayBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onClick = function() {
      var s = _this.s;
      if (s.selectable) {
        s.onClick(s.timestamp);
      }
    };
    return _this;
  }
  WeekDayBase2.prototype._render = function(s, state) {
    var date = new Date(s.timestamp);
    this._cssClass = "mbsc-schedule-header-item " + this._className + this._theme + this._rtl + this._hb + (s.largeNames ? " mbsc-schedule-header-item-large" : "") + (s.selected ? " mbsc-selected" : "") + (state.hasHover ? " mbsc-hover" : "");
    this._data = {
      date,
      events: s.events || [],
      resource: s.resource,
      selected: s.selected
    };
    this._day = date.getDay();
  };
  WeekDayBase2.prototype._mounted = function() {
    var _this = this;
    this._unlisten = gestureListener(this._el, {
      onHoverIn: function() {
        if (_this.s.selectable) {
          _this.setState({
            hasHover: true
          });
        }
      },
      onHoverOut: function() {
        if (_this.s.selectable) {
          _this.setState({
            hasHover: false
          });
        }
      }
    });
  };
  WeekDayBase2.prototype._destroy = function() {
    if (this._unlisten) {
      this._unlisten();
    }
  };
  WeekDayBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵWeekDayBase_BaseFactory;
    return function WeekDayBase_Factory(__ngFactoryType__) {
      return (ɵWeekDayBase_BaseFactory || (ɵWeekDayBase_BaseFactory = ɵɵgetInheritedFactory(WeekDayBase2)))(__ngFactoryType__ || WeekDayBase2);
    };
  })();
  WeekDayBase2.ɵdir = ɵɵdefineDirective({
    type: WeekDayBase2,
    selectors: [["", "mbsc-wd-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return WeekDayBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WeekDayBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-wd-b]"
    }]
  }], null, null);
})();
var TimelineBase = function(_super) {
  __extends(TimelineBase2, _super);
  function TimelineBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._isTimeline = true;
    _this._onScroll = function(ev) {
      var s = _this.s;
      var isRtl = s.rtl;
      var state = _this.state;
      var gridWidth = _this._gridWidth;
      var gridHeight = (state.scrollContHeight || 0) - (state.headerHeight || 0) - (state.footerHeight || 0);
      var scrollCont = _this._scrollCont;
      var scrollTop = scrollCont.scrollTop;
      var scrollLeft = scrollCont.scrollLeft;
      var resCont = _this._resCont;
      var sidebarCont = _this._sidebarCont;
      var footer = _this._footerCont;
      var header = _this._headerCont;
      var stickyHeader = _this._stickyHeader;
      var stickyFooter = _this._stickyFooter;
      var days = _this._days;
      var daysNr = _this._colsNr;
      var rtl = isRtl ? -1 : 1;
      var margin = isRtl ? "marginRight" : "marginLeft";
      var dayWidth = gridWidth / daysNr;
      var dayIndex = dayWidth ? constrain(floor(scrollLeft * rtl / dayWidth), 0, daysNr - 1) : 0;
      var rows = _this._rows;
      var virtualX = floor(scrollLeft * rtl / (dayWidth / _this._times.length || 74));
      if (stickyHeader && hasSticky) {
        var headerStyle = stickyHeader.style;
        headerStyle.marginTop = scrollTop < 0 ? -scrollTop + "px" : "";
        headerStyle[margin] = scrollLeft * rtl < 0 ? -scrollLeft * rtl + "px" : "";
      }
      if (stickyFooter && hasSticky) {
        var footerStyle = stickyFooter.style;
        footerStyle.marginTop = scrollTop < 0 ? -scrollTop + "px" : "";
        footerStyle[margin] = scrollLeft * rtl < 0 ? -scrollLeft * rtl + "px" : "";
      }
      if (!gridWidth) {
        return;
      }
      if ((header || footer) && _this._isDailyResolution) {
        var updateStickyLabel = function(label, key) {
          if (label && dayWidth) {
            var labelWidth = label.offsetWidth;
            var labelStyle = label.style;
            var nextDayIndex = constrain(floor((scrollLeft * rtl + labelWidth) / dayWidth), 0, daysNr - 1);
            if (days[dayIndex][key + "Index"] !== days[nextDayIndex][key + "Index"]) {
              labelStyle[margin] = -(scrollLeft * rtl + labelWidth - days[nextDayIndex][key + "Index"] * dayWidth + 1) + "px";
            } else {
              labelStyle[margin] = "";
            }
          }
        };
        updateStickyLabel(_this._stickyDate, "date");
        updateStickyLabel(_this._stickyMonth, "month");
        updateStickyLabel(_this._stickyWeek, "week");
        if (!hasSticky) {
          if (footer) {
            footer.scrollLeft = scrollLeft;
          }
          if (header) {
            header.scrollLeft = scrollLeft;
          }
        }
      }
      if (!hasSticky || isRtl) {
        if (resCont) {
          resCont.scrollTop = scrollTop;
        }
        if (sidebarCont) {
          sidebarCont.scrollTop = scrollTop;
        }
      }
      _this._scrollTop = scrollTop;
      var virtualChange = false;
      var virtualStartY = 0;
      var virtualEndY = 1;
      var i = 1;
      while (i < rows.length && rows[i].top < scrollTop + gridHeight * 1.5) {
        if (rows[i].top <= scrollTop - gridHeight * 0.5) {
          virtualStartY = i;
        }
        virtualEndY = ++i;
      }
      if (s.virtualScroll && (virtualStartY !== state.virtualStartY || virtualEndY !== state.virtualEndY || virtualX !== state.virtualX)) {
        virtualChange = true;
        _this._calcRowHeights = true;
      }
      if (virtualChange || (_this._stickyDate || _this._stickyMonth || _this._stickyWeek) && dayIndex !== state.dayIndex) {
        _this.setState({
          dayIndex,
          virtualStartY,
          virtualEndY,
          virtualX
        });
      }
      if (!_this._isScrolling && ev) {
        _this._setViewDates(scrollLeft);
      }
      _this._onMouseMove();
    };
    _this._setStickyHeader = function(el2) {
      _this._stickyHeader = el2;
    };
    _this._setStickyFooter = function(el2) {
      _this._stickyFooter = el2;
    };
    _this._setStickyDay = function(el2) {
      _this._stickyDate = el2;
    };
    _this._setStickyMonth = function(el2) {
      _this._stickyMonth = el2;
    };
    _this._setStickyWeek = function(el2) {
      _this._stickyWeek = el2;
    };
    _this._setCont = function(el2) {
      _this._scrollCont = el2;
    };
    _this._setResCont = function(el2) {
      _this._resCont = el2;
    };
    _this._setSidebarCont = function(el2) {
      _this._sidebarCont = el2;
    };
    _this._setGridCont = function(el2) {
      _this._gridCont = el2;
    };
    _this._setDraggedResourceLineEl = function(el2) {
      _this._draggedResourceLineEl = el2;
    };
    _this._setDraggedResourceEl = function(el2) {
      _this._draggedResourceEl = el2;
    };
    _this._setHeaderCont = function(el2) {
      _this._headerCont = el2;
    };
    _this._setFooterCont = function(el2) {
      _this._footerCont = el2;
    };
    _this._setCursorTimeCont = function(el2) {
      _this._cursorTimeCont = el2;
    };
    return _this;
  }
  TimelineBase2.prototype._render = function(s, state) {
    var _this = this;
    _super.prototype._render.call(this, s, state);
    var prevS = this._prevS;
    var eventMap = this._eventMap;
    var resourceTops = this._resourceTops;
    var scrollTop = this._scrollTop || 0;
    var times = this._times;
    var timesLength = times.length;
    var stepCell = this._stepCell;
    var startMinutes = this._startTime % stepCell;
    var endMinutes = this._endTime % stepCell + 1;
    var hasResY = s.resolutionVertical === "day";
    var disableVirtual = s.virtualScroll === false;
    var cellWidth = state.cellWidth || 74;
    var dayWidth = state.dayWidth || cellWidth * this._time / stepCell;
    var dragData = state.dragData;
    var firstCellWidth = cellWidth * ((stepCell - startMinutes) % stepCell / stepCell);
    var lastCellWidth = cellWidth * (endMinutes % stepCell) / stepCell;
    var displayShortDays = this._isDailyResolution && (s.type === "month" || this._isMulti || timesLength > 1);
    var colWidths = {
      xxsmall: "xxs",
      xsmall: "xs",
      small: "s",
      medium: "m",
      large: "l",
      xlarge: "xl",
      xxlarge: "xxl",
      xxxlarge: "xxxl"
    };
    var colWidth = s.columnWidth ? colWidths[s.columnWidth] : this._hasSlots ? "l" : displayShortDays ? "s" : "xl";
    this._colWidthClass = " mbsc-timeline-column-" + colWidth;
    this._colClass = s.resources || !hasResY ? "mbsc-timeline-resource-col" : "mbsc-timeline-date-col";
    this._dayClass = this._isDailyResolution && (s.type === "month" || this._isMulti) ? " mbsc-timeline-day-month" : "";
    this._hasRows = this._hasResources || hasResY;
    this._stickyDay = this._days[state.dayIndex || 0] || this._days[0];
    this._startCellStyle = startMinutes % stepCell !== 0 ? {
      width: firstCellWidth + "px"
    } : UNDEFINED;
    this._endCellStyle = endMinutes % stepCell !== 0 ? {
      width: lastCellWidth + "px"
    } : UNDEFINED;
    this._resourceWidth = (state.resourceColWidth || 0) + this._resourceDepth * (state.resourceDepthStep || 0);
    var cols = this._cols;
    var colsNr = this._colsNr;
    var cellsNr = colsNr * timesLength;
    var cellsInView = floor((state.scrollContWidth || 0) / dayWidth * timesLength) || 16;
    var cellsBufferNr = constrain(floor(cellsInView / 2), 8, 30);
    var vX = constrain(state.virtualX || 0, 0, cellsNr - 1);
    var virtualStartX = disableVirtual ? 0 : constrain(vX - cellsBufferNr, 0, cellsNr - 1);
    var virtualEndX = disableVirtual ? cellsNr - 1 : constrain(vX + cellsInView + cellsBufferNr, 0, cellsNr - 1);
    var virtualStartDay = constrain(floor(virtualStartX / timesLength), 0, colsNr - 1);
    var virtualEndDay = constrain(floor(virtualEndX / timesLength), 0, colsNr - 1);
    var virtualDays = [];
    var addedCols = {};
    var vStart = times[0];
    var vEnd = times[timesLength - 1];
    for (var i = virtualStartDay; i <= virtualEndDay; i++) {
      var dayData = cols[i];
      dayData.phStart = 0;
      dayData.phEnd = 0;
      dayData.times = [];
      for (var j = 0; j < timesLength; j++) {
        var t = times[j];
        var k = i * timesLength + j;
        if (k === virtualStartX && j) {
          vStart = t;
          dayData.phStart = (t - this._startTime) * dayWidth / this._time;
        }
        if (k === virtualEndX && j < timesLength - 1) {
          vEnd = t;
          dayData.phEnd = (this._endTime - t - stepCell) * dayWidth / this._time;
        }
        if (k >= virtualStartX && k <= virtualEndX || t === this._dragTime) {
          dayData.times.push({
            first: !j,
            hidden: t === this._dragTime && (k < virtualStartX || k > virtualEndX),
            i: j,
            last: j === timesLength - 1,
            t
          });
        }
      }
      addedCols[dayData.dateKey] = true;
      virtualDays.push(dayData);
    }
    var vStartDay = virtualDays[0].date;
    var vEndDay = virtualDays[virtualDays.length - 1].date;
    var isViewEnd = hasResY || !this._isDailyResolution && virtualEndDay === colsNr - 1;
    this._virtualStart = hasResY ? +this._firstDayTz : +addTime(vStartDay, vStart, s);
    this._virtualEnd = isViewEnd ? +this._lastDayTz : +addTime(vEndDay, vEnd + stepCell, s);
    this._virtualDays = virtualDays;
    this._phXStart = disableVirtual ? 0 : virtualStartDay * dayWidth;
    this._phXEnd = disableVirtual ? 0 : (colsNr - virtualEndDay - 1) * dayWidth;
    this._rowHeights = {};
    this._dragCol = "";
    this._dragRow = "";
    this._fixedResources = [];
    this._fixedResourceTops = {};
    this._fixedHeight = state.headerHeight || 0;
    var gridContHeight = (state.scrollContHeight || 0) - (state.headerHeight || 0) - (state.footerHeight || 0);
    var rowHeight = state.rowHeight || 52;
    var parentRowHeight = state.parentRowHeight || 52;
    var gutterHeight = state.gutterHeight !== UNDEFINED ? state.gutterHeight : 16;
    var visibleResources = this._visibleResources;
    var verticalDays = hasResY ? this._days : [{}];
    var totalRows = visibleResources.length * verticalDays.length;
    var rows = [];
    var resourceMap = {};
    var addedGroups = {};
    var addedRows = {};
    var virtualRows = [];
    var totalHeight = 0;
    if (state.hasScrollY) {
      this._resourceTops = {};
    }
    verticalDays.forEach(function(d, i2) {
      visibleResources.forEach(function(r2, j2) {
        var key2 = (hasResY ? d.dateKey + "-" : "") + r2.id;
        var row2 = {
          dayIndex: i2,
          key: key2,
          resource: r2,
          top: 0
        };
        resourceMap[key2] = r2;
        if (gridContHeight) {
          var currRowHeight = r2.isParent ? parentRowHeight : rowHeight;
          var showMoreHeight = _this._eventRows["more-" + key2] ? 24 : 0;
          var eventsHeight = (_this._eventRows[key2] || (r2.eventCreation === false ? 0 : 1)) * _this._eventHeight;
          var realHeight = _this._rowHeightsReal[key2];
          var resHeight = _this._setRowHeight ? realHeight || Math.max(eventsHeight + gutterHeight + showMoreHeight, currRowHeight) : currRowHeight;
          var height = _this._variableEventHeight ? realHeight : resHeight;
          _this._rowHeights[key2] = _this._setRowHeight && height ? height + "px" : UNDEFINED;
          if (!hasResY && r2.fixed) {
            _this._fixedResourceTops[key2] = _this._fixedHeight;
            _this._fixedHeight += resHeight;
            _this._fixedResources.push({
              height: resHeight,
              index: j2,
              key: key2,
              resource: r2
            });
          }
          if (state.hasScrollY) {
            _this._resourceTops[key2] = totalHeight;
          }
          row2.top = totalHeight;
          totalHeight += resHeight;
        }
        rows.push(row2);
      });
    });
    var virtualStartY = 0;
    var virtualEndY = disableVirtual ? totalRows : Math.min(30, totalRows);
    if (!disableVirtual && gridContHeight) {
      var l = 0;
      while (l < rows.length && rows[l].top < scrollTop + gridContHeight * 1.5) {
        if (rows[l].top <= scrollTop - gridContHeight * 0.5) {
          virtualStartY = l;
        }
        virtualEndY = ++l;
      }
    }
    var rowGroup = [];
    var lastDayIndex = -1;
    for (var i = virtualStartY; i < virtualEndY; i++) {
      var row = rows[i];
      if (row) {
        var currDayIndex = row.dayIndex;
        if (lastDayIndex !== currDayIndex) {
          rowGroup = [];
          virtualRows.push({
            day: hasResY ? this._days[currDayIndex] : UNDEFINED,
            rows: rowGroup
          });
          lastDayIndex = currDayIndex;
          addedGroups[currDayIndex] = virtualRows[virtualRows.length - 1];
        }
        addedRows[row.key] = true;
        rowGroup.push(row.resource);
      }
    }
    var fixedRowsHeight = 0;
    for (var _i = 0, _a = this._fixedResources; _i < _a.length; _i++) {
      var r = _a[_i];
      if (!addedRows[r.key]) {
        rowGroup.unshift(r.resource);
        addedRows[r.key] = true;
        fixedRowsHeight += r.height;
      }
    }
    if (dragData && dragData.originResource !== UNDEFINED) {
      var resource = dragData.originResource;
      var dateKey = getDateStr(new Date(dragData.originDate));
      var key = (hasResY ? dateKey + "-" : "") + resource;
      var groupIndex = hasResY ? this._dayIndexMap[dateKey] : 0;
      var colIndex = hasResY ? 0 : this._colIndexMap[dateKey];
      var colKey = cols[colIndex].dateKey;
      if (!addedRows[key]) {
        var group = addedGroups[groupIndex];
        if (!group) {
          group = {
            day: hasResY ? this._days[groupIndex] : UNDEFINED,
            hidden: true,
            rows: []
          };
          virtualRows.push(group);
        }
        group.rows.push(resourceMap[key]);
        this._dragRow = key;
      }
      if (!hasResY && !addedCols[colKey] && !dragData.draggedResource) {
        virtualDays.push(cols[colIndex]);
        this._dragCol = colKey;
      }
    }
    this._gridHeight = totalHeight;
    this._rows = rows;
    this._virtualRows = virtualRows;
    this._phY = !disableVirtual ? rows[virtualStartY].top - fixedRowsHeight : 0;
    if (!this._hasSlots) {
      this._viewEvents = {};
      this._viewColors = {};
      this._viewInvalids = {};
      virtualRows.forEach(function(group2) {
        var day = group2.day;
        var dateKey2 = day ? day.dateKey : "";
        group2.rows.forEach(function(resource2) {
          var resourceId = resource2.id;
          var key2 = (dateKey2 ? dateKey2 + "-" : "") + resourceId;
          _this._viewEvents[key2] = _this._getVirtualData(_this._events[resourceId][DEF_ID][dateKey2 || "all"], true);
          _this._viewColors[key2] = _this._getVirtualData(_this._colors[resourceId][DEF_ID][dateKey2 || "all"]);
          _this._viewInvalids[key2] = _this._getVirtualData(_this._invalids[resourceId][DEF_ID][dateKey2 || "all"]);
        });
      });
    }
    var viewStart = new Date(this._virtualStart);
    var viewEnd = new Date(this._virtualEnd);
    var resourceStart = rows[virtualStartY] && rows[virtualStartY].resource.id;
    var resourceEnd = rows[virtualEndY - 1] && rows[virtualEndY - 1].resource.id;
    var pageX = floor(vX / cellsBufferNr);
    var pageY = floor(scrollTop / (gridContHeight / 2));
    if (gridContHeight && !disableVirtual && (pageX !== this._oldPageX || pageY !== this._oldPageY || s.selected !== prevS.selected) && (+viewStart !== +this._oldViewStart || resourceStart !== this._oldResourceStart)) {
      var oldViewStart_1 = this._oldViewStart;
      var oldViewEnd_1 = this._oldViewEnd;
      var oldResourceStart_1 = this._oldResourceStart;
      var oldResourceEnd_1 = this._oldResourceEnd;
      clearTimeout(this._loadTimer);
      this._loadTimer = setTimeout(function() {
        _this._hook("onVirtualLoading", {
          oldResourceEnd: oldResourceEnd_1,
          oldResourceStart: oldResourceStart_1,
          oldViewEnd: oldViewEnd_1,
          oldViewStart: oldViewStart_1,
          resourceEnd,
          resourceStart,
          viewEnd,
          viewStart
        });
      }, 100);
      this._oldResourceStart = resourceStart;
      this._oldResourceEnd = resourceEnd;
      this._oldViewStart = viewStart;
      this._oldViewEnd = viewEnd;
      this._oldPageX = pageX;
      this._oldPageY = pageY;
    }
    if (s.connections !== prevS.connections || s.eventMap !== prevS.eventMap || s.theme !== prevS.theme || s.rtl !== prevS.rtl) {
      this._calcConnections = true;
    }
    if (this._hasSlots) {
      this._connections = UNDEFINED;
    }
    if (this._calcConnections && !this._hasSlots && !this._shouldCheckSize && this._gridWidth) {
      var connections = [];
      var eventHeight = this._eventHeight;
      var gridWidth = this._gridWidth;
      var gridHeight = state.hasScrollY ? this._gridHeight : gridContHeight;
      var constLineH = 1500 / gridWidth;
      var isRtl = s.rtl === true;
      var rtl = isRtl ? -1 : 1;
      var arrowH = 750 / gridWidth * rtl;
      var arrowV = 400 / gridHeight * rtl;
      var eventHeightInPercent = 100 * eventHeight / gridHeight;
      for (var _b = 0, _c = s.connections || []; _b < _c.length; _b++) {
        var connection = _c[_b];
        var fromEvent = eventMap[connection.from];
        var toEvent = eventMap[connection.to];
        var arrow = connection.arrow;
        var color = connection.color;
        var cssClass = connection.cssClass || "";
        var id2 = connection.from + "__" + connection.to;
        var type = connection.type || "fs";
        if (fromEvent && toEvent) {
          var fromPos = fromEvent.position;
          var toPos = toEvent.position;
          var hasFromPos = !!fromPos && fromPos.width !== UNDEFINED;
          var hasToPos = !!toPos && toPos.width !== UNDEFINED;
          var fromResource = fromEvent.resource;
          var toResource = toEvent.resource;
          if ((hasFromPos || hasToPos) && fromPos && toPos && resourceTops[fromResource] >= 0 && resourceTops[toResource] >= 0) {
            var isFirstEnd = type === "fs" || type === "ff";
            var isSecondStart = type === "fs" || type === "ss";
            var from = isFirstEnd ? fromEvent.endDate : fromEvent.startDate;
            var to = isSecondStart ? toEvent.startDate : toEvent.endDate;
            var isToBefore = to < from;
            var startDate = isToBefore ? +to : +from;
            var endDate = isToBefore ? +from : +to;
            var fromTop = fromPos.top || 0;
            var toTop = toPos.top || 0;
            var fromLeft = hasFromPos ? fromEvent.offset : isToBefore ? 100 : 0;
            var toLeft = hasToPos ? toEvent.offset : isToBefore ? 0 : 100;
            var fromWidth = hasFromPos ? +fromPos.width.replace("%", "") : 0;
            var toWidth = hasToPos ? +toPos.width.replace("%", "") : 0;
            var resourceTopsDiff = resourceTops[toResource] - resourceTops[fromResource];
            var avoidLinethrough = !resourceTopsDiff && (type === "fs" && isToBefore || type === "sf" && !isToBefore || type === "ff" || type === "ss") && toTop === fromTop;
            var lineWidth = isFirstEnd && isSecondStart ? toLeft - fromLeft - fromWidth - 2 * constLineH : isFirstEnd && !isSecondStart ? toLeft - fromLeft + (toWidth - fromWidth) : !isFirstEnd && isSecondStart ? toLeft - fromLeft : toLeft - fromLeft + toWidth + 2 * constLineH;
            var toUpperResource = resourceTopsDiff < 0 || !resourceTopsDiff && toTop < fromTop ? -1 : 1;
            var lineHeight = 100 * (resourceTopsDiff - fromTop * eventHeight + toTop * eventHeight + (avoidLinethrough ? eventHeight : 0)) / gridHeight;
            var reversedHLine = type === "fs" && lineWidth < 0 || (type === "ff" || type === "ss") && avoidLinethrough || type === "sf";
            var drawHorizontalFirst = type === "ss" && isToBefore && !reversedHLine || type === "ff" && !isToBefore && !reversedHLine || type === "sf" && lineWidth < 0;
            var posX = (isRtl ? 100 - fromLeft : fromLeft) + (isFirstEnd ? fromWidth * rtl : 0);
            var posY = 100 * (resourceTops[fromResource] + fromTop * eventHeight + 3 + eventHeight / 2) / gridHeight;
            if (hasFromPos && (arrow === "from" || arrow === "bidirectional")) {
              var computedArrowH = isFirstEnd ? arrowH : arrowH * -1;
              connections.push({
                color,
                cssClass: "mbsc-connection-arrow " + cssClass,
                endDate,
                fill: color,
                id: id2 + "__start",
                pathD: "M ".concat(posX, ", ").concat(posY, " L ").concat(posX + computedArrowH, " ").concat(posY - arrowV, " L ").concat(posX + computedArrowH, " ").concat(posY + arrowV, " Z"),
                startDate
              });
            }
            var pathD = "M ".concat(posX, ", ").concat(posY);
            posX += isFirstEnd ? constLineH * rtl : -constLineH * rtl;
            if (drawHorizontalFirst) {
              posX += lineWidth * rtl;
            }
            if (lineHeight) {
              pathD += " H ".concat(posX);
              if (!drawHorizontalFirst) {
                posY += lineHeight - (reversedHLine ? eventHeightInPercent / 2 : 0) * toUpperResource;
                pathD += " V ".concat(posY);
              }
            }
            if (!drawHorizontalFirst) {
              posX += lineWidth * rtl;
            }
            if (lineHeight) {
              pathD += " H ".concat(posX);
              if (drawHorizontalFirst) {
                posY += lineHeight - (reversedHLine ? eventHeightInPercent / 2 : 0) * toUpperResource;
                pathD += " V ".concat(posY);
              }
            }
            if (lineHeight && reversedHLine) {
              posY += eventHeightInPercent / 2 * toUpperResource * (avoidLinethrough ? -1 : 1);
              pathD += " V ".concat(posY);
            }
            posX += isSecondStart ? constLineH * rtl : -constLineH * rtl;
            pathD += " H ".concat(posX);
            connections.push({
              color,
              cssClass,
              id: id2,
              pathD,
              startDate,
              endDate
            });
            if (hasToPos && (arrow === "to" || arrow === "bidirectional" || arrow === true)) {
              var computedArrowH = isSecondStart ? arrowH * -1 : arrowH;
              connections.push({
                color,
                cssClass: "mbsc-connection-arrow " + cssClass,
                endDate,
                fill: color,
                id: id2 + "__end",
                pathD: "M ".concat(posX, ", ").concat(posY, " L ").concat(posX + computedArrowH, " ").concat(posY - arrowV, " L ").concat(posX + computedArrowH, " ").concat(posY + arrowV, " Z"),
                startDate
              });
            }
          }
        }
      }
      this._connections = connections;
      this._calcConnections = false;
    }
  };
  TimelineBase2.prototype._getVirtualData = function(rangeData, checkDrag) {
    var dragData = this.state.dragData;
    var draggedEventId = dragData && dragData.draggedEvent && dragData.draggedEvent.id;
    var dataForView = [[]];
    if (rangeData) {
      var widths = [];
      var tracks = rangeData.tracks;
      if (tracks) {
        for (var i = 0; i < tracks.length; i++) {
          dataForView[i] = [];
          tracks[i] = 0;
          widths[i] = 0;
        }
      }
      for (var _i = 0, _a = rangeData.data; _i < _a.length; _i++) {
        var item = _a[_i];
        var isInView = this._virtualStart <= item.layoutEnd && this._virtualEnd > item.layoutStart;
        var track = item.track || 0;
        if (tracks && (!isInView || !this._calcRowHeights)) {
          tracks[track] = Math.max(tracks[track], this._eventHeights[item.key] || 0);
        }
        if (checkDrag && draggedEventId === item.id || isInView) {
          if (!tracks || !this._setRowHeight || !this._variableEventHeight) {
            dataForView[0].push(item);
          } else {
            var rtl = this.s.rtl;
            var pos = item.position;
            if (pos) {
              var offset = rtl ? pos.right : pos.left;
              var newOffset = offset;
              var changed = false;
              if (!this._hasSlots) {
                newOffset = item.offset - widths[track] + "%";
                if (newOffset !== offset) {
                  pos.left = rtl ? "" : newOffset;
                  pos.right = rtl ? newOffset : "";
                  changed = true;
                }
              }
              dataForView[track].push(changed ? __assign({}, item) : item);
              widths[track] += +pos.width.replace("%", "");
            }
          }
        }
      }
    }
    return dataForView;
  };
  TimelineBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵTimelineBase_BaseFactory;
    return function TimelineBase_Factory(__ngFactoryType__) {
      return (ɵTimelineBase_BaseFactory || (ɵTimelineBase_BaseFactory = ɵɵgetInheritedFactory(TimelineBase2)))(__ngFactoryType__ || TimelineBase2);
    };
  })();
  TimelineBase2.ɵdir = ɵɵdefineDirective({
    type: TimelineBase2,
    selectors: [["", "mbsc-tml-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return TimelineBase2;
}(STBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-tml-b]"
    }]
  }], null, null);
})();
var DraggableDirective = function(_super) {
  __extends(DraggableDirective2, _super);
  function DraggableDirective2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  DraggableDirective2.ɵfac = /* @__PURE__ */ (() => {
    let ɵDraggableDirective_BaseFactory;
    return function DraggableDirective_Factory(__ngFactoryType__) {
      return (ɵDraggableDirective_BaseFactory || (ɵDraggableDirective_BaseFactory = ɵɵgetInheritedFactory(DraggableDirective2)))(__ngFactoryType__ || DraggableDirective2);
    };
  })();
  DraggableDirective2.ɵdir = ɵɵdefineDirective({
    type: DraggableDirective2,
    selectors: [["", "mbsc-draggable", ""]],
    inputs: {
      dragData: "dragData",
      type: "type"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return DraggableDirective2;
}(DraggableBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DraggableDirective, [{
    type: Directive,
    args: [{
      selector: "[mbsc-draggable]"
    }]
  }], null, {
    dragData: [{
      type: Input
    }],
    type: [{
      type: Input
    }]
  });
})();
var MbscDraggableModule = function() {
  function MbscDraggableModule2() {
  }
  MbscDraggableModule2.ɵfac = function MbscDraggableModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscDraggableModule2)();
  };
  MbscDraggableModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscDraggableModule2,
    declarations: [DraggableBase, DraggableDirective],
    imports: [CommonModule],
    exports: [DraggableDirective]
  });
  MbscDraggableModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscDraggableModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDraggableModule, [{
    type: NgModule,
    args: [{
      declarations: [DraggableBase, DraggableDirective],
      exports: [DraggableDirective],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var DropcontainerBase = function(_super) {
  __extends(DropcontainerBase2, _super);
  function DropcontainerBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onExternalDrag = function(args) {
      var element = _this.s.element || _this._el;
      var isIn = function() {
        return args.endY < _this._elBottom && args.endY > _this._elTop && args.endX > _this._elLeft && args.endX < _this._elRight;
      };
      var isInArea;
      switch (args.eventName) {
        case "onDragStart":
          if (element) {
            var rect = element.getBoundingClientRect();
            _this._elTop = rect.top;
            _this._elBottom = rect.bottom;
            _this._elLeft = rect.left;
            _this._elRight = rect.right;
            _this._isItemIn = _this._isOwner = isIn();
          }
          break;
        case "onDragMove":
          isInArea = isIn();
          if (isInArea && !_this._isItemIn) {
            _this._hook("onItemDragEnter", {
              clone: args.clone,
              data: args.dragData,
              dataType: args.dragDataType,
              domEvent: args.domEvent
            });
          } else if (!isInArea && _this._isItemIn) {
            _this._hook("onItemDragLeave", {
              clone: args.clone,
              data: args.dragData,
              dataType: args.dragDataType,
              domEvent: args.domEvent
            });
          }
          _this._isItemIn = isInArea;
          break;
        case "onDragEnd":
          if (_this._isItemIn && !_this._isOwner) {
            if (args.from) {
              if (args.dragDataType === "resource") {
                args.from._resourceDropped = true;
              } else {
                args.from._eventDropped = true;
              }
            }
            _this._hook("onItemDrop", {
              clone: args.clone,
              data: args.dragData,
              dataType: args.dragDataType,
              domEvent: args.domEvent
            });
          }
          _this._isItemIn = false;
          break;
      }
    };
    return _this;
  }
  DropcontainerBase2.prototype._mounted = function() {
    this._unsubscribe = subscribeExternalDrag(this._onExternalDrag);
  };
  DropcontainerBase2.prototype._destroy = function() {
    if (this._unsubscribe) {
      unsubscribeExternalDrag(this._unsubscribe);
    }
  };
  DropcontainerBase2._name = "Dropcontainer";
  DropcontainerBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵDropcontainerBase_BaseFactory;
    return function DropcontainerBase_Factory(__ngFactoryType__) {
      return (ɵDropcontainerBase_BaseFactory || (ɵDropcontainerBase_BaseFactory = ɵɵgetInheritedFactory(DropcontainerBase2)))(__ngFactoryType__ || DropcontainerBase2);
    };
  })();
  DropcontainerBase2.ɵdir = ɵɵdefineDirective({
    type: DropcontainerBase2,
    selectors: [["", "mbsc-dropcontainer", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return DropcontainerBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropcontainerBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-dropcontainer]"
    }]
  }], null, null);
})();
var MbscDropcontainer = function(_super) {
  __extends(MbscDropcontainer2, _super);
  function MbscDropcontainer2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onItemDragEnter = new EventEmitter();
    _this.onItemDragLeave = new EventEmitter();
    _this.onItemDrop = new EventEmitter();
    return _this;
  }
  MbscDropcontainer2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscDropcontainer_BaseFactory;
    return function MbscDropcontainer_Factory(__ngFactoryType__) {
      return (ɵMbscDropcontainer_BaseFactory || (ɵMbscDropcontainer_BaseFactory = ɵɵgetInheritedFactory(MbscDropcontainer2)))(__ngFactoryType__ || MbscDropcontainer2);
    };
  })();
  MbscDropcontainer2.ɵcmp = ɵɵdefineComponent({
    type: MbscDropcontainer2,
    selectors: [["mbsc-dropcontainer"]],
    outputs: {
      onItemDragEnter: "onItemDragEnter",
      onItemDragLeave: "onItemDragLeave",
      onItemDrop: "onItemDrop"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscDropcontainer_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscDropcontainer2;
}(DropcontainerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDropcontainer, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-dropcontainer",
      template: "<ng-content></ng-content>"
    }]
  }], null, {
    onItemDragEnter: [{
      type: Output
    }],
    onItemDragLeave: [{
      type: Output
    }],
    onItemDrop: [{
      type: Output
    }]
  });
})();
var MbscDropcontainerModule = function() {
  function MbscDropcontainerModule2() {
  }
  MbscDropcontainerModule2.ɵfac = function MbscDropcontainerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscDropcontainerModule2)();
  };
  MbscDropcontainerModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscDropcontainerModule2,
    declarations: [DropcontainerBase, MbscDropcontainer],
    imports: [CommonModule],
    exports: [MbscDropcontainer]
  });
  MbscDropcontainerModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscDropcontainerModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscDropcontainerModule, [{
    type: NgModule,
    args: [{
      declarations: [DropcontainerBase, MbscDropcontainer],
      exports: [MbscDropcontainer],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var ListItemBase = function(_super) {
  __extends(ListItemBase2, _super);
  function ListItemBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onClick = function(ev) {
      _this._triggerEvent("onClick", ev);
      if (_this.s.selected) {
        _this.setState({
          hasFocus: false
        });
      }
    };
    _this._onDoubleClick = function(ev) {
      _this._triggerEvent("onDoubleClick", ev);
    };
    _this._onRightClick = function(ev) {
      _this._triggerEvent("onRightClick", ev);
    };
    return _this;
  }
  ListItemBase2.prototype._mounted = function() {
    var _this = this;
    var isDrag;
    var touchTimer;
    this._unlisten = gestureListener(this._el, {
      click: true,
      keepFocus: true,
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onEnd: function(ev) {
        if (isDrag) {
          var s = _this.s;
          var args = __assign({}, ev);
          var eventData = s.eventData;
          args.domEvent.preventDefault();
          args.drag = true;
          args.event = s.event;
          args.eventData = eventData;
          args.resource = eventData && eventData.currentResource && eventData.currentResource.id;
          args.slot = eventData && eventData.currentSlot && eventData.currentSlot.id;
          _this._hook("onDragEnd", args);
          isDrag = false;
        }
        clearTimeout(touchTimer);
      },
      onFocus: function() {
        _this.setState({
          hasFocus: true
        });
      },
      onHoverIn: function(ev) {
        if (_this.s.actionable) {
          _this.setState({
            hasHover: true
          });
        }
        _this._triggerEvent("onHoverIn", ev);
      },
      onHoverOut: function(ev) {
        _this.setState({
          hasHover: false
        });
        _this._triggerEvent("onHoverOut", ev);
      },
      onKeyDown: function(ev) {
        var event = _this.s.event;
        switch (ev.keyCode) {
          case ENTER:
          case SPACE:
            _this._el.click();
            ev.preventDefault();
            break;
          case BACKSPACE:
          case DELETE:
            if (event && event.editable !== false) {
              _this._hook("onDelete", {
                domEvent: ev,
                event,
                source: "agenda"
              });
            }
            break;
        }
      },
      onMove: function(ev) {
        var s = _this.s;
        var args = __assign({}, ev);
        var eventData = s.eventData;
        args.drag = true;
        args.event = s.event;
        args.eventData = eventData;
        args.external = true;
        args.resource = eventData && eventData.currentResource && eventData.currentResource.id;
        args.slot = eventData && eventData.currentSlot && eventData.currentSlot.id;
        if (isDrag || !args.isTouch) {
          args.domEvent.preventDefault();
        }
        if (isDrag) {
          _this._hook("onDragMove", args);
        } else if (Math.abs(args.deltaX) > 7 || Math.abs(args.deltaY) > 7) {
          clearTimeout(touchTimer);
          if (!args.isTouch && s.drag && s.event.editable !== false) {
            isDrag = true;
            _this._hook("onDragStart", args);
          }
        }
      },
      onPress: function() {
        if (_this.s.actionable) {
          _this.setState({
            isActive: true
          });
        }
      },
      onRelease: function() {
        _this.setState({
          isActive: false
        });
      },
      onStart: function(ev) {
        var s = _this.s;
        if (ev.isTouch && s.drag && s.event.editable !== false && !isDrag) {
          touchTimer = setTimeout(function() {
            var args = __assign({}, ev);
            var eventData = s.eventData;
            args.drag = true;
            args.event = s.event;
            args.eventData = eventData;
            args.resource = eventData && eventData.currentResource && eventData.currentResource.id;
            args.slot = eventData && eventData.currentSlot && eventData.currentSlot.id;
            _this._hook("onDragModeOn", args);
            _this._hook("onDragStart", args);
            isDrag = true;
          }, 350);
        }
        return {
          ripple: s.actionable && s.ripple
        };
      }
    });
  };
  ListItemBase2.prototype._render = function(s, state) {
    this._cssClass = this._className + " mbsc-list-item" + this._theme + this._hb + this._rtl + (s.actionable ? " mbsc-list-item-actionable" : "") + (state.hasFocus ? " mbsc-focus" : "") + (state.hasHover ? " mbsc-hover" : "") + (state.isActive ? " mbsc-active" : "") + (s.selected ? " mbsc-selected" : "");
  };
  ListItemBase2.prototype._destroy = function() {
    if (this._unlisten) {
      this._unlisten();
    }
  };
  ListItemBase2.prototype._triggerEvent = function(name, ev) {
    var s = this.s;
    this._hook(name, {
      date: s.date,
      domEvent: ev,
      event: s.event,
      source: s.source,
      target: this._el
    });
  };
  ListItemBase2.defaults = {
    actionable: true,
    ripple: false
  };
  ListItemBase2._name = "ListItem";
  ListItemBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵListItemBase_BaseFactory;
    return function ListItemBase_Factory(__ngFactoryType__) {
      return (ɵListItemBase_BaseFactory || (ɵListItemBase_BaseFactory = ɵɵgetInheritedFactory(ListItemBase2)))(__ngFactoryType__ || ListItemBase2);
    };
  })();
  ListItemBase2.ɵdir = ɵɵdefineDirective({
    type: ListItemBase2,
    selectors: [["", "mbsc-li-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return ListItemBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListItemBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-li-b]"
    }]
  }], null, null);
})();
var MbscListItem = function(_super) {
  __extends(MbscListItem2, _super);
  function MbscListItem2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onClick = new EventEmitter();
    _this.onDoubleClick = new EventEmitter();
    _this.onRightClick = new EventEmitter();
    _this.onHoverIn = new EventEmitter();
    _this.onHoverOut = new EventEmitter();
    _this.onDragEnd = new EventEmitter();
    _this.onDragModeOff = new EventEmitter();
    _this.onDragModeOn = new EventEmitter();
    _this.onDragMove = new EventEmitter();
    _this.onDragStart = new EventEmitter();
    return _this;
  }
  MbscListItem2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscListItem_BaseFactory;
    return function MbscListItem_Factory(__ngFactoryType__) {
      return (ɵMbscListItem_BaseFactory || (ɵMbscListItem_BaseFactory = ɵɵgetInheritedFactory(MbscListItem2)))(__ngFactoryType__ || MbscListItem2);
    };
  })();
  MbscListItem2.ɵcmp = ɵɵdefineComponent({
    type: MbscListItem2,
    selectors: [["mbsc-list-item"]],
    hostAttrs: ["tabindex", "0"],
    hostVars: 2,
    hostBindings: function MbscListItem_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("click", function MbscListItem_click_HostBindingHandler($event) {
          return ctx2._onClick($event);
        })("contextmenu", function MbscListItem_contextmenu_HostBindingHandler($event) {
          return ctx2._onRightClick($event);
        })("dblclick", function MbscListItem_dblclick_HostBindingHandler($event) {
          return ctx2._onDoubleClick($event);
        });
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      actionable: "actionable",
      cssClass: "cssClass",
      drag: "drag",
      event: "event"
    },
    outputs: {
      onClick: "onClick",
      onDoubleClick: "onDoubleClick",
      onRightClick: "onRightClick",
      onHoverIn: "onHoverIn",
      onHoverOut: "onHoverOut",
      onDragEnd: "onDragEnd",
      onDragModeOff: "onDragModeOff",
      onDragModeOn: "onDragModeOn",
      onDragMove: "onDragMove",
      onDragStart: "onDragStart"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 2,
    vars: 1,
    consts: [[3, "innerHTML"]],
    template: function MbscListItem_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵelement(0, "div", 0);
        ɵɵprojection(1);
      }
      if (rf & 2) {
        ɵɵproperty("innerHTML", ctx2.textParam, ɵɵsanitizeHtml);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscListItem2;
}(ListItemBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscListItem, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(click)": "_onClick($event)",
        "(contextmenu)": "_onRightClick($event)",
        "(dblclick)": "_onDoubleClick($event)",
        "[class]": "_cssClass",
        tabindex: "0"
      },
      selector: "mbsc-list-item",
      template: '<div [innerHTML]="textParam"></div><ng-content\n    ></ng-content>'
    }]
  }], null, {
    actionable: [{
      type: Input
    }],
    cssClass: [{
      type: Input
    }],
    drag: [{
      type: Input
    }],
    event: [{
      type: Input
    }],
    onClick: [{
      type: Output
    }],
    onDoubleClick: [{
      type: Output
    }],
    onRightClick: [{
      type: Output
    }],
    onHoverIn: [{
      type: Output
    }],
    onHoverOut: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }],
    onDragModeOff: [{
      type: Output
    }],
    onDragModeOn: [{
      type: Output
    }],
    onDragMove: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }]
  });
})();
var ListBase = function(_super) {
  __extends(ListBase2, _super);
  function ListBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ListBase2.prototype._render = function(s) {
    this._cssClass = this._className + this._rtl + " mbsc-font mbsc-list" + this._theme;
  };
  ListBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵListBase_BaseFactory;
    return function ListBase_Factory(__ngFactoryType__) {
      return (ɵListBase_BaseFactory || (ɵListBase_BaseFactory = ɵɵgetInheritedFactory(ListBase2)))(__ngFactoryType__ || ListBase2);
    };
  })();
  ListBase2.ɵdir = ɵɵdefineDirective({
    type: ListBase2,
    selectors: [["", "mbsc-l-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return ListBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-l-b]"
    }]
  }], null, null);
})();
var MbscList = function(_super) {
  __extends(MbscList2, _super);
  function MbscList2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscList2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscList_BaseFactory;
    return function MbscList_Factory(__ngFactoryType__) {
      return (ɵMbscList_BaseFactory || (ɵMbscList_BaseFactory = ɵɵgetInheritedFactory(MbscList2)))(__ngFactoryType__ || MbscList2);
    };
  })();
  MbscList2.ɵcmp = ɵɵdefineComponent({
    type: MbscList2,
    selectors: [["mbsc-list"]],
    hostVars: 2,
    hostBindings: function MbscList_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscList_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscList2;
}(ListBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscList, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-list",
      template: "<ng-content></ng-content>"
    }]
  }], null, null);
})();
var ListHeaderBase = function(_super) {
  __extends(ListHeaderBase2, _super);
  function ListHeaderBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ListHeaderBase2.prototype._render = function(s) {
    this._cssClass = this._className + " mbsc-list-header" + this._theme + this._hb;
  };
  ListHeaderBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵListHeaderBase_BaseFactory;
    return function ListHeaderBase_Factory(__ngFactoryType__) {
      return (ɵListHeaderBase_BaseFactory || (ɵListHeaderBase_BaseFactory = ɵɵgetInheritedFactory(ListHeaderBase2)))(__ngFactoryType__ || ListHeaderBase2);
    };
  })();
  ListHeaderBase2.ɵdir = ɵɵdefineDirective({
    type: ListHeaderBase2,
    selectors: [["", "mbsc-lh-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return ListHeaderBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ListHeaderBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-lh-b]"
    }]
  }], null, null);
})();
var MbscListHeader = function(_super) {
  __extends(MbscListHeader2, _super);
  function MbscListHeader2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscListHeader2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscListHeader_BaseFactory;
    return function MbscListHeader_Factory(__ngFactoryType__) {
      return (ɵMbscListHeader_BaseFactory || (ɵMbscListHeader_BaseFactory = ɵɵgetInheritedFactory(MbscListHeader2)))(__ngFactoryType__ || MbscListHeader2);
    };
  })();
  MbscListHeader2.ɵcmp = ɵɵdefineComponent({
    type: MbscListHeader2,
    selectors: [["mbsc-list-header"]],
    hostVars: 2,
    hostBindings: function MbscListHeader_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscListHeader_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscListHeader2;
}(ListHeaderBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscListHeader, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-list-header",
      template: "<ng-content></ng-content>"
    }]
  }], null, null);
})();
var MbscScheduleEvent = function(_super) {
  __extends(MbscScheduleEvent2, _super);
  function MbscScheduleEvent2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onClick = new EventEmitter();
    _this.onDoubleClick = new EventEmitter();
    _this.onRightClick = new EventEmitter();
    _this.onHoverIn = new EventEmitter();
    _this.onHoverOut = new EventEmitter();
    _this.onDelete = new EventEmitter();
    _this.onDragEnd = new EventEmitter();
    _this.onDragModeOff = new EventEmitter();
    _this.onDragModeOn = new EventEmitter();
    _this.onDragMove = new EventEmitter();
    _this.onDragStart = new EventEmitter();
    return _this;
  }
  MbscScheduleEvent2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscScheduleEvent_BaseFactory;
    return function MbscScheduleEvent_Factory(__ngFactoryType__) {
      return (ɵMbscScheduleEvent_BaseFactory || (ɵMbscScheduleEvent_BaseFactory = ɵɵgetInheritedFactory(MbscScheduleEvent2)))(__ngFactoryType__ || MbscScheduleEvent2);
    };
  })();
  MbscScheduleEvent2.ɵcmp = ɵɵdefineComponent({
    type: MbscScheduleEvent2,
    selectors: [["mbsc-schedule-event"]],
    hostVars: 18,
    hostBindings: function MbscScheduleEvent_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("click", function MbscScheduleEvent_click_HostBindingHandler($event) {
          return ctx2._onClick($event);
        })("contextmenu", function MbscScheduleEvent_contextmenu_HostBindingHandler($event) {
          return ctx2._onRightClick($event);
        });
      }
      if (rf & 2) {
        ɵɵattribute("data-id", ctx2.event.id)("data-key", ctx2.event.key)("tabindex", 0)("title", ctx2.event.tooltip);
        ɵɵclassMap(ctx2._cssClass);
        ɵɵstyleProp("color", ctx2._style.color)("height", ctx2._style.height)("left", ctx2._style.left)("right", ctx2._style.right)("top", ctx2._style.top)("width", ctx2._style.width);
      }
    },
    inputs: {
      bufferAfterTemplate: "bufferAfterTemplate",
      bufferBeforeTemplate: "bufferBeforeTemplate",
      contentTemplate: "contentTemplate",
      displayTimezone: "displayTimezone",
      drag: "drag",
      event: "event",
      endDay: "endDay",
      eventHeight: "eventHeight",
      exclusiveEndDates: "exclusiveEndDates",
      gridEndTime: "gridEndTime",
      gridStartTime: "gridStartTime",
      hasResY: "hasResY",
      hidden: "hidden",
      inactive: "inactive",
      isDrag: "isDrag",
      isListing: "isListing",
      isTimeline: "isTimeline",
      lastDay: "lastDay",
      resize: "resize",
      resource: "resource",
      resourceObj: "resourceObj",
      rtl: "rtl",
      selected: "selected",
      singleDay: "singleDay",
      slot: "slot",
      slotObj: "slotObj",
      startDay: "startDay",
      stickyPos: "stickyPos",
      template: "template",
      theme: "theme",
      timezonePlugin: "timezonePlugin"
    },
    outputs: {
      onClick: "onClick",
      onDoubleClick: "onDoubleClick",
      onRightClick: "onRightClick",
      onHoverIn: "onHoverIn",
      onHoverOut: "onHoverOut",
      onDelete: "onDelete",
      onDragEnd: "onDragEnd",
      onDragModeOff: "onDragModeOff",
      onDragModeOn: "onDragModeOn",
      onDragMove: "onDragMove",
      onDragStart: "onDragStart"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 8,
    vars: 9,
    consts: [["default", ""], [3, "class", "ngStyle", 4, "ngIf"], [3, "class", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"], [3, "ngStyle"], [4, "ngIf"], ["aria-hidden", "true"], [3, "innerHTML", 4, "ngIf"], ["class", "mbsc-hidden-content", 4, "ngIf"], [1, "mbsc-hidden-content"]],
    template: function MbscScheduleEvent_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscScheduleEvent_div_0_Template, 2, 4, "div", 1)(1, MbscScheduleEvent_div_1_Template, 2, 4, "div", 1)(2, MbscScheduleEvent_div_2_Template, 1, 2, "div", 2)(3, MbscScheduleEvent_div_3_Template, 1, 2, "div", 2)(4, MbscScheduleEvent_ng_template_4_Template, 8, 19, "ng-template", null, 0, ɵɵtemplateRefExtractor)(6, MbscScheduleEvent_ng_template_6_Template, 0, 0, "ng-template", 3);
        ɵɵelement(7, "div", 4);
      }
      if (rf & 2) {
        const default_r2 = ɵɵreference(5);
        ɵɵproperty("ngIf", ctx2._isStart && ctx2.event.bufferBefore);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._isEnd && ctx2.event.bufferAfter);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._isStart && ctx2.resize && ctx2.event.original.editable !== false);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._isEnd && ctx2.resize && ctx2.event.original.editable !== false);
        ɵɵadvance(3);
        ɵɵproperty("ngTemplateOutlet", ctx2.template && !ctx2._isMore ? ctx2.template : default_r2)("ngTemplateOutletContext", ɵɵpureFunction1(7, _c14, ctx2.event));
        ɵɵadvance();
        ɵɵproperty("innerHTML", ctx2.textParam, ɵɵsanitizeHtml);
      }
    },
    dependencies: [NgIf, NgStyle, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscScheduleEvent2;
}(ScheduleEventBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscScheduleEvent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(click)": "_onClick($event)",
        "(contextmenu)": "_onRightClick($event)",
        "[attr.data-id]": "event.id",
        "[attr.data-key]": "event.key",
        "[attr.tabindex]": "0",
        "[attr.title]": "event.tooltip",
        "[class]": "_cssClass",
        "[style.color]": "_style.color",
        "[style.height]": "_style.height",
        "[style.left]": "_style.left",
        "[style.right]": "_style.right",
        "[style.top]": "_style.top",
        "[style.width]": "_style.width"
      },
      selector: "mbsc-schedule-event",
      template: `
    <div
      *ngIf="_isStart && event.bufferBefore"
      [class]="
        'mbsc-' +
        _host +
        '-event-buffer ' +
        'mbsc-' +
        _host +
        '-event-buffer-before' +
        (bufferBeforeTemplate ? '' : ' mbsc-schedule-event-buffer-background') +
        _theme +
        _rtl
      "
      [ngStyle]="_bufferStyleStart!"
    >
      <ng-template *ngIf="bufferBeforeTemplate" [ngTemplateOutlet]="bufferBeforeTemplate" [ngTemplateOutletContext]="{ $implicit: event }">
      </ng-template>
    </div>
    <div
      *ngIf="_isEnd && event.bufferAfter"
      [class]="
        'mbsc-' +
        _host +
        '-event-buffer ' +
        'mbsc-' +
        _host +
        '-event-buffer-after' +
        (isTimeline ? ' mbsc-timeline-event-buffer' : '') +
        (bufferAfterTemplate ? '' : ' mbsc-schedule-event-buffer-background') +
        _theme +
        _rtl
      "
      [ngStyle]="_bufferStyleEnd!"
    >
      <ng-template *ngIf="bufferAfterTemplate" [ngTemplateOutlet]="bufferAfterTemplate" [ngTemplateOutletContext]="{ $implicit: event }">
      </ng-template>
    </div>
    <div
      *ngIf="_isStart && resize && event.original!.editable !== false"
      [class]="
        'mbsc-schedule-event-resize mbsc-schedule-event-resize-start' +
        (isDrag ? ' mbsc-schedule-event-resize-start-touch' : '') +
        (isTimeline ? ' mbsc-timeline-event-resize' : '') +
        _rtl
      "
    ></div>
    <div
      *ngIf="_isEnd && resize && event.original!.editable !== false"
      [class]="
        'mbsc-schedule-event-resize mbsc-schedule-event-resize-end' +
        (isDrag ? ' mbsc-schedule-event-resize-start-touch' : '') +
        (isTimeline ? ' mbsc-timeline-event-resize' : '') +
        _rtl
      "
    ></div>
    <ng-template #default>
      <div *ngIf="!_isAllDay && !_isMore && !isTimeline" [class]="'mbsc-schedule-event-bar' + _theme + _rtl"></div>
      <div
        [class]="
          'mbsc-schedule-event-background' +
          (isTimeline ? ' mbsc-timeline-event-background' : '') +
          (_isAllDay ? ' mbsc-schedule-event-all-day-background' : '') +
          _theme
        "
        [style.background]="event.style.background"
      ></div>
      <div
        aria-hidden="true"
        [class]="'mbsc-schedule-event-inner' + _theme + (_isAllDay ? ' mbsc-schedule-event-all-day-inner' : '') + (event.cssClass || '')"
        [style.color]="event.style.color"
        [style.left]="!s.rtl ? s.stickyPos : undefined"
        [style.right]="s.rtl ? s.stickyPos : undefined"
      >
        <div [class]="'mbsc-schedule-event-title' + (_isAllDay ? ' mbsc-schedule-event-all-day-title' : '') + _theme">
          <div *ngIf="!contentTemplate || _isMore" [innerHTML]="_html"></div>
          <ng-template
            *ngIf="contentTemplate && !_isMore"
            [ngTemplateOutlet]="contentTemplate"
            [ngTemplateOutletContext]="{ $implicit: event }"
          >
          </ng-template>
        </div>
        <div *ngIf="!_isAllDay && !_isMore" [class]="'mbsc-schedule-event-range' + _theme">
          {{ _rangeText }}
        </div>
      </div>
      <div *ngIf="event.ariaLabel" class="mbsc-hidden-content">{{ event.ariaLabel }}</div>
    </ng-template>
    <ng-template
      [ngTemplateOutlet]="template && !_isMore ? template : default"
      [ngTemplateOutletContext]="{ $implicit: event }"
    ></ng-template>
    <div [innerHTML]="textParam"></div>
  `
    }]
  }], null, {
    bufferAfterTemplate: [{
      type: Input
    }],
    bufferBeforeTemplate: [{
      type: Input
    }],
    contentTemplate: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    drag: [{
      type: Input
    }],
    event: [{
      type: Input
    }],
    endDay: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    gridEndTime: [{
      type: Input
    }],
    gridStartTime: [{
      type: Input
    }],
    hasResY: [{
      type: Input
    }],
    hidden: [{
      type: Input
    }],
    inactive: [{
      type: Input
    }],
    isDrag: [{
      type: Input
    }],
    isListing: [{
      type: Input
    }],
    isTimeline: [{
      type: Input
    }],
    lastDay: [{
      type: Input
    }],
    resize: [{
      type: Input
    }],
    resource: [{
      type: Input
    }],
    resourceObj: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    singleDay: [{
      type: Input
    }],
    slot: [{
      type: Input
    }],
    slotObj: [{
      type: Input
    }],
    startDay: [{
      type: Input
    }],
    stickyPos: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    onClick: [{
      type: Output
    }],
    onDoubleClick: [{
      type: Output
    }],
    onRightClick: [{
      type: Output
    }],
    onHoverIn: [{
      type: Output
    }],
    onHoverOut: [{
      type: Output
    }],
    onDelete: [{
      type: Output
    }],
    onDragEnd: [{
      type: Output
    }],
    onDragModeOff: [{
      type: Output
    }],
    onDragModeOn: [{
      type: Output
    }],
    onDragMove: [{
      type: Output
    }],
    onDragStart: [{
      type: Output
    }]
  });
})();
var MbscWeekDay = function(_super) {
  __extends(MbscWeekDay2, _super);
  function MbscWeekDay2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscWeekDay2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscWeekDay_BaseFactory;
    return function MbscWeekDay_Factory(__ngFactoryType__) {
      return (ɵMbscWeekDay_BaseFactory || (ɵMbscWeekDay_BaseFactory = ɵɵgetInheritedFactory(MbscWeekDay2)))(__ngFactoryType__ || MbscWeekDay2);
    };
  })();
  MbscWeekDay2.ɵcmp = ɵɵdefineComponent({
    type: MbscWeekDay2,
    selectors: [["mbsc-week-day"]],
    hostVars: 4,
    hostBindings: function MbscWeekDay_HostBindings(rf, ctx2) {
      if (rf & 1) {
        ɵɵlistener("click", function MbscWeekDay_click_HostBindingHandler() {
          return ctx2._onClick();
        });
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
        ɵɵstyleProp("background", ctx2.background);
      }
    },
    inputs: {
      background: "background",
      day: "day",
      dayNames: "dayNames",
      dayTemplate: "dayTemplate",
      dayContentTemplate: "dayContentTemplate",
      events: "events",
      isToday: "isToday",
      label: "label",
      largeNames: "largeNames",
      resource: "resource",
      rtl: "rtl",
      selectable: "selectable",
      selected: "selected",
      theme: "theme",
      timestamp: "timestamp",
      onClick: "onClick"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 5,
    consts: [[4, "ngIf"], ["aria-hidden", "true", 3, "class", 4, "ngIf"], ["class", "mbsc-hidden-content", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["aria-hidden", "true"], [1, "mbsc-hidden-content"]],
    template: function MbscWeekDay_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscWeekDay_0_Template, 1, 4, null, 0)(1, MbscWeekDay_div_1_Template, 2, 3, "div", 1)(2, MbscWeekDay_div_2_Template, 2, 3, "div", 1)(3, MbscWeekDay_div_3_Template, 2, 3, "div", 2)(4, MbscWeekDay_4_Template, 1, 4, null, 0);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2.dayTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2.dayTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2.dayTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.label);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.dayContentTemplate);
      }
    },
    dependencies: [NgIf, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscWeekDay2;
}(WeekDayBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscWeekDay, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "(click)": "_onClick()",
        "[class]": "_cssClass",
        "[style.background]": "background"
      },
      selector: "mbsc-week-day",
      template: `
    <ng-template *ngIf="dayTemplate" [ngTemplateOutlet]="dayTemplate" [ngTemplateOutletContext]="{ $implicit: _data }"></ng-template>
    <div
      aria-hidden="true"
      *ngIf="!dayTemplate"
      [class]="
        'mbsc-schedule-header-dayname' +
        _theme +
        (s.selected ? ' mbsc-selected' : '') +
        (s.isToday ? ' mbsc-schedule-header-dayname-curr' : '')
      "
    >
      {{ dayNames[_day] }}
    </div>
    <div
      aria-hidden="true"
      *ngIf="!dayTemplate"
      [class]="
        'mbsc-schedule-header-day' +
        _theme +
        _rtl +
        (s.selected ? ' mbsc-selected' : '') +
        (s.isToday ? ' mbsc-schedule-header-day-today' : '') +
        (state.hasHover ? ' mbsc-hover' : '')
      "
    >
      {{ day }}
    </div>
    <div
      *ngIf="label"
      class="mbsc-hidden-content"
      [attr.role]="s.selectable ? 'button' : null"
      [attr.aria-pressed]="s.selectable ? (s.selected ? 'true' : 'false') : null"
    >
      {{ label }}
    </div>
    <ng-template *ngIf="dayContentTemplate" [ngTemplateOutlet]="dayContentTemplate" [ngTemplateOutletContext]="{ $implicit: _data }">
    </ng-template>
  `
    }]
  }], null, {
    background: [{
      type: Input
    }],
    day: [{
      type: Input
    }],
    dayNames: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dayContentTemplate: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    isToday: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    largeNames: [{
      type: Input
    }],
    resource: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    timestamp: [{
      type: Input
    }],
    onClick: [{
      type: Input
    }]
  });
})();
var MbscTimeIndicator = function(_super) {
  __extends(MbscTimeIndicator2, _super);
  function MbscTimeIndicator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscTimeIndicator2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscTimeIndicator_BaseFactory;
    return function MbscTimeIndicator_Factory(__ngFactoryType__) {
      return (ɵMbscTimeIndicator_BaseFactory || (ɵMbscTimeIndicator_BaseFactory = ɵɵgetInheritedFactory(MbscTimeIndicator2)))(__ngFactoryType__ || MbscTimeIndicator2);
    };
  })();
  MbscTimeIndicator2.ɵcmp = ɵɵdefineComponent({
    type: MbscTimeIndicator2,
    selectors: [["mbsc-time-indicator"]],
    inputs: {
      amText: "amText",
      displayedTime: "displayedTime",
      displayedDays: "displayedDays",
      displayTimezone: "displayTimezone",
      endDay: "endDay",
      firstDay: "firstDay",
      hasResY: "hasResY",
      orientation: "orientation",
      pmText: "pmText",
      rtl: "rtl",
      showDayIndicator: "showDayIndicator",
      startDay: "startDay",
      startTime: "startTime",
      theme: "theme",
      timeFormat: "timeFormat",
      timezones: "timezones",
      timezonePlugin: "timezonePlugin"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 5,
    vars: 8,
    consts: [["aria-hidden", "true", 3, "ngStyle"], [4, "ngIf"], [3, "class", "ngStyle", 4, "ngIf"], [3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngStyle"]],
    template: function MbscTimeIndicator_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵelementStart(0, "div", 0)(1, "div");
        ɵɵtemplate(2, MbscTimeIndicator_ng_container_2_Template, 2, 2, "ng-container", 1)(3, MbscTimeIndicator_ng_container_3_Template, 2, 1, "ng-container", 1);
        ɵɵelementEnd();
        ɵɵtemplate(4, MbscTimeIndicator_div_4_Template, 1, 3, "div", 2);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
        ɵɵproperty("ngStyle", ctx2._pos);
        ɵɵadvance();
        ɵɵclassMap((ctx2.timezones ? "mbsc-flex " : "") + "mbsc-schedule-time-indicator-time mbsc-schedule-time-indicator-time-" + ctx2.orientation + ctx2._theme + ctx2._rtl);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.timezones);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2.timezones);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.showDayIndicator);
      }
    },
    dependencies: [NgStyle, NgIf, NgForOf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscTimeIndicator2;
}(TimeIndicatorBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscTimeIndicator, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      selector: "mbsc-time-indicator",
      template: `
    <div aria-hidden="true" [class]="_cssClass" [ngStyle]="_pos">
      <div
        [class]="
          (timezones ? 'mbsc-flex ' : '') +
          'mbsc-schedule-time-indicator-time mbsc-schedule-time-indicator-time-' +
          orientation +
          _theme +
          _rtl
        "
      >
        <ng-container *ngIf="timezones">
          <div *ngFor="let t of timezones; let i = index; trackBy: _getKey" [class]="'mbsc-schedule-time-indicator-tz' + _theme + _rtl">
            {{ _times[i] }}
          </div>
        </ng-container>
        <ng-container *ngIf="!timezones">
          {{ _time }}
        </ng-container>
      </div>
      <div *ngIf="showDayIndicator" [class]="'mbsc-schedule-time-indicator-day' + _theme + _rtl" [ngStyle]="_dayPos"></div>
    </div>
  `
    }]
  }], null, {
    amText: [{
      type: Input
    }],
    displayedTime: [{
      type: Input
    }],
    displayedDays: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    endDay: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    hasResY: [{
      type: Input
    }],
    orientation: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    rtl: [{
      type: Input
    }],
    showDayIndicator: [{
      type: Input
    }],
    startDay: [{
      type: Input
    }],
    startTime: [{
      type: Input
    }],
    theme: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timezones: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }]
  });
})();
var MbscScheduler = function(_super) {
  __extends(MbscScheduler2, _super);
  function MbscScheduler2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._computeEventResize = computeEventResize;
    _this._defId = DEF_ID;
    return _this;
  }
  Object.defineProperty(MbscScheduler2.prototype, "vCursorTimeCont", {
    set: function(el2) {
      this._cursorTimeCont = el2 && el2.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  MbscScheduler2.prototype._getDayKey = function(index, day) {
    return day.timestamp;
  };
  MbscScheduler2.prototype._getEventKey = function(index, event) {
    return event.uid;
  };
  MbscScheduler2.prototype._getDragKey = function(resourceId, dateKey) {
    return resourceId + "__" + dateKey;
  };
  MbscScheduler2.prototype._getId = function(index, data) {
    return data.id;
  };
  MbscScheduler2.prototype._mounted = function() {
    this._scrollCont = this.vScrollCont && this.vScrollCont.nativeElement;
    this._gridCont = this.vGridCont && this.vGridCont.nativeElement;
    this._headerCont = this.vHeaderCont && this.vHeaderCont.nativeElement;
    this._timeCont = this.vTimeCont && this.vTimeCont.nativeElement;
    this._allDayCont = this.vAllDayCont && this.vAllDayCont.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscScheduler2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscScheduler_BaseFactory;
    return function MbscScheduler_Factory(__ngFactoryType__) {
      return (ɵMbscScheduler_BaseFactory || (ɵMbscScheduler_BaseFactory = ɵɵgetInheritedFactory(MbscScheduler2)))(__ngFactoryType__ || MbscScheduler2);
    };
  })();
  MbscScheduler2.ɵcmp = ɵɵdefineComponent({
    type: MbscScheduler2,
    selectors: [["mbsc-scheduler"]],
    viewQuery: function MbscScheduler_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c34, 7, ElementRef);
        ɵɵviewQuery(_c35, 7, ElementRef);
        ɵɵviewQuery(_c36, 5, ElementRef);
        ɵɵviewQuery(_c37, 5, ElementRef);
        ɵɵviewQuery(_c38, 7, ElementRef);
        ɵɵviewQuery(_c39, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vScrollCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vGridCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vHeaderCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vAllDayCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vTimeCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vCursorTimeCont = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscScheduler_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap("mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-wrapper" + ctx2._theme);
      }
    },
    inputs: {
      allDayText: "allDayText",
      amText: "amText",
      bufferAfterTemplate: "bufferAfterTemplate",
      bufferBeforeTemplate: "bufferBeforeTemplate",
      checkSize: "checkSize",
      clickToCreate: "clickToCreate",
      colorsMap: "colorsMap",
      currentTimeIndicator: "currentTimeIndicator",
      dataTimezone: "dataTimezone",
      dateFormat: "dateFormat",
      dateFormatFull: "dateFormatFull",
      dateFormatLong: "dateFormatLong",
      dayNames: "dayNames",
      dayNamesMin: "dayNamesMin",
      dayNamesShort: "dayNamesShort",
      dayTemplate: "dayTemplate",
      dayContentTemplate: "dayContentTemplate",
      events: "events",
      displayTimezone: "displayTimezone",
      dragBetweenResources: "dragBetweenResources",
      dragInTime: "dragInTime",
      dragTimeStep: "dragTimeStep",
      dragToCreate: "dragToCreate",
      dragToMove: "dragToMove",
      dragToResize: "dragToResize",
      endDay: "endDay",
      endTime: "endTime",
      eventDragEnd: "eventDragEnd",
      eventMap: "eventMap",
      eventContentTemplate: "eventContentTemplate",
      eventOrder: "eventOrder",
      eventOverlap: "eventOverlap",
      eventTemplate: "eventTemplate",
      exclusiveEndDates: "exclusiveEndDates",
      extendDefaultEvent: "extendDefaultEvent",
      externalDrag: "externalDrag",
      externalDrop: "externalDrop",
      firstDay: "firstDay",
      fromText: "fromText",
      getDay: "getDay",
      getDate: "getDate",
      getMaxDayOfMonth: "getMaxDayOfMonth",
      getMonth: "getMonth",
      getWeekNumber: "getWeekNumber",
      getYear: "getYear",
      groupBy: "groupBy",
      height: "height",
      immutableData: "immutableData",
      invalidateEvent: "invalidateEvent",
      invalidsMap: "invalidsMap",
      maxDate: "maxDate",
      navigateToEvent: "navigateToEvent",
      maxEventStack: "maxEventStack",
      minDate: "minDate",
      minEventWidth: "minEventWidth",
      monthNames: "monthNames",
      monthNamesShort: "monthNamesShort",
      moreEventsPluralText: "moreEventsPluralText",
      moreEventsText: "moreEventsText",
      navService: "navService",
      newEventText: "newEventText",
      pmText: "pmText",
      refDate: "refDate",
      resources: "resources",
      resourceTemplate: "resourceTemplate",
      scroll: "scroll",
      selected: "selected",
      selectedEventsMap: "selectedEventsMap",
      showAllDay: "showAllDay",
      showDays: "showDays",
      showEventBuffer: "showEventBuffer",
      showEventTooltip: "showEventTooltip",
      size: "size",
      startDay: "startDay",
      startTime: "startTime",
      timeCellStep: "timeCellStep",
      timeFormat: "timeFormat",
      timeLabelStep: "timeLabelStep",
      timezonePlugin: "timezonePlugin",
      timezones: "timezones",
      toText: "toText",
      type: "type",
      width: "width",
      onCellClick: "onCellClick",
      onCellDoubleClick: "onCellDoubleClick",
      onCellRightClick: "onCellRightClick",
      onEventClick: "onEventClick",
      onEventDoubleClick: "onEventDoubleClick",
      onEventRightClick: "onEventRightClick",
      onEventHoverIn: "onEventHoverIn",
      onEventHoverOut: "onEventHoverOut",
      onEventDelete: "onEventDelete",
      onEventDragEnd: "onEventDragEnd",
      onEventDragStart: "onEventDragStart",
      onEventDragEnter: "onEventDragEnter",
      onEventDragLeave: "onEventDragLeave",
      onMoreClick: "onMoreClick",
      onPopoverClose: "onPopoverClose",
      onResourceClick: "onResourceClick",
      onResourceDoubleClick: "onResourceDoubleClick",
      onResourceRightClick: "onResourceRightClick",
      onWeekDayClick: "onWeekDayClick"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 40,
    vars: 30,
    consts: [["tplEvents", ""], ["tplAllDay", ""], ["tplDay", ""], ["tplTimes", ""], ["headerCont", ""], ["timeCont", ""], ["scrollCont", ""], ["gridCont", ""], ["default", ""], ["allDayCont", ""], ["cursorTimeCont", ""], [3, "ngStyle"], [1, "mbsc-flex-1-0", "mbsc-schedule-header-wrapper"], [1, "mbsc-flex"], ["class", "mbsc-flex-1-0-0 mbsc-schedule-resource-group", 4, "ngIf"], [4, "ngIf"], [1, "mbsc-schedule-fake-scroll-y"], ["class", "mbsc-flex mbsc-schedule-timezone-labels", 3, "ngStyle", 4, "ngIf"], [3, "class", 4, "ngIf"], [3, "innerHTML"], ["aria-hidden", "true", 3, "ngStyle"], [1, "mbsc-flex", "mbsc-schedule-time-cont-inner"], [1, "mbsc-flex-col", "mbsc-flex-1-1"], [3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["orientation", "x", 3, "amText", "displayedTime", "displayedDays", "displayTimezone", "endDay", "firstDay", "pmText", "rtl", "showDayIndicator", "startDay", "startTime", "theme", "timeFormat", "timezones", "timezonePlugin", 4, "ngIf"], ["class", "mbsc-schedule-fake-scroll-x", 4, "ngIf"], [3, "scroll"], [1, "mbsc-flex", "mbsc-flex-1-1"], [1, "mbsc-flex", "mbsc-flex-1-0", "mbsc-schedule-grid", 3, "mouseleave", "mousemove"], ["class", "mbsc-calendar-dragging", 4, "ngIf"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "event", "endDay", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hidden", "isDrag", "lastDay", "resize", "resource", "resourceObj", "rtl", "singleDay", "slot", "startDay", "theme", "template", "timezonePlugin", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOff", 4, "ngIf"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "event", "endDay", "exclusiveEndDates", "gridEndTime", "gridStartTime", "isDrag", "lastDay", "resize", "resource", "resourceObj", "rtl", "singleDay", "slot", "startDay", "theme", "template", "timezonePlugin", 4, "ngIf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "event", "endDay", "exclusiveEndDates", "gridEndTime", "gridStartTime", "inactive", "lastDay", "resize", "resource", "resourceObj", "rtl", "singleDay", "selected", "slot", "startDay", "theme", "template", "timezonePlugin", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff", 4, "ngIf"], ["class", "mbsc-schedule-event mbsc-schedule-event-all-day mbsc-schedule-event-all-day-placeholder", 4, "ngIf"], [3, "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff", "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "event", "endDay", "exclusiveEndDates", "gridEndTime", "gridStartTime", "inactive", "lastDay", "resize", "resource", "resourceObj", "rtl", "singleDay", "selected", "slot", "startDay", "theme", "template", "timezonePlugin"], [1, "mbsc-schedule-event", "mbsc-schedule-event-all-day", "mbsc-schedule-event-all-day-placeholder"], [3, "onDragStart", "onDragMove", "onDragEnd", "onDragModeOff", "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "event", "endDay", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hidden", "isDrag", "lastDay", "resize", "resource", "resourceObj", "rtl", "singleDay", "slot", "startDay", "theme", "template", "timezonePlugin"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "event", "endDay", "exclusiveEndDates", "gridEndTime", "gridStartTime", "isDrag", "lastDay", "resize", "resource", "resourceObj", "rtl", "singleDay", "slot", "startDay", "theme", "template", "timezonePlugin"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "ngStyle", 4, "ngIf"], [1, "mbsc-schedule-invalid-text"], [1, "mbsc-schedule-color-text"], [3, "class", "ngStyle", "click", "dblclick", "contextmenu", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "class", "ngStyle", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "click", "dblclick", "contextmenu", "ngStyle"], [1, "mbsc-flex-1-0-0", "mbsc-schedule-resource-group"], ["class", "mbsc-flex", 4, "ngIf"], ["class", "mbsc-flex-1-1", 3, "day", "dayNames", "dayTemplate", "dayContentTemplate", "events", "isToday", "label", "largeNames", "onClick", "rtl", "selectable", "selected", "theme", "timestamp", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-flex-1-1", 3, "day", "dayNames", "dayTemplate", "dayContentTemplate", "events", "isToday", "label", "largeNames", "onClick", "rtl", "selectable", "selected", "theme", "timestamp"], [3, "background", "class", "click", "dblclick", "contextmenu", 4, "ngIf"], [3, "click", "dblclick", "contextmenu"], [1, "mbsc-schedule-resource-title"], [3, "class", "background", "click", "dblclick", "contextmenu", 4, "ngIf"], [3, "class", "background", "day", "dayNames", "dayTemplate", "dayContentTemplate", "events", "isToday", "label", "largeNames", "onClick", "resource", "rtl", "selectable", "selected", "theme", "timestamp", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "background", "day", "dayNames", "dayTemplate", "dayContentTemplate", "events", "isToday", "label", "largeNames", "onClick", "resource", "rtl", "selectable", "selected", "theme", "timestamp"], [3, "day", "dayNames", "dayTemplate", "dayContentTemplate", "events", "isToday", "label", "largeNames", "onClick", "rtl", "selectable", "selected", "theme", "timestamp", 4, "ngIf"], [3, "day", "dayNames", "dayTemplate", "dayContentTemplate", "events", "isToday", "label", "largeNames", "onClick", "rtl", "selectable", "selected", "theme", "timestamp"], [1, "mbsc-flex", "mbsc-schedule-timezone-labels", 3, "ngStyle"], [1, "mbsc-flex-col", "mbsc-flex-1-0", "mbsc-schedule-all-day-group-wrapper"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["orientation", "x", 3, "amText", "displayedTime", "displayedDays", "displayTimezone", "endDay", "firstDay", "pmText", "rtl", "showDayIndicator", "startDay", "startTime", "theme", "timeFormat", "timezones", "timezonePlugin"], [1, "mbsc-schedule-fake-scroll-x"], [1, "mbsc-calendar-dragging"]],
    template: function MbscScheduler_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵtemplate(0, MbscScheduler_ng_template_0_Template, 3, 3, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, MbscScheduler_ng_template_2_Template, 4, 14, "ng-template", null, 1, ɵɵtemplateRefExtractor)(4, MbscScheduler_ng_template_4_Template, 7, 20, "ng-template", null, 2, ɵɵtemplateRefExtractor)(6, MbscScheduler_ng_template_6_Template, 1, 2, "ng-template", null, 3, ɵɵtemplateRefExtractor);
        ɵɵelementStart(8, "div");
        ɵɵelement(9, "div", 11);
        ɵɵelementStart(10, "div", 12)(11, "div", 13, 4);
        ɵɵtemplate(13, MbscScheduler_div_13_Template, 3, 2, "div", 14)(14, MbscScheduler_ng_container_14_Template, 3, 2, "ng-container", 15);
        ɵɵelementEnd()();
        ɵɵelement(15, "div", 16);
        ɵɵelementEnd();
        ɵɵelementStart(16, "div");
        ɵɵtemplate(17, MbscScheduler_div_17_Template, 2, 3, "div", 17)(18, MbscScheduler_div_18_Template, 9, 10, "div", 18);
        ɵɵelementEnd();
        ɵɵelementStart(19, "div");
        ɵɵelement(20, "div", 19);
        ɵɵelementStart(21, "div", 20, 5)(23, "div", 21)(24, "div", 22)(25, "div");
        ɵɵtemplate(26, MbscScheduler_div_26_Template, 2, 3, "div", 23)(27, MbscScheduler_ng_container_27_Template, 1, 3, "ng-container", 24)(28, MbscScheduler_mbsc_time_indicator_28_Template, 1, 15, "mbsc-time-indicator", 25)(29, MbscScheduler_div_29_Template, 2, 2, "div", 18);
        ɵɵelementEnd();
        ɵɵtemplate(30, MbscScheduler_div_30_Template, 1, 0, "div", 26);
        ɵɵelementEnd();
        ɵɵelement(31, "div", 16);
        ɵɵelementEnd()();
        ɵɵelementStart(32, "div", 27, 6);
        ɵɵlistener("scroll", function MbscScheduler_Template_div_scroll_32_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onScroll());
        });
        ɵɵelementStart(34, "div", 28)(35, "div", 29, 7);
        ɵɵlistener("mouseleave", function MbscScheduler_Template_div_mouseleave_35_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onMouseLeave($event));
        })("mousemove", function MbscScheduler_Template_div_mousemove_35_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onMouseMove($event));
        });
        ɵɵtemplate(37, MbscScheduler_ng_container_37_Template, 2, 2, "ng-container", 15)(38, MbscScheduler_ng_container_38_Template, 2, 2, "ng-container", 15);
        ɵɵelementEnd()()()();
        ɵɵtemplate(39, MbscScheduler_div_39_Template, 1, 0, "div", 30);
      }
      if (rf & 2) {
        ɵɵadvance(8);
        ɵɵclassMap("mbsc-schedule-header mbsc-flex mbsc-flex-none" + ctx2._theme + ctx2._hb);
        ɵɵadvance();
        ɵɵclassMap("mbsc-schedule-time-col mbsc-schedule-time-col-empty" + ctx2._theme + ctx2._rtl + ctx2._hb);
        ɵɵproperty("ngStyle", ctx2._timeWidth);
        ɵɵadvance(4);
        ɵɵproperty("ngIf", ctx2.type === "day" && ctx2.size === 1);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.type !== "day" || ctx2.size !== 1);
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-schedule-all-day-cont" + (ctx2.state.showShadow ? " mbsc-schedule-all-day-wrapper-shadow" : "") + ctx2._theme);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.timezones);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.showAllDay);
        ɵɵadvance();
        ɵɵclassMap("mbsc-flex mbsc-flex-1-1 mbsc-schedule-grid-wrapper" + ctx2._theme);
        ɵɵadvance();
        ɵɵproperty("innerHTML", ctx2.textParam, ɵɵsanitizeHtml);
        ɵɵadvance();
        ɵɵclassMap("mbsc-flex-col mbsc-schedule-time-col mbsc-schedule-time-cont" + ctx2._theme + ctx2._rtl);
        ɵɵproperty("ngStyle", ctx2._timeWidth);
        ɵɵadvance(4);
        ɵɵclassMap("mbsc-flex-1-1 mbsc-schedule-time-cont-pos" + ctx2._theme + (ctx2.timezones ? " mbsc-flex " : " mbsc-flex-col mbsc-schedule-time-col-last"));
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx2._timezones)("ngForTrackBy", ctx2._getKey);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2.timezones);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showTimeIndicator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showCursorTime);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.state.hasScrollX);
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-grid-scroll" + ctx2._theme);
        ɵɵadvance(5);
        ɵɵproperty("ngIf", ctx2._groupByResource);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2._groupByResource);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.state.dragData && !ctx2.state.isTouchDrag);
      }
    },
    dependencies: [MbscScheduleEvent, MbscWeekDay, MbscTimeIndicator, NgIf, NgForOf, NgTemplateOutlet, NgStyle],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscScheduler2;
}(SchedulerBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscScheduler, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": '"mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-wrapper" + _theme'
      },
      selector: "mbsc-scheduler",
      template: `
    <ng-template
      #tplEvents
      let-allDay="allDay"
      let-events="events"
      let-dateKey="dateKey"
      let-dragData="dragData"
      let-dragKey="dragKey"
      let-resource="resource"
    >
      <ng-container *ngIf="events">
        <ng-container *ngFor="let event of events; trackBy: _getEventKey">
          <mbsc-schedule-event
            *ngIf="event.showText && event.position"
            [bufferAfterTemplate]="bufferAfterTemplate"
            [bufferBeforeTemplate]="bufferBeforeTemplate"
            [contentTemplate]="eventContentTemplate"
            [displayTimezone]="displayTimezone"
            [drag]="dragToMove || externalDrag"
            [event]="event"
            [endDay]="endDay"
            [exclusiveEndDates]="exclusiveEndDates"
            [gridEndTime]="_endTime"
            [gridStartTime]="_startTime"
            [inactive]="dragData && dragData.draggedEvent && dragData.draggedEvent.id === event.id"
            [lastDay]="_lastDay"
            [resize]="_computeEventResize(event.original!.resize, dragToResize, resource.eventResize)"
            [resource]="resource.id"
            [resourceObj]="resource"
            [rtl]="rtl"
            [singleDay]="!_groupByResource"
            [selected]="!!(selectedEventsMap[event.uid!] || selectedEventsMap[event.id!])"
            [slot]="_defId"
            [startDay]="startDay"
            [theme]="theme"
            [template]="eventTemplate"
            [timezonePlugin]="timezonePlugin"
            (onClick)="_onEventClick($event)"
            (onDoubleClick)="onEventDoubleClick($event)"
            (onRightClick)="onEventRightClick($event)"
            (onHoverIn)="onEventHoverIn($event)"
            (onHoverOut)="onEventHoverOut($event)"
            (onDelete)="onEventDelete($event)"
            (onDragStart)="_onEventDragStart($event)"
            (onDragMove)="_onEventDragMove($event)"
            (onDragEnd)="_onEventDragEnd($event)"
            (onDragModeOn)="_onEventDragModeOn($event)"
            (onDragModeOff)="_onEventDragModeOff($event)"
          >
          </mbsc-schedule-event>
          <div *ngIf="!event.showText" class="mbsc-schedule-event mbsc-schedule-event-all-day mbsc-schedule-event-all-day-placeholder">
            <div [class]="'mbsc-schedule-event-all-day-inner' + _theme"></div>
          </div>
        </ng-container>
      </ng-container>
      <mbsc-schedule-event
        *ngIf="dragData && dragData.originDates && dragData.originDates[dragKey] && !!dragData.originDates[dragKey].allDay === allDay"
        [bufferAfterTemplate]="bufferAfterTemplate"
        [bufferBeforeTemplate]="bufferBeforeTemplate"
        [contentTemplate]="eventContentTemplate"
        [displayTimezone]="displayTimezone"
        [drag]="dragToMove || externalDrag"
        [event]="dragData.originDates[dragKey]"
        [endDay]="endDay"
        [exclusiveEndDates]="exclusiveEndDates"
        [gridEndTime]="_endTime"
        [gridStartTime]="_startTime"
        [hidden]="!!dragData.draggedDates"
        [isDrag]="true"
        [lastDay]="_lastDay"
        [resize]="_computeEventResize(dragData.originDates[dragKey].original!.resize, dragToResize, resource.eventResize)"
        [resource]="resource.id"
        [resourceObj]="resource"
        [rtl]="rtl"
        [singleDay]="!_groupByResource"
        [slot]="_defId"
        [startDay]="startDay"
        [theme]="theme"
        [template]="eventTemplate"
        [timezonePlugin]="timezonePlugin"
        (onDragStart)="_onEventDragStart($event)"
        (onDragMove)="_onEventDragMove($event)"
        (onDragEnd)="_onEventDragEnd($event)"
        (onDragModeOff)="_onEventDragModeOff($event)"
      >
      </mbsc-schedule-event>
      <mbsc-schedule-event
        *ngIf="dragData && dragData.draggedDates && dragData.draggedDates[dragKey] && !!dragData.draggedDates[dragKey].allDay === allDay"
        [bufferAfterTemplate]="bufferAfterTemplate"
        [bufferBeforeTemplate]="bufferBeforeTemplate"
        [contentTemplate]="eventContentTemplate"
        [displayTimezone]="displayTimezone"
        [drag]="dragToMove || externalDrag"
        [event]="dragData.draggedDates[dragKey]"
        [endDay]="endDay"
        [exclusiveEndDates]="exclusiveEndDates"
        [gridEndTime]="_endTime"
        [gridStartTime]="_startTime"
        [isDrag]="true"
        [lastDay]="_lastDay"
        [resize]="_computeEventResize(dragData.draggedDates[dragKey].original!.resize, dragToResize, resource.eventResize)"
        [resource]="resource.id"
        [resourceObj]="resource"
        [rtl]="rtl"
        [singleDay]="!_groupByResource"
        [slot]="_defId"
        [startDay]="startDay"
        [theme]="theme"
        [template]="eventTemplate"
        [timezonePlugin]="timezonePlugin"
      >
      </mbsc-schedule-event>
    </ng-template>

    <ng-template #tplAllDay let-dateKey="dateKey" let-dayName="dayName" let-r="resource" let-resId="resource.id">
      <div
        [class]="
          'mbsc-schedule-all-day-item mbsc-flex-1-0 ' +
          (_groupByResource ? 'mbsc-schedule-column-' + dayName : r.cssClass || '') +
          _colClass +
          _theme +
          _rtl +
          _hb
        "
        [style.background]="r.background"
      >
        <ng-container
          [ngTemplateOutlet]="tplEvents"
          [ngTemplateOutletContext]="{
            allDay: true,
            dateKey: dateKey,
            dragData: state.dragData,
            dragKey: _getDragKey(resId, dateKey),
            events: _events[resId][_defId][dateKey] && _events[resId][_defId][dateKey].allDay,
            resource: r
          }"
        >
        </ng-container>
        <div
          *ngIf="_invalids[resId][_defId][dateKey] && _invalids[resId][_defId][dateKey].allDay[0]"
          [class]="'mbsc-schedule-invalid mbsc-schedule-invalid-all-day' + _invalids[resId][_defId][dateKey].allDay[0].cssClass + _theme"
        >
          <div class="mbsc-schedule-invalid-text">
            {{ _invalids[resId][_defId][dateKey].allDay[0].title }}
          </div>
        </div>
        <div
          *ngIf="_colors[resId][_defId][dateKey] && _colors[resId][_defId][dateKey].allDay[0]"
          [class]="'mbsc-schedule-color mbsc-schedule-color-all-day' + _colors[resId][_defId][dateKey].allDay[0].cssClass + _theme"
          [ngStyle]="_colors[resId][_defId][dateKey].allDay[0].position"
        >
          <div class="mbsc-schedule-color-text">
            {{ _colors[resId][_defId][dateKey].allDay[0].title }}
          </div>
        </div>
      </div>
    </ng-template>

    <ng-template #tplDay let-dateKey="dateKey" let-dayName="dayName" let-r="resource" let-resId="resource.id" let-timestamp="timestamp">
      <div
        [class]="
          'mbsc-flex-col mbsc-flex-1-0 mbsc-schedule-column ' +
          (_groupByResource ? 'mbsc-schedule-column-' + dayName : r.cssClass || '') +
          _colClass +
          _theme +
          _rtl +
          _hb
        "
        [style.background]="r.background"
      >
        <div [class]="'mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-column-inner' + _theme + _rtl + _hb">
          <div
            [class]="
              'mbsc-schedule-events' +
              (_events[resId][_defId][dateKey] && _events[resId][_defId][dateKey].hasMore ? ' mbsc-schedule-events-more' : '') +
              _rtl
            "
          >
            <ng-container
              [ngTemplateOutlet]="tplEvents"
              [ngTemplateOutletContext]="{
                allDay: false,
                dateKey: dateKey,
                dragData: state.dragData,
                dragKey: _getDragKey(resId, dateKey),
                events: _events[resId][_defId][dateKey] && _events[resId][_defId][dateKey].data,
                resource: r
              }"
            >
            </ng-container>
          </div>

          <ng-container *ngIf="_invalids[resId][_defId][dateKey]">
            <ng-container *ngFor="let invalid of _invalids[resId][_defId][dateKey].data; trackBy: _getKey">
              <div *ngIf="invalid.position" [class]="'mbsc-schedule-invalid' + invalid.cssClass + _theme" [ngStyle]="invalid.position">
                <div class="mbsc-schedule-invalid-text">{{ invalid.allDay ? '' : invalid.title }}</div>
              </div>
            </ng-container>
          </ng-container>

          <ng-container *ngIf="_colors[resId][_defId][dateKey]">
            <div
              *ngFor="let color of _colors[resId][_defId][dateKey].data; trackBy: _getKey"
              [class]="'mbsc-schedule-color' + color.cssClass + _theme"
              [ngStyle]="color.position"
            >
              <div class="mbsc-schedule-color-text">{{ color.title }}</div>
            </div>
          </ng-container>

          <div
            *ngFor="let v of _times; let first = first; let last = last; trackBy: _getKey"
            (click)="_onCellClick('onCellClick', timestamp, v, $event, resId)"
            (dblclick)="_onCellClick('onCellDoubleClick', timestamp, v, $event, resId)"
            (contextmenu)="_onCellClick('onCellRightClick', timestamp, v, $event, resId)"
            [class]="
              'mbsc-schedule-item mbsc-flex-1-0' +
              _theme +
              _hb +
              (last ? ' mbsc-schedule-item-last' : '') +
              ((first && !last && _startCellStyle) || (last && !first && _endCellStyle) ? ' mbsc-flex-none' : '')
            "
            [ngStyle]="first && !last ? _startCellStyle! : last && !first ? _endCellStyle! : {}"
          ></div>
        </div>
      </div>
    </ng-template>

    <ng-template #tplTimes let-index="index">
      <div
        *ngFor="let v of _times; let i = index; let first = first; let last = last; trackBy: _getKey"
        [class]="
          'mbsc-flex-col mbsc-flex-1-0 mbsc-schedule-time-wrapper' +
          _theme +
          _rtl +
          (last ? ' mbsc-schedule-time-wrapper-end' : '') +
          ((first && !last && _startCellStyle) || (last && !first && _endCellStyle) ? ' mbsc-flex-none' : '')
        "
        [ngStyle]="first && !last ? _startCellStyle! : last && !first ? _endCellStyle! : {}"
      >
        <div [class]="'mbsc-flex-1-1 mbsc-schedule-time' + _theme + _rtl">
          {{ _timeLabels[index][v] }}
        </div>

        <ng-container *ngFor="let t of _timesBetween; let j = index; trackBy: _getKey">
          <div
            *ngIf="v + (j + 1) * _stepLabel > _startTime && v + (j + 1) * _stepLabel < _endTime"
            [class]="'mbsc-flex-1-1 mbsc-schedule-time' + _theme + _rtl"
          >
            {{ _timeLabels[index][v + (j + 1) * _stepLabel] }}
          </div>
        </ng-container>

        <div *ngIf="last" [class]="'mbsc-schedule-time mbsc-schedule-time-end' + _theme + _rtl">
          {{ _timeLabels[index][_endTime + 1] }}
        </div>
      </div>
    </ng-template>

    <div [class]="'mbsc-schedule-header mbsc-flex mbsc-flex-none' + _theme + _hb">
      <div [class]="'mbsc-schedule-time-col mbsc-schedule-time-col-empty' + _theme + _rtl + _hb" [ngStyle]="_timeWidth!"></div>
      <div class="mbsc-flex-1-0 mbsc-schedule-header-wrapper">
        <div #headerCont class="mbsc-flex">
          <div *ngIf="type === 'day' && size === 1" class="mbsc-flex-1-0-0 mbsc-schedule-resource-group">
            <div *ngIf="showDays" class="mbsc-flex">
              <mbsc-week-day
                *ngFor="let dayData of _headerDays; trackBy: _getDayKey"
                class="mbsc-flex-1-1"
                [day]="dayData.day"
                [dayNames]="_dayNames"
                [dayTemplate]="dayTemplate"
                [dayContentTemplate]="dayContentTemplate"
                [events]="eventMap[dayData.dateKey]"
                [isToday]="_isToday(dayData.timestamp)"
                [label]="dayData.label"
                [largeNames]="_largeDayNames"
                [onClick]="onWeekDayClick"
                [rtl]="rtl"
                [selectable]="true"
                [selected]="_selectedDay === dayData.timestamp"
                [theme]="theme"
                [timestamp]="dayData.timestamp"
              >
              </mbsc-week-day>
            </div>
            <div *ngIf="resources" class="mbsc-flex">
              <ng-container *ngFor="let r of _resources; trackBy: _getId">
                <div
                  *ngIf="r.name || (resourceTemplate && r.id !== _defId)"
                  [style.background]="r.background"
                  [class]="'mbsc-schedule-resource mbsc-flex-1-0 mbsc-schedule-col-width ' + (r.cssClass || '') + _theme + _rtl + _hb"
                  (click)="_onResourceClick('onResourceClick', $event, r)"
                  (dblclick)="_onResourceClick('onResourceDoubleClick', $event, r)"
                  (contextmenu)="_onResourceClick('onResourceRightClick', $event, r)"
                >
                  <div class="mbsc-schedule-resource-title">
                    <ng-template #default>
                      {{ r.name }}
                    </ng-template>
                    <ng-template [ngTemplateOutlet]="resourceTemplate || default" [ngTemplateOutletContext]="{ $implicit: r }">
                    </ng-template>
                  </div>
                </div>
              </ng-container>
            </div>
          </div>
          <ng-container *ngIf="type !== 'day' || size !== 1">
            <ng-container *ngIf="_groupByResource">
              <div
                *ngFor="let r of _resources; trackBy: _getId"
                [class]="'mbsc-flex-1-0-0 mbsc-schedule-resource-group ' + (r.cssClass || '') + _theme + _rtl"
              >
                <div
                  *ngIf="r.name || (resourceTemplate && r.id !== _defId)"
                  [class]="'mbsc-schedule-resource ' + _theme + _rtl + _hb"
                  [style.background]="r.background"
                  (click)="_onResourceClick('onResourceClick', $event, r)"
                  (dblclick)="_onResourceClick('onResourceDoubleClick', $event, r)"
                  (contextmenu)="_onResourceClick('onResourceRightClick', $event, r)"
                >
                  <div class="mbsc-schedule-resource-title">
                    <ng-template #default>
                      {{ r.name }}
                    </ng-template>
                    <ng-template [ngTemplateOutlet]="resourceTemplate || default" [ngTemplateOutletContext]="{ $implicit: r }">
                    </ng-template>
                  </div>
                </div>
                <div *ngIf="showDays" class="mbsc-flex">
                  <mbsc-week-day
                    *ngFor="let dayData of _days; trackBy: _getDayKey"
                    [class]="'mbsc-flex-1-0' + _colClass + ' mbsc-schedule-column-' + dayData.dayName"
                    [background]="r.background"
                    [day]="dayData.day"
                    [dayNames]="_dayNames"
                    [dayTemplate]="dayTemplate"
                    [dayContentTemplate]="dayContentTemplate"
                    [events]="eventMap[dayData.dateKey]"
                    [isToday]="_isSingleResource && _isToday(dayData.timestamp)"
                    [label]="dayData.label"
                    [largeNames]="_largeDayNames"
                    [onClick]="onWeekDayClick"
                    [resource]="r.id"
                    [rtl]="rtl"
                    [selectable]="false"
                    [selected]="_isSingleResource && _isToday(dayData.timestamp)"
                    [theme]="theme"
                    [timestamp]="dayData.timestamp"
                  >
                  </mbsc-week-day>
                </div>
              </div>
            </ng-container>
            <ng-container *ngIf="!_groupByResource">
              <div
                *ngFor="let dayData of _days; trackBy: _getDayKey"
                [class]="'mbsc-flex-1-0-0 mbsc-schedule-resource-group mbsc-schedule-column-' + dayData.dayName + _theme + _rtl"
              >
                <mbsc-week-day
                  *ngIf="showDays"
                  [day]="dayData.day"
                  [dayNames]="_dayNames"
                  [dayTemplate]="dayTemplate"
                  [dayContentTemplate]="dayContentTemplate"
                  [events]="eventMap[dayData.dateKey]"
                  [isToday]="_isSingleResource && _isToday(dayData.timestamp)"
                  [label]="dayData.label"
                  [largeNames]="_largeDayNames"
                  [onClick]="onWeekDayClick"
                  [rtl]="rtl"
                  [selectable]="false"
                  [selected]="_isToday(dayData.timestamp)"
                  [theme]="theme"
                  [timestamp]="dayData.timestamp"
                >
                </mbsc-week-day>
                <div *ngIf="resources" class="mbsc-flex">
                  <ng-container *ngFor="let r of _resources; trackBy: _getId">
                    <div
                      *ngIf="r.name || (resourceTemplate && r.id !== _defId)"
                      [style.background]="r.background"
                      [class]="'mbsc-schedule-resource mbsc-flex-1-0 ' + (r.cssClass || '') + _colClass + _theme + _rtl + _hb"
                      (click)="_onResourceClick('onResourceClick', $event, r, dayData.date)"
                      (dblclick)="_onResourceClick('onResourceDoubleClick', $event, r, dayData.date)"
                      (contextmenu)="_onResourceClick('onResourceRightClick', $event, r, dayData.date)"
                    >
                      <div class="mbsc-schedule-resource-title">
                        <ng-template #default>
                          {{ r.name }}
                        </ng-template>
                        <ng-template
                          [ngTemplateOutlet]="resourceTemplate || default"
                          [ngTemplateOutletContext]="{ $implicit: r, day: dayData.date }"
                        >
                        </ng-template>
                      </div>
                    </div>
                  </ng-container>
                </div>
              </div>
            </ng-container>
          </ng-container>
        </div>
      </div>
      <div class="mbsc-schedule-fake-scroll-y"></div>
    </div>
    <div [class]="'mbsc-schedule-all-day-cont' + (state.showShadow ? ' mbsc-schedule-all-day-wrapper-shadow' : '') + _theme">
      <div *ngIf="timezones" class="mbsc-flex mbsc-schedule-timezone-labels" [ngStyle]="_timeWidth!">
        <div *ngFor="let tz of _timezones; trackBy: _getKey" [class]="'mbsc-flex-1-0-0 mbsc-schedule-timezone-label' + _theme + _rtl">
          {{ tz.label }}
        </div>
      </div>
      <div *ngIf="showAllDay" [class]="'mbsc-schedule-all-day-wrapper mbsc-flex-none' + _theme + _hb">
        <div [class]="'mbsc-flex mbsc-schedule-all-day' + _theme">
          <div [class]="'mbsc-schedule-time-col' + _theme + _rtl" [ngStyle]="_timeWidth!">
            <div *ngIf="!timezones" [class]="'mbsc-schedule-all-day-text' + _theme + _rtl">{{ allDayText }}</div>
          </div>
          <div class="mbsc-flex-col mbsc-flex-1-0 mbsc-schedule-all-day-group-wrapper">
            <div #allDayCont class="mbsc-flex mbsc-flex-1-1">
              <ng-container *ngIf="_groupByResource">
                <div
                  *ngFor="let r of _resources; trackBy: _getId"
                  [class]="'mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group ' + (r.cssClass || '') + _theme + _rtl"
                >
                  <ng-container
                    *ngFor="let dayData of _days; trackBy: _getDayKey"
                    [ngTemplateOutlet]="tplAllDay"
                    [ngTemplateOutletContext]="{
                      dateKey: dayData.dateKey,
                      dayName: dayData.dayName,
                      resource: r,
                      timestamp: dayData.timestamp
                    }"
                  >
                  </ng-container>
                </div>
              </ng-container>
              <ng-container *ngIf="!_groupByResource">
                <div
                  *ngFor="let dayData of _days; trackBy: _getDayKey"
                  [class]="'mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group mbsc-schedule-column-' + dayData.dayName + _theme + _rtl"
                >
                  <ng-container
                    *ngFor="let r of _resources; trackBy: _getId"
                    [ngTemplateOutlet]="tplAllDay"
                    [ngTemplateOutletContext]="{
                      dateKey: dayData.dateKey,
                      dayName: dayData.dayName,
                      resource: r,
                      timestamp: dayData.timestamp
                    }"
                  >
                  </ng-container>
                </div>
              </ng-container>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div [class]="'mbsc-flex mbsc-flex-1-1 mbsc-schedule-grid-wrapper' + _theme">
      <div [innerHTML]="textParam"></div>
      <div
        #timeCont
        aria-hidden="true"
        [class]="'mbsc-flex-col mbsc-schedule-time-col mbsc-schedule-time-cont' + _theme + _rtl"
        [ngStyle]="_timeWidth!"
      >
        <div class="mbsc-flex mbsc-schedule-time-cont-inner">
          <div class="mbsc-flex-col mbsc-flex-1-1">
            <div
              [class]="
                'mbsc-flex-1-1 mbsc-schedule-time-cont-pos' +
                _theme +
                (timezones ? ' mbsc-flex ' : ' mbsc-flex-col mbsc-schedule-time-col-last')
              "
            >
              <div
                *ngFor="let tz of _timezones; let last = last; trackBy: _getKey; let i = index"
                [class]="'mbsc-flex-col' + _theme + (last ? ' mbsc-schedule-time-col-last' : '')"
              >
                <ng-container *ngIf="timezones" [ngTemplateOutlet]="tplTimes" [ngTemplateOutletContext]="{ index: i }"></ng-container>
              </div>
              <ng-container *ngIf="!timezones" [ngTemplateOutlet]="tplTimes" [ngTemplateOutletContext]="{ index: 0 }"></ng-container>
              <mbsc-time-indicator
                *ngIf="_showTimeIndicator"
                [amText]="s.amText"
                [displayedTime]="_time"
                [displayedDays]="_daysNr"
                [displayTimezone]="displayTimezone"
                [endDay]="endDay"
                [firstDay]="_firstDayTz"
                orientation="x"
                [pmText]="s.pmText"
                [rtl]="rtl"
                [showDayIndicator]="_isSingleResource && !_isMulti && type === 'week'"
                [startDay]="startDay"
                [startTime]="_startTime"
                [theme]="theme"
                [timeFormat]="timeFormat"
                [timezones]="_timezones"
                [timezonePlugin]="timezonePlugin"
              >
              </mbsc-time-indicator>
              <div
                *ngIf="_showCursorTime"
                #cursorTimeCont
                [class]="'mbsc-schedule-cursor-time mbsc-schedule-cursor-time-x' + _theme + _rtl"
              ></div>
            </div>
            <div *ngIf="state.hasScrollX" class="mbsc-schedule-fake-scroll-x"></div>
          </div>
          <div class="mbsc-schedule-fake-scroll-y"></div>
        </div>
      </div>
      <div #scrollCont [class]="'mbsc-flex-col mbsc-flex-1-1 mbsc-schedule-grid-scroll' + _theme" (scroll)="_onScroll()">
        <!-- The extra flex div is needed for the div width to expand correctly -->
        <div class="mbsc-flex mbsc-flex-1-1">
          <div
            #gridCont
            class="mbsc-flex mbsc-flex-1-0 mbsc-schedule-grid"
            (mouseleave)="_onMouseLeave($event)"
            (mousemove)="_onMouseMove($event)"
          >
            <ng-container *ngIf="_groupByResource">
              <div
                *ngFor="let r of _resources; trackBy: _getId"
                [class]="'mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group ' + (r.cssClass || '') + _theme + _rtl"
              >
                <ng-container *ngFor="let dayData of _days; trackBy: _getDayKey">
                  <ng-container
                    [ngTemplateOutlet]="tplDay"
                    [ngTemplateOutletContext]="{
                      dateKey: dayData.dateKey,
                      dayName: dayData.dayName,
                      resource: r,
                      timestamp: dayData.timestamp
                    }"
                  >
                  </ng-container>
                </ng-container>
              </div>
            </ng-container>
            <ng-container *ngIf="!_groupByResource">
              <div
                *ngFor="let dayData of _days; trackBy: _getDayKey"
                [class]="'mbsc-flex mbsc-flex-1-0-0 mbsc-schedule-resource-group mbsc-schedule-column-' + dayData.dayName + _theme + _rtl"
              >
                <ng-container *ngFor="let r of _resources; trackBy: _getId">
                  <ng-container
                    [ngTemplateOutlet]="tplDay"
                    [ngTemplateOutletContext]="{
                      dateKey: dayData.dateKey,
                      dayName: dayData.dayName,
                      resource: r,
                      timestamp: dayData.timestamp
                    }"
                  >
                  </ng-container>
                </ng-container>
              </div>
            </ng-container>
          </div>
        </div>
      </div>
    </div>
    <div *ngIf="state.dragData && !state.isTouchDrag" class="mbsc-calendar-dragging"></div>
  `
    }]
  }], null, {
    vScrollCont: [{
      type: ViewChild,
      args: ["scrollCont", {
        static: true,
        read: ElementRef
      }]
    }],
    vGridCont: [{
      type: ViewChild,
      args: ["gridCont", {
        static: true,
        read: ElementRef
      }]
    }],
    vHeaderCont: [{
      type: ViewChild,
      args: ["headerCont", {
        static: false,
        read: ElementRef
      }]
    }],
    vAllDayCont: [{
      type: ViewChild,
      args: ["allDayCont", {
        static: false,
        read: ElementRef
      }]
    }],
    vTimeCont: [{
      type: ViewChild,
      args: ["timeCont", {
        static: true,
        read: ElementRef
      }]
    }],
    allDayText: [{
      type: Input
    }],
    amText: [{
      type: Input
    }],
    bufferAfterTemplate: [{
      type: Input
    }],
    bufferBeforeTemplate: [{
      type: Input
    }],
    checkSize: [{
      type: Input
    }],
    clickToCreate: [{
      type: Input
    }],
    colorsMap: [{
      type: Input
    }],
    currentTimeIndicator: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    dateFormatFull: [{
      type: Input
    }],
    dateFormatLong: [{
      type: Input
    }],
    dayNames: [{
      type: Input
    }],
    dayNamesMin: [{
      type: Input
    }],
    dayNamesShort: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dayContentTemplate: [{
      type: Input
    }],
    events: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    dragBetweenResources: [{
      type: Input
    }],
    dragInTime: [{
      type: Input
    }],
    dragTimeStep: [{
      type: Input
    }],
    dragToCreate: [{
      type: Input
    }],
    dragToMove: [{
      type: Input
    }],
    dragToResize: [{
      type: Input
    }],
    endDay: [{
      type: Input
    }],
    endTime: [{
      type: Input
    }],
    eventDragEnd: [{
      type: Input
    }],
    eventMap: [{
      type: Input
    }],
    eventContentTemplate: [{
      type: Input
    }],
    eventOrder: [{
      type: Input
    }],
    eventOverlap: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    extendDefaultEvent: [{
      type: Input
    }],
    externalDrag: [{
      type: Input
    }],
    externalDrop: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    fromText: [{
      type: Input
    }],
    getDay: [{
      type: Input
    }],
    getDate: [{
      type: Input
    }],
    getMaxDayOfMonth: [{
      type: Input
    }],
    getMonth: [{
      type: Input
    }],
    getWeekNumber: [{
      type: Input
    }],
    getYear: [{
      type: Input
    }],
    groupBy: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    immutableData: [{
      type: Input
    }],
    invalidateEvent: [{
      type: Input
    }],
    invalidsMap: [{
      type: Input
    }],
    maxDate: [{
      type: Input
    }],
    navigateToEvent: [{
      type: Input
    }],
    maxEventStack: [{
      type: Input
    }],
    minDate: [{
      type: Input
    }],
    minEventWidth: [{
      type: Input
    }],
    monthNames: [{
      type: Input
    }],
    monthNamesShort: [{
      type: Input
    }],
    moreEventsPluralText: [{
      type: Input
    }],
    moreEventsText: [{
      type: Input
    }],
    navService: [{
      type: Input
    }],
    newEventText: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    refDate: [{
      type: Input
    }],
    resources: [{
      type: Input
    }],
    resourceTemplate: [{
      type: Input
    }],
    scroll: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    selectedEventsMap: [{
      type: Input
    }],
    showAllDay: [{
      type: Input
    }],
    showDays: [{
      type: Input
    }],
    showEventBuffer: [{
      type: Input
    }],
    showEventTooltip: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    startDay: [{
      type: Input
    }],
    startTime: [{
      type: Input
    }],
    timeCellStep: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timeLabelStep: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    timezones: [{
      type: Input
    }],
    toText: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    onCellClick: [{
      type: Input
    }],
    onCellDoubleClick: [{
      type: Input
    }],
    onCellRightClick: [{
      type: Input
    }],
    onEventClick: [{
      type: Input
    }],
    onEventDoubleClick: [{
      type: Input
    }],
    onEventRightClick: [{
      type: Input
    }],
    onEventHoverIn: [{
      type: Input
    }],
    onEventHoverOut: [{
      type: Input
    }],
    onEventDelete: [{
      type: Input
    }],
    onEventDragEnd: [{
      type: Input
    }],
    onEventDragStart: [{
      type: Input
    }],
    onEventDragEnter: [{
      type: Input
    }],
    onEventDragLeave: [{
      type: Input
    }],
    onMoreClick: [{
      type: Input
    }],
    onPopoverClose: [{
      type: Input
    }],
    onResourceClick: [{
      type: Input
    }],
    onResourceDoubleClick: [{
      type: Input
    }],
    onResourceRightClick: [{
      type: Input
    }],
    onWeekDayClick: [{
      type: Input
    }],
    vCursorTimeCont: [{
      type: ViewChild,
      args: ["cursorTimeCont", {
        static: false,
        read: ElementRef
      }]
    }]
  });
})();
var MbscTimeline = function(_super) {
  __extends(MbscTimeline2, _super);
  function MbscTimeline2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._computeResize = computeEventResize;
    _this._defId = DEF_ID;
    _this._oneDay = ONE_DAY;
    return _this;
  }
  Object.defineProperty(MbscTimeline2.prototype, "vDraggedResourceEl", {
    set: function(el2) {
      this._draggedResourceEl = el2 && el2.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MbscTimeline2.prototype, "vDraggedResvDraggedResourceLineElourceEl", {
    set: function(el2) {
      this._draggedResourceLineEl = el2 && el2.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MbscTimeline2.prototype, "vCursorTimeCont", {
    set: function(el2) {
      this._cursorTimeCont = el2 && el2.nativeElement;
    },
    enumerable: false,
    configurable: true
  });
  MbscTimeline2.prototype._getDayKey = function(index, day) {
    return day.timestamp;
  };
  MbscTimeline2.prototype._getTimeKey = function(index, v) {
    return v.t;
  };
  MbscTimeline2.prototype._getEventKey = function(index, data) {
    return data.uid;
  };
  MbscTimeline2.prototype._getDragKey = function(resourceId, slotId, dateKey) {
    return resourceId + "__" + slotId + "__" + dateKey;
  };
  MbscTimeline2.prototype._getId = function(index, data) {
    return data.id;
  };
  MbscTimeline2.prototype._getOriginDate = function(dragData) {
    return new Date(dragData.originDate);
  };
  MbscTimeline2.prototype._getRowKey = function(index, rowGroup) {
    return rowGroup.day ? rowGroup.day.dateKey : DEF_ID;
  };
  MbscTimeline2.prototype._getDate = function(timestamp) {
    return new Date(timestamp);
  };
  MbscTimeline2.prototype._render = function(s, state) {
    this._hasFooter = !!(this.hourFooterTemplate || this.dayFooterTemplate || this.weekFooterTemplate || this.monthFooterTemplate || this.quarterFooterTemplate || this.yearFooterTemplate);
    this._createEventMaps = !!(this._hasFooter || this.hourTemplate || this.dayTemplate || this.weekTemplate || this.monthTemplate || this.quarterTemplate || this.yearTemplate);
    _super.prototype._render.call(this, s, state);
  };
  MbscTimeline2.prototype._mounted = function() {
    this._footerCont = this.vFooterCont && this.vFooterCont.nativeElement;
    this._headerCont = this.vHeaderCont && this.vHeaderCont.nativeElement;
    this._scrollCont = this.vScrollCont && this.vScrollCont.nativeElement;
    this._gridCont = this.vGridCont && this.vGridCont.nativeElement;
    this._resCont = this.vResCont && this.vResCont.nativeElement;
    this._sidebarCont = this.vSidebarCont && this.vSidebarCont.nativeElement;
    this._stickyDate = this.vStickyDate && this.vStickyDate.nativeElement;
    this._stickyFooter = this.vStickyFooter && this.vStickyFooter.nativeElement;
    this._stickyHeader = this.vStickyHeader && this.vStickyHeader.nativeElement;
    this._stickyMonth = this.vStickyMonth && this.vStickyMonth.nativeElement;
    this._stickyWeek = this.vStickyWeek && this.vStickyWeek.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscTimeline2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscTimeline_BaseFactory;
    return function MbscTimeline_Factory(__ngFactoryType__) {
      return (ɵMbscTimeline_BaseFactory || (ɵMbscTimeline_BaseFactory = ɵɵgetInheritedFactory(MbscTimeline2)))(__ngFactoryType__ || MbscTimeline2);
    };
  })();
  MbscTimeline2.ɵcmp = ɵɵdefineComponent({
    type: MbscTimeline2,
    selectors: [["mbsc-timeline"]],
    viewQuery: function MbscTimeline_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c34, 7, ElementRef);
        ɵɵviewQuery(_c35, 7, ElementRef);
        ɵɵviewQuery(_c47, 5, ElementRef);
        ɵɵviewQuery(_c36, 7, ElementRef);
        ɵɵviewQuery(_c48, 5, ElementRef);
        ɵɵviewQuery(_c49, 5, ElementRef);
        ɵɵviewQuery(_c50, 5, ElementRef);
        ɵɵviewQuery(_c51, 5, ElementRef);
        ɵɵviewQuery(_c52, 5, ElementRef);
        ɵɵviewQuery(_c53, 5, ElementRef);
        ɵɵviewQuery(_c54, 5, ElementRef);
        ɵɵviewQuery(_c55, 5, ElementRef);
        ɵɵviewQuery(_c56, 5, ElementRef);
        ɵɵviewQuery(_c39, 5, ElementRef);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vScrollCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vGridCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vFooterCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vHeaderCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vResCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vSidebarCont = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vStickyFooter = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vStickyHeader = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vStickyDate = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vStickyMonth = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vStickyWeek = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vDraggedResourceEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vDraggedResvDraggedResourceLineElourceEl = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vCursorTimeCont = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscTimeline_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap("mbsc-timeline mbsc-flex-1-1 mbsc-flex-col" + (ctx2.state.cellWidth ? "" : " mbsc-hidden") + (ctx2._variableEventHeight ? " mbsc-timeline-events-variable" : "") + (ctx2._hasSticky ? " mbsc-has-sticky" : "") + (ctx2._hasResources ? "" : " mbsc-timeline-no-resource") + ctx2._theme + ctx2._rtl);
      }
    },
    inputs: {
      allDayText: "allDayText",
      amText: "amText",
      bufferAfterTemplate: "bufferAfterTemplate",
      bufferBeforeTemplate: "bufferBeforeTemplate",
      checkSize: "checkSize",
      clickToCreate: "clickToCreate",
      colorsMap: "colorsMap",
      connections: "connections",
      currentTimeIndicator: "currentTimeIndicator",
      columnWidth: "columnWidth",
      dateFormat: "dateFormat",
      dateFormatFull: "dateFormatFull",
      dateFormatLong: "dateFormatLong",
      dataTimezone: "dataTimezone",
      dayNames: "dayNames",
      dayNamesMin: "dayNamesMin",
      dayNamesShort: "dayNamesShort",
      dayFooterTemplate: "dayFooterTemplate",
      dayTemplate: "dayTemplate",
      dragIcon: "dragIcon",
      monthTemplate: "monthTemplate",
      monthFooterTemplate: "monthFooterTemplate",
      weekTemplate: "weekTemplate",
      weekFooterTemplate: "weekFooterTemplate",
      yearTemplate: "yearTemplate",
      yearFooterTemplate: "yearFooterTemplate",
      hourTemplate: "hourTemplate",
      hourFooterTemplate: "hourFooterTemplate",
      displayTimezone: "displayTimezone",
      dragBetweenResources: "dragBetweenResources",
      dragBetweenSlots: "dragBetweenSlots",
      dragInTime: "dragInTime",
      dragTimeStep: "dragTimeStep",
      dragToCreate: "dragToCreate",
      dragToMove: "dragToMove",
      dragToResize: "dragToResize",
      endDay: "endDay",
      endTime: "endTime",
      eventDragEnd: "eventDragEnd",
      eventMap: "eventMap",
      eventContentTemplate: "eventContentTemplate",
      eventOrder: "eventOrder",
      eventOverlap: "eventOverlap",
      eventTemplate: "eventTemplate",
      exclusiveEndDates: "exclusiveEndDates",
      extendDefaultEvent: "extendDefaultEvent",
      externalDrag: "externalDrag",
      externalDrop: "externalDrop",
      externalResourceDrag: "externalResourceDrag",
      externalResourceDrop: "externalResourceDrop",
      eventHeight: "eventHeight",
      eventList: "eventList",
      firstDay: "firstDay",
      fromText: "fromText",
      getDay: "getDay",
      getDate: "getDate",
      getMaxDayOfMonth: "getMaxDayOfMonth",
      getMonth: "getMonth",
      getWeekNumber: "getWeekNumber",
      getYear: "getYear",
      groupBy: "groupBy",
      height: "height",
      immutableData: "immutableData",
      invalidateEvent: "invalidateEvent",
      invalidsMap: "invalidsMap",
      maxDate: "maxDate",
      maxEventStack: "maxEventStack",
      minDate: "minDate",
      moreEventsPluralText: "moreEventsPluralText",
      moreEventsText: "moreEventsText",
      navigateToEvent: "navigateToEvent",
      monthNames: "monthNames",
      monthNamesShort: "monthNamesShort",
      navService: "navService",
      newEventText: "newEventText",
      nextIcon: "nextIcon",
      nextIconRtl: "nextIconRtl",
      downIcon: "downIcon",
      pmText: "pmText",
      refDate: "refDate",
      resolution: "resolution",
      resolutionVertical: "resolutionVertical",
      resources: "resources",
      resourceFooterTemplate: "resourceFooterTemplate",
      resourceHeaderTemplate: "resourceHeaderTemplate",
      resourceReorder: "resourceReorder",
      resourceTemplate: "resourceTemplate",
      resourceEmptyTemplate: "resourceEmptyTemplate",
      rowHeight: "rowHeight",
      scroll: "scroll",
      selected: "selected",
      selectedEventsMap: "selectedEventsMap",
      showAllDay: "showAllDay",
      showDays: "showDays",
      showEventBuffer: "showEventBuffer",
      showEventTooltip: "showEventTooltip",
      sidebarFooterTemplate: "sidebarFooterTemplate",
      sidebarHeaderTemplate: "sidebarHeaderTemplate",
      sidebarTemplate: "sidebarTemplate",
      size: "size",
      slots: "slots",
      slotTemplate: "slotTemplate",
      startDay: "startDay",
      startTime: "startTime",
      quarterTemplate: "quarterTemplate",
      quarterFooterTemplate: "quarterFooterTemplate",
      quarterText: "quarterText",
      timeCellStep: "timeCellStep",
      timeFormat: "timeFormat",
      timeLabelStep: "timeLabelStep",
      timezonePlugin: "timezonePlugin",
      toText: "toText",
      type: "type",
      virtualScroll: "virtualScroll",
      weekNumbers: "weekNumbers",
      weekText: "weekText",
      width: "width",
      zoomLevel: "zoomLevel",
      onActiveChange: "onActiveChange",
      onCellClick: "onCellClick",
      onCellDoubleClick: "onCellDoubleClick",
      onCellRightClick: "onCellRightClick",
      onEventClick: "onEventClick",
      onEventDoubleClick: "onEventDoubleClick",
      onEventDragEnter: "onEventDragEnter",
      onEventDragLeave: "onEventDragLeave",
      onEventRightClick: "onEventRightClick",
      onEventHoverIn: "onEventHoverIn",
      onEventHoverOut: "onEventHoverOut",
      onEventDelete: "onEventDelete",
      onEventDragEnd: "onEventDragEnd",
      onEventDragStart: "onEventDragStart",
      onMoreClick: "onMoreClick",
      onPopoverClose: "onPopoverClose",
      onResourceClick: "onResourceClick",
      onResourceDoubleClick: "onResourceDoubleClick",
      onResourceCollapse: "onResourceCollapse",
      onResourceCreate: "onResourceCreate",
      onResourceCreated: "onResourceCreated",
      onResourceDelete: "onResourceDelete",
      onResourceDeleted: "onResourceDeleted",
      onResourceDragEnd: "onResourceDragEnd",
      onResourceDragEnter: "onResourceDragEnter",
      onResourceDragLeave: "onResourceDragLeave",
      onResourceDragStart: "onResourceDragStart",
      onResourceExpand: "onResourceExpand",
      onResourceOrderUpdate: "onResourceOrderUpdate",
      onResourceRightClick: "onResourceRightClick",
      onWeekDayClick: "onWeekDayClick",
      onVirtualLoading: "onVirtualLoading"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 80,
    vars: 65,
    consts: [["tplResource", ""], ["tplSidebar", ""], ["tplRow", ""], ["tplHour", ""], ["tplHourFooter", ""], ["tplDay", ""], ["tplDayFooter", ""], ["tplWeek", ""], ["tplWeekFooter", ""], ["tplMonth", ""], ["tplMonthFooter", ""], ["tplQuarter", ""], ["tplQuarterFooter", ""], ["tplYear", ""], ["tplYearFooter", ""], ["tplDayData", ""], ["stickyHeader", ""], ["scrollCont", ""], ["headerCont", ""], ["gridCont", ""], ["default", ""], ["defaultHour", ""], ["defaultDay", ""], ["defaultWeek", ""], ["defaultMonth", ""], ["defaultQuarter", ""], ["defaultYear", ""], ["stickyMonth", ""], ["defaultTmpl", ""], ["stickyWeek", ""], ["stickyDate", ""], ["stickyFooter", ""], ["cursorTimeCont", ""], ["defaultSlot", ""], ["defaultTitle", ""], ["resCont", ""], ["draggedResourceLineEl", ""], ["sidebarCont", ""], ["footerCont", ""], ["draggedResourceEl", ""], [3, "innerHTML"], [3, "class", "height", "width", 4, "ngIf"], [1, "mbsc-flex-1-1"], [4, "ngIf"], [3, "class", "height", 4, "ngIf"], ["class", "mbsc-schedule-fake-scroll-y", 4, "ngIf"], [3, "class", 4, "ngIf"], [3, "scroll"], [3, "class", "width", 4, "ngIf"], [1, "mbsc-timeline-time-indicator-cont"], ["orientation", "y", 3, "amText", "displayedTime", "displayedDays", "displayTimezone", "endDay", "firstDay", "hasResY", "pmText", "rtl", "startDay", "startTime", "theme", "timeFormat", "timezonePlugin", 4, "ngIf"], [1, "mbsc-flex-none"], [1, "mbsc-flex-1-1", "mbsc-overflow-hidden"], ["class", "mbsc-flex", 4, "ngIf"], [1, "mbsc-flex", "mbsc-flex-1-1"], [1, "mbsc-timeline-hidden"], [3, "mouseleave", "mousemove"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["viewBox", "0 0 100 100", "preserveAspectRatio", "none", 4, "ngIf"], ["class", "mbsc-calendar-dragging", 4, "ngIf"], [3, "class", "background", "minHeight", "paddingLeft", "paddingRight", "top", "click", "dblclick", "contextmenu", 4, "ngIf"], [3, "click", "dblclick", "contextmenu"], [3, "class", "svg", "theme", 4, "ngIf"], [3, "class", "svg", "theme", "click", 4, "ngIf"], [3, "svg", "theme"], [3, "click", "svg", "theme"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "background", "minHeight", "top", 4, "ngIf"], [1, "mbsc-timeline-sidebar-resource-title"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], [1, "mbsc-flex", "mbsc-flex-1-0"], [3, "class", "click", "dblclick", "contextmenu", 4, "ngIf"], [3, "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "mbsc-flex-none", 3, "width", 4, "ngIf"], [3, "class", "ngStyle", "click", "dblclick", "contextmenu", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "click", "dblclick", "contextmenu", "ngStyle"], ["aria-hidden", "true"], [1, "mbsc-timeline-footer-week-cont"], [1, "mbsc-timeline-footer-month-cont"], [1, "mbsc-timeline-footer-quarter-cont"], [1, "mbsc-timeline-footer-year-cont"], [1, "mbsc-timeline-events"], ["class", "mbsc-timeline-events-track", 3, "minHeight", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-timeline-events-track"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "endDay", "event", "eventHeight", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hasResY", "hidden", "isDrag", "isTimeline", "isListing", "lastDay", "resize", "resource", "resourceObj", "rtl", "slot", "slotObj", "startDay", "theme", "template", "timezonePlugin", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOff", 4, "ngIf"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "endDay", "event", "eventHeight", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hasResY", "isDrag", "isTimeline", "isListing", "lastDay", "resize", "resource", "resourceObj", "rtl", "slot", "slotObj", "startDay", "theme", "template", "timezonePlugin", 4, "ngIf"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "endDay", "event", "eventHeight", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hasResY", "inactive", "isTimeline", "isListing", "lastDay", "resize", "resource", "resourceObj", "rtl", "selected", "slot", "slotObj", "startDay", "stickyPos", "theme", "template", "timezonePlugin", "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff", 4, "ngIf"], [3, "onClick", "onDoubleClick", "onRightClick", "onHoverIn", "onHoverOut", "onDelete", "onDragStart", "onDragMove", "onDragEnd", "onDragModeOn", "onDragModeOff", "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "endDay", "event", "eventHeight", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hasResY", "inactive", "isTimeline", "isListing", "lastDay", "resize", "resource", "resourceObj", "rtl", "selected", "slot", "slotObj", "startDay", "stickyPos", "theme", "template", "timezonePlugin"], [3, "onDragStart", "onDragMove", "onDragEnd", "onDragModeOff", "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "endDay", "event", "eventHeight", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hasResY", "hidden", "isDrag", "isTimeline", "isListing", "lastDay", "resize", "resource", "resourceObj", "rtl", "slot", "slotObj", "startDay", "theme", "template", "timezonePlugin"], [3, "bufferAfterTemplate", "bufferBeforeTemplate", "contentTemplate", "displayTimezone", "drag", "endDay", "event", "eventHeight", "exclusiveEndDates", "gridEndTime", "gridStartTime", "hasResY", "isDrag", "isTimeline", "isListing", "lastDay", "resize", "resource", "resourceObj", "rtl", "slot", "slotObj", "startDay", "theme", "template", "timezonePlugin"], [3, "class", "ngStyle", 4, "ngIf"], [3, "ngStyle"], [1, "mbsc-schedule-invalid-text"], [1, "mbsc-schedule-color-text"], [1, "mbsc-timeline-resource-header"], [3, "ngTemplateOutlet"], [1, "mbsc-timeline-sidebar-header"], [1, "mbsc-schedule-fake-scroll-y"], ["class", "mbsc-flex-1-1", 4, "ngIf"], [1, "mbsc-timeline-resource-footer"], [1, "mbsc-timeline-sidebar-footer"], ["orientation", "y", 3, "amText", "displayedTime", "displayedDays", "displayTimezone", "endDay", "firstDay", "hasResY", "pmText", "rtl", "startDay", "startTime", "theme", "timeFormat", "timezonePlugin"], [1, "mbsc-flex"], ["aria-hidden", "true", 1, "mbsc-flex"], [3, "ngStyle", "class", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "mbsc-hidden-content", 4, "ngIf"], [1, "mbsc-hidden-content"], [1, "mbsc-timeline-slot-title"], [3, "ngSwitch", 4, "ngIf", "ngIfElse"], [3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mbsc-flex-none mbsc-timeline-footer-ph", 3, "height", 4, "ngIf"], [3, "class", "minHeight", 4, "ngIf"], [1, "mbsc-timeline-row-resource-col", "mbsc-flex-1-1", "mbsc-flex-col"], [1, "mbsc-flex-none", "mbsc-timeline-footer-ph"], ["viewBox", "0 0 100 100", "preserveAspectRatio", "none"], ["vector-effect", "non-scaling-stroke", 3, "stroke", "fill", 4, "ngIf"], ["vector-effect", "non-scaling-stroke"], [3, "ngSwitch", 4, "ngIf"], [1, "mbsc-calendar-dragging"]],
    template: function MbscTimeline_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵtemplate(0, MbscTimeline_ng_template_0_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, MbscTimeline_ng_template_2_Template, 1, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor)(4, MbscTimeline_ng_template_4_Template, 7, 17, "ng-template", null, 2, ɵɵtemplateRefExtractor)(6, MbscTimeline_ng_template_6_Template, 4, 3, "ng-template", null, 3, ɵɵtemplateRefExtractor)(8, MbscTimeline_ng_template_8_Template, 2, 3, "ng-template", null, 4, ɵɵtemplateRefExtractor)(10, MbscTimeline_ng_template_10_Template, 4, 10, "ng-template", null, 5, ɵɵtemplateRefExtractor)(12, MbscTimeline_ng_template_12_Template, 2, 9, "ng-template", null, 6, ɵɵtemplateRefExtractor)(14, MbscTimeline_ng_template_14_Template, 3, 12, "ng-template", null, 7, ɵɵtemplateRefExtractor)(16, MbscTimeline_ng_template_16_Template, 2, 12, "ng-template", null, 8, ɵɵtemplateRefExtractor)(18, MbscTimeline_ng_template_18_Template, 3, 9, "ng-template", null, 9, ɵɵtemplateRefExtractor)(20, MbscTimeline_ng_template_20_Template, 2, 8, "ng-template", null, 10, ɵɵtemplateRefExtractor)(22, MbscTimeline_ng_template_22_Template, 3, 9, "ng-template", null, 11, ɵɵtemplateRefExtractor)(24, MbscTimeline_ng_template_24_Template, 2, 9, "ng-template", null, 12, ɵɵtemplateRefExtractor)(26, MbscTimeline_ng_template_26_Template, 3, 9, "ng-template", null, 13, ɵɵtemplateRefExtractor)(28, MbscTimeline_ng_template_28_Template, 2, 9, "ng-template", null, 14, ɵɵtemplateRefExtractor)(30, MbscTimeline_ng_template_30_Template, 5, 7, "ng-template", null, 15, ɵɵtemplateRefExtractor);
        ɵɵelement(32, "div", 40);
        ɵɵelementStart(33, "div", null, 16);
        ɵɵtemplate(35, MbscTimeline_div_35_Template, 3, 7, "div", 41);
        ɵɵelementStart(36, "div", 42);
        ɵɵtemplate(37, MbscTimeline_ng_container_37_Template, 4, 3, "ng-container", 43);
        ɵɵelementEnd();
        ɵɵtemplate(38, MbscTimeline_div_38_Template, 3, 5, "div", 44)(39, MbscTimeline_div_39_Template, 1, 0, "div", 45);
        ɵɵelementEnd();
        ɵɵtemplate(40, MbscTimeline_div_40_Template, 6, 6, "div", 46);
        ɵɵelementStart(41, "div", 47, 17);
        ɵɵlistener("scroll", function MbscTimeline_Template_div_scroll_41_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onScroll());
        });
        ɵɵelement(43, "div");
        ɵɵelementStart(44, "div", null, 18);
        ɵɵtemplate(46, MbscTimeline_div_46_Template, 1, 4, "div", 48);
        ɵɵelementStart(47, "div")(48, "div", 49);
        ɵɵtemplate(49, MbscTimeline_mbsc_time_indicator_49_Template, 1, 14, "mbsc-time-indicator", 50)(50, MbscTimeline_div_50_Template, 2, 2, "div", 46);
        ɵɵelementEnd();
        ɵɵelement(51, "div", 51);
        ɵɵelementStart(52, "div", 52);
        ɵɵtemplate(53, MbscTimeline_ng_container_53_Template, 5, 4, "ng-container", 43)(54, MbscTimeline_div_54_Template, 2, 2, "div", 53);
        ɵɵelementEnd();
        ɵɵelement(55, "div", 51);
        ɵɵelementEnd();
        ɵɵtemplate(56, MbscTimeline_div_56_Template, 1, 2, "div", 46);
        ɵɵelementEnd();
        ɵɵelementStart(57, "div", 54)(58, "div", 54);
        ɵɵtemplate(59, MbscTimeline_div_59_Template, 7, 15, "div", 48)(60, MbscTimeline_div_60_Template, 1, 4, "div", 48);
        ɵɵelementStart(61, "div", 55);
        ɵɵelement(62, "div")(63, "div")(64, "div")(65, "div")(66, "div")(67, "div")(68, "div");
        ɵɵelementEnd();
        ɵɵelementStart(69, "div", 56, 19);
        ɵɵlistener("mouseleave", function MbscTimeline_Template_div_mouseleave_69_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onMouseLeave($event));
        })("mousemove", function MbscTimeline_Template_div_mousemove_69_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onMouseMove($event));
        });
        ɵɵtemplate(71, MbscTimeline_ng_container_71_Template, 3, 2, "ng-container", 43);
        ɵɵelement(72, "div", 51);
        ɵɵtemplate(73, MbscTimeline_ng_container_73_Template, 3, 2, "ng-container", 57)(74, MbscTimeline__svg_svg_74_Template, 2, 3, "svg", 58);
        ɵɵelementEnd();
        ɵɵtemplate(75, MbscTimeline_div_75_Template, 7, 13, "div", 46)(76, MbscTimeline_div_76_Template, 1, 2, "div", 46);
        ɵɵelementEnd()();
        ɵɵtemplate(77, MbscTimeline_ng_container_77_Template, 12, 18, "ng-container", 43);
        ɵɵelementEnd();
        ɵɵtemplate(78, MbscTimeline_div_78_Template, 3, 8, "div", 46)(79, MbscTimeline_div_79_Template, 1, 0, "div", 59);
      }
      if (rf & 2) {
        ɵɵadvance(32);
        ɵɵproperty("innerHTML", ctx2.textParam, ɵɵsanitizeHtml);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-header-sticky mbsc-flex" + ctx2._theme);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._hasRows);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._isDailyResolution && !ctx2._hasResY);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasRows && !!ctx2.sidebarTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.state.hasScrollY);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasFooter);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-grid-scroll mbsc-flex-col mbsc-flex-1-1" + ctx2._theme + ctx2._rtl + ctx2._hb);
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-flex-none");
        ɵɵstyleProp("height", ctx2._hasSticky ? void 0 : ctx2.state.headerHeight, "px");
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-header mbsc-flex" + ctx2._theme + ctx2._rtl + ctx2._hb);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._hasRows);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-header-bg mbsc-flex-1-0 mbsc-flex" + ctx2._theme);
        ɵɵstyleProp("width", ctx2.state.hasScrollX ? ctx2._gridWidth : void 0, "px");
        ɵɵadvance();
        ɵɵstyleProp("height", (ctx2.state.scrollContHeight || 0) - (ctx2.state.headerHeight || 0), "px");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showTimeIndicator);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showCursorTime);
        ɵɵadvance();
        ɵɵstyleProp("width", ctx2._phXStart, "px");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._isDailyResolution);
        ɵɵadvance();
        ɵɵproperty("ngIf", !ctx2._isDailyResolution);
        ɵɵadvance();
        ɵɵstyleProp("width", ctx2._phXEnd, "px");
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasRows && !!ctx2.sidebarTemplate);
        ɵɵadvance(3);
        ɵɵproperty("ngIf", ctx2._hasRows);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasRows);
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-timeline-day mbsc-timeline-empty-day" + (ctx2._isDailyResolution ? "" : ctx2._colWidthClass) + ctx2._dayClass + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-column mbsc-timeline-empty-column" + (ctx2._hasSlots ? " mbsc-timeline-slot" : "") + ctx2._colWidthClass + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-row mbsc-timeline-empty-row" + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-row mbsc-timeline-parent mbsc-timeline-empty-parent" + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-row-gutter" + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-empty-resource " + ctx2._colClass + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-resource-depth-step" + ctx2._theme);
        ɵɵadvance();
        ɵɵclassMap("mbsc-timeline-grid mbsc-flex-1-0" + (ctx2._hasHierarchy || ctx2.state.hasScrollY ? "" : " mbsc-flex-col"));
        ɵɵstyleProp("width", ctx2.state.hasScrollX ? ctx2._gridWidth : void 0, "px")("height", ctx2.state.hasScrollY ? ctx2._gridHeight : void 0, "px");
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2.state.dragData && ctx2.state.dragData.draggedResourceVisible);
        ɵɵadvance();
        ɵɵstyleProp("height", ctx2._phY, "px");
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx2._virtualRows)("ngForTrackBy", ctx2._getRowKey);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._connections);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasRows && !!ctx2.sidebarTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasRows && !!ctx2.sidebarTemplate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._hasFooter);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.state.dragData && ctx2.state.dragData.draggedResourceVisible && ctx2.state.dragData.draggedResource);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.state.dragData && !ctx2.state.isTouchDrag);
      }
    },
    dependencies: [MbscIcon, MbscScheduleEvent, MbscTimeIndicator, NgIf, NgTemplateOutlet, NgForOf, NgStyle, NgSwitch, NgSwitchCase],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscTimeline2;
}(TimelineBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscTimeline, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": '"mbsc-timeline mbsc-flex-1-1 mbsc-flex-col" +\n      (state.cellWidth ? "" : " mbsc-hidden") +\n      (_variableEventHeight ? " mbsc-timeline-events-variable" : "") +\n      (_hasSticky ? " mbsc-has-sticky" : "") +\n      (_hasResources ? "" : " mbsc-timeline-no-resource") + _theme + _rtl'
      },
      selector: "mbsc-timeline",
      template: `
    <ng-template #tplResource let-res="res" let-key="key" let-day="day" let-isDrag="isDrag">
      <div
        *ngIf="key !== _dragRow"
        [class]="
          'mbsc-timeline-resource mbsc-timeline-row mbsc-flex-1-0' +
          (res.isParent ? ' mbsc-timeline-parent' : '') +
          (res.isParent || (resourceReorder && res.reorder !== false && res.id !== _defId) ? ' mbsc-flex' : '') +
          (state.dragData && res.id === state.dragData.hoverResource ? ' mbsc-timeline-parent-hover' : '') +
          (res.fixed && !_hasResY ? ' mbsc-timeline-row-fixed' : '') +
          (key === _dragRow && !isDrag ? ' mbsc-timeline-hidden' : '') +
          (res.cssClass ? ' ' + res.cssClass : '') +
          _theme +
          _rtl +
          _hb
        "
        [style.background]="res.background"
        [style.minHeight]="_rowHeights[key]"
        [style.paddingLeft.em]="rtl ? undefined : _hasHierarchy ? res.depth! * 1.75 : undefined"
        [style.paddingRight.em]="rtl ? (_hasHierarchy ? res.depth! * 1.75 : undefined) : undefined"
        [style.top]="res.fixed && !_hasResY ? _fixedResourceTops[key] + 'px' : undefined"
        (click)="_onResourceClick('onResourceClick', $event, res, day)"
        (dblclick)="_onResourceClick('onResourceDoubleClick', $event, res, day)"
        (contextmenu)="_onResourceClick('onResourceRightClick', $event, res, day)"
      >
        <mbsc-icon
          *ngIf="resourceReorder && res.reorder !== false && res.id !== _defId"
          [class]="'mbsc-timeline-resource-icon mbsc-timeline-resource-sort ' + _rtl + _hb"
          [svg]="s.dragIcon"
          [theme]="theme"
        >
        </mbsc-icon>

        <mbsc-icon
          *ngIf="res.isParent"
          [class]="'mbsc-timeline-resource-icon' + _rtl + _hb"
          [svg]="res.collapsed ? (rtl ? nextIconRtl : nextIcon) : downIcon"
          [theme]="theme"
          (click)="_toggleResource(res, $event)"
        >
        </mbsc-icon>
        <div
          [class]="
            'mbsc-timeline-resource-title' +
            (res.isParent || (resourceReorder && res.reorder !== false && res.id !== _defId) ? ' mbsc-flex-1-1' : '')
          "
        >
          <ng-template #default>{{ res.name }}</ng-template>
          <ng-template
            *ngIf="res.id !== _defId"
            [ngTemplateOutlet]="resourceTemplate || default"
            [ngTemplateOutletContext]="{ $implicit: res, day: day }"
          >
          </ng-template>
          <ng-template
            *ngIf="res.id === _defId"
            [ngTemplateOutlet]="resourceEmptyTemplate || default"
            [ngTemplateOutletContext]="{ $implicit: res }"
          >
          </ng-template>
        </div>
      </div>
    </ng-template>

    <ng-template #tplSidebar let-res="res" let-key="key">
      <div
        *ngIf="key !== _dragRow"
        [class]="
          'mbsc-timeline-sidebar-resource mbsc-timeline-row mbsc-flex-1-0' +
          (res.isParent ? ' mbsc-timeline-parent mbsc-flex' : '') +
          (state.dragData && res.id === state.dragData.hoverResource ? ' mbsc-timeline-parent-hover' : '') +
          (res.fixed && !_hasResY ? ' mbsc-timeline-row-fixed' : '') +
          (res.cssClass ? ' ' + res.cssClass : '') +
          _theme +
          _rtl +
          _hb
        "
        [style.background]="res.background"
        [style.minHeight]="_rowHeights[key]"
        [style.top]="res.fixed && !_hasResY ? _fixedResourceTops[key] + 'px' : undefined"
      >
        <div class="mbsc-timeline-sidebar-resource-title">
          <ng-template *ngIf="res.id !== _defId" [ngTemplateOutlet]="sidebarTemplate!" [ngTemplateOutletContext]="{ $implicit: res }">
          </ng-template>
        </div>
      </div>
    </ng-template>

    <ng-template #tplRow let-res="res" let-dateKey="dateKey" let-day="day">
      <div
        [class]="
          'mbsc-timeline-row mbsc-timeline-row-outer mbsc-flex mbsc-flex-1-0' +
          (res.isParent ? ' mbsc-timeline-parent' : '') +
          (state.dragData && res.id === state.dragData.hoverResource ? ' mbsc-timeline-parent-hover' : '') +
          (res.fixed && !_hasResY ? ' mbsc-timeline-row-fixed' : '') +
          (res.cssClass ? ' ' + res.cssClass : '') +
          ((dateKey ? dateKey + '-' : '') + res.id === _dragRow ? ' mbsc-timeline-hidden' : '') +
          _theme +
          _hb
        "
        [style.background]="res.background"
        [style.minHeight]="_rowHeights[(dateKey ? dateKey + '-' : '') + res.id]"
        [style.top]="res.fixed && !_hasResY ? _fixedResourceTops[(dateKey ? dateKey + '-' : '') + res.id] + 'px' : undefined"
      >
        <ng-container
          *ngIf="!_hasSlots"
          [ngTemplateOutlet]="tplDayData"
          [ngTemplateOutletContext]="{
            colors: _viewColors[(dateKey ? dateKey + '-' : '') + res.id],
            events: _viewEvents[(dateKey ? dateKey + '-' : '') + res.id],
            invalids: _viewInvalids[(dateKey ? dateKey + '-' : '') + res.id],
            dragData: state.dragData,
            dragKey: _getDragKey(res.id, _defId, dateKey || 'all'),
            resource: res,
            slot: _slots[0],
            tracks: _events[res.id][_defId][dateKey || 'all'] ? _events[res.id][_defId][dateKey || 'all'].tracks : []
          }"
        >
        </ng-container>

        <div [class]="'mbsc-timeline-row mbsc-timeline-row-size' + (res.cssClass ? ' ' + res.cssClass : '')"></div>
        <div [style.width.px]="_phXStart" class="mbsc-flex-none"></div>
        <div class="mbsc-flex mbsc-flex-1-0">
          <ng-container *ngFor="let dayData of _virtualDays; trackBy: _getDayKey">
            <div
              *ngIf="_isDailyResolution"
              [class]="
                'mbsc-timeline-day mbsc-flex mbsc-flex-1-0-0' +
                _dayClass +
                _theme +
                _rtl +
                _hb +
                (dayData.dateKey === _dragCol ? ' mbsc-timeline-hidden' : '') +
                (dayData.dateIndex < _daysNr - 1 && (_stepCell < _oneDay || dayData.lastOfMonth) ? ' mbsc-timeline-day-border' : '')
              "
            >
              <div
                *ngFor="let slot of _slots; trackBy: _getId"
                [class]="'mbsc-flex mbsc-flex-1-1' + (_hasSlots ? ' mbsc-timeline-slot' : '')"
              >
                <ng-container
                  *ngIf="_hasSlots"
                  [ngTemplateOutlet]="tplDayData"
                  [ngTemplateOutletContext]="{
                    colors: (_colors[res.id][slot.id][dateKey || dayData.dateKey] && [
                      _colors[res.id][slot.id][dateKey || dayData.dateKey].data
                    ]) || [[]],
                    events: (_events[res.id][slot.id][dateKey || dayData.dateKey] && [
                      _events[res.id][slot.id][dateKey || dayData.dateKey].data
                    ]) || [[]],
                    invalids: (_invalids[res.id][slot.id][dateKey || dayData.dateKey] && [
                      _invalids[res.id][slot.id][dateKey || dayData.dateKey].data
                    ]) || [[]],
                    dragData: state.dragData,
                    dragKey: _getDragKey(res.id, slot.id, dayData.dateKey),
                    resource: res,
                    slot: slot,
                    tracks: []
                  }"
                >
                </ng-container>
                <div *ngIf="dayData.phStart !== 0" [style.width.px]="dayData.phStart" class="mbsc-flex-none"></div>
                <div
                  *ngFor="let v of dayData.times; trackBy: _getTimeKey"
                  [class]="
                    'mbsc-timeline-column mbsc-flex-1-1' +
                    _colWidthClass +
                    _theme +
                    _rtl +
                    _hb +
                    (v.hidden ? ' mbsc-timeline-hidden' : '') +
                    ((v.first && !v.last && _startCellStyle) || (v.last && !v.first && _endCellStyle) ? ' mbsc-flex-none' : '')
                  "
                  (click)="_onCellClick('onCellClick', (day || dayData).timestamp, v.t, $event, res.id, slot.id)"
                  (dblclick)="_onCellClick('onCellDoubleClick', (day || dayData).timestamp, v.t, $event, res.id, slot.id)"
                  (contextmenu)="_onCellClick('onCellRightClick', (day || dayData).timestamp, v.t, $event, res.id, slot.id)"
                  [ngStyle]="v.first && !v.last ? _startCellStyle! : v.last && !v.first ? _endCellStyle! : {}"
                ></div>
                <div *ngIf="dayData.phEnd !== 0" [style.width.px]="dayData.phEnd" class="mbsc-flex-none"></div>
              </div>
            </div>
            <div
              *ngIf="!_isDailyResolution"
              [class]="
                'mbsc-timeline-day mbsc-timeline-column mbsc-flex-1-0-0' +
                _colWidthClass +
                _theme +
                _rtl +
                _hb +
                (dayData.dateKey === _dragCol ? ' mbsc-timeline-hidden' : '')
              "
              (click)="onCellClick({ date: dayData.date, domEvent: $event, resource: res.id, source: 'timeline' })"
              (dblclick)="onCellDoubleClick({ date: dayData.date, domEvent: $event, resource: res.id, source: 'timeline' })"
              (contextmenu)="onCellRightClick({ date: dayData.date, domEvent: $event, resource: res.id, source: 'timeline' })"
            ></div>
          </ng-container>
        </div>
        <div [style.width.px]="_phXEnd" class="mbsc-flex-none"></div>
      </div>
    </ng-template>

    <ng-template #tplHour let-hour="hour" let-timestamp="timestamp">
      <div aria-hidden="true" [class]="'mbsc-timeline-header-time mbsc-flex-1-1' + _theme">
        <ng-template #defaultHour>{{ _timeLabels[0][timestamp] }}</ng-template>
        <ng-template
          *ngIf="_timeLabels[0][timestamp]"
          [ngTemplateOutlet]="hourTemplate || defaultHour"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: _getDate(+hour.date + timestamp),
              events: hour.eventMap[+hour.date + timestamp] || [],
              isActive: hour.isActive
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template #tplHourFooter let-hour="hour" let-timestamp="timestamp">
      <div aria-hidden="true" [class]="'mbsc-timeline-footer-time mbsc-flex-1-1 ' + _theme">
        <ng-template
          *ngIf="_timeLabels[0][timestamp]"
          [ngTemplateOutlet]="hourFooterTemplate!"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: _getDate(+hour.date + timestamp),
              events: hour.eventMap[+hour.date + timestamp] || [],
              isActive: hour.isActive
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template #tplDay let-day="day">
      <div
        aria-hidden="true"
        [class]="
          (dayTemplate ? '' : 'mbsc-timeline-header-date-text') +
          (day.isActive && !dayTemplate ? ' mbsc-timeline-header-active' : '') +
          _theme
        "
      >
        <ng-template #defaultDay>{{ day.dateText }}</ng-template>
        <ng-template
          [ngTemplateOutlet]="dayTemplate || defaultDay"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: day.date,
              events: day.eventMap.all,
              isActive: day.isActive
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template #tplDayFooter let-day="day">
      <div [class]="'mbsc-timeline-footer-date-cont' + _theme">
        <ng-template
          [ngTemplateOutlet]="dayFooterTemplate!"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: day.date,
              events: day.eventMap.all
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template #tplWeek let-week="week">
      <ng-template #defaultWeek>{{ week.weekText }}</ng-template>
      <ng-template
        [ngTemplateOutlet]="weekTemplate || defaultWeek"
        [ngTemplateOutletContext]="{
          $implicit: {
            date: week.date,
            events: week.eventMap[week.timestamp] || [],
            isActive: week.isActive,
            startDate: week.date,
            endDate: week.endDate,
            weekNr: week.weekNr
          }
        }"
      ></ng-template>
    </ng-template>

    <ng-template #tplWeekFooter let-week="week">
      <div class="mbsc-timeline-footer-week-cont">
        <ng-template
          [ngTemplateOutlet]="weekFooterTemplate!"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: week.date,
              events: week.eventMap[week.timestamp] || [],
              isActive: week.isActive,
              startDate: week.date,
              endDate: week.endDate,
              weekNr: week.weekNr
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template #tplMonth let-month="month">
      <ng-template #defaultMonth>{{ month.monthText }}</ng-template>
      <ng-template
        [ngTemplateOutlet]="monthTemplate || defaultMonth"
        [ngTemplateOutletContext]="{
          $implicit: {
            date: month.date,
            events: month.eventMap[month.timestamp] || [],
            isActive: month.isActive
          }
        }"
      ></ng-template>
    </ng-template>

    <ng-template #tplMonthFooter let-month="month">
      <div class="mbsc-timeline-footer-month-cont">
        <ng-template
          [ngTemplateOutlet]="monthFooterTemplate!"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: month.date,
              events: month.eventMap[month.timestamp] || []
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template #tplQuarter let-quarter="quarter">
      <ng-template #defaultQuarter>{{ quarter.quarterText }}</ng-template>
      <ng-template
        [ngTemplateOutlet]="quarterTemplate || defaultQuarter"
        [ngTemplateOutletContext]="{
          $implicit: {
            date: quarter.date,
            events: quarter.eventMap[quarter.timestamp] || [],
            isActive: quarter.isActive
          }
        }"
      ></ng-template>
    </ng-template>

    <ng-template #tplQuarterFooter let-quarter="quarter">
      <div class="mbsc-timeline-footer-quarter-cont">
        <ng-template
          [ngTemplateOutlet]="quarterFooterTemplate!"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: quarter.date,
              events: quarter.eventMap[quarter.timestamp] || [],
              isActive: quarter.isActive
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template #tplYear let-year="year">
      <ng-template #defaultYear>{{ year.columnTitle }}</ng-template>
      <ng-template
        [ngTemplateOutlet]="yearTemplate || defaultYear"
        [ngTemplateOutletContext]="{
          $implicit: {
            date: year.date,
            events: year.eventMap[year.timestamp] || [],
            isActive: year.isActive
          }
        }"
      ></ng-template>
    </ng-template>

    <ng-template #tplYearFooter let-year="year">
      <div class="mbsc-timeline-footer-year-cont">
        <ng-template
          [ngTemplateOutlet]="yearFooterTemplate!"
          [ngTemplateOutletContext]="{
            $implicit: {
              date: year.date,
              events: year.eventMap[year.timestamp] || [],
              isActive: year.isActive
            }
          }"
        ></ng-template>
      </div>
    </ng-template>

    <ng-template
      #tplDayData
      let-colors="colors"
      let-dragData="dragData"
      let-dragKey="dragKey"
      let-events="events"
      let-invalids="invalids"
      let-resource="resource"
      let-slot="slot"
      let-tracks="tracks"
    >
      <div class="mbsc-timeline-events">
        <div
          *ngFor="let track of events; let i = index; trackBy: _getKey"
          class="mbsc-timeline-events-track"
          [style.minHeight]="_variableEventHeight ? (tracks[i] || 0) + 'px' : undefined"
        >
          <ng-container *ngFor="let event of track; trackBy: _getEventKey">
            <mbsc-schedule-event
              *ngIf="event.position"
              [bufferAfterTemplate]="bufferAfterTemplate"
              [bufferBeforeTemplate]="bufferBeforeTemplate"
              [contentTemplate]="eventContentTemplate"
              [displayTimezone]="displayTimezone"
              [drag]="dragToMove || externalDrag"
              [endDay]="endDay"
              [event]="event"
              [eventHeight]="_setRowHeight && !_variableEventHeight ? _eventHeight : undefined"
              [exclusiveEndDates]="exclusiveEndDates"
              [gridEndTime]="_endTime"
              [gridStartTime]="_startTime"
              [hasResY]="_hasResY"
              [inactive]="dragData && dragData.draggedEvent && dragData.draggedEvent.id === event.id"
              [isTimeline]="true"
              [isListing]="eventList"
              [lastDay]="_lastDay"
              [resize]="_computeResize(event.original!.resize, dragToResize, resource.eventResize)"
              [resource]="resource.id"
              [resourceObj]="resource"
              [rtl]="rtl"
              [selected]="!!(selectedEventsMap[event.uid!] || selectedEventsMap[event.id!])"
              [slot]="slot.id"
              [slotObj]="slot"
              [startDay]="startDay"
              [stickyPos]="_hasSticky && !_hasSlots ? (_hasResources ? _resourceWidth : 0) + 'px' : undefined"
              [theme]="theme"
              [template]="eventTemplate"
              [timezonePlugin]="timezonePlugin"
              (onClick)="_onEventClick($event)"
              (onDoubleClick)="onEventDoubleClick($event)"
              (onRightClick)="onEventRightClick($event)"
              (onHoverIn)="onEventHoverIn($event)"
              (onHoverOut)="onEventHoverOut($event)"
              (onDelete)="onEventDelete($event)"
              (onDragStart)="_onEventDragStart($event)"
              (onDragMove)="_onEventDragMove($event)"
              (onDragEnd)="_onEventDragEnd($event)"
              (onDragModeOn)="_onEventDragModeOn($event)"
              (onDragModeOff)="_onEventDragModeOff($event)"
            >
            </mbsc-schedule-event>
          </ng-container>
          <mbsc-schedule-event
            *ngIf="dragData && dragData.originDates && dragData.originDates[dragKey] && dragData.originDates[dragKey].track === i"
            [bufferAfterTemplate]="bufferAfterTemplate"
            [bufferBeforeTemplate]="bufferBeforeTemplate"
            [contentTemplate]="eventContentTemplate"
            [displayTimezone]="displayTimezone"
            [drag]="dragToMove || externalDrag"
            [endDay]="endDay"
            [event]="dragData.originDates[dragKey]"
            [eventHeight]="_setRowHeight && !_variableEventHeight ? _eventHeight : undefined"
            [exclusiveEndDates]="exclusiveEndDates"
            [gridEndTime]="_endTime"
            [gridStartTime]="_startTime"
            [hasResY]="_hasResY"
            [hidden]="!!dragData.draggedDates"
            [isDrag]="true"
            [isTimeline]="true"
            [isListing]="eventList"
            [lastDay]="_lastDay"
            [resize]="_computeResize(dragData.originDates[dragKey].original!.resize, dragToResize, resource.eventResize)"
            [resource]="resource.id"
            [resourceObj]="resource"
            [rtl]="rtl"
            [slot]="slot.id"
            [slotObj]="slot"
            [startDay]="startDay"
            [theme]="theme"
            [template]="eventTemplate"
            [timezonePlugin]="timezonePlugin"
            (onDragStart)="_onEventDragStart($event)"
            (onDragMove)="_onEventDragMove($event)"
            (onDragEnd)="_onEventDragEnd($event)"
            (onDragModeOff)="_onEventDragModeOff($event)"
          >
          </mbsc-schedule-event>
          <mbsc-schedule-event
            *ngIf="dragData && dragData.draggedDates && dragData.draggedDates[dragKey] && dragData.draggedDates[dragKey].track === i"
            [bufferAfterTemplate]="bufferAfterTemplate"
            [bufferBeforeTemplate]="bufferBeforeTemplate"
            [contentTemplate]="eventContentTemplate"
            [displayTimezone]="displayTimezone"
            [drag]="dragToMove || externalDrag"
            [endDay]="endDay"
            [event]="dragData.draggedDates[dragKey]"
            [eventHeight]="_setRowHeight && !_variableEventHeight ? _eventHeight : undefined"
            [exclusiveEndDates]="exclusiveEndDates"
            [gridEndTime]="_endTime"
            [gridStartTime]="_startTime"
            [hasResY]="_hasResY"
            [isDrag]="true"
            [isTimeline]="true"
            [isListing]="eventList"
            [lastDay]="_lastDay"
            [resize]="_computeResize(dragData.draggedDates[dragKey].original!.resize, dragToResize, resource.eventResize)"
            [resource]="resource.id"
            [resourceObj]="resource"
            [rtl]="rtl"
            [slot]="slot.id"
            [slotObj]="slot"
            [startDay]="startDay"
            [theme]="theme"
            [template]="eventTemplate"
            [timezonePlugin]="timezonePlugin"
          >
          </mbsc-schedule-event>
        </div>
        <div *ngIf="_setRowHeight && _variableEventHeight" [class]="'mbsc-timeline-row-gutter' + _theme"></div>
      </div>
      <ng-container *ngFor="let invalid of invalids[0]; trackBy: _getKey">
        <div
          *ngIf="invalid.position"
          [class]="'mbsc-schedule-invalid mbsc-timeline-invalid' + invalid.cssClass + _theme"
          [ngStyle]="invalid.position"
        >
          <div class="mbsc-schedule-invalid-text">{{ invalid.title }}</div>
        </div>
      </ng-container>
      <ng-container *ngFor="let color of colors[0]; trackBy: _getKey">
        <div [class]="'mbsc-schedule-color mbsc-timeline-color' + color.cssClass + _theme" [ngStyle]="color.position">
          <div class="mbsc-schedule-color-text">{{ color.title }}</div>
        </div>
      </ng-container>
    </ng-template>

    <div [innerHTML]="textParam"></div>
    <div #stickyHeader [class]="'mbsc-timeline-header-sticky mbsc-flex' + _theme">
      <div
        *ngIf="_hasRows"
        [class]="'mbsc-timeline-resource-header-cont ' + _colClass + _theme + _rtl + _hb"
        [style.height.px]="state.headerHeight"
        [style.width.px]="_hasResources ? _resourceWidth : undefined"
      >
        <div class="mbsc-timeline-resource-header">
          <ng-template [ngTemplateOutlet]="resourceHeaderTemplate!"></ng-template>
        </div>
      </div>
      <div class="mbsc-flex-1-1">
        <ng-container *ngIf="_isDailyResolution && !_hasResY">
          <div *ngIf="_isMulti" [class]="'mbsc-timeline-header-month mbsc-flex' + _theme + _rtl + _hb">
            <div
              #stickyMonth
              [class]="
                'mbsc-timeline-header-text ' +
                (monthTemplate ? 'mbsc-timeline-header-month-cont' : 'mbsc-timeline-header-month-text') +
                _theme
              "
            >
              <ng-template #defaultTmpl>{{ _stickyDay.monthText }}</ng-template>
              <ng-template
                [ngTemplateOutlet]="monthTemplate || defaultTmpl"
                [ngTemplateOutletContext]="{
                  $implicit: {
                    date: _stickyDay.date,
                    events: _stickyDay.eventMap[_stickyDay.timestamp] || [],
                    isActive: _stickyDay.isActive
                  }
                }"
              ></ng-template>
            </div>
          </div>
          <div *ngIf="weekNumbers" [class]="'mbsc-timeline-header-week mbsc-flex' + _theme + _rtl + _hb">
            <div
              #stickyWeek
              [class]="
                'mbsc-timeline-header-text ' + (weekTemplate ? 'mbsc-timeline-header-week-cont' : 'mbsc-timeline-header-week-text') + _theme
              "
            >
              <ng-template #defaultTmpl>{{ _stickyDay.weekText }}</ng-template>
              <ng-template
                [ngTemplateOutlet]="weekTemplate || defaultTmpl"
                [ngTemplateOutletContext]="{
                  $implicit: {
                    date: _stickyDay.date,
                    events: _stickyDay.eventMap[_stickyDay.timestamp] || [],
                    isActive: _stickyDay.isActive,
                    startDate: _stickyDay.date,
                    endDate: _stickyDay.endDate,
                    weekNr: _stickyDay.weekNr
                  }
                }"
              ></ng-template>
            </div>
          </div>
          <div *ngIf="_hasSlots || _stepCell < _oneDay" [class]="'mbsc-timeline-header-date mbsc-flex' + _theme + _rtl + _hb">
            <div
              #stickyDate
              [class]="
                'mbsc-timeline-header-text ' +
                (_stickyDay.isActive && !dayTemplate ? 'mbsc-timeline-header-active ' : '') +
                (dayTemplate ? 'mbsc-timeline-header-date-cont' : 'mbsc-timeline-header-date-text') +
                _theme
              "
            >
              <ng-template #defaultDay>{{ _stickyDay.dateText }}</ng-template>
              <ng-template
                [ngTemplateOutlet]="dayTemplate || defaultDay"
                [ngTemplateOutletContext]="{
                  $implicit: {
                    date: _stickyDay.date,
                    events: _stickyDay.eventMap.all,
                    isActive: _stickyDay.isActive
                  }
                }"
              ></ng-template>
            </div>
          </div>
        </ng-container>
      </div>
      <div
        *ngIf="_hasRows && !!sidebarTemplate"
        [class]="'mbsc-timeline-sidebar-header-cont mbsc-timeline-sidebar-col' + _theme + _rtl + _hb"
        [style.height.px]="state.headerHeight"
      >
        <div class="mbsc-timeline-sidebar-header">
          <ng-template [ngTemplateOutlet]="sidebarHeaderTemplate!"></ng-template>
        </div>
      </div>
      <div *ngIf="state.hasScrollY" class="mbsc-schedule-fake-scroll-y"></div>
    </div>

    <div #stickyFooter *ngIf="_hasFooter" [class]="'mbsc-timeline-footer-sticky mbsc-flex' + _theme">
      <div
        *ngIf="_hasRows"
        [class]="'mbsc-timeline-resource-footer-cont ' + _colClass + _theme + _rtl + _hb"
        [style.height.px]="state.footerHeight"
        [style.width.px]="_hasResources ? _resourceWidth : undefined"
      >
        <div class="mbsc-timeline-resource-footer">
          <ng-template [ngTemplateOutlet]="resourceFooterTemplate!"></ng-template>
        </div>
      </div>
      <div *ngIf="_isDailyResolution" class="mbsc-flex-1-1"></div>
      <div
        *ngIf="_hasRows && !!sidebarTemplate"
        [class]="'mbsc-timeline-sidebar-footer-cont mbsc-timeline-sidebar-col' + _theme + _rtl + _hb"
        [style.height.px]="state.footerHeight"
      >
        <div class="mbsc-timeline-sidebar-footer">
          <ng-template [ngTemplateOutlet]="sidebarFooterTemplate!"></ng-template>
        </div>
      </div>
      <div *ngIf="state.hasScrollY" class="mbsc-schedule-fake-scroll-y"></div>
    </div>

    <div #scrollCont [class]="'mbsc-timeline-grid-scroll mbsc-flex-col mbsc-flex-1-1' + _theme + _rtl + _hb" (scroll)="_onScroll()">
      <div [class]="'mbsc-flex-none'" [style.height.px]="_hasSticky ? undefined : state.headerHeight"></div>
      <div #headerCont [class]="'mbsc-timeline-header mbsc-flex' + _theme + _rtl + _hb">
        <div
          *ngIf="_hasRows"
          [class]="'mbsc-timeline-resource-header-cont ' + _colClass + _theme + _rtl + _hb"
          [style.width.px]="_hasResources ? _resourceWidth : undefined"
        ></div>
        <div
          [class]="'mbsc-timeline-header-bg mbsc-flex-1-0 mbsc-flex' + _theme"
          [style.width.px]="state.hasScrollX ? this._gridWidth : undefined"
        >
          <div class="mbsc-timeline-time-indicator-cont" [style.height.px]="(state.scrollContHeight || 0) - (state.headerHeight || 0)">
            <mbsc-time-indicator
              *ngIf="_showTimeIndicator"
              [amText]="s.amText"
              [displayedTime]="_time"
              [displayedDays]="_daysNr"
              [displayTimezone]="displayTimezone"
              [endDay]="endDay"
              [firstDay]="_firstDayTz"
              [hasResY]="_hasResY"
              orientation="y"
              [pmText]="s.pmText"
              [rtl]="rtl"
              [startDay]="startDay"
              [startTime]="_startTime"
              [theme]="theme"
              [timeFormat]="timeFormat"
              [timezonePlugin]="timezonePlugin"
            >
            </mbsc-time-indicator>
            <div *ngIf="_showCursorTime" #cursorTimeCont [class]="'mbsc-schedule-cursor-time mbsc-schedule-cursor-time-y' + _theme"></div>
          </div>
          <div [style.width.px]="_phXStart" class="mbsc-flex-none"></div>
          <div class="mbsc-flex-1-1 mbsc-overflow-hidden">
            <ng-container *ngIf="_isDailyResolution">
              <div *ngIf="_isMulti && !_hasResY" class="mbsc-flex">
                <ng-container *ngFor="let d of _virtualDays; trackBy: _getDayKey">
                  <div
                    *ngIf="d.dateKey !== _dragCol"
                    [class]="
                      'mbsc-timeline-month mbsc-flex-1-0-0' +
                      _colWidthClass +
                      _theme +
                      _rtl +
                      _hb +
                      (d.dateIndex < _daysNr - 1 && d.lastOfMonth ? ' mbsc-timeline-day mbsc-timeline-day-border' : '')
                    "
                  >
                    <div
                      [class]="
                        'mbsc-timeline-header-month' +
                        _theme +
                        _rtl +
                        _hb +
                        (d.dateIndex < _daysNr - 1 && d.lastOfMonth ? ' mbsc-timeline-header-month-last' : '')
                      "
                    >
                      <div
                        [class]="
                          (monthTemplate ? 'mbsc-timeline-header-month-cont' : 'mbsc-timeline-header-month-text') +
                          (d.lastOfMonth ? ' mbsc-timeline-header-month-text-last' : '') +
                          _theme
                        "
                      >
                        <ng-template
                          *ngIf="d.monthTitle"
                          [ngTemplateOutlet]="tplMonth"
                          [ngTemplateOutletContext]="{ month: d }"
                        ></ng-template>
                      </div>
                    </div>
                  </div>
                </ng-container>
              </div>
              <div *ngIf="s.weekNumbers" class="mbsc-flex">
                <ng-container *ngFor="let d of _virtualDays; trackBy: _getDayKey">
                  <div
                    *ngIf="d.dateKey !== _dragCol"
                    [class]="
                      'mbsc-timeline-month mbsc-flex-1-0-0' +
                      _colWidthClass +
                      _theme +
                      _rtl +
                      _hb +
                      (d.dateIndex < _daysNr - 1 && d.lastOfWeek && (_stepCell < _oneDay || d.lastOfMonth)
                        ? ' mbsc-timeline-day mbsc-timeline-day-border'
                        : '')
                    "
                  >
                    <div
                      [class]="'mbsc-timeline-header-week' + _theme + _rtl + _hb + (d.lastOfWeek ? ' mbsc-timeline-header-week-last' : '')"
                    >
                      <div
                        [class]="
                          (weekTemplate ? 'mbsc-timeline-header-week-cont' : 'mbsc-timeline-header-week-text') +
                          (d.lastOfWeek ? ' mbsc-timeline-header-week-text-last' : '') +
                          _theme
                        "
                      >
                        <ng-template *ngIf="d.weekTitle" [ngTemplateOutlet]="tplWeek" [ngTemplateOutletContext]="{ week: d }"></ng-template>
                      </div>
                    </div>
                  </div>
                </ng-container>
              </div>
              <div class="mbsc-flex">
                <ng-container *ngFor="let d of _virtualDays; trackBy: _getDayKey">
                  <div
                    *ngIf="d.dateKey !== _dragCol"
                    [class]="
                      'mbsc-timeline-day mbsc-flex-1-0-0' +
                      _dayClass +
                      _theme +
                      _rtl +
                      _hb +
                      (d.dateIndex < _daysNr - 1 && (_stepCell < _oneDay || d.lastOfMonth) ? ' mbsc-timeline-day-border' : '')
                    "
                  >
                    <div *ngIf="!_hasResY" [class]="'mbsc-timeline-header-date' + _theme + _rtl + _hb">
                      <ng-template [ngTemplateOutlet]="tplDay" [ngTemplateOutletContext]="{ day: d }"></ng-template>
                      <div *ngIf="d.label" class="mbsc-hidden-content">{{ d.label }}</div>
                    </div>
                    <div *ngIf="_hasSlots" [class]="'mbsc-flex mbsc-timeline-slots' + _theme">
                      <div
                        *ngFor="let slot of _slots; trackBy: _getId"
                        [class]="'mbsc-timeline-slot mbsc-timeline-slot-header mbsc-flex-1-1' + _colWidthClass + _rtl + _theme"
                      >
                        <div class="mbsc-timeline-slot-title">
                          <ng-template #defaultSlot>
                            {{ slot.name }}
                          </ng-template>
                          <ng-template
                            [ngTemplateOutlet]="slotTemplate || defaultSlot"
                            [ngTemplateOutletContext]="{ $implicit: { slot: slot, date: d.date } }"
                          >
                          </ng-template>
                        </div>
                      </div>
                    </div>
                    <div aria-hidden="true" class="mbsc-flex">
                      <div *ngIf="d.phStart !== 0" [style.width.px]="d.phStart" class="mbsc-flex-none"></div>
                      <div
                        *ngFor="let v of d.times; trackBy: _getTimeKey"
                        [ngStyle]="v.first && !v.last ? _startCellStyle! : v.last && !v.first ? _endCellStyle! : {}"
                        [class]="
                          'mbsc-flex mbsc-flex-1-1 mbsc-timeline-header-column' +
                          _colWidthClass +
                          _theme +
                          _rtl +
                          _hb +
                          (v.hidden ? ' mbsc-timeline-hidden' : '') +
                          (!_displayTime || _hasSlots ? ' mbsc-timeline-no-height' : '') +
                          (_stepLabel > _stepCell && _times[v.i + 1] % _stepLabel ? ' mbsc-timeline-no-border' : '') +
                          ((v.first && !v.last && _startCellStyle) || (v.last && !v.first && _endCellStyle) ? ' mbsc-flex-none' : '')
                        "
                      >
                        <ng-template
                          *ngIf="_displayTime"
                          [ngTemplateOutlet]="tplHour"
                          [ngTemplateOutletContext]="{ hour: d, timestamp: v.t }"
                        ></ng-template>
                        <ng-container *ngFor="let tb of _timesBetween; let j = index; trackBy: _getKey">
                          <ng-template
                            *ngIf="v.t + (j + 1) * _stepLabel > _startTime && v.t + (j + 1) * _stepLabel < _endTime"
                            [ngTemplateOutlet]="tplHour"
                            [ngTemplateOutletContext]="{ hour: d, timestamp: v.t + (j + 1) * _stepLabel }"
                          ></ng-template>
                        </ng-container>
                      </div>
                      <div *ngIf="d.phEnd !== 0" [style.width.px]="d.phEnd" class="mbsc-flex-none"></div>
                    </div>
                  </div>
                </ng-container>
              </div>
            </ng-container>
            <div *ngIf="!_isDailyResolution" class="mbsc-flex">
              <ng-container *ngFor="let d of _virtualDays; trackBy: _getDayKey">
                <div *ngIf="d.dateKey !== _dragCol" [class]="'mbsc-timeline-day mbsc-flex-1-0-0' + _colWidthClass + _theme + _rtl + _hb">
                  <div [class]="'mbsc-timeline-header-week mbsc-timeline-header-week-last' + _theme + _rtl + _hb">
                    <div
                      [class]="
                        'mbsc-timeline-header-week-text mbsc-timeline-header-week-text-last' +
                        (d.isActive && !(weekTemplate || dayTemplate || monthTemplate || quarterTemplate || yearTemplate)
                          ? ' mbsc-timeline-header-active'
                          : '') +
                        _theme
                      "
                    >
                      <ng-container
                        *ngIf="weekTemplate || monthTemplate || quarterTemplate || yearTemplate; else defaultTitle"
                        [ngSwitch]="resolution"
                      >
                        <div [class]="'mbsc-timeline-header-' + resolution + '-cont'">
                          <ng-template
                            *ngSwitchCase="'week'"
                            [ngTemplateOutlet]="tplWeek"
                            [ngTemplateOutletContext]="{ week: d }"
                          ></ng-template>
                          <ng-template
                            *ngSwitchCase="'month'"
                            [ngTemplateOutlet]="tplMonth"
                            [ngTemplateOutletContext]="{ month: d }"
                          ></ng-template>
                          <ng-template
                            *ngSwitchCase="'quarter'"
                            [ngTemplateOutlet]="tplQuarter"
                            [ngTemplateOutletContext]="{ quarter: d }"
                          ></ng-template>
                          <ng-template
                            *ngSwitchCase="'year'"
                            [ngTemplateOutlet]="tplYear"
                            [ngTemplateOutletContext]="{ year: d }"
                          ></ng-template>
                        </div>
                      </ng-container>
                      <ng-template #defaultTitle>{{ d.columnTitle }}</ng-template>
                    </div>
                  </div>
                </div>
              </ng-container>
            </div>
          </div>
          <div [style.width.px]="_phXEnd" class="mbsc-flex-none"></div>
        </div>
        <div
          *ngIf="_hasRows && !!sidebarTemplate"
          [class]="'mbsc-timeline-sidebar-header-cont mbsc-timeline-sidebar-col' + _theme + _rtl + _hb"
        ></div>
      </div>

      <div class="mbsc-flex mbsc-flex-1-1">
        <!-- The extra flex div is needed for the div height to expand correctly -->
        <div class="mbsc-flex mbsc-flex-1-1">
          <div
            *ngIf="_hasRows"
            #resCont
            [class]="'mbsc-timeline-resources mbsc-flex-col ' + _colClass + _theme + _rtl"
            [style.width.px]="_hasResources ? _resourceWidth : undefined"
          >
            <div [class]="'mbsc-flex-none'" [style.height.px]="_hasSideSticky ? undefined : state.headerHeight"></div>
            <div [class]="'mbsc-timeline-resource-bg mbsc-flex-1-1' + (_hasHierarchy || state.hasScrollY ? '' : ' mbsc-flex-col') + _theme">
              <div [style.height.px]="_phY" class="mbsc-flex-none"></div>
              <ng-container *ngFor="let rowGroup of _virtualRows; trackBy: _getRowKey">
                <ng-container *ngIf="!rowGroup.day && !rowGroup.hidden">
                  <ng-template
                    *ngFor="let r of rowGroup.rows; trackBy: _getId"
                    [ngTemplateOutlet]="tplResource"
                    [ngTemplateOutletContext]="{ res: r, key: r.id }"
                  >
                  </ng-template>
                </ng-container>
                <ng-container *ngIf="rowGroup.day && !rowGroup.hidden">
                  <div *ngIf="_hasResources" [class]="'mbsc-timeline-row-group mbsc-flex mbsc-flex-1-0' + _theme + _hb">
                    <div [class]="'mbsc-timeline-row-date mbsc-timeline-row-date-col mbsc-flex-none' + _rtl + _theme + _hb">
                      <ng-template [ngTemplateOutlet]="tplDay" [ngTemplateOutletContext]="{ day: rowGroup.day }"> </ng-template>
                    </div>
                    <div class="mbsc-timeline-row-resource-col mbsc-flex-1-1 mbsc-flex-col">
                      <ng-template
                        *ngFor="let r of rowGroup.rows; trackBy: _getId"
                        [ngTemplateOutlet]="tplResource"
                        [ngTemplateOutletContext]="{ res: r, key: rowGroup.day.dateKey + '-' + r.id, day: rowGroup.day.date }"
                      >
                      </ng-template>
                    </div>
                  </div>
                  <div
                    *ngIf="!_hasResources"
                    [class]="'mbsc-timeline-row-date mbsc-flex-1-0' + _rtl + _theme + _hb"
                    [style.minHeight]="_rowHeights[rowGroup.day.dateKey + '-' + _defId]"
                  >
                    <ng-template [ngTemplateOutlet]="tplDay" [ngTemplateOutletContext]="{ day: rowGroup.day }"> </ng-template>
                  </div>
                </ng-container>
              </ng-container>
            </div>
            <div
              *ngIf="_hasFooter"
              class="mbsc-flex-none mbsc-timeline-footer-ph"
              [style.height.px]="_hasSideSticky ? undefined : state.footerHeight"
            ></div>
          </div>
          <div
            *ngIf="_hasRows"
            [class]="_hasSideSticky ? '' : _colClass"
            [style.width.px]="_hasSideSticky || !_hasResources ? undefined : _resourceWidth"
          ></div>
          <div class="mbsc-timeline-hidden">
            <div
              [class]="'mbsc-timeline-day mbsc-timeline-empty-day' + (_isDailyResolution ? '' : _colWidthClass) + _dayClass + _theme"
            ></div>
            <div
              [class]="
                'mbsc-timeline-column mbsc-timeline-empty-column' + (_hasSlots ? ' mbsc-timeline-slot' : '') + _colWidthClass + _theme
              "
            ></div>
            <div [class]="'mbsc-timeline-row mbsc-timeline-empty-row' + _theme"></div>
            <div [class]="'mbsc-timeline-row mbsc-timeline-parent mbsc-timeline-empty-parent' + _theme"></div>
            <div [class]="'mbsc-timeline-row-gutter' + _theme"></div>
            <div [class]="'mbsc-timeline-empty-resource ' + _colClass + _theme"></div>
            <div [class]="'mbsc-timeline-resource-depth-step' + _theme"></div>
          </div>
          <div
            #gridCont
            [class]="'mbsc-timeline-grid mbsc-flex-1-0' + (_hasHierarchy || state.hasScrollY ? '' : ' mbsc-flex-col')"
            [style.width.px]="state.hasScrollX ? _gridWidth : undefined"
            [style.height.px]="state.hasScrollY ? _gridHeight : undefined"
            (mouseleave)="_onMouseLeave($event)"
            (mousemove)="_onMouseMove($event)"
          >
            <ng-container *ngIf="state.dragData && state.dragData.draggedResourceVisible">
              <div
                #draggedResourceLineEl
                [class]="
                  'mbsc-timeline-resource-drop' +
                  (state.dragData && state.dragData.draggedResourceInvalid ? ' mbsc-timeline-resource-drop-invalid ' : ' ') +
                  _theme
                "
              ></div>
            </ng-container>
            <div [style.height.px]="_phY" class="mbsc-flex-none"></div>
            <ng-container *ngFor="let rowGroup of _virtualRows; trackBy: _getRowKey">
              <ng-container *ngIf="!rowGroup.day || !_hasResources">
                <ng-template
                  *ngFor="let r of rowGroup.rows; trackBy: _getId"
                  [ngTemplateOutlet]="tplRow"
                  [ngTemplateOutletContext]="{ res: r, dateKey: rowGroup.day ? rowGroup.day.dateKey : '', day: rowGroup.day }"
                >
                </ng-template>
              </ng-container>
              <ng-container *ngIf="rowGroup.day && _hasResources">
                <div [class]="'mbsc-timeline-row-group mbsc-flex-col mbsc-flex-1-0' + _theme + _hb">
                  <ng-template
                    *ngFor="let r of rowGroup.rows; trackBy: _getId"
                    [ngTemplateOutlet]="tplRow"
                    [ngTemplateOutletContext]="{ res: r, dateKey: rowGroup.day.dateKey, day: rowGroup.day }"
                  >
                  </ng-template>
                </div>
              </ng-container>
            </ng-container>
            <svg *ngIf="_connections" [attr.class]="'mbsc-connections' + _theme" viewBox="0 0 100 100" preserveAspectRatio="none">
              <ng-container *ngFor="let c of _connections; trackBy: _getId">
                <path
                  *ngIf="_virtualStart <= c.endDate && _virtualEnd > c.startDate"
                  [attr.d]="c.pathD"
                  [attr.class]="'mbsc-connection ' + c.cssClass + _theme"
                  [style.stroke]="c.color"
                  [style.fill]="c.fill"
                  vector-effect="non-scaling-stroke"
                ></path>
              </ng-container>
            </svg>
          </div>

          <div
            *ngIf="_hasRows && !!sidebarTemplate"
            #sidebarCont
            [class]="'mbsc-timeline-sidebar mbsc-timeline-sidebar-col mbsc-flex-col' + _theme + _rtl"
          >
            <div [class]="'mbsc-flex-none'" [style.height.px]="_hasSideSticky ? undefined : state.headerHeight"></div>
            <div [class]="'mbsc-timeline-resource-bg mbsc-flex-1-1' + (_hasHierarchy || state.hasScrollY ? '' : ' mbsc-flex-col') + _theme">
              <div [style.height.px]="_phY" class="mbsc-flex-none"></div>
              <ng-container *ngFor="let rowGroup of _virtualRows; trackBy: _getRowKey">
                <ng-container *ngIf="!rowGroup.day && !rowGroup.hidden">
                  <ng-template
                    *ngFor="let r of rowGroup.rows; trackBy: _getId"
                    [ngTemplateOutlet]="tplSidebar"
                    [ngTemplateOutletContext]="{ res: r, key: r.id }"
                  >
                  </ng-template>
                </ng-container>
                <ng-container *ngIf="rowGroup.day && !rowGroup.hidden">
                  <div [class]="'mbsc-timeline-row-group mbsc-flex-col mbsc-flex-1-0' + _theme + _hb">
                    <ng-template
                      *ngFor="let r of rowGroup.rows; trackBy: _getId"
                      [ngTemplateOutlet]="tplSidebar"
                      [ngTemplateOutletContext]="{ res: r, key: rowGroup.day.dateKey + '-' + r.id }"
                    >
                    </ng-template>
                  </div>
                </ng-container>
              </ng-container>
            </div>
            <div
              *ngIf="_hasFooter"
              class="mbsc-flex-none mbsc-timeline-footer-ph"
              [style.height.px]="_hasSideSticky ? undefined : state.footerHeight"
            ></div>
          </div>
          <div *ngIf="_hasRows && !!sidebarTemplate" [class]="_hasSideSticky ? '' : 'mbsc-timeline-sidebar-col'"></div>
        </div>
      </div>

      <ng-container *ngIf="_hasFooter">
        <div [class]="'mbsc-flex-none'" [style.height.px]="_hasSticky ? undefined : state.footerHeight"></div>
        <div #footerCont [class]="'mbsc-timeline-footer mbsc-flex' + _theme + _rtl + _hb">
          <div
            *ngIf="_hasRows"
            [class]="'mbsc-timeline-resource-footer-cont ' + _colClass + _theme + _rtl + _hb"
            [style.width.px]="_hasResources ? _resourceWidth : undefined"
          ></div>
          <div
            [class]="'mbsc-timeline-footer-bg mbsc-flex-1-0 mbsc-flex' + _theme"
            [style.width.px]="state.hasScrollX ? this._gridWidth : undefined"
          >
            <div [style.width.px]="_phXStart" class="mbsc-flex-none"></div>
            <div class="mbsc-flex-1-1 mbsc-overflow-hidden">
              <div *ngIf="_isDailyResolution" class="mbsc-flex">
                <ng-container *ngFor="let d of _virtualDays; trackBy: _getDayKey">
                  <div
                    *ngIf="d.dateKey !== _dragCol"
                    [class]="
                      'mbsc-timeline-day mbsc-flex-1-0-0' +
                      _dayClass +
                      _theme +
                      _rtl +
                      _hb +
                      (d.dateIndex < _daysNr - 1 && (_stepCell < _oneDay || d.lastOfMonth) ? ' mbsc-timeline-day-border' : '')
                    "
                  >
                    <div class="mbsc-flex">
                      <div *ngIf="d.phStart !== 0" [style.width.px]="d.phStart" class="mbsc-flex-none"></div>
                      <div
                        *ngFor="let v of d.times; trackBy: _getTimeKey"
                        [ngStyle]="v.first && !v.last ? _startCellStyle! : v.last && !v.first ? _endCellStyle! : {}"
                        [class]="
                          'mbsc-flex mbsc-flex-1-1 mbsc-timeline-column mbsc-timeline-footer-column' +
                          _colWidthClass +
                          _theme +
                          _rtl +
                          _hb +
                          (v.hidden ? ' mbsc-timeline-hidden' : '') +
                          (!_displayTime || _hasSlots ? ' mbsc-timeline-no-height' : '') +
                          (_stepLabel > _stepCell && _times[v.i + 1] % _stepLabel ? ' mbsc-timeline-no-border' : '') +
                          ((v.first && !v.last && _startCellStyle) || (v.last && !v.first && _endCellStyle) ? ' mbsc-flex-none' : '')
                        "
                      >
                        <ng-template
                          *ngIf="_displayTime"
                          [ngTemplateOutlet]="tplHourFooter"
                          [ngTemplateOutletContext]="{ hour: d, timestamp: v.t }"
                        ></ng-template>
                        <ng-container *ngFor="let tb of _timesBetween; let j = index; trackBy: _getKey">
                          <ng-template
                            *ngIf="v.t + (j + 1) * _stepLabel > _startTime && v.t + (j + 1) * _stepLabel < _endTime"
                            [ngTemplateOutlet]="tplHourFooter"
                            [ngTemplateOutletContext]="{ hour: d, timestamp: v.t + (j + 1) * _stepLabel }"
                          ></ng-template>
                        </ng-container>
                      </div>
                      <div *ngIf="d.phEnd !== 0" [style.width.px]="d.phEnd" class="mbsc-flex-none"></div>
                    </div>
                    <div *ngIf="dayFooterTemplate" [class]="'mbsc-timeline-footer-date' + _theme + _rtl + _hb">
                      <ng-template [ngTemplateOutlet]="tplDayFooter" [ngTemplateOutletContext]="{ day: d }"></ng-template>
                    </div>
                    <div *ngIf="_hasSlots" class="mbsc-flex">
                      <div *ngFor="let slot of _slots; trackBy: _getId" [class]="'mbsc-timeline-slot mbsc-flex-1-1' + _rtl + _theme"></div>
                    </div>
                  </div>
                </ng-container>
              </div>
              <div *ngIf="!_isDailyResolution" class="mbsc-flex">
                <ng-container *ngFor="let d of _virtualDays; trackBy: _getDayKey">
                  <div *ngIf="d.dateKey !== _dragCol" [class]="'mbsc-timeline-day mbsc-flex-1-0-0' + _colWidthClass + _theme + _rtl + _hb">
                    <div [class]="'mbsc-timeline-footer-week mbsc-timeline-footer-week-last' + _theme + _rtl + _hb">
                      <div [class]="'mbsc-timeline-footer-week-text' + _theme">
                        <ng-container
                          *ngIf="weekFooterTemplate || monthFooterTemplate || quarterFooterTemplate || yearFooterTemplate"
                          [ngSwitch]="s.resolution"
                        >
                          <ng-template
                            *ngSwitchCase="'week'"
                            [ngTemplateOutlet]="tplWeekFooter"
                            [ngTemplateOutletContext]="{ week: d }"
                          ></ng-template>
                          <ng-template
                            *ngSwitchCase="'month'"
                            [ngTemplateOutlet]="tplMonthFooter"
                            [ngTemplateOutletContext]="{ month: d }"
                          ></ng-template>
                          <ng-template
                            *ngSwitchCase="'quarter'"
                            [ngTemplateOutlet]="tplQuarterFooter"
                            [ngTemplateOutletContext]="{ quarter: d }"
                          ></ng-template>
                          <ng-template
                            *ngSwitchCase="'year'"
                            [ngTemplateOutlet]="tplYearFooter"
                            [ngTemplateOutletContext]="{ year: d }"
                          ></ng-template>
                        </ng-container>
                      </div>
                    </div>
                  </div>
                </ng-container>
              </div>
            </div>
            <div [style.width.px]="_phXEnd" class="mbsc-flex-none"></div>
          </div>
          <div
            *ngIf="_hasRows && !!sidebarTemplate"
            [class]="'mbsc-timeline-sidebar-footer-cont mbsc-timeline-sidebar-col' + _theme + _rtl + _hb"
          ></div>
        </div>
      </ng-container>
    </div>
    <div
      *ngIf="state.dragData && state.dragData.draggedResourceVisible && state.dragData.draggedResource"
      #draggedResourceEl
      [class]="'mbsc-timeline-resource-dragged mbsc-flex mbsc-flex-1-1' + _theme"
    >
      <ng-template
        [ngTemplateOutlet]="tplResource"
        [ngTemplateOutletContext]="{
          res: state.dragData.draggedResource,
          key: state.dragData.draggedResource.id,
          day: _getOriginDate(state.dragData),
          isDrag: true
        }"
      >
      </ng-template>
    </div>
    <div *ngIf="state.dragData && !state.isTouchDrag" class="mbsc-calendar-dragging"></div>
  `
    }]
  }], null, {
    vScrollCont: [{
      type: ViewChild,
      args: ["scrollCont", {
        static: true,
        read: ElementRef
      }]
    }],
    vGridCont: [{
      type: ViewChild,
      args: ["gridCont", {
        static: true,
        read: ElementRef
      }]
    }],
    vFooterCont: [{
      type: ViewChild,
      args: ["footerCont", {
        static: false,
        read: ElementRef
      }]
    }],
    vHeaderCont: [{
      type: ViewChild,
      args: ["headerCont", {
        static: true,
        read: ElementRef
      }]
    }],
    vResCont: [{
      type: ViewChild,
      args: ["resCont", {
        static: false,
        read: ElementRef
      }]
    }],
    vSidebarCont: [{
      type: ViewChild,
      args: ["sidebarCont", {
        static: false,
        read: ElementRef
      }]
    }],
    vStickyFooter: [{
      type: ViewChild,
      args: ["stickyFooter", {
        static: false,
        read: ElementRef
      }]
    }],
    vStickyHeader: [{
      type: ViewChild,
      args: ["stickyHeader", {
        static: false,
        read: ElementRef
      }]
    }],
    vStickyDate: [{
      type: ViewChild,
      args: ["stickyDate", {
        static: false,
        read: ElementRef
      }]
    }],
    vStickyMonth: [{
      type: ViewChild,
      args: ["stickyMonth", {
        static: false,
        read: ElementRef
      }]
    }],
    vStickyWeek: [{
      type: ViewChild,
      args: ["stickyWeek", {
        static: false,
        read: ElementRef
      }]
    }],
    allDayText: [{
      type: Input
    }],
    amText: [{
      type: Input
    }],
    bufferAfterTemplate: [{
      type: Input
    }],
    bufferBeforeTemplate: [{
      type: Input
    }],
    checkSize: [{
      type: Input
    }],
    clickToCreate: [{
      type: Input
    }],
    colorsMap: [{
      type: Input
    }],
    connections: [{
      type: Input
    }],
    currentTimeIndicator: [{
      type: Input
    }],
    columnWidth: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    dateFormatFull: [{
      type: Input
    }],
    dateFormatLong: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    dayNames: [{
      type: Input
    }],
    dayNamesMin: [{
      type: Input
    }],
    dayNamesShort: [{
      type: Input
    }],
    dayFooterTemplate: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dragIcon: [{
      type: Input
    }],
    monthTemplate: [{
      type: Input
    }],
    monthFooterTemplate: [{
      type: Input
    }],
    weekTemplate: [{
      type: Input
    }],
    weekFooterTemplate: [{
      type: Input
    }],
    yearTemplate: [{
      type: Input
    }],
    yearFooterTemplate: [{
      type: Input
    }],
    hourTemplate: [{
      type: Input
    }],
    hourFooterTemplate: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    dragBetweenResources: [{
      type: Input
    }],
    dragBetweenSlots: [{
      type: Input
    }],
    dragInTime: [{
      type: Input
    }],
    dragTimeStep: [{
      type: Input
    }],
    dragToCreate: [{
      type: Input
    }],
    dragToMove: [{
      type: Input
    }],
    dragToResize: [{
      type: Input
    }],
    endDay: [{
      type: Input
    }],
    endTime: [{
      type: Input
    }],
    eventDragEnd: [{
      type: Input
    }],
    eventMap: [{
      type: Input
    }],
    eventContentTemplate: [{
      type: Input
    }],
    eventOrder: [{
      type: Input
    }],
    eventOverlap: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    extendDefaultEvent: [{
      type: Input
    }],
    externalDrag: [{
      type: Input
    }],
    externalDrop: [{
      type: Input
    }],
    externalResourceDrag: [{
      type: Input
    }],
    externalResourceDrop: [{
      type: Input
    }],
    eventHeight: [{
      type: Input
    }],
    eventList: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    fromText: [{
      type: Input
    }],
    getDay: [{
      type: Input
    }],
    getDate: [{
      type: Input
    }],
    getMaxDayOfMonth: [{
      type: Input
    }],
    getMonth: [{
      type: Input
    }],
    getWeekNumber: [{
      type: Input
    }],
    getYear: [{
      type: Input
    }],
    groupBy: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    immutableData: [{
      type: Input
    }],
    invalidateEvent: [{
      type: Input
    }],
    invalidsMap: [{
      type: Input
    }],
    maxDate: [{
      type: Input
    }],
    maxEventStack: [{
      type: Input
    }],
    minDate: [{
      type: Input
    }],
    moreEventsPluralText: [{
      type: Input
    }],
    moreEventsText: [{
      type: Input
    }],
    navigateToEvent: [{
      type: Input
    }],
    monthNames: [{
      type: Input
    }],
    monthNamesShort: [{
      type: Input
    }],
    navService: [{
      type: Input
    }],
    newEventText: [{
      type: Input
    }],
    nextIcon: [{
      type: Input
    }],
    nextIconRtl: [{
      type: Input
    }],
    downIcon: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    refDate: [{
      type: Input
    }],
    resolution: [{
      type: Input
    }],
    resolutionVertical: [{
      type: Input
    }],
    resources: [{
      type: Input
    }],
    resourceFooterTemplate: [{
      type: Input
    }],
    resourceHeaderTemplate: [{
      type: Input
    }],
    resourceReorder: [{
      type: Input
    }],
    resourceTemplate: [{
      type: Input
    }],
    resourceEmptyTemplate: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }],
    scroll: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    selectedEventsMap: [{
      type: Input
    }],
    showAllDay: [{
      type: Input
    }],
    showDays: [{
      type: Input
    }],
    showEventBuffer: [{
      type: Input
    }],
    showEventTooltip: [{
      type: Input
    }],
    sidebarFooterTemplate: [{
      type: Input
    }],
    sidebarHeaderTemplate: [{
      type: Input
    }],
    sidebarTemplate: [{
      type: Input
    }],
    size: [{
      type: Input
    }],
    slots: [{
      type: Input
    }],
    slotTemplate: [{
      type: Input
    }],
    startDay: [{
      type: Input
    }],
    startTime: [{
      type: Input
    }],
    quarterTemplate: [{
      type: Input
    }],
    quarterFooterTemplate: [{
      type: Input
    }],
    quarterText: [{
      type: Input
    }],
    timeCellStep: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timeLabelStep: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    toText: [{
      type: Input
    }],
    type: [{
      type: Input
    }],
    virtualScroll: [{
      type: Input
    }],
    weekNumbers: [{
      type: Input
    }],
    weekText: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    zoomLevel: [{
      type: Input
    }],
    onActiveChange: [{
      type: Input
    }],
    onCellClick: [{
      type: Input
    }],
    onCellDoubleClick: [{
      type: Input
    }],
    onCellRightClick: [{
      type: Input
    }],
    onEventClick: [{
      type: Input
    }],
    onEventDoubleClick: [{
      type: Input
    }],
    onEventDragEnter: [{
      type: Input
    }],
    onEventDragLeave: [{
      type: Input
    }],
    onEventRightClick: [{
      type: Input
    }],
    onEventHoverIn: [{
      type: Input
    }],
    onEventHoverOut: [{
      type: Input
    }],
    onEventDelete: [{
      type: Input
    }],
    onEventDragEnd: [{
      type: Input
    }],
    onEventDragStart: [{
      type: Input
    }],
    onMoreClick: [{
      type: Input
    }],
    onPopoverClose: [{
      type: Input
    }],
    onResourceClick: [{
      type: Input
    }],
    onResourceDoubleClick: [{
      type: Input
    }],
    onResourceCollapse: [{
      type: Input
    }],
    onResourceCreate: [{
      type: Input
    }],
    onResourceCreated: [{
      type: Input
    }],
    onResourceDelete: [{
      type: Input
    }],
    onResourceDeleted: [{
      type: Input
    }],
    onResourceDragEnd: [{
      type: Input
    }],
    onResourceDragEnter: [{
      type: Input
    }],
    onResourceDragLeave: [{
      type: Input
    }],
    onResourceDragStart: [{
      type: Input
    }],
    onResourceExpand: [{
      type: Input
    }],
    onResourceOrderUpdate: [{
      type: Input
    }],
    onResourceRightClick: [{
      type: Input
    }],
    onWeekDayClick: [{
      type: Input
    }],
    onVirtualLoading: [{
      type: Input
    }],
    vDraggedResourceEl: [{
      type: ViewChild,
      args: ["draggedResourceEl", {
        static: false,
        read: ElementRef
      }]
    }],
    vDraggedResvDraggedResourceLineElourceEl: [{
      type: ViewChild,
      args: ["draggedResourceLineEl", {
        static: false,
        read: ElementRef
      }]
    }],
    vCursorTimeCont: [{
      type: ViewChild,
      args: ["cursorTimeCont", {
        static: false,
        read: ElementRef
      }]
    }]
  });
})();
var MbscEventListService = function() {
  function MbscEventListService2() {
  }
  MbscEventListService2.ɵfac = function MbscEventListService_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscEventListService2)();
  };
  MbscEventListService2.ɵprov = ɵɵdefineInjectable({
    token: MbscEventListService2,
    factory: MbscEventListService2.ɵfac
  });
  return MbscEventListService2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscEventListService, [{
    type: Injectable
  }], null, null);
})();
var MbscEventListDayDirective = function() {
  function MbscEventListDayDirective2(_el, _els) {
    this._el = _el;
    this._els = _els;
  }
  MbscEventListDayDirective2.prototype.ngAfterViewChecked = function() {
    if (this._els && this._els.days && !this._els.days[this.timestamp]) {
      this._els.days[this.timestamp] = this._el.nativeElement;
    }
  };
  MbscEventListDayDirective2.ɵfac = function MbscEventListDayDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscEventListDayDirective2)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MbscEventListService, 8));
  };
  MbscEventListDayDirective2.ɵdir = ɵɵdefineDirective({
    type: MbscEventListDayDirective2,
    selectors: [["", "mbsc-event-list-day", ""]],
    inputs: {
      timestamp: "timestamp"
    },
    standalone: false
  });
  return MbscEventListDayDirective2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscEventListDayDirective, [{
    type: Directive,
    args: [{
      selector: "[mbsc-event-list-day]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: MbscEventListService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    timestamp: [{
      type: Input
    }]
  });
})();
var MbscEventListItem = function(_super) {
  __extends(MbscEventListItem2, _super);
  function MbscEventListItem2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscEventListItem2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscEventListItem_BaseFactory;
    return function MbscEventListItem_Factory(__ngFactoryType__) {
      return (ɵMbscEventListItem_BaseFactory || (ɵMbscEventListItem_BaseFactory = ɵɵgetInheritedFactory(MbscEventListItem2)))(__ngFactoryType__ || MbscEventListItem2);
    };
  })();
  MbscEventListItem2.ɵcmp = ɵɵdefineComponent({
    type: MbscEventListItem2,
    selectors: [["mbsc-event-list-item"]],
    hostAttrs: ["tabindex", "0"],
    hostVars: 7,
    hostBindings: function MbscEventListItem_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵattribute("data-id", ctx2.eventData.original.id);
        ɵɵclassMap((ctx2.showColor ? "" : "mbsc-colored-event ") + ctx2._cssClass);
        ɵɵstyleProp("background", ctx2.showColor ? "" : ctx2.eventData.style.background)("color", ctx2.showColor ? "" : ctx2.eventData.style.color);
      }
    },
    inputs: {
      date: "date",
      eventData: "eventData",
      hasDate: "hasDate",
      selected: "selected",
      showColor: "showColor",
      source: "source",
      template: "template",
      eventContentTemplate: "eventContentTemplate"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 6,
    vars: 6,
    consts: [["def", ""], ["defaultEventContent", ""], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "class", "ngStyle", 4, "ngIf"], [3, "class", 4, "ngIf"], [3, "ngStyle"], [3, "innerHTML"]],
    template: function MbscEventListItem_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵtemplate(0, MbscEventListItem_ng_template_0_Template, 9, 14, "ng-template", null, 0, ɵɵtemplateRefExtractor)(2, MbscEventListItem_ng_template_2_Template, 1, 4, "ng-template", null, 1, ɵɵtemplateRefExtractor)(4, MbscEventListItem_ng_template_4_Template, 0, 0, "ng-template", 2);
        ɵɵelement(5, "div");
      }
      if (rf & 2) {
        const def_r3 = ɵɵreference(1);
        ɵɵadvance(4);
        ɵɵproperty("ngTemplateOutlet", ctx2.template || def_r3)("ngTemplateOutletContext", ɵɵpureFunction1(4, _c14, ctx2.eventData));
        ɵɵadvance();
        ɵɵclassMap("mbsc-list-item-background" + ctx2._theme);
      }
    },
    dependencies: [NgIf, NgStyle, NgTemplateOutlet],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscEventListItem2;
}(MbscListItem);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscEventListItem, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "[attr.data-id]": "eventData.original.id",
        "[class]": '(showColor ? "" : "mbsc-colored-event ") + _cssClass',
        "[style.background]": 'showColor ? "" : eventData.style.background',
        "[style.color]": 'showColor ? "" : eventData.style.color',
        tabindex: "0"
      },
      selector: "mbsc-event-list-item",
      template: `
    <ng-template #def>
      <div *ngIf="showColor" [class]="'mbsc-event-color' + _theme + _rtl" [ngStyle]="eventData.style"></div>
      <div [class]="'mbsc-event-content mbsc-flex-1-1 ' + _theme">
        <ng-template
          [ngTemplateOutlet]="eventContentTemplate || defaultEventContent"
          [ngTemplateOutletContext]="{ $implicit: eventData }"
        ></ng-template>
      </div>
      <div [class]="'mbsc-event-time' + (hasDate ? ' mbsc-event-date' : '') + _theme + _rtl">
        <div *ngIf="eventData.allDayText" [class]="'mbsc-event-all-day' + _theme">{{ eventData.allDayText }}</div>
        <div *ngIf="eventData.lastDay" [class]="'mbsc-event-until' + _theme">{{ eventData.lastDay }}</div>
        <div *ngIf="eventData.start" [class]="'mbsc-event-start' + _theme">{{ eventData.start }}</div>
        <div *ngIf="eventData.start && eventData.end" [class]="'mbsc-event-sep' + _theme">-</div>
        <div *ngIf="eventData.end" [class]="'mbsc-event-end' + _theme">{{ eventData.end }}</div>
      </div>
    </ng-template>
    <ng-template #defaultEventContent>
      <div [class]="'mbsc-event-text' + _theme" [attr.title]="eventData.tooltip" [innerHTML]="eventData.html"></div>
    </ng-template>
    <ng-template [ngTemplateOutlet]="template || def" [ngTemplateOutletContext]="{ $implicit: eventData }"></ng-template>
    <div [class]="'mbsc-list-item-background' + _theme"></div>
  `
    }]
  }], null, {
    date: [{
      type: Input
    }],
    eventData: [{
      type: Input
    }],
    hasDate: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    showColor: [{
      type: Input
    }],
    source: [{
      type: Input
    }],
    template: [{
      type: Input
    }],
    eventContentTemplate: [{
      type: Input
    }]
  });
})();
var MbscEventcalendar = function(_super) {
  __extends(MbscEventcalendar2, _super);
  function MbscEventcalendar2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.selectedDateChange = new EventEmitter();
    _this.selectedEventsChange = new EventEmitter();
    _this.onCellClick = new EventEmitter();
    _this.onCellDoubleClick = new EventEmitter();
    _this.onCellRightClick = new EventEmitter();
    _this.onCellHoverIn = new EventEmitter();
    _this.onCellHoverOut = new EventEmitter();
    _this.onEventClick = new EventEmitter();
    _this.onEventDoubleClick = new EventEmitter();
    _this.onEventRightClick = new EventEmitter();
    _this.onEventHoverIn = new EventEmitter();
    _this.onEventHoverOut = new EventEmitter();
    _this.onEventCreate = new EventEmitter();
    _this.onEventCreated = new EventEmitter();
    _this.onEventDelete = new EventEmitter();
    _this.onEventDeleted = new EventEmitter();
    _this.onEventDragEnd = new EventEmitter();
    _this.onEventDragStart = new EventEmitter();
    _this.onEventUpdate = new EventEmitter();
    _this.onEventUpdated = new EventEmitter();
    _this.onEventCreateFailed = new EventEmitter();
    _this.onEventUpdateFailed = new EventEmitter();
    _this.onEventDragEnter = new EventEmitter();
    _this.onEventDragLeave = new EventEmitter();
    _this.onLabelClick = new EventEmitter();
    _this.onSelectedEventsChange = new EventEmitter();
    _this.onPageChange = new EventEmitter();
    _this.onPageLoaded = new EventEmitter();
    _this.onPageLoading = new EventEmitter();
    _this.onResourceClick = new EventEmitter();
    _this.onResourceCollapse = new EventEmitter();
    _this.onResourceDoubleClick = new EventEmitter();
    _this.onResourceExpand = new EventEmitter();
    _this.onResourceDragStart = new EventEmitter();
    _this.onResourceCreate = new EventEmitter();
    _this.onResourceCreated = new EventEmitter();
    _this.onResourceDelete = new EventEmitter();
    _this.onResourceDeleted = new EventEmitter();
    _this.onResourceDragEnd = new EventEmitter();
    _this.onResourceDragEnter = new EventEmitter();
    _this.onResourceDragLeave = new EventEmitter();
    _this.onResourceRightClick = new EventEmitter();
    _this.onResourceOrderUpdate = new EventEmitter();
    _this.onSelectedDateChange = new EventEmitter();
    _this.onVirtualLoading = new EventEmitter();
    _this._hours = ARRAY24;
    return _this;
  }
  MbscEventcalendar2.prototype._getDayKey = function(index, data) {
    return data.timestamp;
  };
  MbscEventcalendar2.prototype._getEventKey = function(index, data) {
    return data.uid;
  };
  MbscEventcalendar2.prototype._ctor = function() {
    this._els = this._injector.get(MbscEventListService);
    this._instanceService = this._injector.get(MbscInstanceService);
  };
  MbscEventcalendar2.prototype._mounted = function() {
    this._instanceService.instance = this;
    _super.prototype._mounted.call(this);
  };
  MbscEventcalendar2.prototype._render = function(s, state) {
    if (!this._listDays) {
      this._listDays = {};
      this._els.days = this._listDays;
    }
    _super.prototype._render.call(this, s, state);
  };
  MbscEventcalendar2.prototype._updated = function() {
    this._list = this.vList && this.vList.nativeElement;
    _super.prototype._updated.call(this);
  };
  MbscEventcalendar2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscEventcalendar_BaseFactory;
    return function MbscEventcalendar_Factory(__ngFactoryType__) {
      return (ɵMbscEventcalendar_BaseFactory || (ɵMbscEventcalendar_BaseFactory = ɵɵgetInheritedFactory(MbscEventcalendar2)))(__ngFactoryType__ || MbscEventcalendar2);
    };
  })();
  MbscEventcalendar2.ɵcmp = ɵɵdefineComponent({
    type: MbscEventcalendar2,
    selectors: [["mbsc-eventcalendar"]],
    viewQuery: function MbscEventcalendar_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c74, 5, ElementRef);
        ɵɵviewQuery(_c75, 7);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vList = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2._calendarView = _t.first);
      }
    },
    inputs: {
      actionableEvents: "actionableEvents",
      agendaEmptyTemplate: "agendaEmptyTemplate",
      agendaTemplate: "agendaTemplate",
      bufferAfterTemplate: "bufferAfterTemplate",
      bufferBeforeTemplate: "bufferBeforeTemplate",
      calendarSystem: "calendarSystem",
      clickToCreate: "clickToCreate",
      colors: "colors",
      connections: "connections",
      data: "data",
      dayTemplate: "dayTemplate",
      dayContentTemplate: "dayContentTemplate",
      dayFooterTemplate: "dayFooterTemplate",
      dataTimezone: "dataTimezone",
      displayTimezone: "displayTimezone",
      dragBetweenResources: "dragBetweenResources",
      dragBetweenSlots: "dragBetweenSlots",
      dragInTime: "dragInTime",
      dragTimeStep: "dragTimeStep",
      dragToCreate: "dragToCreate",
      dragToResize: "dragToResize",
      dragToMove: "dragToMove",
      eventContentTemplate: "eventContentTemplate",
      eventDelete: "eventDelete",
      eventOrder: "eventOrder",
      eventOverlap: "eventOverlap",
      eventTemplate: "eventTemplate",
      exclusiveEndDates: "exclusiveEndDates",
      extendDefaultEvent: "extendDefaultEvent",
      externalDrag: "externalDrag",
      externalDrop: "externalDrop",
      externalResourceDrag: "externalResourceDrag",
      externalResourceDrop: "externalResourceDrop",
      groupBy: "groupBy",
      headerTemplate: "headerTemplate",
      height: "height",
      hourTemplate: "hourTemplate",
      hourFooterTemplate: "hourFooterTemplate",
      immutableData: "immutableData",
      invalid: "invalid",
      invalidateEvent: "invalidateEvent",
      labelContentTemplate: "labelContentTemplate",
      labels: "labels",
      labelTemplate: "labelTemplate",
      marked: "marked",
      max: "max",
      min: "min",
      mousewheel: "mousewheel",
      monthTemplate: "monthTemplate",
      monthFooterTemplate: "monthFooterTemplate",
      refDate: "refDate",
      resources: "resources",
      resourceHeaderTemplate: "resourceHeaderTemplate",
      resourceFooterTemplate: "resourceFooterTemplate",
      resourceTemplate: "resourceTemplate",
      resourceEmptyTemplate: "resourceEmptyTemplate",
      slots: "slots",
      slotTemplate: "slotTemplate",
      scheduleEventContentTemplate: "scheduleEventContentTemplate",
      scheduleEventTemplate: "scheduleEventTemplate",
      selectedDate: "selectedDate",
      selectedEvents: "selectedEvents",
      selectMultipleEvents: "selectMultipleEvents",
      showControls: "showControls",
      showEventBuffer: "showEventBuffer",
      showEventTooltip: "showEventTooltip",
      sidebarFooterTemplate: "sidebarFooterTemplate",
      sidebarHeaderTemplate: "sidebarHeaderTemplate",
      sidebarTemplate: "sidebarTemplate",
      quarterTemplate: "quarterTemplate",
      quarterFooterTemplate: "quarterFooterTemplate",
      quarterText: "quarterText",
      valid: "valid",
      view: "view",
      width: "width",
      weekTemplate: "weekTemplate",
      weekFooterTemplate: "weekFooterTemplate",
      yearTemplate: "yearTemplate",
      yearFooterTemplate: "yearFooterTemplate",
      zoomLevel: "zoomLevel",
      allDayText: "allDayText",
      amText: "amText",
      dateFormat: "dateFormat",
      dateFormatFull: "dateFormatFull",
      dateFormatLong: "dateFormatLong",
      dayNames: "dayNames",
      dayNamesMin: "dayNamesMin",
      dayNamesShort: "dayNamesShort",
      eventsText: "eventsText",
      eventText: "eventText",
      firstDay: "firstDay",
      monthNames: "monthNames",
      monthNamesShort: "monthNamesShort",
      moreEventsPluralText: "moreEventsPluralText",
      moreEventsText: "moreEventsText",
      newEventText: "newEventText",
      nextPageText: "nextPageText",
      noEventsText: "noEventsText",
      pmText: "pmText",
      prevPageText: "prevPageText",
      timeFormat: "timeFormat",
      timezonePlugin: "timezonePlugin"
    },
    outputs: {
      selectedDateChange: "selectedDateChange",
      selectedEventsChange: "selectedEventsChange",
      onCellClick: "onCellClick",
      onCellDoubleClick: "onCellDoubleClick",
      onCellRightClick: "onCellRightClick",
      onCellHoverIn: "onCellHoverIn",
      onCellHoverOut: "onCellHoverOut",
      onEventClick: "onEventClick",
      onEventDoubleClick: "onEventDoubleClick",
      onEventRightClick: "onEventRightClick",
      onEventHoverIn: "onEventHoverIn",
      onEventHoverOut: "onEventHoverOut",
      onEventCreate: "onEventCreate",
      onEventCreated: "onEventCreated",
      onEventDelete: "onEventDelete",
      onEventDeleted: "onEventDeleted",
      onEventDragEnd: "onEventDragEnd",
      onEventDragStart: "onEventDragStart",
      onEventUpdate: "onEventUpdate",
      onEventUpdated: "onEventUpdated",
      onEventCreateFailed: "onEventCreateFailed",
      onEventUpdateFailed: "onEventUpdateFailed",
      onEventDragEnter: "onEventDragEnter",
      onEventDragLeave: "onEventDragLeave",
      onLabelClick: "onLabelClick",
      onSelectedEventsChange: "onSelectedEventsChange",
      onPageChange: "onPageChange",
      onPageLoaded: "onPageLoaded",
      onPageLoading: "onPageLoading",
      onResourceClick: "onResourceClick",
      onResourceCollapse: "onResourceCollapse",
      onResourceDoubleClick: "onResourceDoubleClick",
      onResourceExpand: "onResourceExpand",
      onResourceDragStart: "onResourceDragStart",
      onResourceCreate: "onResourceCreate",
      onResourceCreated: "onResourceCreated",
      onResourceDelete: "onResourceDelete",
      onResourceDeleted: "onResourceDeleted",
      onResourceDragEnd: "onResourceDragEnd",
      onResourceDragEnter: "onResourceDragEnter",
      onResourceDragLeave: "onResourceDragLeave",
      onResourceRightClick: "onResourceRightClick",
      onResourceOrderUpdate: "onResourceOrderUpdate",
      onSelectedDateChange: "onSelectedDateChange",
      onVirtualLoading: "onVirtualLoading"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MbscEventListService, MbscInstanceService]), ɵɵInheritDefinitionFeature],
    decls: 10,
    vars: 144,
    consts: [["calendar", ""], ["list", ""], ["def", ""], ["noEventsText", ""], ["default", ""], ["selectView", "page", 3, "activeDate", "amText", "calendarScroll", "calendarType", "clickToCreate", "colors", "context", "cssClass", "dataTimezone", "dayTemplate", "dayContentTemplate", "displayTimezone", "downIcon", "dragData", "dragToCreate", "dragToMove", "dragToResize", "endDay", "eventExact", "eventMap", "eventOrder", "eventRange", "eventRangeSize", "exclusiveEndDates", "hasContent", "hasPicker", "headerTemplate", "height", "invalid", "instanceService", "labels", "labelsMap", "labelList", "labelTemplate", "labelContentTemplate", "marked", "marksMap", "max", "min", "mouseSwipe", "mousewheel", "navService", "navView", "nextIconH", "nextIconV", "nextPageText", "noOuterChange", "onActiveChange", "onCellHoverIn", "onCellHoverOut", "onDayClick", "onDayDoubleClick", "onDayRightClick", "onGestureStart", "onLabelClick", "onLabelDoubleClick", "onLabelRightClick", "onLabelHoverIn", "onLabelHoverOut", "onLabelDelete", "onLabelUpdateStart", "onLabelUpdateMove", "onLabelUpdateEnd", "onLabelUpdateModeOn", "onLabelUpdateModeOff", "onPageChange", "onPageLoaded", "onPageLoading", "onResize", "pageLoad", "pmText", "prevIconH", "prevIconV", "prevPageText", "refDate", "resourcesMap", "responsiveStyle", "rtl", "selectedDates", "selectedEventsMap", "showCalendar", "showControls", "showEventTooltip", "showLabelCount", "showOuterDays", "showSchedule", "showToday", "showWeekNumbers", "size", "startDay", "swipe", "theme", "themeVariant", "timeFormat", "timezonePlugin", "update", "upIcon", "valid", "weeks", "width", "getDate", "getDay", "getMaxDayOfMonth", "getMonth", "getWeekNumber", "getYear", "dateFormat", "dayNames", "dayNamesMin", "dayNamesShort", "eventText", "eventsText", "firstDay", "fromText", "monthNames", "monthNamesShort", "moreEventsPluralText", "moreEventsText", "todayText", "toText", "weekText", "yearSuffix"], [3, "class", 4, "ngIf"], [3, "class", "scroll", 4, "ngIf"], [3, "allDayText", "amText", "bufferAfterTemplate", "bufferBeforeTemplate", "checkSize", "clickToCreate", "colorsMap", "context", "currentTimeIndicator", "dataTimezone", "dateFormat", "dateFormatFull", "dateFormatLong", "dayNames", "dayNamesMin", "dayNamesShort", "dayTemplate", "dayContentTemplate", "displayTimezone", "dragBetweenResources", "dragInTime", "dragTimeStep", "dragToCreate", "dragToMove", "dragToResize", "endDay", "endTime", "eventContentTemplate", "eventDragEnd", "eventMap", "eventOrder", "eventOverlap", "eventTemplate", "exclusiveEndDates", "extendDefaultEvent", "externalDrag", "externalDrop", "firstDay", "fromText", "getDay", "getDate", "getMaxDayOfMonth", "getMonth", "getYear", "getWeekNumber", "groupBy", "height", "immutableData", "invalidateEvent", "invalidsMap", "maxDate", "maxEventStack", "minEventWidth", "moreEventsPluralText", "moreEventsText", "navigateToEvent", "minDate", "monthNames", "monthNamesShort", "navService", "newEventText", "pmText", "refDate", "resources", "resourceTemplate", "rtl", "scroll", "selected", "selectedEventsMap", "showAllDay", "showDays", "showEventBuffer", "showEventTooltip", "size", "startDay", "startTime", "timeCellStep", "timeFormat", "timeLabelStep", "timezonePlugin", "timezones", "theme", "themeVariant", "toText", "type", "width", "onCellClick", "onCellDoubleClick", "onCellRightClick", "onEventClick", "onEventDoubleClick", "onEventRightClick", "onEventHoverIn", "onEventHoverOut", "onEventDelete", "onEventDragEnd", "onEventDragStart", "onEventDragEnter", "onEventDragLeave", "onMoreClick", "onPopoverClose", "onResourceClick", "onResourceDoubleClick", "onResourceRightClick", "onWeekDayClick", 4, "ngIf"], [3, "allDayText", "amText", "bufferAfterTemplate", "bufferBeforeTemplate", "checkSize", "clickToCreate", "colorsMap", "connections", "context", "currentTimeIndicator", "columnWidth", "dataTimezone", "dateFormat", "dateFormatFull", "dateFormatLong", "dayNames", "dayNamesMin", "dayNamesShort", "dayFooterTemplate", "dayTemplate", "weekTemplate", "weekFooterTemplate", "yearTemplate", "yearFooterTemplate", "hourTemplate", "hourFooterTemplate", "monthTemplate", "monthFooterTemplate", "displayTimezone", "dragBetweenResources", "dragBetweenSlots", "dragIcon", "dragInTime", "dragTimeStep", "dragToCreate", "dragToMove", "dragToResize", "downIcon", "endDay", "endTime", "eventHeight", "eventList", "eventDragEnd", "eventContentTemplate", "eventMap", "eventOrder", "eventOverlap", "eventTemplate", "exclusiveEndDates", "extendDefaultEvent", "externalDrag", "externalDrop", "externalResourceDrag", "externalResourceDrop", "firstDay", "fromText", "getDay", "getDate", "getMaxDayOfMonth", "getMonth", "getWeekNumber", "getYear", "groupBy", "height", "immutableData", "invalidateEvent", "invalidsMap", "maxDate", "maxEventStack", "minDate", "moreEventsPluralText", "moreEventsText", "navigateToEvent", "monthNames", "monthNamesShort", "navService", "newEventText", "nextIcon", "nextIconRtl", "pmText", "refDate", "resolution", "resolutionVertical", "resources", "resourceFooterTemplate", "resourceHeaderTemplate", "resourceReorder", "resourceTemplate", "resourceEmptyTemplate", "rtl", "rowHeight", "scroll", "showEventBuffer", "showEventTooltip", "slots", "slotTemplate", "selected", "selectedEventsMap", "sidebarFooterTemplate", "sidebarHeaderTemplate", "sidebarTemplate", "size", "startDay", "startTime", "quarterFooterTemplate", "quarterTemplate", "quarterText", "timeCellStep", "timeFormat", "timeLabelStep", "timezonePlugin", "theme", "themeVariant", "toText", "type", "virtualScroll", "weekNumbers", "weekText", "width", "onActiveChange", "onCellClick", "onCellDoubleClick", "onCellRightClick", "onEventClick", "onEventDoubleClick", "onEventRightClick", "onEventHoverIn", "onEventHoverOut", "onEventDelete", "onEventDragEnd", "onEventDragStart", "onEventDragEnter", "onEventDragLeave", "onMoreClick", "onPopoverClose", "onResourceClick", "onResourceCollapse", "onResourceCreate", "onResourceCreated", "onResourceDelete", "onResourceDeleted", "onResourceDoubleClick", "onResourceExpand", "onResourceDragEnd", "onResourceDragEnter", "onResourceDragLeave", "onResourceDragStart", "onResourceOrderUpdate", "onResourceRightClick", "onVirtualLoading", "zoomLevel", 4, "ngIf"], ["display", "anchored", "maxHeight", "24em", 3, "onClose", "anchor", "closeOnScroll", "contentPadding", "context", "cssClass", "isOpen", "locale", "rtl", "scrollLock", "showOverlay", "theme", "themeVariant"], [1, "mbsc-popover-list", 3, "rtl", "theme", "themeVariant"], ["class", "mbsc-event", "source", "popover", 3, "actionable", "cssClass", "date", "event", "eventContentTemplate", "eventData", "hasDate", "rtl", "selected", "showColor", "template", "theme", "themeVariant", "drag", "onHoverIn", "onHoverOut", "onClick", "onDoubleClick", "onRightClick", "onDragEnd", "onDragModeOff", "onDragModeOn", "onDragMove", "onDragStart", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "mbsc-calendar-dragging", 4, "ngIf"], ["class", "mbsc-schedule-time-col", 4, "ngIf"], ["class", "mbsc-schedule-fake-scroll-y", 4, "ngIf"], [1, "mbsc-schedule-time-col"], [1, "mbsc-schedule-fake-scroll-y"], [3, "scroll"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "rtl", "theme", "themeVariant"], [4, "ngIf"], [3, "ngTemplateOutlet"], ["mbsc-event-list-day", "", 3, "class", "timestamp", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["mbsc-event-list-day", "", 3, "timestamp"], ["class", "mbsc-event-day", 3, "theme", "themeVariant", 4, "ngIf"], ["class", "mbsc-event", "source", "agenda", 3, "actionable", "cssClass", "date", "event", "eventContentTemplate", "eventData", "rtl", "selected", "showColor", "template", "theme", "themeVariant", "onHoverIn", "onHoverOut", "onClick", "onDoubleClick", "onRightClick", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "mbsc-event-day", 3, "theme", "themeVariant"], ["source", "agenda", 1, "mbsc-event", 3, "onHoverIn", "onHoverOut", "onClick", "onDoubleClick", "onRightClick", "actionable", "cssClass", "date", "event", "eventContentTemplate", "eventData", "rtl", "selected", "showColor", "template", "theme", "themeVariant"], [3, "allDayText", "amText", "bufferAfterTemplate", "bufferBeforeTemplate", "checkSize", "clickToCreate", "colorsMap", "context", "currentTimeIndicator", "dataTimezone", "dateFormat", "dateFormatFull", "dateFormatLong", "dayNames", "dayNamesMin", "dayNamesShort", "dayTemplate", "dayContentTemplate", "displayTimezone", "dragBetweenResources", "dragInTime", "dragTimeStep", "dragToCreate", "dragToMove", "dragToResize", "endDay", "endTime", "eventContentTemplate", "eventDragEnd", "eventMap", "eventOrder", "eventOverlap", "eventTemplate", "exclusiveEndDates", "extendDefaultEvent", "externalDrag", "externalDrop", "firstDay", "fromText", "getDay", "getDate", "getMaxDayOfMonth", "getMonth", "getYear", "getWeekNumber", "groupBy", "height", "immutableData", "invalidateEvent", "invalidsMap", "maxDate", "maxEventStack", "minEventWidth", "moreEventsPluralText", "moreEventsText", "navigateToEvent", "minDate", "monthNames", "monthNamesShort", "navService", "newEventText", "pmText", "refDate", "resources", "resourceTemplate", "rtl", "scroll", "selected", "selectedEventsMap", "showAllDay", "showDays", "showEventBuffer", "showEventTooltip", "size", "startDay", "startTime", "timeCellStep", "timeFormat", "timeLabelStep", "timezonePlugin", "timezones", "theme", "themeVariant", "toText", "type", "width", "onCellClick", "onCellDoubleClick", "onCellRightClick", "onEventClick", "onEventDoubleClick", "onEventRightClick", "onEventHoverIn", "onEventHoverOut", "onEventDelete", "onEventDragEnd", "onEventDragStart", "onEventDragEnter", "onEventDragLeave", "onMoreClick", "onPopoverClose", "onResourceClick", "onResourceDoubleClick", "onResourceRightClick", "onWeekDayClick"], [3, "allDayText", "amText", "bufferAfterTemplate", "bufferBeforeTemplate", "checkSize", "clickToCreate", "colorsMap", "connections", "context", "currentTimeIndicator", "columnWidth", "dataTimezone", "dateFormat", "dateFormatFull", "dateFormatLong", "dayNames", "dayNamesMin", "dayNamesShort", "dayFooterTemplate", "dayTemplate", "weekTemplate", "weekFooterTemplate", "yearTemplate", "yearFooterTemplate", "hourTemplate", "hourFooterTemplate", "monthTemplate", "monthFooterTemplate", "displayTimezone", "dragBetweenResources", "dragBetweenSlots", "dragIcon", "dragInTime", "dragTimeStep", "dragToCreate", "dragToMove", "dragToResize", "downIcon", "endDay", "endTime", "eventHeight", "eventList", "eventDragEnd", "eventContentTemplate", "eventMap", "eventOrder", "eventOverlap", "eventTemplate", "exclusiveEndDates", "extendDefaultEvent", "externalDrag", "externalDrop", "externalResourceDrag", "externalResourceDrop", "firstDay", "fromText", "getDay", "getDate", "getMaxDayOfMonth", "getMonth", "getWeekNumber", "getYear", "groupBy", "height", "immutableData", "invalidateEvent", "invalidsMap", "maxDate", "maxEventStack", "minDate", "moreEventsPluralText", "moreEventsText", "navigateToEvent", "monthNames", "monthNamesShort", "navService", "newEventText", "nextIcon", "nextIconRtl", "pmText", "refDate", "resolution", "resolutionVertical", "resources", "resourceFooterTemplate", "resourceHeaderTemplate", "resourceReorder", "resourceTemplate", "resourceEmptyTemplate", "rtl", "rowHeight", "scroll", "showEventBuffer", "showEventTooltip", "slots", "slotTemplate", "selected", "selectedEventsMap", "sidebarFooterTemplate", "sidebarHeaderTemplate", "sidebarTemplate", "size", "startDay", "startTime", "quarterFooterTemplate", "quarterTemplate", "quarterText", "timeCellStep", "timeFormat", "timeLabelStep", "timezonePlugin", "theme", "themeVariant", "toText", "type", "virtualScroll", "weekNumbers", "weekText", "width", "onActiveChange", "onCellClick", "onCellDoubleClick", "onCellRightClick", "onEventClick", "onEventDoubleClick", "onEventRightClick", "onEventHoverIn", "onEventHoverOut", "onEventDelete", "onEventDragEnd", "onEventDragStart", "onEventDragEnter", "onEventDragLeave", "onMoreClick", "onPopoverClose", "onResourceClick", "onResourceCollapse", "onResourceCreate", "onResourceCreated", "onResourceDelete", "onResourceDeleted", "onResourceDoubleClick", "onResourceExpand", "onResourceDragEnd", "onResourceDragEnter", "onResourceDragLeave", "onResourceDragStart", "onResourceOrderUpdate", "onResourceRightClick", "onVirtualLoading", "zoomLevel"], ["source", "popover", 1, "mbsc-event", 3, "onHoverIn", "onHoverOut", "onClick", "onDoubleClick", "onRightClick", "onDragEnd", "onDragModeOff", "onDragModeOn", "onDragMove", "onDragStart", "actionable", "cssClass", "date", "event", "eventContentTemplate", "eventData", "hasDate", "rtl", "selected", "showColor", "template", "theme", "themeVariant", "drag"], [1, "mbsc-calendar-dragging"]],
    template: function MbscEventcalendar_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "mbsc-calendar-view", 5, 0);
        ɵɵtemplate(2, MbscEventcalendar_div_2_Template, 5, 7, "div", 6)(3, MbscEventcalendar_div_3_Template, 5, 6, "div", 7)(4, MbscEventcalendar_mbsc_scheduler_4_Template, 1, 105, "mbsc-scheduler", 8)(5, MbscEventcalendar_mbsc_timeline_5_Template, 1, 151, "mbsc-timeline", 9);
        ɵɵelementStart(6, "mbsc-popup", 10);
        ɵɵlistener("onClose", function MbscEventcalendar_Template_mbsc_popup_onClose_6_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPopoverClose($event));
        });
        ɵɵelementStart(7, "mbsc-list", 11);
        ɵɵtemplate(8, MbscEventcalendar_mbsc_event_list_item_8_Template, 1, 14, "mbsc-event-list-item", 12);
        ɵɵelementEnd()();
        ɵɵtemplate(9, MbscEventcalendar_div_9_Template, 1, 0, "div", 13);
        ɵɵelementEnd();
      }
      if (rf & 2) {
        ɵɵproperty("activeDate", ctx2._active)("amText", ctx2.s.amText)("calendarScroll", ctx2._calendarScroll)("calendarType", ctx2._calendarType)("clickToCreate", ctx2.s.clickToCreate)("colors", ctx2.s.colors)("context", ctx2.s.context)("cssClass", ctx2._cssClass)("dataTimezone", ctx2.s.dataTimezone)("dayTemplate", ctx2.dayTemplate)("dayContentTemplate", ctx2.dayContentTemplate)("displayTimezone", ctx2.s.displayTimezone)("downIcon", ctx2.s.downIcon)("dragData", ctx2.state.labelDragData)("dragToCreate", ctx2.s.dragToCreate)("dragToMove", ctx2.s.dragToMove || ctx2.s.externalDrag)("dragToResize", ctx2.s.dragToResize)("endDay", ctx2._rangeEndDay)("eventExact", ctx2._eventExact)("eventMap", ctx2._eventMap)("eventOrder", ctx2.s.eventOrder)("eventRange", ctx2._rangeType)("eventRangeSize", ctx2._showSchedule ? ctx2._scheduleSize : ctx2._showTimeline ? ctx2._timelineSize : ctx2._eventListSize)("exclusiveEndDates", ctx2.s.exclusiveEndDates)("hasContent", ctx2._showEventList || ctx2._showSchedule || ctx2._showTimeline)("hasPicker", true)("headerTemplate", ctx2.headerTemplate)("height", ctx2.s.height)("invalid", ctx2.s.invalid)("instanceService", ctx2._instanceService)("labels", ctx2.s.labels)("labelsMap", ctx2._labelsMap)("labelList", ctx2._calendarLabelList)("labelTemplate", ctx2.labelTemplate)("labelContentTemplate", ctx2.labelContentTemplate)("marked", ctx2.s.marked)("marksMap", ctx2._marksMap)("max", ctx2.s.max)("min", ctx2.s.min)("mouseSwipe", !ctx2.s.dragToCreate && ctx2.s.clickToCreate !== "single" || !ctx2._showEventLabels && !ctx2._showEventCount)("mousewheel", ctx2.s.mousewheel)("navService", ctx2._navService)("navView", ctx2._navView)("nextIconH", ctx2.s.nextIconH)("nextIconV", ctx2.s.nextIconV)("nextPageText", ctx2.s.nextPageText)("noOuterChange", !ctx2._showEventList)("onActiveChange", ctx2._onActiveChange)("onCellHoverIn", ctx2._onCellHoverIn)("onCellHoverOut", ctx2._onCellHoverOut)("onDayClick", ctx2._onDayClick)("onDayDoubleClick", ctx2._onDayDoubleClick)("onDayRightClick", ctx2._onDayRightClick)("onGestureStart", ctx2._onGestureStart)("onLabelClick", ctx2._onLabelClick)("onLabelDoubleClick", ctx2._onLabelDoubleClick)("onLabelRightClick", ctx2._onLabelRightClick)("onLabelHoverIn", ctx2._onLabelHoverIn)("onLabelHoverOut", ctx2._onLabelHoverOut)("onLabelDelete", ctx2._onEventDelete)("onLabelUpdateStart", ctx2._onLabelUpdateStart)("onLabelUpdateMove", ctx2._onLabelUpdateMove)("onLabelUpdateEnd", ctx2._onLabelUpdateEnd)("onLabelUpdateModeOn", ctx2._onLabelUpdateModeOn)("onLabelUpdateModeOff", ctx2._onLabelUpdateModeOff)("onPageChange", ctx2._onPageChange)("onPageLoaded", ctx2._onPageLoaded)("onPageLoading", ctx2._onPageLoading)("onResize", ctx2._onResize)("pageLoad", ctx2._pageLoad)("pmText", ctx2.s.pmText)("prevIconH", ctx2.s.prevIconH)("prevIconV", ctx2.s.prevIconV)("prevPageText", ctx2.s.prevPageText)("refDate", ctx2._refDate)("resourcesMap", ctx2._resourcesMap)("responsiveStyle", true)("rtl", ctx2.s.rtl)("selectedDates", ctx2._selectedDates)("selectedEventsMap", ctx2._selectedEventsMap)("showCalendar", ctx2._showCalendar)("showControls", ctx2.s.showControls)("showEventTooltip", ctx2.s.showEventTooltip)("showLabelCount", ctx2._showEventCount)("showOuterDays", ctx2._showOuterDays)("showSchedule", ctx2._showSchedule || ctx2._showTimeline)("showToday", ctx2.s.showToday)("showWeekNumbers", ctx2._showWeekNumbers)("size", ctx2._calendarSize)("startDay", ctx2._rangeStartDay)("swipe", !ctx2.state.isTouchDrag)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant)("timeFormat", ctx2.s.timeFormat)("timezonePlugin", ctx2.s.timezonePlugin)("update", ctx2._update)("upIcon", ctx2.s.upIcon)("valid", ctx2.s.valid)("weeks", ctx2._calendarSize)("width", ctx2.s.width)("getDate", ctx2.s.getDate)("getDay", ctx2.s.getDay)("getMaxDayOfMonth", ctx2.s.getMaxDayOfMonth)("getMonth", ctx2.s.getMonth)("getWeekNumber", ctx2.s.getWeekNumber)("getYear", ctx2.s.getYear)("dateFormat", ctx2.s.dateFormat)("dayNames", ctx2.s.dayNames)("dayNamesMin", ctx2.s.dayNamesMin)("dayNamesShort", ctx2.s.dayNamesShort)("eventText", ctx2.s.eventText)("eventsText", ctx2.s.eventsText)("firstDay", ctx2.s.firstDay)("fromText", ctx2.s.fromText)("monthNames", ctx2.s.monthNames)("monthNamesShort", ctx2.s.monthNamesShort)("moreEventsPluralText", ctx2.s.moreEventsPluralText)("moreEventsText", ctx2.s.moreEventsText)("todayText", ctx2.s.todayText)("toText", ctx2.s.toText)("weekText", ctx2.s.weekText)("yearSuffix", ctx2.s.yearSuffix);
        ɵɵadvance(2);
        ɵɵproperty("ngIf", ctx2._showDate);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showEventList);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showSchedule);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2._showTimeline);
        ɵɵadvance();
        ɵɵproperty("anchor", ctx2._anchor)("closeOnScroll", true)("contentPadding", false)("context", ctx2.state.popoverContext || ctx2.s.context)("cssClass", "mbsc-calendar-popup " + (ctx2.state.popoverHidden ? "mbsc-popover-hidden " : "") + ctx2._popoverClass)("isOpen", ctx2.state.showPopover)("locale", ctx2.s.locale)("rtl", ctx2.s.rtl)("scrollLock", false)("showOverlay", false)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant);
        ɵɵadvance();
        ɵɵproperty("rtl", ctx2.s.rtl)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant);
        ɵɵadvance();
        ɵɵproperty("ngForOf", ctx2.state.popoverList)("ngForTrackBy", ctx2._getEventKey);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.state.labelDragData && ctx2.state.labelDragData.draggedEvent && !ctx2.state.isTouchDrag);
      }
    },
    dependencies: [MbscCalendarView, MbscList, MbscListHeader, MbscEventListItem, MbscScheduler, MbscTimeline, MbscPopup, NgIf, NgTemplateOutlet, NgForOf, MbscEventListDayDirective],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscEventcalendar2;
}(EventcalendarBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscEventcalendar, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [MbscEventListService, MbscInstanceService],
      selector: "mbsc-eventcalendar",
      template: `
    <mbsc-calendar-view
      #calendar
      [activeDate]="_active"
      [amText]="s.amText"
      [calendarScroll]="_calendarScroll"
      [calendarType]="_calendarType"
      [clickToCreate]="s.clickToCreate"
      [colors]="s.colors"
      [context]="s.context"
      [cssClass]="_cssClass"
      [dataTimezone]="s.dataTimezone"
      [dayTemplate]="dayTemplate"
      [dayContentTemplate]="dayContentTemplate"
      [displayTimezone]="s.displayTimezone"
      [downIcon]="s.downIcon"
      [dragData]="state.labelDragData"
      [dragToCreate]="s.dragToCreate"
      [dragToMove]="s.dragToMove || s.externalDrag"
      [dragToResize]="s.dragToResize"
      [endDay]="_rangeEndDay"
      [eventExact]="_eventExact"
      [eventMap]="_eventMap"
      [eventOrder]="s.eventOrder"
      [eventRange]="_rangeType"
      [eventRangeSize]="_showSchedule ? _scheduleSize : _showTimeline ? _timelineSize : _eventListSize"
      [exclusiveEndDates]="s.exclusiveEndDates"
      [hasContent]="_showEventList || _showSchedule || _showTimeline"
      [hasPicker]="true"
      [headerTemplate]="headerTemplate"
      [height]="s.height"
      [invalid]="s.invalid"
      [instanceService]="_instanceService"
      [labels]="s.labels"
      [labelsMap]="_labelsMap"
      [labelList]="_calendarLabelList"
      [labelTemplate]="labelTemplate"
      [labelContentTemplate]="labelContentTemplate"
      [marked]="s.marked"
      [marksMap]="_marksMap"
      [max]="s.max"
      [min]="s.min"
      [mouseSwipe]="(!s.dragToCreate && s.clickToCreate !== 'single') || (!_showEventLabels && !_showEventCount)"
      [mousewheel]="s.mousewheel"
      [navService]="_navService"
      [navView]="_navView"
      [nextIconH]="s.nextIconH"
      [nextIconV]="s.nextIconV"
      [nextPageText]="s.nextPageText"
      [noOuterChange]="!_showEventList"
      [onActiveChange]="_onActiveChange"
      [onCellHoverIn]="_onCellHoverIn"
      [onCellHoverOut]="_onCellHoverOut"
      [onDayClick]="_onDayClick"
      [onDayDoubleClick]="_onDayDoubleClick"
      [onDayRightClick]="_onDayRightClick"
      [onGestureStart]="_onGestureStart"
      [onLabelClick]="_onLabelClick"
      [onLabelDoubleClick]="_onLabelDoubleClick"
      [onLabelRightClick]="_onLabelRightClick"
      [onLabelHoverIn]="_onLabelHoverIn"
      [onLabelHoverOut]="_onLabelHoverOut"
      [onLabelDelete]="_onEventDelete"
      [onLabelUpdateStart]="_onLabelUpdateStart"
      [onLabelUpdateMove]="_onLabelUpdateMove"
      [onLabelUpdateEnd]="_onLabelUpdateEnd"
      [onLabelUpdateModeOn]="_onLabelUpdateModeOn"
      [onLabelUpdateModeOff]="_onLabelUpdateModeOff"
      [onPageChange]="_onPageChange"
      [onPageLoaded]="_onPageLoaded"
      [onPageLoading]="_onPageLoading"
      [onResize]="_onResize"
      [pageLoad]="_pageLoad"
      [pmText]="s.pmText"
      [prevIconH]="s.prevIconH"
      [prevIconV]="s.prevIconV"
      [prevPageText]="s.prevPageText"
      [refDate]="_refDate"
      [resourcesMap]="_resourcesMap"
      [responsiveStyle]="true"
      [rtl]="s.rtl"
      [selectedDates]="_selectedDates"
      [selectedEventsMap]="_selectedEventsMap"
      selectView="page"
      [showCalendar]="_showCalendar"
      [showControls]="s.showControls"
      [showEventTooltip]="s.showEventTooltip"
      [showLabelCount]="_showEventCount"
      [showOuterDays]="_showOuterDays"
      [showSchedule]="_showSchedule || _showTimeline"
      [showToday]="s.showToday"
      [showWeekNumbers]="_showWeekNumbers"
      [size]="_calendarSize"
      [startDay]="_rangeStartDay"
      [swipe]="!state.isTouchDrag"
      [theme]="s.theme"
      [themeVariant]="s.themeVariant"
      [timeFormat]="s.timeFormat"
      [timezonePlugin]="s.timezonePlugin"
      [update]="_update"
      [upIcon]="s.upIcon"
      [valid]="s.valid"
      [weeks]="_calendarSize"
      [width]="s.width"
      [getDate]="s.getDate"
      [getDay]="s.getDay"
      [getMaxDayOfMonth]="s.getMaxDayOfMonth"
      [getMonth]="s.getMonth"
      [getWeekNumber]="s.getWeekNumber"
      [getYear]="s.getYear"
      [dateFormat]="s.dateFormat"
      [dayNames]="s.dayNames"
      [dayNamesMin]="s.dayNamesMin"
      [dayNamesShort]="s.dayNamesShort"
      [eventText]="s.eventText"
      [eventsText]="s.eventsText"
      [firstDay]="s.firstDay"
      [fromText]="s.fromText"
      [monthNames]="s.monthNames"
      [monthNamesShort]="s.monthNamesShort"
      [moreEventsPluralText]="s.moreEventsPluralText"
      [moreEventsText]="s.moreEventsText"
      [todayText]="s.todayText"
      [toText]="s.toText"
      [weekText]="s.weekText"
      [yearSuffix]="s.yearSuffix"
    >
      <div *ngIf="_showDate" [class]="'mbsc-schedule-date-header mbsc-flex' + _theme + _hb">
        <div *ngIf="_showSchedule && !_showCalendar && s.resources" class="mbsc-schedule-time-col"></div>
        <div [class]="'mbsc-schedule-date-header-text mbsc-flex-1-1' + _theme">{{ _selectedDateHeader }}</div>
        <div *ngIf="_showSchedule && !_showCalendar && s.resources" class="mbsc-schedule-fake-scroll-y"></div>
      </div>
      <div
        *ngIf="_showEventList"
        [class]="'mbsc-flex-1-1 mbsc-event-list' + (state.isListScrollable ? ' mbsc-event-list-scroll' : '')"
        (scroll)="_onScroll()"
        #list
      >
        <ng-template #def let-data>
          <mbsc-list [rtl]="s.rtl" [theme]="s.theme" [themeVariant]="s.themeVariant">
            <div *ngIf="!_eventListNr && !_showEmptyDays" [class]="!agendaEmptyTemplate ? 'mbsc-event-list-empty' + _theme : ''">
              <ng-template #noEventsText>
                {{ s.noEventsText }}
              </ng-template>
              <ng-container [ngTemplateOutlet]="agendaEmptyTemplate || noEventsText"></ng-container>
            </div>
            <ng-container *ngIf="_eventListNr || _showEmptyDays">
              <div
                *ngFor="let day of data; trackBy: _getDayKey"
                mbsc-event-list-day
                [class]="'mbsc-event-group' + (day.events.length || _showEmptyDays ? '' : ' mbsc-event-group-empty') + _theme"
                [timestamp]="day.timestamp"
              >
                <mbsc-list-header
                  *ngIf="_showEmptyDays || day.events.length"
                  class="mbsc-event-day"
                  [theme]="s.theme"
                  [themeVariant]="s.themeVariant"
                >
                  <ng-container
                    [ngTemplateOutlet]="dayTemplate || default"
                    [ngTemplateOutletContext]="{ $implicit: { date: day.dateObj, events: day.events } }"
                  >
                  </ng-container>
                  <ng-template #default>{{ day.date }}</ng-template>
                </mbsc-list-header>
                <mbsc-event-list-item
                  *ngFor="let event of day.events; trackBy: _getEventKey"
                  [actionable]="s.actionableEvents"
                  [cssClass]="event.original!.cssClass"
                  class="mbsc-event"
                  [date]="day.timestamp"
                  [event]="event.original"
                  [eventContentTemplate]="eventContentTemplate"
                  [eventData]="event"
                  [rtl]="s.rtl"
                  [selected]="!!(_selectedEventsMap[event.uid!] || _selectedEventsMap[event.id])"
                  [showColor]="!_colorEventList"
                  source="agenda"
                  [template]="eventTemplate"
                  [theme]="s.theme"
                  [themeVariant]="s.themeVariant"
                  (onHoverIn)="_onEventHoverIn($event)"
                  (onHoverOut)="_onEventHoverOut($event)"
                  (onClick)="_onEventClick($event)"
                  (onDoubleClick)="_onEventDoubleClick($event)"
                  (onRightClick)="_onEventRightClick($event)"
                >
                </mbsc-event-list-item>
              </div>
            </ng-container>
          </mbsc-list>
        </ng-template>
        <ng-container [ngTemplateOutlet]="agendaTemplate || def" [ngTemplateOutletContext]="{ $implicit: state.eventList }"></ng-container>
      </div>

      <mbsc-scheduler
        *ngIf="_showSchedule"
        [allDayText]="s.allDayText"
        [amText]="s.amText"
        [bufferAfterTemplate]="bufferAfterTemplate"
        [bufferBeforeTemplate]="bufferBeforeTemplate"
        [checkSize]="_checkSize"
        [clickToCreate]="s.clickToCreate"
        [colorsMap]="_colorsMap"
        [context]="s.context"
        [currentTimeIndicator]="_currentTimeIndicator"
        [dataTimezone]="s.dataTimezone"
        [dateFormat]="s.dateFormat"
        [dateFormatFull]="s.dateFormatFull"
        [dateFormatLong]="s.dateFormatLong"
        [dayNames]="s.dayNames"
        [dayNamesMin]="s.dayNamesMin"
        [dayNamesShort]="s.dayNamesShort"
        [dayTemplate]="dayTemplate"
        [dayContentTemplate]="dayContentTemplate"
        [displayTimezone]="s.displayTimezone"
        [dragBetweenResources]="s.dragBetweenResources"
        [dragInTime]="s.dragInTime"
        [dragTimeStep]="_dragTimeStep"
        [dragToCreate]="s.dragToCreate"
        [dragToMove]="s.dragToMove"
        [dragToResize]="s.dragToResize"
        [endDay]="_scheduleEndDay"
        [endTime]="_scheduleEndTime"
        [eventContentTemplate]="scheduleEventContentTemplate"
        [eventDragEnd]="_onEventDragStop"
        [eventMap]="_eventMap"
        [eventOrder]="s.eventOrder"
        [eventOverlap]="s.eventOverlap"
        [eventTemplate]="scheduleEventTemplate"
        [exclusiveEndDates]="s.exclusiveEndDates"
        [extendDefaultEvent]="s.extendDefaultEvent"
        [externalDrag]="s.externalDrag"
        [externalDrop]="s.externalDrop"
        [firstDay]="s.firstDay"
        [fromText]="s.fromText"
        [getDay]="s.getDay"
        [getDate]="s.getDate"
        [getMaxDayOfMonth]="s.getMaxDayOfMonth"
        [getMonth]="s.getMonth"
        [getYear]="s.getYear"
        [getWeekNumber]="s.getWeekNumber"
        [groupBy]="s.groupBy"
        [height]="state.height"
        [immutableData]="s.immutableData"
        [invalidateEvent]="s.invalidateEvent"
        [invalidsMap]="_invalidsMap"
        [maxDate]="s.max"
        [maxEventStack]="_scheduleMaxEventStack"
        [minEventWidth]="_scheduleMinEventWidth"
        [moreEventsPluralText]="s.moreEventsPluralText"
        [moreEventsText]="s.moreEventsText"
        [navigateToEvent]="_navigateToEvent"
        [minDate]="s.min"
        [monthNames]="s.monthNames"
        [monthNamesShort]="s.monthNamesShort"
        [navService]="_navService"
        [newEventText]="s.newEventText"
        [pmText]="s.pmText"
        [refDate]="_refDate"
        [resources]="s.resources"
        [resourceTemplate]="resourceTemplate"
        [rtl]="s.rtl"
        [scroll]="_shouldScrollSchedule"
        [selected]="_selectedDateTime"
        [selectedEventsMap]="_selectedEventsMap"
        [showAllDay]="_showScheduleAllDay"
        [showDays]="_showScheduleDays"
        [showEventBuffer]="s.showEventBuffer"
        [showEventTooltip]="s.showEventTooltip"
        [size]="_scheduleSize"
        [startDay]="_scheduleStartDay"
        [startTime]="_scheduleStartTime"
        [timeCellStep]="_scheduleTimeCellStep"
        [timeFormat]="s.timeFormat"
        [timeLabelStep]="_scheduleTimeLabelStep"
        [timezonePlugin]="s.timezonePlugin"
        [timezones]="_scheduleTimezones"
        [theme]="s.theme"
        [themeVariant]="s.themeVariant"
        [toText]="s.toText"
        [type]="_scheduleType"
        [width]="state.width"
        [onCellClick]="_onCellClick"
        [onCellDoubleClick]="_onCellDoubleClick"
        [onCellRightClick]="_onCellRightClick"
        [onEventClick]="_onEventClick"
        [onEventDoubleClick]="_onEventDoubleClick"
        [onEventRightClick]="_onEventRightClick"
        [onEventHoverIn]="_onEventHoverIn"
        [onEventHoverOut]="_onEventHoverOut"
        [onEventDelete]="_onEventDelete"
        [onEventDragEnd]="_onEventDragEnd"
        [onEventDragStart]="_onEventDragStart"
        [onEventDragEnter]="_onEventDragEnter"
        [onEventDragLeave]="_onEventDragLeave"
        [onMoreClick]="_onMoreClick"
        [onPopoverClose]="_onPopoverClose"
        [onResourceClick]="_proxy"
        [onResourceDoubleClick]="_proxy"
        [onResourceRightClick]="_proxy"
        [onWeekDayClick]="_onWeekDayClick"
      >
      </mbsc-scheduler>

      <mbsc-timeline
        *ngIf="_showTimeline"
        [allDayText]="s.allDayText"
        [amText]="s.amText"
        [bufferAfterTemplate]="bufferAfterTemplate"
        [bufferBeforeTemplate]="bufferBeforeTemplate"
        [checkSize]="_checkSize"
        [clickToCreate]="s.clickToCreate"
        [colorsMap]="_colorsMap"
        [connections]="s.connections"
        [context]="s.context"
        [currentTimeIndicator]="_currentTimeIndicator"
        [columnWidth]="_timelineColWidth"
        [dataTimezone]="s.dataTimezone"
        [dateFormat]="s.dateFormat"
        [dateFormatFull]="s.dateFormatFull"
        [dateFormatLong]="s.dateFormatLong"
        [dayNames]="s.dayNames"
        [dayNamesMin]="s.dayNamesMin"
        [dayNamesShort]="s.dayNamesShort"
        [dayFooterTemplate]="dayFooterTemplate"
        [dayTemplate]="dayTemplate"
        [weekTemplate]="weekTemplate"
        [weekFooterTemplate]="weekFooterTemplate"
        [yearTemplate]="yearTemplate"
        [yearFooterTemplate]="yearFooterTemplate"
        [hourTemplate]="hourTemplate"
        [hourFooterTemplate]="hourFooterTemplate"
        [monthTemplate]="monthTemplate"
        [monthFooterTemplate]="monthFooterTemplate"
        [displayTimezone]="s.displayTimezone"
        [dragBetweenResources]="s.dragBetweenResources"
        [dragBetweenSlots]="s.dragBetweenSlots"
        [dragIcon]="s.dragIcon"
        [dragInTime]="s.dragInTime"
        [dragTimeStep]="_dragTimeStep"
        [dragToCreate]="slots ? false : s.dragToCreate"
        [dragToMove]="s.dragToMove"
        [dragToResize]="slots ? false : s.dragToResize"
        [downIcon]="s.chevronIconDown"
        [endDay]="_timelineEndDay"
        [endTime]="_timelineEndTime"
        [eventHeight]="_timelineEventHeight"
        [eventList]="_timelineListing"
        [eventDragEnd]="_onEventDragStop"
        [eventContentTemplate]="scheduleEventContentTemplate"
        [eventMap]="_eventMap"
        [eventOrder]="s.eventOrder"
        [eventOverlap]="s.eventOverlap"
        [eventTemplate]="scheduleEventTemplate"
        [exclusiveEndDates]="s.exclusiveEndDates"
        [extendDefaultEvent]="s.extendDefaultEvent"
        [externalDrag]="s.externalDrag"
        [externalDrop]="s.externalDrop"
        [externalResourceDrag]="s.externalResourceDrag"
        [externalResourceDrop]="s.externalResourceDrop"
        [firstDay]="s.firstDay"
        [fromText]="s.fromText"
        [getDay]="s.getDay"
        [getDate]="s.getDate"
        [getMaxDayOfMonth]="s.getMaxDayOfMonth"
        [getMonth]="s.getMonth"
        [getWeekNumber]="s.getWeekNumber"
        [getYear]="s.getYear"
        [groupBy]="s.groupBy"
        [height]="state.height"
        [immutableData]="s.immutableData"
        [invalidateEvent]="s.invalidateEvent"
        [invalidsMap]="_invalidsMap"
        [maxDate]="s.max"
        [maxEventStack]="_timelineMaxEventStack"
        [minDate]="s.min"
        [moreEventsPluralText]="s.moreEventsPluralText"
        [moreEventsText]="s.moreEventsText"
        [navigateToEvent]="_navigateToEvent"
        [monthNames]="s.monthNames"
        [monthNamesShort]="s.monthNamesShort"
        [navService]="_navService"
        [newEventText]="s.newEventText"
        [nextIcon]="s.nextIconH"
        [nextIconRtl]="s.prevIconH"
        [pmText]="s.pmText"
        [refDate]="_refDate"
        [resolution]="_timelineResolution"
        [resolutionVertical]="_timelineResolutionVertical"
        [resources]="s.resources"
        [resourceFooterTemplate]="resourceFooterTemplate"
        [resourceHeaderTemplate]="resourceHeaderTemplate"
        [resourceReorder]="_timelineResourceOrder"
        [resourceTemplate]="resourceTemplate"
        [resourceEmptyTemplate]="resourceEmptyTemplate"
        [rtl]="s.rtl"
        [rowHeight]="_timelineRowHeight"
        [scroll]="_shouldScrollSchedule"
        [showEventBuffer]="s.showEventBuffer"
        [showEventTooltip]="s.showEventTooltip"
        [slots]="s.slots"
        [slotTemplate]="slotTemplate"
        [selected]="_selectedDateTime"
        [selectedEventsMap]="_selectedEventsMap"
        [sidebarFooterTemplate]="sidebarFooterTemplate"
        [sidebarHeaderTemplate]="sidebarHeaderTemplate"
        [sidebarTemplate]="sidebarTemplate"
        [size]="_timelineSize"
        [startDay]="_timelineStartDay"
        [startTime]="_timelineStartTime"
        [quarterFooterTemplate]="quarterFooterTemplate"
        [quarterTemplate]="quarterTemplate"
        [quarterText]="s.quarterText"
        [timeCellStep]="_timelineTimeCellStep"
        [timeFormat]="s.timeFormat"
        [timeLabelStep]="_timelineTimeLabelStep"
        [timezonePlugin]="s.timezonePlugin"
        [theme]="s.theme"
        [themeVariant]="s.themeVariant"
        [toText]="s.toText"
        [type]="_timelineType"
        [virtualScroll]="!_print && _timelineVirtualScroll"
        [weekNumbers]="_showTimelineWeekNumbers"
        [weekText]="s.weekText"
        [width]="state.width"
        [onActiveChange]="_onActiveChange"
        [onCellClick]="_onCellClick"
        [onCellDoubleClick]="_onCellDoubleClick"
        [onCellRightClick]="_onCellRightClick"
        [onEventClick]="_onEventClick"
        [onEventDoubleClick]="_onEventDoubleClick"
        [onEventRightClick]="_onEventRightClick"
        [onEventHoverIn]="_onEventHoverIn"
        [onEventHoverOut]="_onEventHoverOut"
        [onEventDelete]="_onEventDelete"
        [onEventDragEnd]="_onEventDragEnd"
        [onEventDragStart]="_onEventDragStart"
        [onEventDragEnter]="_onEventDragEnter"
        [onEventDragLeave]="_onEventDragLeave"
        [onMoreClick]="_onMoreClick"
        [onPopoverClose]="_onPopoverClose"
        [onResourceClick]="_proxy"
        [onResourceCollapse]="_proxy"
        [onResourceCreate]="_proxy"
        [onResourceCreated]="_proxy"
        [onResourceDelete]="_proxy"
        [onResourceDeleted]="_proxy"
        [onResourceDoubleClick]="_proxy"
        [onResourceExpand]="_proxy"
        [onResourceDragEnd]="_proxy"
        [onResourceDragEnter]="_proxy"
        [onResourceDragLeave]="_proxy"
        [onResourceDragStart]="_proxy"
        [onResourceOrderUpdate]="_proxy"
        [onResourceRightClick]="_proxy"
        [onVirtualLoading]="_proxy"
        [zoomLevel]="s.zoomLevel"
      >
      </mbsc-timeline>

      <mbsc-popup
        [anchor]="_anchor"
        [closeOnScroll]="true"
        [contentPadding]="false"
        [context]="state.popoverContext || s.context"
        [cssClass]="'mbsc-calendar-popup ' + (state.popoverHidden ? 'mbsc-popover-hidden ' : '') + _popoverClass"
        display="anchored"
        [isOpen]="state.showPopover"
        [locale]="s.locale"
        maxHeight="24em"
        [rtl]="s.rtl"
        [scrollLock]="false"
        [showOverlay]="false"
        [theme]="s.theme"
        [themeVariant]="s.themeVariant"
        (onClose)="_onPopoverClose($event)"
      >
        <mbsc-list class="mbsc-popover-list" [rtl]="s.rtl" [theme]="s.theme" [themeVariant]="s.themeVariant">
          <mbsc-event-list-item
            *ngFor="let event of state.popoverList; trackBy: _getEventKey"
            [actionable]="s.actionableEvents"
            [cssClass]="event.original!.cssClass"
            class="mbsc-event"
            [date]="state.popoverDate"
            [event]="event.original"
            [eventContentTemplate]="eventContentTemplate"
            [eventData]="event"
            [hasDate]="!!state.popoverHost"
            [rtl]="s.rtl"
            [selected]="!!(_selectedEventsMap[event.uid!] || _selectedEventsMap[event.id])"
            [showColor]="!_colorEventList"
            source="popover"
            [template]="eventTemplate"
            [theme]="s.theme"
            [themeVariant]="s.themeVariant"
            [drag]="(_showEventLabels || state.popoverHost) && (s.dragToMove || s.externalDrag)"
            (onHoverIn)="_onEventHoverIn($event)"
            (onHoverOut)="_onEventHoverOut($event)"
            (onClick)="_onEventClick($event)"
            (onDoubleClick)="_onEventDoubleClick($event)"
            (onRightClick)="_onEventRightClick($event)"
            (onDragEnd)="state.popoverHost ? state.popoverHost._onEventDragEnd($event) : _onLabelUpdateEnd($event)"
            (onDragModeOff)="state.popoverHost ? state.popoverHost._onEventDragModeOff($event) : _onLabelUpdateModeOff($event)"
            (onDragModeOn)="state.popoverHost ? state.popoverHost._onEventDragModeOn($event) : _onLabelUpdateModeOn($event)"
            (onDragMove)="state.popoverHost ? state.popoverHost._onEventDragMove($event) : _onLabelUpdateMove($event)"
            (onDragStart)="state.popoverHost ? state.popoverHost._onEventDragStart($event) : _onLabelUpdateStart($event)"
          >
          </mbsc-event-list-item>
        </mbsc-list>
      </mbsc-popup>
      <div *ngIf="state.labelDragData && state.labelDragData.draggedEvent && !state.isTouchDrag" class="mbsc-calendar-dragging"></div>
    </mbsc-calendar-view>
  `
    }]
  }], null, {
    vList: [{
      type: ViewChild,
      args: ["list", {
        static: false,
        read: ElementRef
      }]
    }],
    _calendarView: [{
      type: ViewChild,
      args: ["calendar", {
        static: true
      }]
    }],
    actionableEvents: [{
      type: Input
    }],
    agendaEmptyTemplate: [{
      type: Input
    }],
    agendaTemplate: [{
      type: Input
    }],
    bufferAfterTemplate: [{
      type: Input
    }],
    bufferBeforeTemplate: [{
      type: Input
    }],
    calendarSystem: [{
      type: Input
    }],
    clickToCreate: [{
      type: Input
    }],
    colors: [{
      type: Input
    }],
    connections: [{
      type: Input
    }],
    data: [{
      type: Input
    }],
    dayTemplate: [{
      type: Input
    }],
    dayContentTemplate: [{
      type: Input
    }],
    dayFooterTemplate: [{
      type: Input
    }],
    dataTimezone: [{
      type: Input
    }],
    displayTimezone: [{
      type: Input
    }],
    dragBetweenResources: [{
      type: Input
    }],
    dragBetweenSlots: [{
      type: Input
    }],
    dragInTime: [{
      type: Input
    }],
    dragTimeStep: [{
      type: Input
    }],
    dragToCreate: [{
      type: Input
    }],
    dragToResize: [{
      type: Input
    }],
    dragToMove: [{
      type: Input
    }],
    eventContentTemplate: [{
      type: Input
    }],
    eventDelete: [{
      type: Input
    }],
    eventOrder: [{
      type: Input
    }],
    eventOverlap: [{
      type: Input
    }],
    eventTemplate: [{
      type: Input
    }],
    exclusiveEndDates: [{
      type: Input
    }],
    extendDefaultEvent: [{
      type: Input
    }],
    externalDrag: [{
      type: Input
    }],
    externalDrop: [{
      type: Input
    }],
    externalResourceDrag: [{
      type: Input
    }],
    externalResourceDrop: [{
      type: Input
    }],
    groupBy: [{
      type: Input
    }],
    headerTemplate: [{
      type: Input
    }],
    height: [{
      type: Input
    }],
    hourTemplate: [{
      type: Input
    }],
    hourFooterTemplate: [{
      type: Input
    }],
    immutableData: [{
      type: Input
    }],
    invalid: [{
      type: Input
    }],
    invalidateEvent: [{
      type: Input
    }],
    labelContentTemplate: [{
      type: Input
    }],
    labels: [{
      type: Input
    }],
    labelTemplate: [{
      type: Input
    }],
    marked: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    mousewheel: [{
      type: Input
    }],
    monthTemplate: [{
      type: Input
    }],
    monthFooterTemplate: [{
      type: Input
    }],
    refDate: [{
      type: Input
    }],
    resources: [{
      type: Input
    }],
    resourceHeaderTemplate: [{
      type: Input
    }],
    resourceFooterTemplate: [{
      type: Input
    }],
    resourceTemplate: [{
      type: Input
    }],
    resourceEmptyTemplate: [{
      type: Input
    }],
    slots: [{
      type: Input
    }],
    slotTemplate: [{
      type: Input
    }],
    scheduleEventContentTemplate: [{
      type: Input
    }],
    scheduleEventTemplate: [{
      type: Input
    }],
    selectedDate: [{
      type: Input
    }],
    selectedDateChange: [{
      type: Output
    }],
    selectedEvents: [{
      type: Input
    }],
    selectedEventsChange: [{
      type: Output
    }],
    selectMultipleEvents: [{
      type: Input
    }],
    showControls: [{
      type: Input
    }],
    showEventBuffer: [{
      type: Input
    }],
    showEventTooltip: [{
      type: Input
    }],
    sidebarFooterTemplate: [{
      type: Input
    }],
    sidebarHeaderTemplate: [{
      type: Input
    }],
    sidebarTemplate: [{
      type: Input
    }],
    quarterTemplate: [{
      type: Input
    }],
    quarterFooterTemplate: [{
      type: Input
    }],
    quarterText: [{
      type: Input
    }],
    valid: [{
      type: Input
    }],
    view: [{
      type: Input
    }],
    width: [{
      type: Input
    }],
    weekTemplate: [{
      type: Input
    }],
    weekFooterTemplate: [{
      type: Input
    }],
    yearTemplate: [{
      type: Input
    }],
    yearFooterTemplate: [{
      type: Input
    }],
    zoomLevel: [{
      type: Input
    }],
    allDayText: [{
      type: Input
    }],
    amText: [{
      type: Input
    }],
    dateFormat: [{
      type: Input
    }],
    dateFormatFull: [{
      type: Input
    }],
    dateFormatLong: [{
      type: Input
    }],
    dayNames: [{
      type: Input
    }],
    dayNamesMin: [{
      type: Input
    }],
    dayNamesShort: [{
      type: Input
    }],
    eventsText: [{
      type: Input
    }],
    eventText: [{
      type: Input
    }],
    firstDay: [{
      type: Input
    }],
    monthNames: [{
      type: Input
    }],
    monthNamesShort: [{
      type: Input
    }],
    moreEventsPluralText: [{
      type: Input
    }],
    moreEventsText: [{
      type: Input
    }],
    newEventText: [{
      type: Input
    }],
    nextPageText: [{
      type: Input
    }],
    noEventsText: [{
      type: Input
    }],
    pmText: [{
      type: Input
    }],
    prevPageText: [{
      type: Input
    }],
    timeFormat: [{
      type: Input
    }],
    timezonePlugin: [{
      type: Input
    }],
    onCellClick: [{
      type: Output
    }],
    onCellDoubleClick: [{
      type: Output
    }],
    onCellRightClick: [{
      type: Output
    }],
    onCellHoverIn: [{
      type: Output
    }],
    onCellHoverOut: [{
      type: Output
    }],
    onEventClick: [{
      type: Output
    }],
    onEventDoubleClick: [{
      type: Output
    }],
    onEventRightClick: [{
      type: Output
    }],
    onEventHoverIn: [{
      type: Output
    }],
    onEventHoverOut: [{
      type: Output
    }],
    onEventCreate: [{
      type: Output
    }],
    onEventCreated: [{
      type: Output
    }],
    onEventDelete: [{
      type: Output
    }],
    onEventDeleted: [{
      type: Output
    }],
    onEventDragEnd: [{
      type: Output
    }],
    onEventDragStart: [{
      type: Output
    }],
    onEventUpdate: [{
      type: Output
    }],
    onEventUpdated: [{
      type: Output
    }],
    onEventCreateFailed: [{
      type: Output
    }],
    onEventUpdateFailed: [{
      type: Output
    }],
    onEventDragEnter: [{
      type: Output
    }],
    onEventDragLeave: [{
      type: Output
    }],
    onLabelClick: [{
      type: Output
    }],
    onSelectedEventsChange: [{
      type: Output
    }],
    onPageChange: [{
      type: Output
    }],
    onPageLoaded: [{
      type: Output
    }],
    onPageLoading: [{
      type: Output
    }],
    onResourceClick: [{
      type: Output
    }],
    onResourceCollapse: [{
      type: Output
    }],
    onResourceDoubleClick: [{
      type: Output
    }],
    onResourceExpand: [{
      type: Output
    }],
    onResourceDragStart: [{
      type: Output
    }],
    onResourceCreate: [{
      type: Output
    }],
    onResourceCreated: [{
      type: Output
    }],
    onResourceDelete: [{
      type: Output
    }],
    onResourceDeleted: [{
      type: Output
    }],
    onResourceDragEnd: [{
      type: Output
    }],
    onResourceDragEnter: [{
      type: Output
    }],
    onResourceDragLeave: [{
      type: Output
    }],
    onResourceRightClick: [{
      type: Output
    }],
    onResourceOrderUpdate: [{
      type: Output
    }],
    onSelectedDateChange: [{
      type: Output
    }],
    onVirtualLoading: [{
      type: Output
    }]
  });
})();
var MbscListModule = function() {
  function MbscListModule2() {
  }
  MbscListModule2.ɵfac = function MbscListModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscListModule2)();
  };
  MbscListModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscListModule2,
    declarations: [ListBase, ListHeaderBase, ListItemBase, MbscList, MbscListHeader, MbscListItem],
    imports: [CommonModule],
    exports: [MbscList, MbscListHeader, MbscListItem]
  });
  MbscListModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscListModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscListModule, [{
    type: NgModule,
    args: [{
      declarations: [ListBase, ListHeaderBase, ListItemBase, MbscList, MbscListHeader, MbscListItem],
      exports: [MbscList, MbscListHeader, MbscListItem],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var MbscEventcalendarModule = function() {
  function MbscEventcalendarModule2() {
  }
  MbscEventcalendarModule2.ɵfac = function MbscEventcalendarModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscEventcalendarModule2)();
  };
  MbscEventcalendarModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscEventcalendarModule2,
    declarations: [EventcalendarBase, MbscEventcalendar, MbscEventListDayDirective, MbscEventListItem, MbscScheduleEvent, MbscScheduler, MbscTimeline, MbscWeekDay, MbscTimeIndicator, ScheduleEventBase, SchedulerBase, STBase, TimeIndicatorBase, TimelineBase, WeekDayBase],
    imports: [CommonModule, MbscCalendarHeaderModule, MbscCalendarViewModule, MbscIconModule, MbscListModule, MbscPopupModule],
    exports: [MbscEventcalendar, MbscEventListDayDirective, MbscEventListItem, MbscCalendarHeaderModule, MbscDraggableModule, MbscDropcontainerModule]
  });
  MbscEventcalendarModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscCalendarHeaderModule, MbscCalendarViewModule, MbscIconModule, MbscListModule, MbscPopupModule], MbscCalendarHeaderModule, MbscDraggableModule, MbscDropcontainerModule]
  });
  return MbscEventcalendarModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscEventcalendarModule, [{
    type: NgModule,
    args: [{
      declarations: [EventcalendarBase, MbscEventcalendar, MbscEventListDayDirective, MbscEventListItem, MbscScheduleEvent, MbscScheduler, MbscTimeline, MbscWeekDay, MbscTimeIndicator, ScheduleEventBase, SchedulerBase, STBase, TimeIndicatorBase, TimelineBase, WeekDayBase],
      exports: [MbscEventcalendar, MbscEventListDayDirective, MbscEventListItem, MbscCalendarHeaderModule, MbscDraggableModule, MbscDropcontainerModule],
      imports: [CommonModule, MbscCalendarHeaderModule, MbscCalendarViewModule, MbscIconModule, MbscListModule, MbscPopupModule]
    }]
  }], null, null);
})();
var CheckboxBase = function(_super) {
  __extends(CheckboxBase2, _super);
  function CheckboxBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onChange = function(ev) {
      var s = _this.s;
      var checked = ev.target.checked;
      if (s.checked === UNDEFINED) {
        _this._checked = checked;
        _this.setState({
          checked
        });
      }
      _this._change(checked);
      if (s.onChange) {
        s.onChange(ev);
      }
    };
    _this._setInput = function(input) {
      _this._input = input;
    };
    return _this;
  }
  CheckboxBase2.prototype._change = function(checked) {
  };
  CheckboxBase2.prototype._mounted = function() {
    var _this = this;
    this._unlisten = gestureListener(this._input, {
      click: true,
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onFocus: function() {
        _this.setState({
          hasFocus: true
        });
      },
      onPress: function() {
        _this.setState({
          isActive: true
        });
      },
      onRelease: function() {
        _this.setState({
          isActive: false
        });
      }
    });
  };
  CheckboxBase2.prototype._render = function(s, state) {
    var disabled = s.disabled === UNDEFINED ? state.disabled : emptyOrTrue(s.disabled);
    var position = s.position === "start" ? s.rtl ? "right" : "left" : s.rtl ? "left" : "right";
    var modelValue = s.modelValue !== UNDEFINED ? s.modelValue : s.checked;
    this._disabled = disabled;
    this._checked = modelValue !== UNDEFINED ? emptyOrTrue(modelValue) : state.checked === UNDEFINED ? emptyOrTrue(s.defaultChecked) : state.checked;
    this._cssClass = "mbsc-checkbox mbsc-form-control-wrapper mbsc-font " + this._className + this._theme + this._rtl + this._hb + " mbsc-checkbox-" + position + (disabled ? " mbsc-disabled" : "");
    this._boxClass = "mbsc-checkbox-box" + this._theme + " mbsc-checkbox-box-" + position + (state.hasFocus && !disabled ? " mbsc-focus" : "") + (state.isActive && !disabled ? " mbsc-active" : "") + (s.color ? " mbsc-checkbox-box-" + s.color : "") + (disabled ? " mbsc-disabled" : "") + (this._checked ? " mbsc-checked" : "");
  };
  CheckboxBase2.prototype._destroy = function() {
    if (this._unlisten) {
      this._unlisten();
    }
  };
  CheckboxBase2.defaults = {
    position: "start"
  };
  CheckboxBase2._name = "Checkbox";
  CheckboxBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵCheckboxBase_BaseFactory;
    return function CheckboxBase_Factory(__ngFactoryType__) {
      return (ɵCheckboxBase_BaseFactory || (ɵCheckboxBase_BaseFactory = ɵɵgetInheritedFactory(CheckboxBase2)))(__ngFactoryType__ || CheckboxBase2);
    };
  })();
  CheckboxBase2.ɵdir = ɵɵdefineDirective({
    type: CheckboxBase2,
    selectors: [["", "mbsc-cb-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return CheckboxBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-cb-b]"
    }]
  }], null, null);
})();
var MbscCheckbox = function(_super) {
  __extends(MbscCheckbox2, _super);
  function MbscCheckbox2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Object.defineProperty(MbscCheckbox2.prototype, "checked", {
    get: function() {
      return this._check;
    },
    set: function(val) {
      if (this._check !== val) {
        this.props.checked = val;
        this._onFormChange(val);
        this._check = val;
        this.setState({
          checked: val
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  MbscCheckbox2.prototype.registerOnChange = function(fn) {
    this._onFormChange = fn;
  };
  MbscCheckbox2.prototype.registerOnTouched = function(fn) {
    this._onFormTouch = fn;
  };
  MbscCheckbox2.prototype.setDisabledState = function(disabled) {
    this.setState({
      disabled
    });
  };
  MbscCheckbox2.prototype.writeValue = function(val) {
    this.checked = val;
  };
  MbscCheckbox2.prototype._change = function(checked) {
    this.checked = checked;
  };
  MbscCheckbox2.prototype._mounted = function() {
    this._input = this.vInput.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscCheckbox2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscCheckbox_BaseFactory;
    return function MbscCheckbox_Factory(__ngFactoryType__) {
      return (ɵMbscCheckbox_BaseFactory || (ɵMbscCheckbox_BaseFactory = ɵɵgetInheritedFactory(MbscCheckbox2)))(__ngFactoryType__ || MbscCheckbox2);
    };
  })();
  MbscCheckbox2.ɵcmp = ɵɵdefineComponent({
    type: MbscCheckbox2,
    selectors: [["mbsc-checkbox"]],
    viewQuery: function MbscCheckbox_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscCheckbox_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      color: "color",
      defaultChecked: "defaultChecked",
      description: "description",
      disabled: "disabled",
      inputStyle: "inputStyle",
      label: "label",
      name: "name",
      position: "position",
      checked: "checked"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 6,
    vars: 7,
    consts: [["input", ""], ["type", "checkbox", 1, "mbsc-form-control-input", "mbsc-reset", 3, "blur", "change", "checked", "disabled", "name"], [3, "class", 4, "ngIf"]],
    template: function MbscCheckbox_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵelementStart(0, "input", 1, 0);
        ɵɵlistener("blur", function MbscCheckbox_Template_input_blur_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onFormTouch($event));
        })("change", function MbscCheckbox_Template_input_change_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onChange($event));
        });
        ɵɵelementEnd();
        ɵɵelement(2, "span");
        ɵɵtemplate(3, MbscCheckbox_span_3_Template, 2, 3, "span", 2)(4, MbscCheckbox_span_4_Template, 2, 3, "span", 2);
        ɵɵprojection(5);
      }
      if (rf & 2) {
        ɵɵproperty("checked", ctx2._checked)("disabled", ctx2._disabled)("name", ctx2.name || "");
        ɵɵadvance(2);
        ɵɵclassMap(ctx2._boxClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.label);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.description);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscCheckbox2;
}(CheckboxBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCheckbox, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-checkbox",
      template: `
    <input
      #input
      type="checkbox"
      class="mbsc-form-control-input mbsc-reset"
      (blur)="_onFormTouch($event)"
      (change)="_onChange($event)"
      [checked]="_checked"
      [disabled]="_disabled"
      [name]="name || ''"
    />
    <span [class]="_boxClass"></span>
    <span *ngIf="s.label" [class]="'mbsc-form-control-label' + _theme + (_disabled ? ' mbsc-disabled' : '')">{{ s.label }}</span>
    <span *ngIf="s.description" [class]="'mbsc-description' + _theme + (_disabled ? ' mbsc-disabled' : '')">{{ s.description }}</span>
    <ng-content></ng-content>
  `
    }]
  }], null, {
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    color: [{
      type: Input
    }],
    defaultChecked: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    inputStyle: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    checked: [{
      type: Input
    }]
  });
})();
var MbscCheckboxModule = function() {
  function MbscCheckboxModule2() {
  }
  MbscCheckboxModule2.ɵfac = function MbscCheckboxModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscCheckboxModule2)();
  };
  MbscCheckboxModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscCheckboxModule2,
    declarations: [CheckboxBase, MbscCheckbox],
    imports: [CommonModule],
    exports: [MbscCheckbox]
  });
  MbscCheckboxModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscCheckboxModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscCheckboxModule, [{
    type: NgModule,
    args: [{
      declarations: [CheckboxBase, MbscCheckbox],
      exports: [MbscCheckbox],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var popupQueue = [];
var notificationQueue = [];
var hasPromise = isBrowser && !!win.Promise;
function getOptions(queue, options2, more, destroy, resolve) {
  return __assign({
    closeOnOverlayClick: false,
    context: options2.context,
    cssClass: "mbsc-alert",
    display: options2.display || "center",
    onClose: function() {
      queue.shift();
    },
    onClosed: function() {
      handleClose(options2, destroy, resolve);
    },
    theme: options2.theme,
    themeVariant: options2.themeVariant
  }, more);
}
function getToastSnackbarOptions(options2, destroy, resolve, isToast) {
  return getOptions(notificationQueue, options2, {
    animation: options2.animation || (isToast ? "pop" : UNDEFINED),
    buttons: [],
    closeOnOverlayClick: false,
    contentPadding: isToast,
    cssClass: "mbsc-" + (isToast ? "toast" : "snackbar") + " mbsc-" + (options2.color ? options2.color : "color-none") + " " + (options2.cssClass || ""),
    display: options2.display || "bottom",
    focusOnClose: false,
    focusOnOpen: false,
    focusTrap: false,
    onOpen: function(ev, inst) {
      handleOpen(options2, inst);
    },
    scrollLock: false,
    setActive: false,
    showOverlay: false,
    touchUi: true
  }, destroy, resolve);
}
function handleClose(options2, destroy, resolve, result) {
  if (resolve) {
    resolve(result);
  }
  if (options2.callback) {
    options2.callback(result);
  }
  if (options2.onClose) {
    options2.onClose(result);
  }
  if (popupQueue.length) {
    popupQueue[0].open();
  } else if (notificationQueue.length) {
    notificationQueue[0].open();
  }
  if (destroy) {
    destroy();
  }
}
function handleOpen(options2, inst) {
  if (options2.duration !== false) {
    setTimeout(function() {
      inst.close();
    }, options2.duration || 3e3);
  }
}
function getToastOptions(options2, destroy, resolve) {
  return getToastSnackbarOptions(options2, destroy, resolve, true);
}
function getSnackbarOptions(options2, destroy, resolve) {
  return getToastSnackbarOptions(options2, destroy, resolve, false);
}
function getAlertOptions(options2, destroy, resolve) {
  return getOptions(popupQueue, options2, {
    buttons: ["ok"],
    cssClass: "mbsc-alert " + (options2.cssClass || ""),
    okText: options2.okText || "OK"
  }, destroy, resolve);
}
function getConfirmOptions(options2, destroy, resolve) {
  var result = false;
  return getOptions(popupQueue, options2, {
    buttons: ["cancel", "ok"],
    cancelText: options2.cancelText || "Cancel",
    cssClass: "mbsc-confirm " + (options2.cssClass || ""),
    okText: options2.okText || "OK",
    onButtonClick: function(ev) {
      if (ev.button.name === "ok") {
        result = true;
      }
    },
    onClosed: function() {
      handleClose(options2, destroy, resolve, result);
    }
  }, destroy, resolve);
}
function getPromptOptions(options2, destroy, resolve, getValue2, resetValue) {
  var okClicked;
  return getOptions(popupQueue, options2, {
    activeElm: "input",
    buttons: ["cancel", "ok"],
    cancelText: options2.cancelText || "Cancel",
    cssClass: "mbsc-prompt " + (options2.cssClass || ""),
    okText: options2.okText || "OK",
    onButtonClick: function(ev) {
      if (ev.button.name === "ok") {
        okClicked = true;
      }
    },
    onClosed: function() {
      handleClose(options2, destroy, resolve, okClicked && getValue2 ? getValue2() : null);
      if (resetValue) {
        setTimeout(function() {
          resetValue();
        });
      }
    }
  }, destroy, resolve);
}
function showModal(popup) {
  if (!popupQueue.length) {
    popup.open();
  }
  popupQueue.push(popup);
}
function showNotification(notification) {
  var activeNotification = notificationQueue[0];
  notificationQueue.push(notification);
  if (!popupQueue.length) {
    if (activeNotification) {
      activeNotification.close();
    } else {
      notification.open();
    }
  }
}
function promise(func, options2) {
  var p;
  if (hasPromise) {
    p = new Promise(function(resolve) {
      func(options2, resolve);
    });
  } else {
    func(options2, noop);
  }
  return p;
}
function getAlertElm(options2) {
  var elm = doc.createElement("div");
  elm.className = "mbsc-alert-content";
  elm.innerHTML = '<h2 class="mbsc-alert-title">' + options2.title + '</h2><p class="mbsc-alert-message">' + options2.message + "</p>";
  return elm;
}
var Notifications = function() {
  function Notifications2(_injector, _cfr, _app) {
    var _this = this;
    this._injector = _injector;
    this._cfr = _cfr;
    this._app = _app;
    this._showToast = function(options2, resolve) {
      var elm = doc.createElement("div");
      elm.className = "mbsc-toast-background mbsc-toast-message";
      elm.innerText = options2.message;
      var instance = _this._createPopup(MbscPopup, options2, getToastOptions, resolve, elm);
      showNotification(instance);
    };
    this._showSnackbar = function(options2, resolve) {
      var instance = _this._createPopup(MbscSnackbar, options2, getSnackbarOptions, resolve);
      instance.button = options2.button;
      instance.message = options2.message;
      setTimeout(function() {
        showNotification(instance.popup);
      });
    };
    this._showAlert = function(options2, resolve) {
      var elm = getAlertElm(options2);
      var instance = _this._createPopup(MbscPopup, options2, getAlertOptions, resolve, elm);
      showModal(instance);
    };
    this._showConfirm = function(options2, resolve) {
      var elm = getAlertElm(options2);
      var instance = _this._createPopup(MbscPopup, options2, getConfirmOptions, resolve, elm);
      showModal(instance);
    };
    this._showPrompt = function(options2, resolve) {
      var instance = _this._createPopup(MbscPrompt, options2, getPromptOptions, resolve, UNDEFINED, function() {
        return instance.value;
      });
      instance.inputType = options2.inputType;
      instance.label = options2.label;
      instance.message = options2.message;
      instance.placeholder = options2.placeholder;
      instance.title = options2.title;
      setTimeout(function() {
        showModal(instance.popup);
      });
    };
    this._cfr = this._injector.get(ComponentFactoryResolver$1);
  }
  Notifications2.prototype.toast = function(options2) {
    return promise(this._showToast, options2);
  };
  Notifications2.prototype.snackbar = function(options2) {
    return promise(this._showSnackbar, options2);
  };
  Notifications2.prototype.alert = function(options2) {
    return promise(this._showAlert, options2);
  };
  Notifications2.prototype.confirm = function(options2) {
    return promise(this._showConfirm, options2);
  };
  Notifications2.prototype.prompt = function(options2) {
    return promise(this._showPrompt, options2);
  };
  Notifications2.prototype._createPopup = function(Comp, options2, getPopupOptions, resolve, body, getValue2) {
    var componentFactory = this._cfr.resolveComponentFactory(Comp);
    var host = doc.createElement("div");
    var ref = componentFactory.create(this._injector, [[body]], host);
    var instance = ref.instance;
    var destroy = function() {
      ref.destroy();
    };
    instance.props = getPopupOptions(options2, destroy, resolve, getValue2);
    this._app.attachView(ref.hostView);
    return instance;
  };
  Notifications2.ɵfac = function Notifications_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || Notifications2)(ɵɵinject(Injector), ɵɵinject(ComponentFactoryResolver$1), ɵɵinject(ApplicationRef));
  };
  Notifications2.ɵprov = ɵɵdefineInjectable({
    token: Notifications2,
    factory: Notifications2.ɵfac
  });
  return Notifications2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Notifications, [{
    type: Injectable
  }], function() {
    return [{
      type: Injector
    }, {
      type: ComponentFactoryResolver$1
    }, {
      type: ApplicationRef
    }];
  }, null);
})();
var MbscNotificationsModule = function() {
  function MbscNotificationsModule2() {
  }
  MbscNotificationsModule2.ɵfac = function MbscNotificationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscNotificationsModule2)();
  };
  MbscNotificationsModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscNotificationsModule2,
    imports: [MbscInputModule, MbscPopupModule]
  });
  MbscNotificationsModule2.ɵinj = ɵɵdefineInjector({
    providers: [Notifications],
    imports: [[MbscInputModule, MbscPopupModule]]
  });
  return MbscNotificationsModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscNotificationsModule, [{
    type: NgModule,
    args: [{
      imports: [MbscInputModule, MbscPopupModule],
      providers: [Notifications]
    }]
  }], null, null);
})();
var PageBase = function(_super) {
  __extends(PageBase2, _super);
  function PageBase2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  PageBase2.prototype._render = function(s) {
    this._cssClass = "mbsc-page mbsc-font ".concat(this._className).concat(this._theme).concat(this._rtl);
  };
  PageBase2.defaults = {};
  PageBase2._name = "Page";
  PageBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵPageBase_BaseFactory;
    return function PageBase_Factory(__ngFactoryType__) {
      return (ɵPageBase_BaseFactory || (ɵPageBase_BaseFactory = ɵɵgetInheritedFactory(PageBase2)))(__ngFactoryType__ || PageBase2);
    };
  })();
  PageBase2.ɵdir = ɵɵdefineDirective({
    type: PageBase2,
    selectors: [["", "mbsc-page-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return PageBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-page-b]"
    }]
  }], null, null);
})();
var MbscPage = function(_super) {
  __extends(MbscPage2, _super);
  function MbscPage2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscPage2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscPage_BaseFactory;
    return function MbscPage_Factory(__ngFactoryType__) {
      return (ɵMbscPage_BaseFactory || (ɵMbscPage_BaseFactory = ɵɵgetInheritedFactory(MbscPage2)))(__ngFactoryType__ || MbscPage2);
    };
  })();
  MbscPage2.ɵcmp = ɵɵdefineComponent({
    type: MbscPage2,
    selectors: [["mbsc-page"]],
    hostVars: 2,
    hostBindings: function MbscPage_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscPage_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscPage2;
}(PageBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscPage, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-page",
      template: "<ng-content></ng-content>"
    }]
  }], null, null);
})();
var MbscPageModule = function() {
  function MbscPageModule2() {
  }
  MbscPageModule2.ɵfac = function MbscPageModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscPageModule2)();
  };
  MbscPageModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscPageModule2,
    declarations: [MbscPage, PageBase],
    imports: [CommonModule],
    exports: [MbscPage]
  });
  MbscPageModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscPageModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscPageModule, [{
    type: NgModule,
    args: [{
      declarations: [MbscPage, PageBase],
      exports: [MbscPage],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var guid$3 = 1;
var RadioBase = function(_super) {
  __extends(RadioBase2, _super);
  function RadioBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._setInput = function(inp) {
      _this._input = inp;
    };
    _this._onChange = function(ev) {
      var s = _this.s;
      var checked = ev.target.checked;
      _this._change(checked);
      if (_this._onGroupChange) {
        _this._onGroupChange(ev, _this._value);
      }
      _this._toggle(checked);
      if (s.onChange) {
        s.onChange(ev);
      }
    };
    _this._onValueChange = function(value) {
      var s = _this.s;
      var checked = value === _this._value;
      if (s.checked === UNDEFINED) {
        _this.setState({
          checked
        });
      }
      _this._change(checked);
    };
    return _this;
  }
  RadioBase2.prototype._change = function(checked) {
  };
  RadioBase2.prototype._groupOptions = function(_a) {
    var color = _a.color, disabled = _a.disabled, name = _a.name, onChange = _a.onChange, position = _a.position, rtl = _a.rtl, value = _a.value;
    var s = this.s;
    var state = this.state;
    var isRtl = rtl === UNDEFINED ? s.rtl : rtl;
    var col = color === UNDEFINED ? s.color : color;
    var p = position === UNDEFINED ? s.position : position;
    var pos = p === "start" ? s.rtl ? "right" : "left" : s.rtl ? "left" : "right";
    var dis = disabled === UNDEFINED ? s.disabled === UNDEFINED ? state.disabled : emptyOrTrue(s.disabled) : emptyOrTrue(disabled);
    var modelValue = s.modelValue !== UNDEFINED ? s.modelValue === s.value : s.checked;
    var checked = modelValue !== UNDEFINED ? emptyOrTrue(modelValue) : state.checked === UNDEFINED ? emptyOrTrue(s.defaultChecked) : state.checked;
    this._id = s.id === UNDEFINED ? this._id || "mbsc-radio-" + guid$3++ : s.id;
    this._value = s.value === UNDEFINED ? this._id : s.value;
    this._onGroupChange = onChange;
    this._name = name === UNDEFINED ? s.name : name;
    this._rtl = isRtl ? " mbsc-rtl" : " mbsc-ltr";
    this._checked = value === UNDEFINED ? checked : value === this._value;
    this._disabled = dis;
    this._cssClass = "mbsc-radio mbsc-form-control-wrapper mbsc-font " + this._className + this._theme + this._rtl + this._hb + " mbsc-radio-" + pos + (dis ? " mbsc-disabled" : "");
    this._boxClass = "mbsc-radio-box" + this._theme + " mbsc-radio-box-" + pos + (state.hasFocus && !dis ? " mbsc-focus" : "") + (state.isActive && !dis ? " mbsc-active" : "") + (col ? " mbsc-radio-box-" + col : "") + (dis ? " mbsc-disabled" : "") + (this._checked ? " mbsc-checked" : "");
  };
  RadioBase2.prototype._toggle = function(checked) {
    if (this.s.checked === UNDEFINED) {
      this.setState({
        checked
      });
    }
    if (checked) {
      setRadio(this._name, this._value);
    }
  };
  RadioBase2.prototype._mounted = function() {
    var _this = this;
    this._unlisten = gestureListener(this._input, {
      click: true,
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onFocus: function() {
        _this.setState({
          hasFocus: true
        });
      },
      onPress: function() {
        _this.setState({
          isActive: true
        });
      },
      onRelease: function() {
        _this.setState({
          isActive: false
        });
      }
    });
  };
  RadioBase2.prototype._updated = function() {
    if (this._name && !this._unsubscribe) {
      this._unsubscribe = subscribeRadio(this._name, this._onValueChange);
    }
  };
  RadioBase2.prototype._destroy = function() {
    if (this._unsubscribe) {
      unsubscribeRadio(this._name, this._unsubscribe);
      this._unsubscribe = UNDEFINED;
    }
    if (this._unlisten) {
      this._unlisten();
    }
  };
  RadioBase2.defaults = {
    position: "start"
  };
  RadioBase2._name = "Radio";
  RadioBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵRadioBase_BaseFactory;
    return function RadioBase_Factory(__ngFactoryType__) {
      return (ɵRadioBase_BaseFactory || (ɵRadioBase_BaseFactory = ɵɵgetInheritedFactory(RadioBase2)))(__ngFactoryType__ || RadioBase2);
    };
  })();
  RadioBase2.ɵdir = ɵɵdefineDirective({
    type: RadioBase2,
    selectors: [["", "mbsc-radio-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return RadioBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-radio-b]"
    }]
  }], null, null);
})();
var guid$2 = 1;
var RadioGroupBase = function(_super) {
  __extends(RadioGroupBase2, _super);
  function RadioGroupBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._id = "mbsc-radio-group" + guid$2++;
    _this._onChange = function(ev, val) {
      var s = _this.s;
      _this.value = val;
      _this._change(val);
      if (s.onChange) {
        s.onChange(ev);
      }
    };
    return _this;
  }
  RadioGroupBase2.prototype._change = function(value) {
  };
  RadioGroupBase2.prototype._render = function(s) {
    this._name = s.name === UNDEFINED ? this._id : s.name;
    this._groupClass = "mbsc-radio-group" + this._theme + this._rtl;
    this._groupOpt = {
      color: s.color,
      disabled: s.disabled,
      name: this._name,
      onChange: this._onChange,
      position: s.position,
      rtl: s.rtl,
      value: s.modelValue !== UNDEFINED ? s.modelValue : s.value
    };
  };
  RadioGroupBase2.defaults = {};
  RadioGroupBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵRadioGroupBase_BaseFactory;
    return function RadioGroupBase_Factory(__ngFactoryType__) {
      return (ɵRadioGroupBase_BaseFactory || (ɵRadioGroupBase_BaseFactory = ɵɵgetInheritedFactory(RadioGroupBase2)))(__ngFactoryType__ || RadioGroupBase2);
    };
  })();
  RadioGroupBase2.ɵdir = ɵɵdefineDirective({
    type: RadioGroupBase2,
    selectors: [["", "mbsc-rg-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return RadioGroupBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioGroupBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-rg-b]"
    }]
  }], null, null);
})();
var MbscRadio = function(_super) {
  __extends(MbscRadio2, _super);
  function MbscRadio2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.checkedChange = new EventEmitter();
    return _this;
  }
  Object.defineProperty(MbscRadio2.prototype, "checked", {
    get: function() {
      return this._check;
    },
    set: function(val) {
      var rs = this._radioService;
      if (this._check !== val) {
        if (val) {
          if (rs) {
            rs.value = this.value;
          }
          this._onFormChange(this.value);
        }
        this.props.checked = val;
        this._check = val;
        this.setState({
          checked: val
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  MbscRadio2.prototype.registerOnChange = function(fn) {
    this._onFormChange = fn;
  };
  MbscRadio2.prototype.registerOnTouched = function(fn) {
    this._onFormTouch = fn;
  };
  MbscRadio2.prototype.setDisabledState = function(disabled) {
    this.setState({
      disabled
    });
  };
  MbscRadio2.prototype.writeValue = function(val) {
    this.checked = this.value === val;
  };
  MbscRadio2.prototype._change = function(checked) {
    this.checked = checked;
  };
  MbscRadio2.prototype._ctor = function() {
    this._radioService = this._injector.get(MbscRadioService, null);
  };
  MbscRadio2.prototype._mounted = function() {
    this._input = this.vInput.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscRadio2.prototype._render = function(s, state) {
    this._groupOptions(this._radioService || {});
    _super.prototype._render.call(this, s, state);
  };
  MbscRadio2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscRadio_BaseFactory;
    return function MbscRadio_Factory(__ngFactoryType__) {
      return (ɵMbscRadio_BaseFactory || (ɵMbscRadio_BaseFactory = ɵɵgetInheritedFactory(MbscRadio2)))(__ngFactoryType__ || MbscRadio2);
    };
  })();
  MbscRadio2.ɵcmp = ɵɵdefineComponent({
    type: MbscRadio2,
    selectors: [["mbsc-radio"]],
    viewQuery: function MbscRadio_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscRadio_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      color: "color",
      description: "description",
      disabled: "disabled",
      id: "id",
      label: "label",
      name: "name",
      position: "position",
      checked: "checked"
    },
    outputs: {
      checkedChange: "checkedChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 6,
    vars: 8,
    consts: [["input", ""], ["type", "radio", 1, "mbsc-form-control-input", "mbsc-reset", 3, "blur", "change", "checked", "disabled", "name", "value"], [3, "class", 4, "ngIf"]],
    template: function MbscRadio_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵprojectionDef();
        ɵɵelementStart(0, "input", 1, 0);
        ɵɵlistener("blur", function MbscRadio_Template_input_blur_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onFormTouch($event));
        })("change", function MbscRadio_Template_input_change_0_listener($event) {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onChange($event));
        });
        ɵɵelementEnd();
        ɵɵelement(2, "span");
        ɵɵtemplate(3, MbscRadio_span_3_Template, 2, 3, "span", 2)(4, MbscRadio_span_4_Template, 2, 3, "span", 2);
        ɵɵprojection(5);
      }
      if (rf & 2) {
        ɵɵproperty("checked", ctx2._checked)("disabled", ctx2._disabled)("name", ctx2._name)("value", ctx2._value);
        ɵɵadvance(2);
        ɵɵclassMap(ctx2._boxClass);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.label);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.description);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscRadio2;
}(RadioBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscRadio, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-radio",
      template: `
    <input
      #input
      type="radio"
      class="mbsc-form-control-input mbsc-reset"
      (blur)="_onFormTouch($event)"
      (change)="_onChange($event)"
      [checked]="_checked"
      [disabled]="_disabled"
      [name]="_name"
      [value]="_value"
    />
    <span [class]="_boxClass"></span>
    <span *ngIf="s.label" [class]="'mbsc-form-control-label' + _theme + (_disabled ? ' mbsc-disabled' : '')">{{ s.label }}</span>
    <span *ngIf="s.description" [class]="'mbsc-description' + _theme + (_disabled ? ' mbsc-disabled' : '')">{{ s.description }}</span>
    <ng-content></ng-content>
  `
    }]
  }], null, {
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    color: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    checkedChange: [{
      type: Output
    }],
    checked: [{
      type: Input
    }]
  });
})();
var MbscRadioGroup = function(_super) {
  __extends(MbscRadioGroup2, _super);
  function MbscRadioGroup2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  MbscRadioGroup2.prototype._onValueChange = function(value) {
    this._radioService.value = value;
    setRadio(this._radioService.name, value);
  };
  MbscRadioGroup2.prototype._ctor = function() {
    this._radioService = this._injector.get(MbscRadioService);
  };
  MbscRadioGroup2.prototype._render = function(s) {
    _super.prototype._render.call(this, s);
    var rs = this._radioService;
    rs.color = s.color;
    rs.disabled = s.disabled;
    rs.name = this._name;
    rs.value = this.value;
    rs.onChange = this._onChange;
    rs.position = s.position;
  };
  MbscRadioGroup2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscRadioGroup_BaseFactory;
    return function MbscRadioGroup_Factory(__ngFactoryType__) {
      return (ɵMbscRadioGroup_BaseFactory || (ɵMbscRadioGroup_BaseFactory = ɵɵgetInheritedFactory(MbscRadioGroup2)))(__ngFactoryType__ || MbscRadioGroup2);
    };
  })();
  MbscRadioGroup2.ɵcmp = ɵɵdefineComponent({
    type: MbscRadioGroup2,
    selectors: [["mbsc-radio-group"]],
    hostVars: 2,
    hostBindings: function MbscRadioGroup_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._groupClass);
      }
    },
    inputs: {
      color: "color",
      disabled: "disabled",
      name: "name",
      position: "position"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([MbscRadioService]), ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscRadioGroup_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  MbscRadioGroup2 = __decorate([FormControl], MbscRadioGroup2);
  return MbscRadioGroup2;
}(RadioGroupBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscRadioGroup, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_groupClass"
      },
      providers: [MbscRadioService],
      selector: "mbsc-radio-group",
      template: "<ng-content></ng-content>"
    }]
  }], null, {
    color: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    position: [{
      type: Input
    }]
  });
})();
var MbscRadioModule = function() {
  function MbscRadioModule2() {
  }
  MbscRadioModule2.ɵfac = function MbscRadioModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscRadioModule2)();
  };
  MbscRadioModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscRadioModule2,
    declarations: [RadioBase, RadioGroupBase, MbscRadio, MbscRadioGroup],
    imports: [CommonModule],
    exports: [MbscRadio, MbscRadioGroup]
  });
  MbscRadioModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscRadioModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscRadioModule, [{
    type: NgModule,
    args: [{
      declarations: [RadioBase, RadioGroupBase, MbscRadio, MbscRadioGroup],
      exports: [MbscRadio, MbscRadioGroup],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var StepperBase = function(_super) {
  __extends(StepperBase2, _super);
  function StepperBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onChange = function(ev) {
      var s = _this.s;
      var val = _this._round(+ev.target.value);
      ev.target.value = val + "";
      if (s.value === UNDEFINED) {
        _this.setState({
          value: val
        });
      }
      _this._change(val);
      if (s.onChange) {
        s.onChange(ev);
      }
    };
    _this._onMinusClick = function() {
      _this._setValue(_this._value - _this._step);
    };
    _this._onPlusClick = function() {
      _this._setValue(_this._value + _this._step);
    };
    _this._setInput = function(input) {
      _this._input = input;
    };
    _this._onLabelClick = function(ev) {
      ev.preventDefault();
    };
    return _this;
  }
  StepperBase2.prototype._change = function(val) {
  };
  StepperBase2.prototype._mounted = function() {
    listen(this._input, CHANGE, this._onChange);
  };
  StepperBase2.prototype._render = function(s, state) {
    this._max = isEmpty(s.max) ? 100 : +s.max;
    this._min = isEmpty(s.min) ? 0 : +s.min;
    this._step = isEmpty(s.step) ? 1 : +s.step;
    var disabled = s.disabled === UNDEFINED ? state.disabled : emptyOrTrue(s.disabled);
    var defVal = s.defaultValue !== UNDEFINED ? s.defaultValue : this._min || 0;
    var modelValue = s.modelValue !== UNDEFINED ? s.modelValue : s.value;
    var val = modelValue !== UNDEFINED ? modelValue : state.value !== UNDEFINED ? state.value : defVal;
    this._value = this._round(val);
    this._changed = this._value !== +val;
    this._disabled = disabled;
    this._disabledMinus = this._value === this._min || disabled;
    this._disabledPlus = this._value === this._max || disabled;
    this._cssClass = "mbsc-stepper mbsc-form-control-wrapper mbsc-font mbsc-" + (s.color || "color-none") + this._theme + this._rtl + this._hb + " mbsc-stepper-" + s.inputPosition + (disabled ? " mbsc-disabled" : "");
  };
  StepperBase2.prototype._updated = function() {
    this._input.value = this._value + "";
    if (this._changed) {
      trigger(this._input, CHANGE);
      this._changed = false;
    }
  };
  StepperBase2.prototype._destroy = function() {
    unlisten(this._input, CHANGE, this._onChange);
  };
  StepperBase2.prototype._round = function(v) {
    var step2 = this._step;
    var scale = Math.abs(step2) < 1 ? (step2 + "").split(".")[1].length : 0;
    return +Math.min(this._max, Math.max(Math.round(v / step2) * step2, this._min)).toFixed(scale);
  };
  StepperBase2.prototype._setValue = function(val) {
    var oldValue = +this._input.value;
    var newValue = this._round(val);
    if (oldValue !== newValue) {
      this._input.value = newValue + "";
      trigger(this._input, CHANGE);
    }
  };
  StepperBase2.defaults = {
    inputPosition: "center"
  };
  StepperBase2._name = "Stepper";
  StepperBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵStepperBase_BaseFactory;
    return function StepperBase_Factory(__ngFactoryType__) {
      return (ɵStepperBase_BaseFactory || (ɵStepperBase_BaseFactory = ɵɵgetInheritedFactory(StepperBase2)))(__ngFactoryType__ || StepperBase2);
    };
  })();
  StepperBase2.ɵdir = ɵɵdefineDirective({
    type: StepperBase2,
    selectors: [["", "mbsc-stepper", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return StepperBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-stepper]"
    }]
  }], null, null);
})();
var guid$1 = 0;
var MbscStepper = function(_super) {
  __extends(MbscStepper2, _super);
  function MbscStepper2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.onChange = new EventEmitter();
    _this._id = "mbsc-stepper-" + guid$1++;
    return _this;
  }
  MbscStepper2.prototype._change = function(value) {
    this.value = value;
  };
  MbscStepper2.prototype._mounted = function() {
    this._input = this.vInput.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscStepper2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscStepper_BaseFactory;
    return function MbscStepper_Factory(__ngFactoryType__) {
      return (ɵMbscStepper_BaseFactory || (ɵMbscStepper_BaseFactory = ɵɵgetInheritedFactory(MbscStepper2)))(__ngFactoryType__ || MbscStepper2);
    };
  })();
  MbscStepper2.ɵcmp = ɵɵdefineComponent({
    type: MbscStepper2,
    selectors: [["mbsc-stepper"]],
    viewQuery: function MbscStepper_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscStepper_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      color: "color",
      defaultValue: "defaultValue",
      description: "description",
      disabled: "disabled",
      id: "id",
      inputPosition: "inputPosition",
      label: "label",
      min: "min",
      max: "max",
      name: "name",
      readonly: "readonly",
      step: "step"
    },
    outputs: {
      onChange: "onChange"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    decls: 12,
    vars: 24,
    consts: [["input", ""], [1, "mbsc-stepper-content", 3, "for"], [3, "class", 4, "ngIf"], [1, "mbsc-stepper-minus", "mbsc-stepper-button", 3, "click", "disabled", "theme", "themeVariant"], ["type", "number", 3, "disabled", "id", "max", "min", "readonly", "step"], [1, "mbsc-stepper-plus", "mbsc-stepper-button", 3, "click", "disabled", "theme", "themeVariant"]],
    template: function MbscStepper_Template(rf, ctx2) {
      if (rf & 1) {
        const _r1 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "label", 1);
        ɵɵtemplate(1, MbscStepper_span_1_Template, 2, 3, "span", 2)(2, MbscStepper_span_2_Template, 2, 3, "span", 2);
        ɵɵelementEnd();
        ɵɵelementStart(3, "div")(4, "mbsc-button", 3);
        ɵɵlistener("click", function MbscStepper_Template_mbsc_button_click_4_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onMinusClick());
        });
        ɵɵelementStart(5, "span");
        ɵɵtext(6, "–");
        ɵɵelementEnd()();
        ɵɵelement(7, "input", 4, 0);
        ɵɵelementStart(9, "mbsc-button", 5);
        ɵɵlistener("click", function MbscStepper_Template_mbsc_button_click_9_listener() {
          ɵɵrestoreView(_r1);
          return ɵɵresetView(ctx2._onPlusClick());
        });
        ɵɵelementStart(10, "span");
        ɵɵtext(11, "+");
        ɵɵelementEnd()()();
      }
      if (rf & 2) {
        ɵɵproperty("for", ctx2.id || ctx2._id);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.label);
        ɵɵadvance();
        ɵɵproperty("ngIf", ctx2.s.description);
        ɵɵadvance();
        ɵɵclassMap("mbsc-stepper-control mbsc-flex" + ctx2._theme + ctx2._rtl);
        ɵɵadvance();
        ɵɵproperty("disabled", ctx2._disabledMinus)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant);
        ɵɵadvance();
        ɵɵclassMap("mbsc-stepper-inner" + ctx2._theme);
        ɵɵadvance(2);
        ɵɵclassMap("mbsc-stepper-input" + (ctx2._disabled ? " mbsc-disabled" : "") + ctx2._theme);
        ɵɵproperty("disabled", ctx2._disabled)("id", ctx2.id || ctx2._id)("max", ctx2._max)("min", ctx2._min)("readonly", ctx2.readonly)("step", ctx2._step);
        ɵɵattribute("name", ctx2.name);
        ɵɵadvance(2);
        ɵɵproperty("disabled", ctx2._disabledPlus)("theme", ctx2.s.theme)("themeVariant", ctx2.s.themeVariant);
        ɵɵadvance();
        ɵɵclassMap("mbsc-stepper-inner" + ctx2._theme);
      }
    },
    dependencies: [MbscButton, NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  MbscStepper2 = __decorate([FormControl], MbscStepper2);
  return MbscStepper2;
}(StepperBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscStepper, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-stepper",
      template: `
    <label class="mbsc-stepper-content" [for]="id || _id">
      <span *ngIf="s.label" [class]="'mbsc-stepper-label' + _theme + (_disabled ? ' mbsc-disabled' : '')">{{ s.label }}</span>
      <span *ngIf="s.description" [class]="'mbsc-description' + _theme + (_disabled ? ' mbsc-disabled' : '')">{{ s.description }}</span>
    </label>
    <div [class]="'mbsc-stepper-control mbsc-flex' + _theme + _rtl">
      <mbsc-button
        class="mbsc-stepper-minus mbsc-stepper-button"
        (click)="_onMinusClick()"
        [disabled]="_disabledMinus"
        [theme]="s.theme"
        [themeVariant]="s.themeVariant"
      >
        <span [class]="'mbsc-stepper-inner' + _theme">&ndash;</span>
      </mbsc-button>
      <input
        #input
        [attr.name]="name"
        [class]="'mbsc-stepper-input' + (_disabled ? ' mbsc-disabled' : '') + _theme"
        [disabled]="_disabled"
        [id]="id || _id"
        [max]="_max"
        [min]="_min"
        [readonly]="readonly"
        [step]="_step"
        type="number"
      />
      <mbsc-button
        class="mbsc-stepper-plus mbsc-stepper-button"
        (click)="_onPlusClick()"
        [disabled]="_disabledPlus"
        [theme]="s.theme"
        [themeVariant]="s.themeVariant"
      >
        <span [class]="'mbsc-stepper-inner' + _theme">+</span>
      </mbsc-button>
    </div>
  `
    }]
  }], null, {
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    color: [{
      type: Input
    }],
    defaultValue: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    inputPosition: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    name: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    onChange: [{
      type: Output
    }]
  });
})();
var MbscStepperModule = function() {
  function MbscStepperModule2() {
  }
  MbscStepperModule2.ɵfac = function MbscStepperModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscStepperModule2)();
  };
  MbscStepperModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscStepperModule2,
    declarations: [StepperBase, MbscStepper],
    imports: [CommonModule, MbscButtonModule],
    exports: [MbscStepper]
  });
  MbscStepperModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscButtonModule]]
  });
  return MbscStepperModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscStepperModule, [{
    type: NgModule,
    args: [{
      declarations: [StepperBase, MbscStepper],
      exports: [MbscStepper],
      imports: [CommonModule, MbscButtonModule]
    }]
  }], null, null);
})();
var CLICK_MOVE_THRESHOLD = 3;
var CLICK_HOLD_THRESHOLD = 300;
var SwitchBase = function(_super) {
  __extends(SwitchBase2, _super);
  function SwitchBase2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._onChange = function(ev) {
      var s = _this.s;
      var checked = ev.target.checked;
      ev.stopPropagation();
      if (s.checked === UNDEFINED) {
        _this._checked = checked;
        _this.setState({
          checked
        });
      }
      _this._change(checked);
      if (s.onChange) {
        s.onChange(ev);
      }
    };
    _this._setInput = function(input) {
      _this._input = input;
    };
    _this._setHandleCont = function(span) {
      _this._handleCont = span;
    };
    _this._setHandle = function(span) {
      _this._handle = span;
    };
    _this._onLabelClick = function(ev) {
      ev.preventDefault();
    };
    return _this;
  }
  SwitchBase2.prototype._change = function(checked) {
  };
  SwitchBase2.prototype._setHandleLeft = function(left) {
    this._handle.style.left = left + "%";
  };
  SwitchBase2.prototype._mounted = function() {
    var _this = this;
    var handleContWidth;
    var handleContLeft;
    var gestureStart;
    var isHandle;
    var isNativeScroll;
    listen(this._input, CLICK, this._onChange);
    this._inputUnlisten = gestureListener(this._input, {
      onBlur: function() {
        _this.setState({
          hasFocus: false
        });
      },
      onFocus: function() {
        if (!_this._disabled) {
          _this.setState({
            hasFocus: true
          });
        }
      }
    });
    this._unlisten = gestureListener(this._el, {
      click: false,
      onEnd: function(ev) {
        if (!_this._disabled && !isNativeScroll) {
          if (isHandle) {
            var noMovement = Math.abs(ev.deltaX) < CLICK_MOVE_THRESHOLD && Math.abs(ev.deltaY) < CLICK_MOVE_THRESHOLD;
            var longHold = +/* @__PURE__ */ new Date() - gestureStart > CLICK_HOLD_THRESHOLD;
            var newChecked = noMovement && !longHold ? !_this._checked : _this._handleLeft >= 50;
            if (newChecked !== _this._checked) {
              _this._input.click();
              _this._change(newChecked);
            }
            isHandle = false;
          }
          _this.setState({
            dragging: false,
            isActive: false
          });
        }
      },
      onMove: function(ev) {
        var domEvent = ev.domEvent;
        var dragging = _this.state.dragging;
        if (!_this._disabled && !isNativeScroll && isHandle && handleContWidth) {
          if (Math.abs(ev.deltaX) > 5) {
            dragging = true;
            _this.setState({
              dragging: true
            });
          }
          if (dragging) {
            if (domEvent.cancelable) {
              domEvent.preventDefault();
            }
            var offset = (ev.startX - handleContLeft) / handleContWidth * 100;
            var cappedOffset = Math.max(Math.min(offset, 100), 0);
            var left = cappedOffset + ev.deltaX / handleContWidth * 100;
            var capped = Math.max(Math.min(left, 100), 0);
            _this._handleLeft = capped;
            _this._setHandleLeft(capped);
          }
        }
        if (!dragging && !isNativeScroll && Math.abs(ev.deltaY) > 7 && domEvent.type === TOUCH_MOVE) {
          isNativeScroll = true;
          _this.setState({
            isActive: false
          });
        }
      },
      onStart: function(ev) {
        if (!_this._disabled) {
          isNativeScroll = false;
          handleContWidth = _this._handleCont.clientWidth;
          handleContLeft = getOffset(_this._handleCont).left;
          gestureStart = +/* @__PURE__ */ new Date();
          if (ev.domEvent.target === _this._handleCont || _this._handleCont.contains(ev.domEvent.target)) {
            isHandle = true;
          }
          _this.setState({
            isActive: true
          });
        }
      }
    });
    this._setHandleLeft(this._handleLeft);
  };
  SwitchBase2.prototype._render = function(s, state) {
    var disabled = s.disabled === UNDEFINED ? state.disabled : emptyOrTrue(s.disabled);
    var position = s.position === "start" ? s.rtl ? "right" : "left" : s.rtl ? "left" : "right";
    var colorClass = s.color !== UNDEFINED ? " mbsc-switch-" + s.color : "";
    var modelValue = s.modelValue !== UNDEFINED ? s.modelValue : s.checked;
    this._disabled = disabled;
    this._checked = modelValue !== UNDEFINED ? emptyOrTrue(modelValue) : state.checked === UNDEFINED ? emptyOrTrue(s.defaultChecked) : state.checked;
    this._cssClass = "mbsc-switch mbsc-form-control-wrapper mbsc-font " + this._className + this._theme + this._rtl + this._hb + " mbsc-switch-" + position + (disabled ? " mbsc-disabled" : "");
    if (!state.dragging) {
      var hl = this._checked ? 100 : 0;
      if (hl !== this._handleLeft && this._handle) {
        this._setHandleLeft(hl);
      }
      this._handleLeft = hl;
    }
    this._handleContClass = "mbsc-switch-track mbsc-switch-track-" + position + this._theme + colorClass + (this._checked ? " mbsc-checked" : "") + (disabled ? " mbsc-disabled" : "") + (state.hasFocus ? " mbsc-focus" : "") + (state.isActive ? " mbsc-active" : "");
    this._handleClass = "mbsc-switch-handle" + this._theme + colorClass + (state.dragging ? "" : " mbsc-switch-handle-animate") + (this._checked ? " mbsc-checked" : "") + (this.state.isActive ? " mbsc-active" : "") + (disabled ? " mbsc-disabled" : "") + (this.state.hasFocus ? " mbsc-focus" : "");
  };
  SwitchBase2.prototype._destroy = function() {
    unlisten(this._input, CLICK, this._onChange);
    if (this._unlisten) {
      this._unlisten();
    }
    if (this._inputUnlisten) {
      this._inputUnlisten();
    }
  };
  SwitchBase2.defaults = {
    position: "end"
  };
  SwitchBase2._name = "Switch";
  SwitchBase2.ɵfac = /* @__PURE__ */ (() => {
    let ɵSwitchBase_BaseFactory;
    return function SwitchBase_Factory(__ngFactoryType__) {
      return (ɵSwitchBase_BaseFactory || (ɵSwitchBase_BaseFactory = ɵɵgetInheritedFactory(SwitchBase2)))(__ngFactoryType__ || SwitchBase2);
    };
  })();
  SwitchBase2.ɵdir = ɵɵdefineDirective({
    type: SwitchBase2,
    selectors: [["", "mbsc-sw-b", ""]],
    standalone: false,
    features: [ɵɵInheritDefinitionFeature]
  });
  return SwitchBase2;
}(BaseComponent);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SwitchBase, [{
    type: Directive,
    args: [{
      selector: "[mbsc-sw-b]"
    }]
  }], null, null);
})();
var guid = 0;
var MbscSwitch = function(_super) {
  __extends(MbscSwitch2, _super);
  function MbscSwitch2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._id = "mbsc-switch-" + guid++;
    return _this;
  }
  Object.defineProperty(MbscSwitch2.prototype, "checked", {
    get: function() {
      return this._check;
    },
    set: function(val) {
      if (this._check !== val) {
        this.props.checked = val;
        this._onFormChange(val);
        this._check = val;
        this.setState({
          checked: val
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  MbscSwitch2.prototype.registerOnChange = function(fn) {
    this._onFormChange = fn;
  };
  MbscSwitch2.prototype.registerOnTouched = function(fn) {
    this._onFormTouch = fn;
  };
  MbscSwitch2.prototype.setDisabledState = function(disabled) {
    this.setState({
      disabled
    });
  };
  MbscSwitch2.prototype.writeValue = function(val) {
    this.checked = val;
  };
  MbscSwitch2.prototype._change = function(checked) {
    this.checked = checked;
  };
  MbscSwitch2.prototype._mounted = function() {
    this._input = this.vInput.nativeElement;
    this._handle = this.vHandle.nativeElement;
    this._handleCont = this.vHandleCont.nativeElement;
    _super.prototype._mounted.call(this);
  };
  MbscSwitch2.ɵfac = /* @__PURE__ */ (() => {
    let ɵMbscSwitch_BaseFactory;
    return function MbscSwitch_Factory(__ngFactoryType__) {
      return (ɵMbscSwitch_BaseFactory || (ɵMbscSwitch_BaseFactory = ɵɵgetInheritedFactory(MbscSwitch2)))(__ngFactoryType__ || MbscSwitch2);
    };
  })();
  MbscSwitch2.ɵcmp = ɵɵdefineComponent({
    type: MbscSwitch2,
    selectors: [["mbsc-switch"]],
    viewQuery: function MbscSwitch_Query(rf, ctx2) {
      if (rf & 1) {
        ɵɵviewQuery(_c3, 5);
        ɵɵviewQuery(_c76, 5);
        ɵɵviewQuery(_c77, 5);
      }
      if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vInput = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vHandle = _t.first);
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx2.vHandleCont = _t.first);
      }
    },
    hostVars: 2,
    hostBindings: function MbscSwitch_HostBindings(rf, ctx2) {
      if (rf & 2) {
        ɵɵclassMap(ctx2._cssClass);
      }
    },
    inputs: {
      color: "color",
      description: "description",
      disabled: "disabled",
      id: "id",
      label: "label",
      position: "position",
      readonly: "readonly",
      checked: "checked"
    },
    standalone: false,
    features: [ɵɵInheritDefinitionFeature],
    ngContentSelectors: _c0,
    decls: 8,
    vars: 9,
    consts: [["input", ""], ["handleCont", ""], ["handle", ""], [3, "for", "class", 4, "ngIf"], ["type", "checkbox", 1, "mbsc-form-control-input", "mbsc-reset", 3, "id", "checked", "disabled", "readonly"], [3, "for"], [3, "class", 4, "ngIf"]],
    template: function MbscSwitch_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵtemplate(0, MbscSwitch_label_0_Template, 3, 5, "label", 3);
        ɵɵelement(1, "input", 4, 0);
        ɵɵelementStart(3, "span", null, 1);
        ɵɵelement(5, "span", null, 2);
        ɵɵelementEnd();
        ɵɵprojection(7);
      }
      if (rf & 2) {
        ɵɵproperty("ngIf", ctx2.s.label);
        ɵɵadvance();
        ɵɵproperty("id", ctx2.id || ctx2._id)("checked", ctx2._checked)("disabled", ctx2._disabled)("readonly", ctx2.readonly);
        ɵɵadvance(2);
        ɵɵclassMap(ctx2._handleContClass);
        ɵɵadvance(2);
        ɵɵclassMap(ctx2._handleClass);
      }
    },
    dependencies: [NgIf],
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscSwitch2;
}(SwitchBase);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSwitch, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "[class]": "_cssClass"
      },
      selector: "mbsc-switch",
      template: `
    <label *ngIf="s.label" [for]="id || _id" [class]="'mbsc-form-control-label' + _theme + (_disabled ? ' mbsc-disabled' : '')"
      >{{ s.label }}
      <span *ngIf="s.description" [class]="'mbsc-description' + _theme + (_disabled ? ' mbsc-disabled' : '')">{{ s.description }}</span>
    </label>

    <input
      #input
      type="checkbox"
      class="mbsc-form-control-input mbsc-reset"
      [id]="id || _id"
      [checked]="_checked"
      [disabled]="_disabled"
      [readonly]="readonly"
    />

    <span [class]="_handleContClass" #handleCont>
      <span [class]="_handleClass" #handle></span>
    </span>

    <ng-content></ng-content>
  `
    }]
  }], null, {
    vInput: [{
      type: ViewChild,
      args: ["input", {
        static: false
      }]
    }],
    vHandle: [{
      type: ViewChild,
      args: ["handle", {
        static: false
      }]
    }],
    vHandleCont: [{
      type: ViewChild,
      args: ["handleCont", {
        static: false
      }]
    }],
    color: [{
      type: Input
    }],
    description: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    position: [{
      type: Input
    }],
    readonly: [{
      type: Input
    }],
    checked: [{
      type: Input
    }]
  });
})();
var MbscSwitchModule = function() {
  function MbscSwitchModule2() {
  }
  MbscSwitchModule2.ɵfac = function MbscSwitchModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscSwitchModule2)();
  };
  MbscSwitchModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscSwitchModule2,
    declarations: [SwitchBase, MbscSwitch],
    imports: [CommonModule],
    exports: [MbscSwitch]
  });
  MbscSwitchModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule]]
  });
  return MbscSwitchModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscSwitchModule, [{
    type: NgModule,
    args: [{
      declarations: [SwitchBase, MbscSwitch],
      exports: [MbscSwitch],
      imports: [CommonModule]
    }]
  }], null, null);
})();
var MbscFormsModule = function() {
  function MbscFormsModule2() {
  }
  MbscFormsModule2.ɵfac = function MbscFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscFormsModule2)();
  };
  MbscFormsModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscFormsModule2,
    imports: [CommonModule, MbscButtonModule, MbscCheckboxModule, MbscInputModule, MbscPageModule, MbscRadioModule, MbscSegmentedModule, MbscStepperModule, MbscSwitchModule],
    exports: [MbscButtonModule, MbscCheckboxModule, MbscInputModule, MbscPageModule, MbscRadioModule, MbscSegmentedModule, MbscStepperModule, MbscSwitchModule, MbscNotificationsModule]
  });
  MbscFormsModule2.ɵinj = ɵɵdefineInjector({
    imports: [[CommonModule, MbscButtonModule, MbscCheckboxModule, MbscInputModule, MbscPageModule, MbscRadioModule, MbscSegmentedModule, MbscStepperModule, MbscSwitchModule], MbscButtonModule, MbscCheckboxModule, MbscInputModule, MbscPageModule, MbscRadioModule, MbscSegmentedModule, MbscStepperModule, MbscSwitchModule, MbscNotificationsModule]
  });
  return MbscFormsModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscFormsModule, [{
    type: NgModule,
    args: [{
      exports: [MbscButtonModule, MbscCheckboxModule, MbscInputModule, MbscPageModule, MbscRadioModule, MbscSegmentedModule, MbscStepperModule, MbscSwitchModule, MbscNotificationsModule],
      imports: [CommonModule, MbscButtonModule, MbscCheckboxModule, MbscInputModule, MbscPageModule, MbscRadioModule, MbscSegmentedModule, MbscStepperModule, MbscSwitchModule]
    }]
  }], null, null);
})();
var MbscOptionsProviderComponent = function() {
  function MbscOptionsProviderComponent2(_opt) {
    this._opt = _opt;
  }
  MbscOptionsProviderComponent2.prototype.ngOnChanges = function(changes) {
    var key = "options";
    var change = changes[key];
    if (change) {
      this._opt.setOptions(change.currentValue);
    }
  };
  MbscOptionsProviderComponent2.ɵfac = function MbscOptionsProviderComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscOptionsProviderComponent2)(ɵɵdirectiveInject(MbscOptionsService));
  };
  MbscOptionsProviderComponent2.ɵcmp = ɵɵdefineComponent({
    type: MbscOptionsProviderComponent2,
    selectors: [["mbsc-options-provider"]],
    inputs: {
      options: "options"
    },
    standalone: false,
    features: [ɵɵProvidersFeature([{
      provide: MbscOptionsService,
      useClass: MbscOptionsService
    }]), ɵɵNgOnChangesFeature],
    ngContentSelectors: _c0,
    decls: 1,
    vars: 0,
    template: function MbscOptionsProviderComponent_Template(rf, ctx2) {
      if (rf & 1) {
        ɵɵprojectionDef();
        ɵɵprojection(0);
      }
    },
    encapsulation: 2,
    changeDetection: 0
  });
  return MbscOptionsProviderComponent2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscOptionsProviderComponent, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      providers: [{
        provide: MbscOptionsService,
        useClass: MbscOptionsService
      }],
      selector: "mbsc-options-provider",
      template: "<ng-content></ng-content>"
    }]
  }], function() {
    return [{
      type: MbscOptionsService
    }];
  }, {
    options: [{
      type: Input
    }]
  });
})();
var MbscOptionsModule = function() {
  function MbscOptionsModule2() {
  }
  MbscOptionsModule2.ɵfac = function MbscOptionsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscOptionsModule2)();
  };
  MbscOptionsModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscOptionsModule2,
    declarations: [MbscOptionsProviderComponent],
    exports: [MbscOptionsProviderComponent]
  });
  MbscOptionsModule2.ɵinj = ɵɵdefineInjector({});
  return MbscOptionsModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscOptionsModule, [{
    type: NgModule,
    args: [{
      declarations: [MbscOptionsProviderComponent],
      exports: [MbscOptionsProviderComponent]
    }]
  }], null, null);
})();
var MbscBaseModule = function() {
  function MbscBaseModule2() {
  }
  MbscBaseModule2.ɵfac = function MbscBaseModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscBaseModule2)();
  };
  MbscBaseModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscBaseModule2,
    declarations: [Base, BaseComponent]
  });
  MbscBaseModule2.ɵinj = ɵɵdefineInjector({});
  return MbscBaseModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscBaseModule, [{
    type: NgModule,
    args: [{
      declarations: [Base, BaseComponent]
    }]
  }], null, null);
})();
var MbscModule = function() {
  function MbscModule2() {
  }
  MbscModule2.ɵfac = function MbscModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || MbscModule2)();
  };
  MbscModule2.ɵmod = ɵɵdefineNgModule({
    type: MbscModule2,
    imports: [MbscCalendarModule, MbscBaseModule, MbscDatepickerModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscIconModule, MbscOptionsModule, MbscPopupModule, MbscScrollerModule, MbscSelectModule, MbscTimegridModule],
    exports: [MbscCalendarModule, MbscDatepickerModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscIconModule, MbscOptionsModule, MbscPopupModule, MbscScrollerModule, MbscSelectModule, MbscTimegridModule]
  });
  MbscModule2.ɵinj = ɵɵdefineInjector({
    imports: [[MbscCalendarModule, MbscBaseModule, MbscDatepickerModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscIconModule, MbscOptionsModule, MbscPopupModule, MbscScrollerModule, MbscSelectModule, MbscTimegridModule], MbscCalendarModule, MbscDatepickerModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscIconModule, MbscOptionsModule, MbscPopupModule, MbscScrollerModule, MbscSelectModule, MbscTimegridModule]
  });
  return MbscModule2;
}();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MbscModule, [{
    type: NgModule,
    args: [{
      exports: [MbscCalendarModule, MbscDatepickerModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscIconModule, MbscOptionsModule, MbscPopupModule, MbscScrollerModule, MbscSelectModule, MbscTimegridModule],
      imports: [MbscCalendarModule, MbscBaseModule, MbscDatepickerModule, MbscDatetimeModule, MbscEventcalendarModule, MbscFormsModule, MbscIconModule, MbscOptionsModule, MbscPopupModule, MbscScrollerModule, MbscSelectModule, MbscTimegridModule]
    }]
  }], null, null);
})();
remote.fw = "angular";
export {
  DraggableDirective,
  MBSC_OPTIONS,
  MbscButton,
  MbscButtonModule,
  MbscCalendar,
  MbscCalendarHeaderModule,
  MbscCalendarModule,
  MbscCalendarNav,
  MbscCalendarNext,
  MbscCalendarPrev,
  MbscCalendarToday,
  MbscCheckbox,
  MbscCheckboxModule,
  MbscCustomEndIcon,
  MbscCustomIcon,
  MbscCustomStartIcon,
  MbscDate,
  MbscDatepicker,
  MbscDatepickerDirective,
  MbscDatepickerModule,
  MbscDatetime,
  MbscDatetimeModule,
  MbscDraggableModule,
  MbscDropcontainer,
  MbscDropcontainerModule,
  MbscDropdown,
  MbscEventListDayDirective,
  MbscEventListItem,
  MbscEventcalendar,
  MbscEventcalendarModule,
  MbscFormsModule,
  MbscIcon,
  MbscIconModule,
  MbscInput,
  MbscInputModule,
  MbscModule,
  MbscNotificationsModule,
  MbscOptionsModule,
  MbscOptionsProviderComponent,
  MbscOptionsService,
  MbscPage,
  MbscPageModule,
  MbscPopup,
  MbscPopupModule,
  MbscPrompt,
  MbscRadio,
  MbscRadioGroup,
  MbscRadioModule,
  MbscScroller,
  MbscScrollerModule,
  MbscSegmented,
  MbscSegmentedGroup,
  MbscSegmentedModule,
  MbscSelect,
  MbscSelectDirective,
  MbscSelectModule,
  MbscSelectOptionComponent,
  MbscSelectOptionDirective,
  MbscSnackbar,
  MbscStepper,
  MbscStepperModule,
  MbscSwitch,
  MbscSwitchModule,
  MbscTextarea,
  MbscTime,
  MbscTimegrid,
  MbscTimegridModule,
  Notifications,
  autoDetect,
  createCustomTheme,
  dayjsTimezone,
  formatDatePublic as formatDate,
  getAutoTheme,
  getJson,
  globalChanges,
  hijriCalendar,
  jalaliCalendar,
  locale,
  ar as localeAr,
  bg as localeBg,
  ca as localeCa,
  cs as localeCs,
  da as localeDa,
  de as localeDe,
  el as localeEl,
  localeEn,
  enGB as localeEnGB,
  es as localeEs,
  fa as localeFa,
  fi as localeFi,
  fr as localeFr,
  he as localeHe,
  hi as localeHi,
  hr as localeHr,
  hu as localeHu,
  it as localeIt,
  ja as localeJa,
  ko as localeKo,
  lt as localeLt,
  nl as localeNl,
  no as localeNo,
  pl as localePl,
  localePtBR,
  ptPT as localePtPT,
  ro as localeRo,
  ru as localeRu,
  localeRuUA,
  sk as localeSk,
  sr as localeSr,
  sv as localeSv,
  th as localeTh,
  tr as localeTr,
  ua as localeUa,
  vi as localeVi,
  zh as localeZh,
  luxonTimezone,
  momentTimezone,
  options,
  parseDate,
  platform,
  remote,
  setOptions,
  themes,
  updateRecurringEvent,
  util
};
//# sourceMappingURL=@mobiscroll_angular.js.map
