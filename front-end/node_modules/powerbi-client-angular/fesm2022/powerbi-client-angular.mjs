import * as i0 from '@angular/core';
import { Component, Input, ViewChild, NgModule } from '@angular/core';
import { service, factories } from 'powerbi-client';

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Get JSON string representation of the given map.
 *
 * @param map Map of event and corresponding handler method
 *
 */
const stringifyMap = (map) => {
    // Return empty string for empty/null map
    if (!map) {
        return '';
    }
    // Get entries of map as array
    const mapEntries = Array.from(map);
    // Return JSON string
    return JSON.stringify(mapEntries.map((mapEntry) => 
    // Convert event handler method to a string containing its source code for comparison
    [mapEntry[0], mapEntry[1] ? mapEntry[1].toString() : '']));
};
/**
 * Check if the container element, access token, and embed URL are available.
 *
 * @param containerRef Reference to the container element
 * @param embedConfig Configuration object for the embed, containing access token and embed URL
 *
 */
const isEmbedSetupValid = (containerRef, embedConfig) => {
    return !!containerRef.nativeElement && !!embedConfig.accessToken && !!embedConfig.embedUrl;
};
// SDK information to be used with service instance
const sdkType = 'powerbi-client-angular';
const sdkWrapperVersion = '5.0.0';

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Base component to hold common properties for all the Power BI entities
 */
class PowerBIEmbedComponent {
    constructor() {
        // JSON stringify of prev event handler map
        this.prevEventHandlerMapString = '';
    }
    ngOnInit() {
        // Initialize powerbi variable for child component
        if (this.service) {
            this.powerbi = this.service;
        }
        else {
            if (!PowerBIEmbedComponent._powerbi) {
                PowerBIEmbedComponent._powerbi = new service.Service(factories.hpmFactory, factories.wpmpFactory, factories.routerFactory);
            }
            this.powerbi = PowerBIEmbedComponent._powerbi;
        }
        this.powerbi.setSdkInfo(sdkType, sdkWrapperVersion);
    }
    /**
     * Sets all event handlers from the input on the embedded entity
     *
     * @param embed Embedded object
     * @param eventHandlerMap Array of event handlers to be set on embedded entity
     * @returns void
     */
    setEventHandlers(embed, eventHandlerMap) {
        // Get string representation of eventHandlerMap
        const eventHandlerMapString = stringifyMap(eventHandlerMap);
        // Check if event handler map changed
        if (this.prevEventHandlerMapString === eventHandlerMapString) {
            return;
        }
        // Update prev string representation of event handler map
        this.prevEventHandlerMapString = eventHandlerMapString;
        // Apply all provided event handlers
        eventHandlerMap.forEach((eventHandlerMethod, eventName) => {
            // Removes event handler for this event
            embed.off(eventName);
            // Event handler is effectively removed for this event when eventHandlerMethod is null
            if (eventHandlerMethod) {
                // Set single event handler
                embed.on(eventName, (event) => {
                    eventHandlerMethod(event, embed);
                });
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBIEmbedComponent, selector: "powerbi-embed", inputs: { cssClassName: "cssClassName", service: "service" }, ngImport: i0, template: '', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-embed',
                    template: '',
                }]
        }], propDecorators: { cssClassName: [{
                type: Input
            }], service: [{
                type: Input
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Report component to embed the report, extends the Base Component
 */
class PowerBIReportEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
        // Phased embedding flag (Optional)
        this.phasedEmbedding = false;
    }
    // Returns embed object to calling function
    getReport() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embed function to re-embed the report
                this.embedReport();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed, load or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedReport();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed or load the PowerBI Report based on phasedEmbedding flag
     *
     * @returns void
     */
    embedReport() {
        if (!isEmbedSetupValid(this.containerRef, this.embedConfig)) {
            return;
        }
        // Load when phasedEmbedding flag is true, embed otherwise
        if (this.phasedEmbedding) {
            this.embed = this.powerbi.load(this.containerRef.nativeElement, this.embedConfig);
        }
        else {
            this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIReportEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBIReportEmbedComponent, selector: "powerbi-report[embedConfig]", inputs: { embedConfig: "embedConfig", phasedEmbedding: "phasedEmbedding", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["reportContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #reportContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIReportEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-report[embedConfig]',
                    template: '<div class={{cssClassName}} #reportContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], phasedEmbedding: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['reportContainer']
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Dashboard component to embed the dashboard, extends the Base component
 */
class PowerBIDashboardEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    // Returns embed object to calling function
    getDashboard() {
        return this.embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedDashboard function
                this.embedDashboard();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedDashboard();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Dashboard
     *
     * @returns void
     */
    embedDashboard() {
        if (!isEmbedSetupValid(this.containerRef, this.embedConfig)) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIDashboardEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBIDashboardEmbedComponent, selector: "powerbi-dashboard[embedConfig]", inputs: { embedConfig: "embedConfig", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["dashboardContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #dashboardContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIDashboardEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-dashboard[embedConfig]',
                    template: '<div class={{cssClassName}} #dashboardContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['dashboardContainer']
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Tile component to embed the tile, extends Base component
 */
class PowerBITileEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    // Returns embed object to calling function
    getTile() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedTile function
                this.embedTile();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedTile();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Tile
     *
     * @returns void
     */
    embedTile() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement || !this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBITileEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBITileEmbedComponent, selector: "powerbi-tile[embedConfig]", inputs: { embedConfig: "embedConfig", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["tileContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #tileContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBITileEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-tile[embedConfig]',
                    template: '<div class={{cssClassName}} #tileContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['tileContainer']
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Paginated report component to embed the entity, extends the Base component
 */
class PowerBIPaginatedReportEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedPaginatedReport function
                this.embedPaginatedReport();
            }
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed
            this.embedPaginatedReport();
        }
    }
    /**
     * Embed the PowerBI Paginated report
     *
     * @returns void
     */
    embedPaginatedReport() {
        // Check if the HTML container is rendered and available
        if (!isEmbedSetupValid(this.containerRef, this.embedConfig)) {
            return;
        }
        // Embed paginated report
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIPaginatedReportEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBIPaginatedReportEmbedComponent, selector: "powerbi-paginated-report[embedConfig]", inputs: { embedConfig: "embedConfig" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["paginatedReportContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #paginatedReportContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIPaginatedReportEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-paginated-report[embedConfig]',
                    template: '<div class={{cssClassName}} #paginatedReportContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['paginatedReportContainer']
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Visual component to embed the visual, extends Base component
 */
class PowerBIVisualEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    // Returns embed object to calling function
    getVisual() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedVisual function
                this.embedVisual();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedVisual();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Visual
     *
     * @returns void
     */
    embedVisual() {
        if (!isEmbedSetupValid(this.containerRef, this.embedConfig)) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIVisualEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBIVisualEmbedComponent, selector: "powerbi-visual[embedConfig]", inputs: { embedConfig: "embedConfig", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["visualContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #visualContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIVisualEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-visual[embedConfig]',
                    template: '<div class={{cssClassName}} #visualContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['visualContainer']
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Qna component to embed the Qna visual, extends Base component
 */
class PowerBIQnaEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    // Returns embed object to calling function
    getQna() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedQnaVisual function
                this.embedQnaVisual();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedQnaVisual();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI QnA Visual
     *
     * @returns void
     */
    embedQnaVisual() {
        // Check if the HTML container is rendered and available
        if (!isEmbedSetupValid(this.containerRef, this.embedConfig)) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIQnaEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBIQnaEmbedComponent, selector: "powerbi-qna[embedConfig]", inputs: { embedConfig: "embedConfig", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["qnaContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #qnaContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIQnaEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-qna[embedConfig]',
                    template: '<div class={{cssClassName}} #qnaContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['qnaContainer']
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/**
 * Create report component to embed the entity, extends the Base component
 */
class PowerBICreateReportEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    // Returns embed object to calling function
    getCreateObject() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedCreateReport function
                this.embedCreateReport();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Decide to embed
        this.embedCreateReport();
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Create report
     *
     * @returns void
     */
    embedCreateReport() {
        // Check if the HTML container is rendered and available
        if (!isEmbedSetupValid(this.containerRef, this.embedConfig)) {
            return;
        }
        // Embed create report
        this.embed = this.powerbi.createReport(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBICreateReportEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBICreateReportEmbedComponent, selector: "powerbi-create-report[embedConfig]", inputs: { embedConfig: "embedConfig", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["createReportContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #createReportContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBICreateReportEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-create-report[embedConfig]',
                    template: '<div class={{cssClassName}} #createReportContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['createReportContainer']
            }] } });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
class PowerBIEmbedModule {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIEmbedModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule }); }
    static { this.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "17.3.12", ngImport: i0, type: PowerBIEmbedModule, declarations: [PowerBIEmbedComponent,
            PowerBIDashboardEmbedComponent,
            PowerBIPaginatedReportEmbedComponent,
            PowerBIQnaEmbedComponent,
            PowerBIReportEmbedComponent,
            PowerBITileEmbedComponent,
            PowerBIVisualEmbedComponent,
            PowerBICreateReportEmbedComponent], exports: [PowerBIDashboardEmbedComponent,
            PowerBIPaginatedReportEmbedComponent,
            PowerBIQnaEmbedComponent,
            PowerBIReportEmbedComponent,
            PowerBITileEmbedComponent,
            PowerBIVisualEmbedComponent,
            PowerBICreateReportEmbedComponent] }); }
    static { this.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIEmbedModule }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIEmbedModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [
                        PowerBIEmbedComponent,
                        PowerBIDashboardEmbedComponent,
                        PowerBIPaginatedReportEmbedComponent,
                        PowerBIQnaEmbedComponent,
                        PowerBIReportEmbedComponent,
                        PowerBITileEmbedComponent,
                        PowerBIVisualEmbedComponent,
                        PowerBICreateReportEmbedComponent
                    ],
                    imports: [],
                    exports: [
                        PowerBIDashboardEmbedComponent,
                        PowerBIPaginatedReportEmbedComponent,
                        PowerBIQnaEmbedComponent,
                        PowerBIReportEmbedComponent,
                        PowerBITileEmbedComponent,
                        PowerBIVisualEmbedComponent,
                        PowerBICreateReportEmbedComponent
                    ],
                }]
        }] });

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
/*
 * Public API Surface of powerbi-client-angular
 */

/**
 * Generated bundle index. Do not edit.
 */

export { PowerBICreateReportEmbedComponent, PowerBIDashboardEmbedComponent, PowerBIEmbedModule, PowerBIPaginatedReportEmbedComponent, PowerBIQnaEmbedComponent, PowerBIReportEmbedComponent, PowerBITileEmbedComponent, PowerBIVisualEmbedComponent };
//# sourceMappingURL=powerbi-client-angular.mjs.map
