// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { Component, Input, ViewChild } from '@angular/core';
import { PowerBIEmbedComponent } from '../powerbi-embed/powerbi-embed.component';
import { isEmbedSetupValid } from '../../utils/utils';
import * as i0 from "@angular/core";
/**
 * Dashboard component to embed the dashboard, extends the Base component
 */
export class PowerBIDashboardEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    // Returns embed object to calling function
    getDashboard() {
        return this.embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedDashboard function
                this.embedDashboard();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedDashboard();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Dashboard
     *
     * @returns void
     */
    embedDashboard() {
        if (!isEmbedSetupValid(this.containerRef, this.embedConfig)) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIDashboardEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBIDashboardEmbedComponent, selector: "powerbi-dashboard[embedConfig]", inputs: { embedConfig: "embedConfig", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["dashboardContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #dashboardContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBIDashboardEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-dashboard[embedConfig]',
                    template: '<div class={{cssClassName}} #dashboardContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['dashboardContainer']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG93ZXJiaS1kYXNoYm9hcmQtZW1iZWQuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2NvbXBvbmVudHMvcG93ZXJiaS1kYXNoYm9hcmQtZW1iZWQvcG93ZXJiaS1kYXNoYm9hcmQtZW1iZWQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHVDQUF1QztBQUN2QyxrQ0FBa0M7QUFFbEMsT0FBTyxFQUFpQixTQUFTLEVBQWMsS0FBSyxFQUFvQyxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekgsT0FBTyxFQUFnQixxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQy9GLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG1CQUFtQixDQUFDOztBQUV0RDs7R0FFRztBQUtILE1BQU0sT0FBTyw4QkFBK0IsU0FBUSxxQkFBcUI7SUFldkUseUJBQXlCO0lBQ3pCLElBQVksS0FBSztRQUNmLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBRUQseUJBQXlCO0lBQ3pCLElBQVksS0FBSyxDQUFDLGdCQUFtQztRQUNuRCxJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFnQixDQUFDO0lBQ2pDLENBQUM7SUFFRDtRQUNFLEtBQUssRUFBRSxDQUFDO0lBQ1YsQ0FBQztJQUVELDJDQUEyQztJQUMzQyxZQUFZO1FBQ1YsT0FBTyxJQUFJLENBQUMsS0FBa0IsQ0FBQztJQUNqQyxDQUFDO0lBRUQsUUFBUTtRQUNOLDJEQUEyRDtRQUMzRCxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUVELFdBQVcsQ0FBQyxPQUFzQjtRQUNoQyxJQUFJLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUN4QiwyREFBMkQ7WUFDM0QsSUFBSSxPQUFPLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUM7Z0JBQ3hDLE9BQU87WUFDVCxDQUFDO1lBRUQsTUFBTSxlQUFlLEdBQWlDLE9BQU8sQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDO1lBQ3hGLE1BQU0sa0JBQWtCLEdBQWlDLE9BQU8sQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDO1lBQzFGLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxlQUFlLENBQUMsS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQztnQkFDM0UsbUVBQW1FO2dCQUNuRSxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDeEIsQ0FBQztRQUNILENBQUM7UUFFRCxrQ0FBa0M7UUFDbEMsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNyQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDekQsQ0FBQztJQUNILENBQUM7SUFFRCxlQUFlO1FBQ2Isc0NBQXNDO1FBQ3RDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNwQywrQkFBK0I7WUFDL0IsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUM5RCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7WUFDeEIsQ0FBQztpQkFBTSxDQUFDO2dCQUNOLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3pGLENBQUM7UUFDSCxDQUFDO1FBRUQsa0NBQWtDO1FBQ2xDLElBQUksSUFBSSxDQUFDLGFBQWEsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDckMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ3pELENBQUM7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLGNBQWM7UUFDcEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUM7WUFDNUQsT0FBTztRQUNULENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyRixDQUFDOytHQXhGVSw4QkFBOEI7bUdBQTlCLDhCQUE4Qiw4U0FGL0Isd0RBQXdEOzs0RkFFdkQsOEJBQThCO2tCQUoxQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSxnQ0FBZ0M7b0JBQzFDLFFBQVEsRUFBRSx3REFBd0Q7aUJBQ25FO3dEQUlVLFdBQVc7c0JBQW5CLEtBQUs7Z0JBR0csYUFBYTtzQkFBckIsS0FBSztnQkFHbUMsWUFBWTtzQkFBcEQsU0FBUzt1QkFBQyxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuLy8gTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG5cclxuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIFNpbXBsZUNoYW5nZXMsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBEYXNoYm9hcmQsIEVtYmVkLCBJRGFzaGJvYXJkRW1iZWRDb25maWd1cmF0aW9uIH0gZnJvbSAncG93ZXJiaS1jbGllbnQnO1xyXG5pbXBvcnQgeyBFdmVudEhhbmRsZXIsIFBvd2VyQklFbWJlZENvbXBvbmVudCB9IGZyb20gJy4uL3Bvd2VyYmktZW1iZWQvcG93ZXJiaS1lbWJlZC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBpc0VtYmVkU2V0dXBWYWxpZCB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBEYXNoYm9hcmQgY29tcG9uZW50IHRvIGVtYmVkIHRoZSBkYXNoYm9hcmQsIGV4dGVuZHMgdGhlIEJhc2UgY29tcG9uZW50XHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3Bvd2VyYmktZGFzaGJvYXJkW2VtYmVkQ29uZmlnXScsXHJcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPXt7Y3NzQ2xhc3NOYW1lfX0gI2Rhc2hib2FyZENvbnRhaW5lcj48L2Rpdj4nLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUG93ZXJCSURhc2hib2FyZEVtYmVkQ29tcG9uZW50IGV4dGVuZHMgUG93ZXJCSUVtYmVkQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQge1xyXG4gIC8vIElucHV0KCkgc3BlY2lmeSBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgZnJvbSBwYXJlbnRcclxuICAvLyBDb25maWd1cmF0aW9uIGZvciBlbWJlZGRpbmcgdGhlIFBvd2VyQkkgRGFzaGJvYXJkIChSZXF1aXJlZClcclxuICBASW5wdXQoKSBlbWJlZENvbmZpZyE6IElEYXNoYm9hcmRFbWJlZENvbmZpZ3VyYXRpb247XHJcblxyXG4gIC8vIE1hcCBvZiBldmVudCBuYW1lIGFuZCBoYW5kbGVyIG1ldGhvZHMgcGFpcnMgdG8gYmUgdHJpZ2dlcmVkIG9uIHRoZSBldmVudCAoT3B0aW9uYWwpXHJcbiAgQElucHV0KCkgZXZlbnRIYW5kbGVycz86IE1hcDxzdHJpbmcsIEV2ZW50SGFuZGxlciB8IG51bGw+O1xyXG5cclxuICAvLyBSZWYgdG8gdGhlIEhUTUwgZGl2IGNvbnRhaW5lciBlbGVtZW50XHJcbiAgQFZpZXdDaGlsZCgnZGFzaGJvYXJkQ29udGFpbmVyJykgcHJpdmF0ZSBjb250YWluZXJSZWYhOiBFbGVtZW50UmVmPEhUTUxEaXZFbGVtZW50PjtcclxuXHJcbiAgLy8gRW1iZWRkZWQgZW50aXR5XHJcbiAgLy8gTm90ZTogRG8gbm90IHJlYWQgb3IgYXNzaWduIHRvIHRoaXMgbWVtYmVyIHZhcmlhYmxlIGRpcmVjdGx5LCBpbnN0ZWFkIHVzZSB0aGUgZ2V0dGVyIGFuZCBzZXR0ZXJcclxuICBwcml2YXRlIF9lbWJlZD86IEVtYmVkO1xyXG5cclxuICAvLyBHZXR0ZXIgZm9yIHRoaXMuX2VtYmVkXHJcbiAgcHJpdmF0ZSBnZXQgZW1iZWQoKTogRW1iZWQgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIHRoaXMuX2VtYmVkO1xyXG4gIH1cclxuXHJcbiAgLy8gU2V0dGVyIGZvciB0aGlzLl9lbWJlZFxyXG4gIHByaXZhdGUgc2V0IGVtYmVkKG5ld0VtYmVkSW5zdGFuY2U6IEVtYmVkIHwgdW5kZWZpbmVkKSB7XHJcbiAgICB0aGlzLl9lbWJlZCA9IG5ld0VtYmVkSW5zdGFuY2U7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZXR1cm5zIGVtYmVkIG9iamVjdCB0byBjYWxsaW5nIGZ1bmN0aW9uXHJcbiAgZ2V0RGFzaGJvYXJkKCk6IERhc2hib2FyZCB7XHJcbiAgICByZXR1cm4gdGhpcy5lbWJlZCBhcyBEYXNoYm9hcmQ7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgIC8vIEluaXRpYWxpemUgUG93ZXJCSSBzZXJ2aWNlIGluc3RhbmNlIHZhcmlhYmxlIGZyb20gcGFyZW50XHJcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgaWYgKGNoYW5nZXMuZW1iZWRDb25maWcpIHtcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZ1bmN0aW9uIGlzIGJlaW5nIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuICAgICAgaWYgKGNoYW5nZXMuZW1iZWRDb25maWcuaXNGaXJzdENoYW5nZSgpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcmV2RW1iZWRDb25maWc6IElEYXNoYm9hcmRFbWJlZENvbmZpZ3VyYXRpb24gPSBjaGFuZ2VzLmVtYmVkQ29uZmlnLnByZXZpb3VzVmFsdWU7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRFbWJlZENvbmZpZzogSURhc2hib2FyZEVtYmVkQ29uZmlndXJhdGlvbiA9IGNoYW5nZXMuZW1iZWRDb25maWcuY3VycmVudFZhbHVlO1xyXG4gICAgICBpZiAoSlNPTi5zdHJpbmdpZnkocHJldkVtYmVkQ29uZmlnKSAhPT0gSlNPTi5zdHJpbmdpZnkoY3VycmVudEVtYmVkQ29uZmlnKSkge1xyXG4gICAgICAgIC8vIElucHV0IGZyb20gcGFyZW50IGdldCB1cGRhdGVkLCB0aHVzIGNhbGwgZW1iZWREYXNoYm9hcmQgZnVuY3Rpb25cclxuICAgICAgICB0aGlzLmVtYmVkRGFzaGJvYXJkKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgZXZlbnQgaGFuZGxlcnMgaWYgYXZhaWxhYmxlXHJcbiAgICBpZiAodGhpcy5ldmVudEhhbmRsZXJzICYmIHRoaXMuZW1iZWQpIHtcclxuICAgICAgc3VwZXIuc2V0RXZlbnRIYW5kbGVycyh0aGlzLmVtYmVkLCB0aGlzLmV2ZW50SGFuZGxlcnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgLy8gQ2hlY2sgaWYgY29udGFpbmVyIGV4aXN0cyBvbiB0aGUgVUlcclxuICAgIGlmICh0aGlzLmNvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50KSB7XHJcbiAgICAgIC8vIERlY2lkZSB0byBlbWJlZCBvciBib290c3RyYXBcclxuICAgICAgaWYgKHRoaXMuZW1iZWRDb25maWcuYWNjZXNzVG9rZW4gJiYgdGhpcy5lbWJlZENvbmZpZy5lbWJlZFVybCkge1xyXG4gICAgICAgIHRoaXMuZW1iZWREYXNoYm9hcmQoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmVtYmVkID0gdGhpcy5wb3dlcmJpLmJvb3RzdHJhcCh0aGlzLmNvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLmVtYmVkQ29uZmlnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFNldCBldmVudCBoYW5kbGVycyBpZiBhdmFpbGFibGVcclxuICAgIGlmICh0aGlzLmV2ZW50SGFuZGxlcnMgJiYgdGhpcy5lbWJlZCkge1xyXG4gICAgICBzdXBlci5zZXRFdmVudEhhbmRsZXJzKHRoaXMuZW1iZWQsIHRoaXMuZXZlbnRIYW5kbGVycyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbWJlZCB0aGUgUG93ZXJCSSBEYXNoYm9hcmRcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIGVtYmVkRGFzaGJvYXJkKCk6IHZvaWQge1xyXG4gICAgaWYgKCFpc0VtYmVkU2V0dXBWYWxpZCh0aGlzLmNvbnRhaW5lclJlZiwgdGhpcy5lbWJlZENvbmZpZykpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZW1iZWQgPSB0aGlzLnBvd2VyYmkuZW1iZWQodGhpcy5jb250YWluZXJSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5lbWJlZENvbmZpZyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==