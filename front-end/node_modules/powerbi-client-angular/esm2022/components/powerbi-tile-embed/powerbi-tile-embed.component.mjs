// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { Component, Input, ViewChild } from '@angular/core';
import { PowerBIEmbedComponent } from '../powerbi-embed/powerbi-embed.component';
import * as i0 from "@angular/core";
/**
 * Tile component to embed the tile, extends Base component
 */
export class PowerBITileEmbedComponent extends PowerBIEmbedComponent {
    // Getter for this._embed
    get embed() {
        return this._embed;
    }
    // Setter for this._embed
    set embed(newEmbedInstance) {
        this._embed = newEmbedInstance;
    }
    constructor() {
        super();
    }
    // Returns embed object to calling function
    getTile() {
        return this._embed;
    }
    ngOnInit() {
        // Initialize PowerBI service instance variable from parent
        super.ngOnInit();
    }
    ngOnChanges(changes) {
        if (changes.embedConfig) {
            // Check if the function is being called for the first time
            if (changes.embedConfig.isFirstChange()) {
                return;
            }
            const prevEmbedConfig = changes.embedConfig.previousValue;
            const currentEmbedConfig = changes.embedConfig.currentValue;
            if (JSON.stringify(prevEmbedConfig) !== JSON.stringify(currentEmbedConfig)) {
                // Input from parent get updated, thus call embedTile function
                this.embedTile();
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    ngAfterViewInit() {
        // Check if container exists on the UI
        if (this.containerRef.nativeElement) {
            // Decide to embed or bootstrap
            if (this.embedConfig.accessToken && this.embedConfig.embedUrl) {
                this.embedTile();
            }
            else {
                this.embed = this.powerbi.bootstrap(this.containerRef.nativeElement, this.embedConfig);
            }
        }
        // Set event handlers if available
        if (this.eventHandlers && this.embed) {
            super.setEventHandlers(this.embed, this.eventHandlers);
        }
    }
    /**
     * Embed the PowerBI Tile
     *
     * @returns void
     */
    embedTile() {
        // Check if the HTML container is rendered and available
        if (!this.containerRef.nativeElement || !this.embedConfig.accessToken || !this.embedConfig.embedUrl) {
            return;
        }
        this.embed = this.powerbi.embed(this.containerRef.nativeElement, this.embedConfig);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBITileEmbedComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "17.3.12", type: PowerBITileEmbedComponent, selector: "powerbi-tile[embedConfig]", inputs: { embedConfig: "embedConfig", eventHandlers: "eventHandlers" }, viewQueries: [{ propertyName: "containerRef", first: true, predicate: ["tileContainer"], descendants: true }], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: '<div class={{cssClassName}} #tileContainer></div>', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.12", ngImport: i0, type: PowerBITileEmbedComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'powerbi-tile[embedConfig]',
                    template: '<div class={{cssClassName}} #tileContainer></div>',
                }]
        }], ctorParameters: () => [], propDecorators: { embedConfig: [{
                type: Input
            }], eventHandlers: [{
                type: Input
            }], containerRef: [{
                type: ViewChild,
                args: ['tileContainer']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG93ZXJiaS10aWxlLWVtYmVkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21wb25lbnRzL3Bvd2VyYmktdGlsZS1lbWJlZC9wb3dlcmJpLXRpbGUtZW1iZWQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHVDQUF1QztBQUN2QyxrQ0FBa0M7QUFFbEMsT0FBTyxFQUFpQixTQUFTLEVBQWMsS0FBSyxFQUFvQyxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekgsT0FBTyxFQUFnQixxQkFBcUIsRUFBRSxNQUFNLDBDQUEwQyxDQUFDOztBQUcvRjs7R0FFRztBQUtILE1BQU0sT0FBTyx5QkFBMEIsU0FBUSxxQkFBcUI7SUFlbEUseUJBQXlCO0lBQ3pCLElBQVksS0FBSztRQUNmLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBRUQseUJBQXlCO0lBQ3pCLElBQVksS0FBSyxDQUFDLGdCQUFtQztRQUNuRCxJQUFJLENBQUMsTUFBTSxHQUFHLGdCQUFnQixDQUFDO0lBQ2pDLENBQUM7SUFFRDtRQUNFLEtBQUssRUFBRSxDQUFDO0lBQ1YsQ0FBQztJQUVELDJDQUEyQztJQUMzQyxPQUFPO1FBQ0wsT0FBTyxJQUFJLENBQUMsTUFBYyxDQUFDO0lBQzdCLENBQUM7SUFFRCxRQUFRO1FBQ04sMkRBQTJEO1FBQzNELEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQ2hDLElBQUksT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3hCLDJEQUEyRDtZQUMzRCxJQUFJLE9BQU8sQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLEVBQUUsQ0FBQztnQkFDeEMsT0FBTztZQUNULENBQUM7WUFFRCxNQUFNLGVBQWUsR0FBNEIsT0FBTyxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUM7WUFDbkYsTUFBTSxrQkFBa0IsR0FBNEIsT0FBTyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUM7WUFDckYsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDO2dCQUMzRSw4REFBOEQ7Z0JBQzlELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNuQixDQUFDO1FBQ0gsQ0FBQztRQUVELGtDQUFrQztRQUNsQyxJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3JDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUN6RCxDQUFDO0lBQ0gsQ0FBQztJQUVELGVBQWU7UUFDYixzQ0FBc0M7UUFDdEMsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3BDLCtCQUErQjtZQUMvQixJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7Z0JBQzlELElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUNuQixDQUFDO2lCQUFNLENBQUM7Z0JBQ04sSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDekYsQ0FBQztRQUNILENBQUM7UUFFRCxrQ0FBa0M7UUFDbEMsSUFBSSxJQUFJLENBQUMsYUFBYSxJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNyQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFDekQsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssU0FBUztRQUNmLHdEQUF3RDtRQUN4RCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDcEcsT0FBTztRQUNULENBQUM7UUFFRCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyRixDQUFDOytHQXpGVSx5QkFBeUI7bUdBQXpCLHlCQUF5QixvU0FGMUIsbURBQW1EOzs0RkFFbEQseUJBQXlCO2tCQUpyQyxTQUFTO21CQUFDO29CQUNULFFBQVEsRUFBRSwyQkFBMkI7b0JBQ3JDLFFBQVEsRUFBRSxtREFBbUQ7aUJBQzlEO3dEQUlVLFdBQVc7c0JBQW5CLEtBQUs7Z0JBR0csYUFBYTtzQkFBckIsS0FBSztnQkFHOEIsWUFBWTtzQkFBL0MsU0FBUzt1QkFBQyxlQUFlIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuXHJcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uQ2hhbmdlcywgT25Jbml0LCBTaW1wbGVDaGFuZ2VzLCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRW1iZWQsIElUaWxlRW1iZWRDb25maWd1cmF0aW9uLCBUaWxlIH0gZnJvbSAncG93ZXJiaS1jbGllbnQnO1xyXG5pbXBvcnQgeyBFdmVudEhhbmRsZXIsIFBvd2VyQklFbWJlZENvbXBvbmVudCB9IGZyb20gJy4uL3Bvd2VyYmktZW1iZWQvcG93ZXJiaS1lbWJlZC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBpc0VtYmVkU2V0dXBWYWxpZCB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBUaWxlIGNvbXBvbmVudCB0byBlbWJlZCB0aGUgdGlsZSwgZXh0ZW5kcyBCYXNlIGNvbXBvbmVudFxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdwb3dlcmJpLXRpbGVbZW1iZWRDb25maWddJyxcclxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9e3tjc3NDbGFzc05hbWV9fSAjdGlsZUNvbnRhaW5lcj48L2Rpdj4nLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUG93ZXJCSVRpbGVFbWJlZENvbXBvbmVudCBleHRlbmRzIFBvd2VyQklFbWJlZENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0IHtcclxuICAvLyBJbnB1dCgpIHNwZWNpZnkgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgcGFzc2VkIGZyb20gcGFyZW50XHJcbiAgLy8gQ29uZmlndXJhdGlvbiBmb3IgZW1iZWRkaW5nIHRoZSBQb3dlckJJIFRpbGUgKFJlcXVpcmVkKVxyXG4gIEBJbnB1dCgpIGVtYmVkQ29uZmlnITogSVRpbGVFbWJlZENvbmZpZ3VyYXRpb247XHJcblxyXG4gIC8vIE1hcCBvZiBldmVudCBuYW1lIGFuZCBoYW5kbGVyIG1ldGhvZHMgcGFpcnMgdG8gYmUgdHJpZ2dlcmVkIG9uIHRoZSBldmVudCAoT3B0aW9uYWwpXHJcbiAgQElucHV0KCkgZXZlbnRIYW5kbGVycz86IE1hcDxzdHJpbmcsIEV2ZW50SGFuZGxlciB8IG51bGw+O1xyXG5cclxuICAvLyBSZWYgdG8gdGhlIEhUTUwgZGl2IGNvbnRhaW5lciBlbGVtZW50XHJcbiAgQFZpZXdDaGlsZCgndGlsZUNvbnRhaW5lcicpIHByaXZhdGUgY29udGFpbmVyUmVmITogRWxlbWVudFJlZjxIVE1MRGl2RWxlbWVudD47XHJcblxyXG4gIC8vIEVtYmVkZGVkIGVudGl0eVxyXG4gIC8vIE5vdGU6IERvIG5vdCByZWFkIG9yIGFzc2lnbiB0byB0aGlzIG1lbWJlciB2YXJpYWJsZSBkaXJlY3RseSwgaW5zdGVhZCB1c2UgdGhlIGdldHRlciBhbmQgc2V0dGVyXHJcbiAgcHJpdmF0ZSBfZW1iZWQ/OiBFbWJlZDtcclxuXHJcbiAgLy8gR2V0dGVyIGZvciB0aGlzLl9lbWJlZFxyXG4gIHByaXZhdGUgZ2V0IGVtYmVkKCk6IEVtYmVkIHwgdW5kZWZpbmVkIHtcclxuICAgIHJldHVybiB0aGlzLl9lbWJlZDtcclxuICB9XHJcblxyXG4gIC8vIFNldHRlciBmb3IgdGhpcy5fZW1iZWRcclxuICBwcml2YXRlIHNldCBlbWJlZChuZXdFbWJlZEluc3RhbmNlOiBFbWJlZCB8IHVuZGVmaW5lZCkge1xyXG4gICAgdGhpcy5fZW1iZWQgPSBuZXdFbWJlZEluc3RhbmNlO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gIH1cclxuXHJcbiAgLy8gUmV0dXJucyBlbWJlZCBvYmplY3QgdG8gY2FsbGluZyBmdW5jdGlvblxyXG4gIGdldFRpbGUoKTogVGlsZSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZW1iZWQgYXMgVGlsZTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCk6IHZvaWQge1xyXG4gICAgLy8gSW5pdGlhbGl6ZSBQb3dlckJJIHNlcnZpY2UgaW5zdGFuY2UgdmFyaWFibGUgZnJvbSBwYXJlbnRcclxuICAgIHN1cGVyLm5nT25Jbml0KCk7XHJcbiAgfVxyXG5cclxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XHJcbiAgICBpZiAoY2hhbmdlcy5lbWJlZENvbmZpZykge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkIGZvciB0aGUgZmlyc3QgdGltZVxyXG4gICAgICBpZiAoY2hhbmdlcy5lbWJlZENvbmZpZy5pc0ZpcnN0Q2hhbmdlKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHByZXZFbWJlZENvbmZpZzogSVRpbGVFbWJlZENvbmZpZ3VyYXRpb24gPSBjaGFuZ2VzLmVtYmVkQ29uZmlnLnByZXZpb3VzVmFsdWU7XHJcbiAgICAgIGNvbnN0IGN1cnJlbnRFbWJlZENvbmZpZzogSVRpbGVFbWJlZENvbmZpZ3VyYXRpb24gPSBjaGFuZ2VzLmVtYmVkQ29uZmlnLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHByZXZFbWJlZENvbmZpZykgIT09IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRFbWJlZENvbmZpZykpIHtcclxuICAgICAgICAvLyBJbnB1dCBmcm9tIHBhcmVudCBnZXQgdXBkYXRlZCwgdGh1cyBjYWxsIGVtYmVkVGlsZSBmdW5jdGlvblxyXG4gICAgICAgIHRoaXMuZW1iZWRUaWxlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgZXZlbnQgaGFuZGxlcnMgaWYgYXZhaWxhYmxlXHJcbiAgICBpZiAodGhpcy5ldmVudEhhbmRsZXJzICYmIHRoaXMuZW1iZWQpIHtcclxuICAgICAgc3VwZXIuc2V0RXZlbnRIYW5kbGVycyh0aGlzLmVtYmVkLCB0aGlzLmV2ZW50SGFuZGxlcnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG4gICAgLy8gQ2hlY2sgaWYgY29udGFpbmVyIGV4aXN0cyBvbiB0aGUgVUlcclxuICAgIGlmICh0aGlzLmNvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50KSB7XHJcbiAgICAgIC8vIERlY2lkZSB0byBlbWJlZCBvciBib290c3RyYXBcclxuICAgICAgaWYgKHRoaXMuZW1iZWRDb25maWcuYWNjZXNzVG9rZW4gJiYgdGhpcy5lbWJlZENvbmZpZy5lbWJlZFVybCkge1xyXG4gICAgICAgIHRoaXMuZW1iZWRUaWxlKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5lbWJlZCA9IHRoaXMucG93ZXJiaS5ib290c3RyYXAodGhpcy5jb250YWluZXJSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5lbWJlZENvbmZpZyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgZXZlbnQgaGFuZGxlcnMgaWYgYXZhaWxhYmxlXHJcbiAgICBpZiAodGhpcy5ldmVudEhhbmRsZXJzICYmIHRoaXMuZW1iZWQpIHtcclxuICAgICAgc3VwZXIuc2V0RXZlbnRIYW5kbGVycyh0aGlzLmVtYmVkLCB0aGlzLmV2ZW50SGFuZGxlcnMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1iZWQgdGhlIFBvd2VyQkkgVGlsZVxyXG4gICAqXHJcbiAgICogQHJldHVybnMgdm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZW1iZWRUaWxlKCk6IHZvaWQge1xyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIEhUTUwgY29udGFpbmVyIGlzIHJlbmRlcmVkIGFuZCBhdmFpbGFibGVcclxuICAgIGlmICghdGhpcy5jb250YWluZXJSZWYubmF0aXZlRWxlbWVudCB8fCAhdGhpcy5lbWJlZENvbmZpZy5hY2Nlc3NUb2tlbiB8fCAhdGhpcy5lbWJlZENvbmZpZy5lbWJlZFVybCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbWJlZCA9IHRoaXMucG93ZXJiaS5lbWJlZCh0aGlzLmNvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLmVtYmVkQ29uZmlnKTtcclxuICB9XHJcbn1cclxuIl19